<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>落雨乄天珀夜</title>
  
  
  <link href="https://conqueror712.github.io/atom.xml" rel="self"/>
  
  <link href="https://conqueror712.github.io/"/>
  <updated>2023-02-15T06:33:34.815Z</updated>
  <id>https://conqueror712.github.io/</id>
  
  <author>
    <name>落雨乄天珀夜</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机网络 - 上丨学习记录</title>
    <link href="https://conqueror712.github.io/post/Computer-Network.html"/>
    <id>https://conqueror712.github.io/post/Computer-Network.html</id>
    <published>2023-02-09T12:03:22.000Z</published>
    <updated>2023-02-15T06:33:34.815Z</updated>
    
    <content type="html"><![CDATA[<p><em>Computer Networking A Top-Down Approach Learning Note Part 1</em></p><p><strong>前言的前言的前言</strong>：</p><p>本文在笔者的博客内有流程图加载不出来的bug，烦请各位读者移步：<a href="https://juejin.cn/post/7198159223203676219">计算机网络丨学习记录 - 上 - 掘金 (juejin.cn)</a></p><p>后续会进行调整。</p><hr><p><strong>前言的前言</strong>：</p><p>本文是笔者初学计算机网络的笔记和一些心得，难免会有部分疏漏和错误，还请各位读者积极指出，不吝赐教。</p><p>有一些内容是笔者认为对自己暂时没那么重要的部分，就没有放上去，具体的内容可以查看相关的书籍。</p><p>还有要补充的就是，计算机网络的学习记录将会分为上中下三部分，这一部分，也就是上，主要是涵盖了《自顶向下计算机网络》的第一章部分，因为是初学，笔者对于很多概念还比较陌生，加之这一章节与其他章节的性质不同，是一个概览，所以单独把这一章节放在上这一部分。</p><p>事不宜迟，我们开始吧！</p><hr><h1 id="Unit-1-计算机网络概述"><a href="#Unit-1-计算机网络概述" class="headerlink" title="Unit 1 计算机网络概述"></a>Unit 1 计算机网络概述</h1><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>该课程的总体教学目标需要掌握计网的什么？</p><ul><li>基本概念</li><li>工作原理</li><li>常用技术</li></ul><p>计算机网络为什么比较难学？</p><p>有很多的**”定性的、逻辑描述的推理”**；</p><p>与数学物理不同，倒是有点像政治，有着比较强的**”表述性”**；</p><p>在学习的过程中应当”取其精华”，尤其是面对一些晦涩难懂且冗长的概念。</p><p>这一章节作为导论，有什么”关键词”吗？</p><p><strong>框架、术语、原理、历史。</strong></p><p>此外，每一章大致分为两个部分：原理 + 实例；</p><p>其中，原理又有两个部分：功能 + 服务（一般是向上层提供接口的服务）</p><p><img src="https://s2.loli.net/2023/02/05/CmaRS2pUiZKVYP5.png" alt="avatar"></p><hr><h2 id="1-什么是Internet"><a href="#1-什么是Internet" class="headerlink" title="1. 什么是Internet?"></a>1. 什么是Internet?</h2><p><img src="https://s2.loli.net/2023/02/05/ejtp8fUq4HBGIRO.png" alt="avatar"></p><h3 id="从具体构成角度："><a href="#从具体构成角度：" class="headerlink" title="从具体构成角度："></a>从具体构成角度：</h3><p>互联网只是网络的一种，广义的网络就是<strong>节点 + 边</strong>，例如蜘蛛网、家族图谱等等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">Internet --- 节点</span><br><span class="line">Internet --- 边:通信链路</span><br><span class="line">Internet --- 协议</span><br><span class="line">节点 --- 主机节点</span><br><span class="line">节点 --- 数据交换节点</span><br><span class="line">边:通信链路 --- 接入链路</span><br><span class="line">边:通信链路 --- 骨干链路</span><br><span class="line">数据交换节点 --- 中继器</span><br><span class="line">数据交换节点 --- 交换机</span><br><span class="line">数据交换节点 --- 路由器</span><br><span class="line">数据交换节点 --- 负载均衡设备</span><br></pre></td></tr></table></figure><ul><li>主机节点：主机<code>host</code> &#x3D; 端系统<code>end system</code>，图例是<code>□</code>，还包括运行的网络应用程序；</li><li>数据交换节点：负责转发数据，图例是<code>○</code>；</li><li>通信链路：以<code>带宽bps，即bit/s</code>作为传输速率衡量标准，常见的有光纤、同轴电缆、卫星、无线电等；</li><li>接入链路：<code>□与○之间</code>；</li><li>骨干链路：<code>○与○之间</code>；</li><li>交换机：在链路层；</li><li>路由器：在网络层；</li></ul><h4 id="互联网："><a href="#互联网：" class="headerlink" title="互联网："></a>互联网：</h4><ul><li>由TCP和IP协议为主的一簇协议支撑工作的那个网，概括来说可以称为<strong>网络的网络</strong>；</li><li>松散的层次结构，互联的ISP (Internet Service Provider)因特网服务提供商；</li><li>公共Internet，专用intranet；</li><li>标准：RFC文档 → IETF；</li></ul><h4 id="协议："><a href="#协议：" class="headerlink" title="协议："></a>协议：</h4><ul><li>对等层的实体，在通信的过程中需要遵守的规范的集合。</li><li>协议控制发送</li><li>定义了在两个或多个通信实体之间交换的报文<strong>格式</strong>和<strong>次序</strong>，以及在报文传输、接收或其他事件方面所采取的<strong>动作</strong>。</li><li>PDU (Protocol Data Unit)协议数据单元，是指对等层次之间传递的数据单位。<ul><li>物理层的PDU是<code>bit</code></li><li>数据链路层的PDU是<code>数据帧frame</code></li><li>网络层的PDU是<code>数据包packet</code></li><li>传输层的PDU是<code>数据段segment</code></li><li>其他更高层次的PDU是数据<code>data</code></li></ul></li></ul><h3 id="从服务角度："><a href="#从服务角度：" class="headerlink" title="从服务角度："></a>从服务角度：</h3><p>包括分布式应用进程和为分布式应用进程提供通讯服务的基础设施。</p><h4 id="分布式应用进程："><a href="#分布式应用进程：" class="headerlink" title="分布式应用进程："></a>分布式应用进程：</h4><p>使用通信设施进行通信，包括Web、VoIP、Email、社交网络、电商等等；</p><h4 id="基础设施："><a href="#基础设施：" class="headerlink" title="基础设施："></a>基础设施：</h4><p>形式是API，将发送和接收数据的APPS与互联网连接起来，组成如下：</p><ul><li>主机</li><li>应用层以下的所有协议实体</li><li>网络的部分</li></ul><p>类型如下：区别就在于”打招呼与否”</p><ul><li>面向连接的可靠服务，用<code>TCP / IP()</code></li><li>无连接的不可靠服务，用<code>UDP</code></li></ul><blockquote><p>[缩写说明]：</p><ul><li>TCP Transmission Control Protocal是传输控制协议；</li><li>IP Internet Protocol是网际协议；</li><li>IETF Internet Engineering Task Force因特网工程任务组；</li><li>RFC Request for commets请求评论；</li><li>API Application Programming Interface应用程序编程接口；</li></ul></blockquote><hr><h2 id="2-网络边缘"><a href="#2-网络边缘" class="headerlink" title="2. 网络边缘"></a>2. 网络边缘</h2><p><img src="https://s2.loli.net/2023/02/06/UByjCsFYKgawRHn.png" alt="avatar"></p><h3 id="何为网络边缘？"><a href="#何为网络边缘？" class="headerlink" title="何为网络边缘？"></a>何为网络边缘？</h3><p><strong>采用网络设施的面向连接的服务；</strong></p><p>说白了，就是上文提到过的那些”方的”，也就是主机节点和应用程序<code>□</code>，它们是edge；</p><p>网络边缘是计算机网络的部件，当然还有其他的部件，一起构成了网络结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">网络结构 --- 网络边缘</span><br><span class="line">网络结构 --- 网络核心</span><br><span class="line">网络结构 --- 接入网+物理媒介</span><br><span class="line">网络边缘 --- 主机</span><br><span class="line">网络边缘 --- 应用程序</span><br><span class="line">网络核心 --- 路由器</span><br><span class="line">网络核心 --- 交换机</span><br><span class="line">主机 --- 客户端Client</span><br><span class="line">主机 --- 服务器Server</span><br></pre></td></tr></table></figure><hr><h3 id="应用进程间的通讯方式："><a href="#应用进程间的通讯方式：" class="headerlink" title="应用进程间的通讯方式："></a>应用进程间的通讯方式：</h3><p>主要有两种模式</p><h4 id="CS模式"><a href="#CS模式" class="headerlink" title="CS模式"></a>CS模式</h4><p>即客户端-服务器模式，这种模式是<strong>主从的</strong>，资源在服务器，客户端来请求之；</p><p>客户端是主动的，而服务器是被动的；</p><p>会有什么问题呢？</p><p>就是当Client太多的时候，需要好多的Server构成Server Farm，</p><p>从而导致更大的扩容代价和宕机代价，</p><p>总体来说就是<strong>可扩展性差</strong>。</p><h4 id="P2P模式"><a href="#P2P模式" class="headerlink" title="P2P模式"></a>P2P模式</h4><p>即peer - peer模式，是对等的一种模式，而非主从；</p><p>每个节点既可以是Client，也可以是Server，构成分布式的系统，<strong>可扩展性好</strong>；</p><p>例如迅雷等文件分发软件，就是利用P2P模式来进行更好的工作，传统的话是使用FTP；</p><blockquote><p>举例来说，如果你要下载一个文件，它会给你分成三个片段，你将会从不同的三个节点获得一部分片段，最后拼接汇集在一起，这样就实现了带宽的提升，速率的提升。</p></blockquote><hr><h3 id="关于连接服务："><a href="#关于连接服务：" class="headerlink" title="关于连接服务："></a>关于连接服务：</h3><p>共同点：都是采用网络设施进行的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">连接 --- 面向连接服务 --- 通信的状态只是在端系统维护 --- TCP</span><br><span class="line">连接 --- 有连接 --- 通信的状态由端系统和中间的节点共同维护</span><br><span class="line">无连接 --- 无连接服务 --- UDP</span><br></pre></td></tr></table></figure><h4 id="TCP服务"><a href="#TCP服务" class="headerlink" title="TCP服务"></a>TCP服务</h4><ul><li>可靠：不出错、不乱序、不重复、不丢失；</li><li>流量控制：维护一个Balance，协调发送方和接收方的速率；</li><li>拥塞控制：维护一个Balance，协调链路上的节点的通行能力，类似道路车流量控制；</li></ul><h4 id="UDP服务"><a href="#UDP服务" class="headerlink" title="UDP服务"></a>UDP服务</h4><ul><li>无连接：上来就发送，就是任性</li><li>不可靠：丢了一些也没关系</li><li>无流量控制</li><li>无拥塞控制</li></ul><p>对于无连接服务，这里有补充：</p><p><img src="https://s2.loli.net/2023/02/09/IFwhJQifvaKbPu3.png" alt="avatar"></p><hr><h2 id="3-网络核心"><a href="#3-网络核心" class="headerlink" title="3. 网络核心"></a>3. 网络核心</h2><p>网络分类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">通信网络 --- 分组交换网络</span><br><span class="line">通信网络 --- 电路交换网络</span><br><span class="line">电路交换网络 --- FDM</span><br><span class="line">电路交换网络 --- TDM</span><br><span class="line">分组交换网络 --- 有网络层 --- 数据报网络</span><br><span class="line">分组交换网络 --- 无网络层 --- 虚电路网络</span><br></pre></td></tr></table></figure><p>基本问题：<strong>数据怎样通过网络进行传输？</strong></p><p>网络核心包括分组交换机以及网络链路，它们一起构成了<strong>网状网络</strong>；</p><h3 id="分组交换："><a href="#分组交换：" class="headerlink" title="分组交换："></a>分组交换：</h3><p>关键功能：<strong>路由 + 转发</strong></p><ul><li>路由：决定分组采用的源到目标的路径，路由算法；</li><li>转发：将分组从路由器的输入链路转移到输出链路；</li></ul><p>特点：</p><ul><li>将要传送的数据分成一个个单位：分组packet；</li><li>将分组packet从一个路由器传到相邻路由器hop，一段段最终从源端传送到目标端；</li><li>每段：采用链路的最大传输能力，即带宽；</li></ul><p><img src="https://s2.loli.net/2023/02/08/i8aqtym1HWz3ATd.png" alt="avatar"></p><h4 id="存储转发传输"><a href="#存储转发传输" class="headerlink" title="存储转发传输"></a>存储转发传输</h4><ul><li>被传输到下一个链路之前，整个分组必须到达路由器；</li><li>在一个速率为<code>R</code> bps的链路 ，一个长度为<code>L</code> bits 的分组 的存储转发延时： <code>L/R</code> s；</li></ul><h4 id="排队延时和分组丢失"><a href="#排队延时和分组丢失" class="headerlink" title="排队延时和分组丢失"></a>排队延时和分组丢失</h4><p><img src="https://s2.loli.net/2023/02/08/hGF62ZPvNKTErOq.png" alt="avatar"></p><ul><li>如果到达速率 &gt; 链路的输出速率，则分组将会排队，形成queue；</li><li>但如果路由器的缓存用完了，分组将会被抛弃，俗称丢包；</li></ul><h4 id="统计多路复用"><a href="#统计多路复用" class="headerlink" title="统计多路复用"></a>统计多路复用</h4><p><img src="https://s2.loli.net/2023/02/08/kVEIqCre7obDHF1.png" alt="avatar"></p><h4 id="转发表和路由选择协议"><a href="#转发表和路由选择协议" class="headerlink" title="转发表和路由选择协议"></a>转发表和路由选择协议</h4><p>路由器怎样决定它应当向哪条链路进行转发呢？</p><p>在因特网中，每个端系统具有一个称为IP地址的地址，当源主机要向目标端系统发送一个packet时，源在该分组的首部包含了目的地的IP地址，方便路由器进行转发；</p><p>另外，每台路由器具有一个<strong>转发表</strong>，用于将目的地址（或者一部分）映射为输出链路。</p><p>但是，转发表示如何进行设置的？是人工的还是自动的？实际上是通过<strong>路由选择协议</strong>来实现自动设置转发表，在后面的章节会详细介绍（第四章）。</p><h4 id="分组交换的网络层"><a href="#分组交换的网络层" class="headerlink" title="分组交换的网络层"></a>分组交换的网络层</h4><blockquote><ol><li><p>数据报网络： </p><p> 分组的目标地址决定下一跳</p><p> 在不同的阶段，路由可以改变</p><p> 类似：问路</p><p> Internent</p></li><li><p>虚电路网络：</p><p> 每个分组都带标签（虚电路标识 VC ID），标签决定下一跳</p><p> 在呼叫建立时决定路径，在整个呼叫中路径保持不变</p><p> 路由器维持每个呼叫的状态信息</p><p> X.25 和ATM</p></li></ol></blockquote><p><em>其工作原理暂略</em></p><hr><h3 id="电路交换："><a href="#电路交换：" class="headerlink" title="电路交换："></a>电路交换：</h3><p>这是一种端到端 end-to-end 的连接</p><ul><li>为每个呼叫<strong>预留</strong>一条专有电路：如电话网；</li><li>专用资源：不共享，即每个呼叫一旦建立起来就能够保证性能；</li><li>如果呼叫没有数据发送，被分配的资源就会被浪费；</li><li>通常被传统电话网络采用，不适合计算机之间的通信；<ul><li>连接建立时间长；</li><li>计算机之间的通信有突发性，如果使用电路交换则浪费的片较多；</li></ul></li></ul><h4 id="电路交换-网络资源分片"><a href="#电路交换-网络资源分片" class="headerlink" title="电路交换-网络资源分片"></a>电路交换-网络资源分片</h4><p>网络资源，如带宽被分成片</p><ul><li>FDM 频分复用</li><li>TDM 时分复用</li><li>WDM 波分复用</li></ul><p><img src="https://s2.loli.net/2023/02/08/2eDUayYI1VsgCwX.png" alt="avatar"></p><h4 id="电路交换-计算"><a href="#电路交换-计算" class="headerlink" title="电路交换-计算"></a>电路交换-计算</h4><p><img src="https://s2.loli.net/2023/02/08/Ep6Xf7Lhr2ayGPH.png" alt="avatar"></p><hr><h3 id="分组交换网中的时延、丢包和吞吐量详解："><a href="#分组交换网中的时延、丢包和吞吐量详解：" class="headerlink" title="分组交换网中的时延、丢包和吞吐量详解："></a>分组交换网中的时延、丢包和吞吐量详解：</h3><h4 id="四种时延："><a href="#四种时延：" class="headerlink" title="四种时延："></a>四种时延：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">节点总时延 --- 处理时延</span><br><span class="line">节点总时延 --- 排队时延</span><br><span class="line">节点总时延 --- 传输时延</span><br><span class="line">节点总时延 --- 传播时延</span><br></pre></td></tr></table></figure><ul><li>处理时延：检查分组首部和决定将该分组导向何处所需要的时间是处理时延的一部分；</li><li>排队时延：在队列中，当分组在链路上等待传输时，它经受排队时延；</li><li>传输时延：<code>L / R</code>，也就是路由器将分组从队列中推出去的时间；</li><li>传播时延：从链路起点到终点的物理传播需要的时间；</li></ul><h4 id="流量强度："><a href="#流量强度：" class="headerlink" title="流量强度："></a><strong>流量强度</strong>：</h4><p><code>L * a / R</code>，<code>a</code>是表示分组到达队列的平均速率，单位是<code>分组/秒</code>，即<code>pkt/s</code>；</p><p><img src="https://s2.loli.net/2023/02/08/pEzcJ6yqtaZl5A4.png" alt="avatar"></p><h4 id="丢包："><a href="#丢包：" class="headerlink" title="丢包："></a><strong>丢包</strong>：</h4><p>随着流量强度接近1，队列将满，路由器将丢弃后续分组。</p><h4 id="端到端时延："><a href="#端到端时延：" class="headerlink" title="端到端时延："></a>端到端时延：</h4><p><img src="https://s2.loli.net/2023/02/08/cGiBtFpqmgaOxYD.png" alt="avatar"></p><h5 id="1-Traceroute："><a href="#1-Traceroute：" class="headerlink" title="1. Traceroute："></a>1. Traceroute：</h5><p>Traceroute是一个简单的程序，它能够在任何因特网上运行。</p><p>当用户指定一个目的主机名字时，源主机中的该程序朝着该目的地发送多个特殊的分组。</p><p>更具体的内容暂略。</p><h5 id="2-端系统、应用程序和其他时延"><a href="#2-端系统、应用程序和其他时延" class="headerlink" title="2. 端系统、应用程序和其他时延"></a>2. 端系统、应用程序和其他时延</h5><p>这种填充一个分组的时间称为分组化时延，可能较大。</p><h4 id="计算机网络中的吞吐量"><a href="#计算机网络中的吞吐量" class="headerlink" title="计算机网络中的吞吐量"></a>计算机网络中的吞吐量</h4><p>吞吐量分为<strong>瞬时吞吐量</strong>和<strong>平均吞吐量</strong>；</p><ul><li>瞬时吞吐量：是主机接收到文件的速率，以bps计；</li><li>平均吞吐量：如果该文件由<code>F bit</code>，主机B接收到所有<code>F bit</code>用去了<code>T秒</code>，则文件传送的平均吞吐量是<code>F / T bps</code>；</li></ul><h5 id="瓶颈链路"><a href="#瓶颈链路" class="headerlink" title="瓶颈链路"></a>瓶颈链路</h5><p><img src="https://s2.loli.net/2023/02/08/gLapHFwhsI7WqyN.png" alt="avatar"></p><hr><h2 id="4-接入网与物理媒体"><a href="#4-接入网与物理媒体" class="headerlink" title="4. 接入网与物理媒体"></a>4. 接入网与物理媒体</h2><p>接入网是指host与edge router相连的这条物理链路；</p><p>三个方式：</p><ul><li>家庭接入网络</li><li>单位接入网络（学校、公司）</li><li>无线接入网络</li></ul><p>两个注意：</p><ul><li>接入网络的带宽？</li><li>共享 or 专用？</li></ul><h3 id="家庭接入："><a href="#家庭接入：" class="headerlink" title="家庭接入："></a>家庭接入：</h3><p><img src="https://s2.loli.net/2023/02/08/qMKP6JzvwNAlVmi.png" alt="avatar"></p><ul><li>DSL 数字用户线，即接入网<ul><li>采用现存的到交换局DSLAM的电话线；<ul><li>DSL线路上的数据被传到互联网；</li><li>DSL线路上的语音被传到电话网；</li></ul></li><li>&lt; 2.5 Mbps上行传输速率(typically &lt; 1 Mbps)；</li><li>&lt; 24 Mbps下行传输速率(typically &lt; 10 Mbps)；</li></ul></li></ul><p><img src="https://s2.loli.net/2023/02/08/dzcoI4xFt3kKDEW.png" alt="avatar"></p><hr><ul><li><p>电缆</p><p>  <img src="https://s2.loli.net/2023/02/08/AfL1I4be9KXhJtB.png" alt="avatar"></p></li></ul><hr><ul><li>FTTH 光纤到户<ul><li>又称线缆网络，有线电视信号线缆双向改造；</li><li>FDM: 在不同频段传输不同信道的数据，数字电视和上网数据（上下行）；</li><li>HFC: hybrid fiber coax<ul><li>非对称: 最高30Mbps的下行传输速率, 2 Mbps 上行传输速率；</li></ul></li><li><strong>线缆和光纤网络</strong>将家庭用户接入到ISP路由器；</li><li>各用户共享到线缆头端的接入网络；<ul><li>与DSL不同，DSL每个用户一个专用线路到CO (Central Office)；</li></ul></li></ul></li></ul><p><img src="https://s2.loli.net/2023/02/08/K3CfPj7cB6nm54F.png" alt="avatar"></p><hr><ul><li>拨号 + 卫星<ul><li>利用modem，将上网数据<strong>调制</strong>加载音频信号上，在电话线上传输，在局端将其中的数据<strong>解调</strong>出来，反之亦然；<ul><li>调频</li><li>调幅</li><li>调相位</li><li>综合调制</li></ul></li><li>56Kbps 的速率直接接入路由器 (通常更低)；</li><li>不能同时上网和打电话：不能总是在线；</li></ul></li></ul><hr><h3 id="企业接入网络："><a href="#企业接入网络：" class="headerlink" title="企业接入网络："></a>企业接入网络：</h3><p><img src="https://s2.loli.net/2023/02/08/OypJYFo6GZ1HmMc.png" alt="avatar"></p><ul><li>以太网</li><li>WiFi</li></ul><hr><h3 id="广域无线接入网络："><a href="#广域无线接入网络：" class="headerlink" title="广域无线接入网络："></a>广域无线接入网络：</h3><p>各无线端系统共享无线接入网络（端系统到无线路由器），通过基站（接入站）；</p><p><img src="https://s2.loli.net/2023/02/08/oVwYQ3TDIbL1vMJ.png" alt="avatar"></p><hr><h3 id="物理媒体："><a href="#物理媒体：" class="headerlink" title="物理媒体："></a>物理媒体：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">物理媒体 --- 引导型媒体</span><br><span class="line">物理媒体 --- 非引导型媒体</span><br><span class="line">引导型媒体 --- 光缆</span><br><span class="line">引导型媒体 --- 双绞铜线TP</span><br><span class="line">双绞铜线TP --- 5类</span><br><span class="line">双绞铜线TP --- 6类</span><br><span class="line">引导型媒体 --- 同轴电缆</span><br><span class="line">非引导型媒体 --- 无线LAN</span><br><span class="line">非引导型媒体 --- 数字卫星频道</span><br><span class="line">无线LAN --- 几米</span><br><span class="line">无线LAN --- 百米</span><br><span class="line">无线LAN --- 万米</span><br><span class="line">数字卫星频道 --- 同步卫星36000km</span><br><span class="line">数字卫星频道 --- 近地轨道卫星LEO</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/02/08/x85PnRkLuey3gmH.png" alt="avatar"></p><p><img src="https://s2.loli.net/2023/02/08/R6fuCnWYScw9Khy.png" alt="avatar"></p><hr><h2 id="5-Internet结构和ISP"><a href="#5-Internet结构和ISP" class="headerlink" title="5. Internet结构和ISP"></a>5. Internet结构和ISP</h2><h3 id="互联网络结构：网络的网络"><a href="#互联网络结构：网络的网络" class="headerlink" title="互联网络结构：网络的网络"></a>互联网络结构：网络的网络</h3><p>端系统通过<strong>接入ISP</strong>来连接到互联网；</p><p>若将每个接入ISP都连接到全局ISP，客户ISPs和提供者ISPs又经纪合约，这样一定会有竞争者有利可图，一定存在竞争，于是不能直接这么干；</p><p><img src="https://s2.loli.net/2023/02/09/jEsRQm896bUuTCF.png" alt="avatar"></p><ul><li>POP: 高层ISP面向客户网络的接入点，涉及费用结算<ul><li>如一个低层ISP接入多个高层ISP，多宿（multi home）</li></ul></li><li>对等接入：2个ISP对等互接，不涉及费用结算</li><li>IXP：多个对等ISP互联互通之处，通常不涉及费用结算<ul><li>对等接入</li></ul></li><li>ICP自己部署专用网络，同时和各级ISP连接</li></ul><hr><h2 id="6-协议层次及服务模型"><a href="#6-协议层次及服务模型" class="headerlink" title="6. 协议层次及服务模型"></a>6. 协议层次及服务模型</h2><p>网络有很多构成元素和设备：</p><ul><li>主机</li><li>路由器</li><li>各种媒体的链路</li><li>应用</li><li>协议</li><li>硬件，软件</li><li>…</li></ul><p>如何组织和实现这个复杂的网络功能呢？答案是<strong>分层</strong>！</p><h3 id="层次化方式实现复杂网络功能："><a href="#层次化方式实现复杂网络功能：" class="headerlink" title="层次化方式实现复杂网络功能："></a>层次化方式实现复杂网络功能：</h3><ul><li>将网络复杂的功能分层功能明确的<strong>层次</strong>，每一层实现了其中一个或一组<strong>功能</strong>，功能中有其上层可以使用的功能：<strong>服务</strong>；</li><li>本层协议实体相互交互执行本层的<strong>协议动作</strong>，<em>目的是实现本层功能，通过接口为上层提供更好的服务</em>；</li><li>在实现本层协议的时候，直接利用了下层所提供的服务；</li><li>本层的服务：借助下层服务实现的本层协议实体之间交互带来的新功能（上层可以利用的）+ 更下层所提供的服务；</li></ul><h3 id="服务与协议："><a href="#服务与协议：" class="headerlink" title="服务与协议："></a>服务与协议：</h3><h4 id="服务与协议的区别"><a href="#服务与协议的区别" class="headerlink" title="服务与协议的区别"></a>服务与协议的区别</h4><ul><li>服务(Service)：低层实体<strong>向上层</strong>实体提供它们之间的通信的能力，是通过原语(primitive)来操作的，垂直的</li><li>协议(protocol) ：<strong>对等层</strong>实体(peer entity)之间在相互通信的过程中，需要遵循的规则的集合，水平的</li></ul><h4 id="服务与协议的联系"><a href="#服务与协议的联系" class="headerlink" title="服务与协议的联系"></a>服务与协议的联系</h4><ul><li>本层协议的实现要靠下层提供的服务来实现</li><li>本层实体通过协议为上层提供更高级的服务</li></ul><h3 id="数据单元DU："><a href="#数据单元DU：" class="headerlink" title="数据单元DU："></a>数据单元DU：</h3><p><img src="https://s2.loli.net/2023/02/09/LAfnrGHpzymOXt1.png" alt="avatar"></p><p>上文提到过的：</p><p>PDU (Protocol Data Unit)协议数据单元，是指对等层次之间传递的数据单位。</p><ul><li>物理层的PDU是<code>bit</code></li><li>数据链路层的PDU是<code>数据帧frame</code></li><li>网络层的PDU是<code>数据包packet</code></li><li>传输层的PDU是<code>数据段segment</code></li><li>其他更高层次的PDU是数据<code>data</code></li></ul><p><strong>具体来说</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">数据单元 --- 应用层 --- 报文message</span><br><span class="line">数据单元 --- 传输层 --- 报文段segment</span><br><span class="line">数据单元 --- 网络层 --- 分组packet</span><br><span class="line">数据单元 --- 链路层 --- 帧frame</span><br><span class="line">数据单元 --- 物理层 --- 位bit</span><br></pre></td></tr></table></figure><h3 id="分层处理和实现复杂系统的好处？"><a href="#分层处理和实现复杂系统的好处？" class="headerlink" title="分层处理和实现复杂系统的好处？"></a>分层处理和实现复杂系统的好处？</h3><ul><li>概念化：结构清晰，便于标示网络组件，以及描述其相互关系<ul><li>分层参考模型</li></ul></li><li>结构化：模块化更易于维护和系统升级<ul><li>针对某一层的改变是独立的</li></ul></li></ul><h3 id="Internet协议栈："><a href="#Internet协议栈：" class="headerlink" title="Internet协议栈："></a>Internet协议栈：</h3><p>应用层: 网络应用</p><ul><li>为人类用户或者其他应用进程提供网络应用服务</li><li>FTP，SMTP，HTTP，DNS</li></ul><p>传输层: 主机之间的数据传输</p><ul><li>在网络层提供的端到端通信基础上，细分为进程 到进程，将不可靠的通信变成可靠地通信</li><li>TCP，UDP</li></ul><p>网络层: 为数据包从源到目的选择路由</p><ul><li>主机主机之间的通信，端到端通信，不可靠</li><li>IP，路由协议</li></ul><p>链路层: 相邻网络节点间的数据传输</p><ul><li>2个相邻2点的通信，点到点通信，可靠或不可靠</li><li>点对对协议PPP，802.11(wifi)，Ethernet</li></ul><p>物理层: 在线路上传送bit</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">Internet协议栈 --- 应用层 --- 网络应用</span><br><span class="line">Internet协议栈 --- 传输层 --- 主机之间的数据传输</span><br><span class="line">Internet协议栈 --- 网络层 --- 为数据包从源到目的选择路由</span><br><span class="line">Internet协议栈 --- 链路层 --- 相邻网络节点之间的数据传输</span><br><span class="line">Internet协议栈 --- 物理层 --- 在线路上传送bit</span><br></pre></td></tr></table></figure><h3 id="ISO-x2F-OSI-参考模型："><a href="#ISO-x2F-OSI-参考模型：" class="headerlink" title="ISO &#x2F; OSI 参考模型："></a>ISO &#x2F; OSI 参考模型：</h3><p><img src="https://s2.loli.net/2023/02/09/sUY6iWKrzgXEuAk.png" alt="avatar"></p><h3 id="封装与解封装："><a href="#封装与解封装：" class="headerlink" title="封装与解封装："></a>封装与解封装：</h3><p><img src="https://s2.loli.net/2023/02/09/ujJOm6TViNrvBZw.png" alt="avatar"></p><hr><h2 id="7-面对攻击的网络"><a href="#7-面对攻击的网络" class="headerlink" title="7. 面对攻击的网络"></a>7. 面对攻击的网络</h2><p>网络安全领域主要探讨以下问题：</p><ul><li>坏家伙如何攻击计算机网络？</li><li>我们如何防御以免受他们的攻击？</li></ul><h3 id="坏家伙能够经因特网将有害程序放入你的计算机中："><a href="#坏家伙能够经因特网将有害程序放入你的计算机中：" class="headerlink" title="坏家伙能够经因特网将有害程序放入你的计算机中："></a>坏家伙能够经因特网将有害程序放入你的计算机中：</h3><p>一些<strong>恶意软件</strong>，会做各种不正当的事情，包括但不限于删除我们的文件，安装间谍软件来收集隐私信息。</p><p>受害的主机也会变成数以千计的受害设备网络中的一员，被统称为<strong>僵尸网络</strong>。</p><p>如今（当时是2013年），多数恶意软件是通过<strong>自我复制</strong>来操作的，通过病毒或蠕虫的方式扩散：</p><ul><li>病毒：是一种需要某种形式的用户交互来感染用户设备的恶意软件，典型的例子是包含恶意可执行代码的电子邮件附件。</li><li>蠕虫：是一种无需任何明显用户交互就能进入设备的恶意软件，那些应用程序可能从因特网接收恶意软件并运行它，生成了蠕虫。新近感染设备中的蠕虫则能扫描因特网，搜索其他运行相同易受感染的网络应用程序的主机，一经发现便发送一个自身副本。</li></ul><h3 id="坏家伙能够攻击服务器和网络基础设施："><a href="#坏家伙能够攻击服务器和网络基础设施：" class="headerlink" title="坏家伙能够攻击服务器和网络基础设施："></a>坏家伙能够攻击服务器和网络基础设施：</h3><p>另一种宽泛类型的安全性威胁称为<strong>拒绝服务攻击</strong>（Denial-of-Service (DoS) attack），顾名思义，DoS攻击使得网络、主机或其他基础设施部分不能由合法用户所使用。Web服务器、电子邮件服务器、DNS服务器等都可以作为DoS攻击的目标。一般有如下三种类型：</p><ul><li><strong>弱点攻击</strong>：这涉及向一台目标主机上运行的易受攻击的应用程序或操作系统发送制作精细的报文，如果适当顺序的多个分组发送给一个易受攻击的应用程序或操作系统，该服务器可能停止运行，或者更糟糕的是主机可能崩溃。</li><li><strong>带宽洪泛</strong>：攻击者向目标主机发送大量的分组，分组数量之多使得目标的接入链路变得拥塞，使得合法的分组无法到达服务器。</li><li><strong>连接洪泛</strong>：攻击者在目标主机中创建大量的半开或者全开TCP连接，该主机因为这些伪造的连接而陷入困境，并停止接受合法的连接。</li></ul><p>值得一提的是，<strong>分布式DoS</strong>(Distributed DoS)攻击就是大名鼎鼎的DDoS攻击，攻击者控制多个源并让每个源向目标猛烈发送流量，比起单一主机的DoS，DDoS更加难以检测和防范。</p><p><img src="https://s2.loli.net/2023/02/09/gaZ2Cz9KfmYvEIM.png" alt="avatar"></p><h3 id="坏家伙能够嗅探分组："><a href="#坏家伙能够嗅探分组：" class="headerlink" title="坏家伙能够嗅探分组："></a>坏家伙能够嗅探分组：</h3><p>当无处不在的因特网接入极为便利并使得令人惊奇的新应用程序为移动用户所用的同时，也产生了重大的安全弱点——在无线传输设备的附近放置一台被动的接收机，该接收机就能得到传输的每个分组的副本。记录每个流经的分组副本的被动接收机也被称为<strong>分组嗅探器</strong>(packet sniffer)。</p><p>当然，这也能够部署在有线环境中，这里先略过。</p><p>因为分组嗅探器是被动的，也就是说它们不向信道中注入分组，所以难以检测它们的存在，因此，我们向无线信道发送分组的时候，<strong>必须接受这样的可能性</strong>。</p><h3 id="坏家伙能够伪装成你信任的人："><a href="#坏家伙能够伪装成你信任的人：" class="headerlink" title="坏家伙能够伪装成你信任的人："></a>坏家伙能够伪装成你信任的人：</h3><p>这个大家还是挺熟悉的，后面再介绍更加细节的内容。</p><p>这里就介绍一个概念：</p><p>将具有虚假源地址的分组注入因特网的能力被称为<strong>IP哄骗</strong> (IP spoofing)；</p><hr><h2 id="8-计算机网络的历史"><a href="#8-计算机网络的历史" class="headerlink" title="8. 计算机网络的历史"></a>8. 计算机网络的历史</h2><p><img src="https://s2.loli.net/2023/02/09/lt87ge4ZbTCksoW.png" alt="avatar"></p><p>具体内容待补充，敬请期待！</p><p><em>“不闻不若闻之，闻之不若见之，见之不若知之，知之不若行之。”</em></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;em&gt;Computer Networking A Top-Down Approach Learning Note Part 1&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前言的前言的前言&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;本文在笔者的博客内有流程图加载不出来的bug，烦请各</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>RabbitMQ丨学习记录</title>
    <link href="https://conqueror712.github.io/post/RabbitMQ.html"/>
    <id>https://conqueror712.github.io/post/RabbitMQ.html</id>
    <published>2023-02-01T02:42:42.000Z</published>
    <updated>2023-02-15T14:22:58.546Z</updated>
    
    <content type="html"><![CDATA[<h1 id="零、前言"><a href="#零、前言" class="headerlink" title="零、前言"></a>零、前言</h1><p>本文记录了笔者在学习消息队列和RabbitMQ的基础知识的过程，</p><p>若笔者有任何疏忽纰漏之处，烦请不吝赐教。</p><p>本文会不断的补充、修改和完善，期待您的宝贵意见。</p><h2 id="什么是中间件？为什么要使用它？"><a href="#什么是中间件？为什么要使用它？" class="headerlink" title="什么是中间件？为什么要使用它？"></a>什么是中间件？为什么要使用它？</h2><p>中间件 Middleware 是<strong>处于操作系统和应用程序之间的软件</strong>。</p><p>人们在使用中间件时，往往是一组中间件<strong>集成在一起</strong>，构成一个平台（包括开发平台和运行平台），</p><p>但在这组中间件中必须要有一个<strong>通信中间件</strong>，即<code>中间件 = 平台 + 通信</code>，</p><p>这个定义也限定了只有<strong>用于分布式系统</strong>中才能称为中间件，同时还可以把它与支撑软件和实用软件区分开来。</p><p>中间件<strong>屏蔽了底层操作系统的复杂性</strong>，使程序开发人员面对一个简单而统一的开发环境，减少程序设计的复杂性，将注意力集中在自己的业务上，不必再为程序在不同系统软件上的移植而重复工作，从而大大减少了技术上的负担。</p><p>中间件带给应用系统的，不只是开发的简便、开发周期的缩短，也减少了系统的维护、运行和管理的工作量，还减少了计算机总体费用的投入。</p><p>中间件应该具有以下的<strong>特点</strong>：</p><ul><li>满足大量应用的需要</li><li>运行于多种硬件和OS平台</li><li>支持分布计算，提供跨网络、硬件和OS平台的透明性的应用或服务的交互</li><li>支持标准的协议</li><li>支持标准的接口</li></ul><p>另外，中间件的技术一般现在一些互联网公司或者项目中使用比较多，如果仅仅还只是一个初创公司建议还是使用单体架构，最多加个缓存中间件即可，不要盲目追求新或者所谓的高性能，而<strong>追求的背后一定是业务的驱动和项目的驱动</strong>。</p><h2 id="知识图谱："><a href="#知识图谱：" class="headerlink" title="知识图谱："></a><strong>知识图谱</strong>：</h2><p><img src="https://s2.loli.net/2023/02/01/bB8HDJIs2tlKSXw.png" alt="avatar"></p><h2 id="学习目标与技巧"><a href="#学习目标与技巧" class="headerlink" title="学习目标与技巧"></a>学习目标与技巧</h2><p><strong>我们需要理解和掌握</strong>：</p><ul><li>什么是消息中间件</li><li>什么是协议</li><li>什么是持久化</li><li>消息分发</li><li>消息的高可用</li><li>消息的集群</li><li>消息的容错</li><li>消息的冗余</li></ul><p><strong>一些可供参考的方法</strong>：</p><ul><li>理解中间件在项目架构中的作用，以及各中间件的底层实现；</li><li>可以使用一些类比的生活概念去理解中间件；</li><li>使用一些流程图或者脑图的方式去梳理各个中间件在架构中的作用；</li><li>思考中间件在项目中设计的和使用的原因；</li><li>学会查看中间件的源码以及开开源项目和博客。</li></ul><hr><h1 id="一、分布式架构与消息中间件"><a href="#一、分布式架构与消息中间件" class="headerlink" title="一、分布式架构与消息中间件"></a>一、分布式架构与消息中间件</h1><h2 id="0-分布式架构"><a href="#0-分布式架构" class="headerlink" title="0. 分布式架构"></a>0. 分布式架构</h2><p>通俗解释分布式系统：<strong>一个请求由服务器端的多个服务协同处理完成</strong>。</p><p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/02/28/kuangstudyd40834ed-a15f-4606-bb36-ce475b05a949.png" alt="avatar"></p><blockquote><p><strong>存在问题</strong><br>1：学习成本高，技术栈过多；<br>2：运维成本和服务器成本增高；<br>3：人员的成本也会增高；<br>4：项目的负载度也会上升；<br>5：面临的错误和容错性也会成倍增加；<br>6：占用的服务器端口和通讯的选择的成本高；<br>7：安全性的考虑和因素逼迫可能选择RMI&#x2F;MQ相关的服务器端通讯。</p><p><strong>好处</strong><br>1：服务系统的独立，占用的服务器资源减少和占用的硬件成本减少；<br>确切的说是：可以合理的分配服务资源，不造成服务器资源的浪费；<br>2：系统的独立维护和部署，耦合度降低，可插拔性；<br>3：系统的架构和技术栈的选择可以变的灵活；<br>4：弹性的部署，不会造成平台因部署造成的瘫痪和停服的状态。</p></blockquote><hr><h2 id="1-消息中间件"><a href="#1-消息中间件" class="headerlink" title="1. 消息中间件"></a>1. 消息中间件</h2><h3 id="消息中间件的主要作用："><a href="#消息中间件的主要作用：" class="headerlink" title="消息中间件的主要作用："></a>消息中间件的<strong>主要作用</strong>：</h3><ul><li>利用可靠的消息传递机制进行<strong>系统和系统直接的通讯</strong>；</li><li>通过提供消息传递和消息的排队机制，它可以在分布式系统环境下<strong>扩展进程间的通讯</strong>。</li></ul><h3 id="消息中间件的应用场景："><a href="#消息中间件的应用场景：" class="headerlink" title="消息中间件的应用场景："></a>消息中间件的应用场景：</h3><ul><li>跨系统数据传递；</li><li>高并发的流量削峰；</li><li>数据的分发和异步处理；</li><li>大数据分析与传递；</li><li>分布式事务；</li></ul><p>很常见的一个例子就是电商的并发订单。</p><h3 id="消息中间件的本质及设计："><a href="#消息中间件的本质及设计：" class="headerlink" title="消息中间件的本质及设计："></a>消息中间件的本质及设计：</h3><p>它是一种接受数据，接受请求、存储数据、发送数据等功能的技术服务。</p><p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/02/28/kuangstudy7c171d88-687a-4c6c-8a97-2b257467172e.png" alt="avatar"></p><h3 id="消息中间件的核心组成部分："><a href="#消息中间件的核心组成部分：" class="headerlink" title="消息中间件的核心组成部分："></a>消息中间件的核心组成部分：</h3><ul><li>消息的协议</li><li>消息的持久化机制</li><li>消息的分发策略</li><li>消息的高可用，高可靠</li><li>消息的容错机制</li></ul><hr><h1 id="二、消息与消息队列"><a href="#二、消息与消息队列" class="headerlink" title="二、消息与消息队列"></a>二、消息与消息队列</h1><h2 id="0-网络协议简介"><a href="#0-网络协议简介" class="headerlink" title="0. 网络协议简介"></a>0. 网络协议简介</h2><p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/03/02/kuangstudy9e91d500-e775-45f3-92fa-78a6278efc51.png" alt="avatar"></p><p>协议：</p><ol><li>计算机底层操作系统和应用程序通讯时共同遵守的一组约定，只有遵循共同的约定和规范，系统和底层操作系统之间才能相互交流。</li><li>和一般的网络应用程序的不同它主要负责数据的接受和传递，所以性能比较的高。</li><li>协议对数据格式和计算机之间交换数据都必须严格遵守规范。</li></ol><p>协议的<strong>三要素</strong>：</p><ol><li>语法：语法是用户数据与控制信息的结构与格式，以及数据出现的顺序。</li><li>语义：语义是解释控制信息每个部分的意义。它规定了需要发出何种控制信息，以及完成的动作与做出什么样的响应。</li><li>时序：时序是对事件发生顺序的详细说明。</li></ol><blockquote><p>以HTTP请求协议举例：</p><p>语法：http规定了请求报文和响应报文的格式。<br>语义：客户端主动发起请求称之为请求。<br>时序：一个请求对应一个响应，注意是先有请求再有响应。</p></blockquote><blockquote><p>Q：为什么消息中间件不直接使用HTTP协议呢？</p><p>A：首先因为http请求报文头和响应报文头是比较复杂的，包含了cookie，数据的加密解密，状态码，响应码等附加的功能，但是对于一个消息而言，我们并不需要这么复杂，也没有这个必要性，它其实就是负责数据传递，存储，分发就行，一定要追求的是高性能。尽量简洁，快速。其次大部分情况下http大部分都是短链接，在实际的交互过程中，一个请求到响应很有可能会中断，中断以后就不会就行持久化，就会造成请求的丢失。这样就不利于消息中间件的业务场景，因为消息中间件可能是一个长期的获取消息的过程，出现问题和故障要对数据或消息就行持久化等，目的是为了保证消息和数据的高可靠和稳健的运行。</p></blockquote><hr><h3 id="AMQP协议"><a href="#AMQP协议" class="headerlink" title="AMQP协议"></a>AMQP协议</h3><p>Advanced Message Queuing Protocol 高级消息队列协议</p><p>它是一种面向消息中间件的开放标准，支持应用程序之间安全可靠的通信。</p><p>它提供了一个灵活和可扩展的消息体系结构，具有事务、路由和消息持久性等特性。</p><p>特点：</p><ul><li>分布式事务支持。</li><li>消息的持久化支持。</li><li>高性能和高可靠的消息处理优势。</li></ul><h3 id="MQTT协议"><a href="#MQTT协议" class="headerlink" title="MQTT协议"></a>MQTT协议</h3><p>Message Queueing Telemetry Transport </p><p>它是一种轻量级的发布-订阅消息传递协议，专为资源受限的设备和低带宽的网络设计。</p><p>它被广泛应用于物联网(Internet of Things)和M2M (Machine-to-Machine)通信，为设备之间的数据传输和接收提供了一种简单高效的机制。</p><p>特点：</p><ul><li>轻量</li><li>结构简单</li><li>传输快，不支持事务</li><li>没有持久化设计。</li></ul><p>应用场景：</p><ul><li>适用于计算能力有限</li><li>低带宽</li><li>网络不稳定的场景。</li></ul><h3 id="OpenMessage协议"><a href="#OpenMessage协议" class="headerlink" title="OpenMessage协议"></a>OpenMessage协议</h3><p>它是阿里巴巴集团为其中间件产品RocketMQ开发的专有消息协议。</p><p>它提供高性能和可靠的消息传递，具有消息排序、容错和发布-订阅消息等特性。</p><p>特点：</p><ul><li>结构简单</li><li>解析速度快</li><li>支持事务和持久化设计。</li></ul><h3 id="Kafka协议"><a href="#Kafka协议" class="headerlink" title="Kafka协议"></a>Kafka协议</h3><p>Kafka协议是基于TCP&#x2F;IP的二进制协议。</p><p>其消息内部是通过长度来分割，由一些基本数据类型组成。</p><p>特点：</p><ul><li>结构简单</li><li>解析速度快</li><li>无事务支持</li><li>有持久化设计</li></ul><hr><h2 id="1-MQ持久化"><a href="#1-MQ持久化" class="headerlink" title="1. MQ持久化"></a>1. MQ持久化</h2><p>持久化就是将数据存入磁盘，而不是存在内存中随服务器重启断开而消失，使数据能够永久保存。</p><p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/02/28/kuangstudyf908e193-4ca3-44b7-87d0-cbb17b55a107.png" alt="avatar"></p><hr><h2 id="2-消息的分发策略"><a href="#2-消息的分发策略" class="headerlink" title="2. 消息的分发策略"></a>2. 消息的分发策略</h2><p>由于MQ有<strong>生产者、存储信息和消费者</strong>这三个角色，</p><p>那么当生产者生成消息之后，MQ进行存储，消费者通过<code>push</code>和<code>pull</code>来进行获取消息。</p><p>MQ就是一种推送的过程。</p><p>具体来说：</p><p>消息分发策略是指<strong>用于确定哪些消费者从消息传递系统哪里接收什么特定消息的技术</strong>。</p><p>以下是常见的消息分发策略。</p><ul><li><p>Fan-Out：这种策略包括同时向所有订阅者或消费者发送消息。</p></li><li><p>Fan-In：这种策略涉及一次将消息发送给一个consumer，通常采用轮询方式。</p></li><li><p>负载平衡：此策略涉及基于消费者的处理能力和当前工作负载等因素以平衡的方式将消息分发给消费者。</p></li><li><p>分片Sharding：这种策略涉及将消息分成更小的块，称为分片(shard)，并将它们分发给不同的消费者进行并行处理。</p></li><li><p>过滤Filtering：此策略涉及根据预定义的过滤器(如消息内容或消费者类型)将消息发送给消费者的子集。</p></li><li><p>路由Routing：此策略涉及根据其路由键(由消息发布者确定)将消息发送给特定的消费者。</p></li></ul><hr><h2 id="3-MQ高可用和高可靠"><a href="#3-MQ高可用和高可靠" class="headerlink" title="3. MQ高可用和高可靠"></a>3. MQ高可用和高可靠</h2><h3 id="高可用？"><a href="#高可用？" class="headerlink" title="高可用？"></a>高可用？</h3><p>指产品在规定的条件和规定的时间内处于<strong>可执行规定功能状态的能力</strong>。</p><p>高可用有以下几种<strong>集群模式</strong>，都是为了保证消息服务器不会寄，就算寄了依然可以很快的修复或者维持基本功能。</p><ul><li>Master-slave主从共享数据的部署方式</li><li>Master- slave主从同步部署方式</li><li>多主集群同步部署模式</li><li>多主集群转发部署模式</li><li>Master-slave与Breoker-cluster组合的方案</li></ul><h3 id="高可靠？"><a href="#高可靠？" class="headerlink" title="高可靠？"></a>高可靠？</h3><p>指系统可以<strong>无故障地持续运行</strong>，若一个系统突然崩溃、报错、异常，能不影响线上业务的正常运行，且出错的几率极低。</p><p>若想达到高可靠性，需要考虑以下两点：</p><ul><li>消息的传输：通过协议来保证系统间数据解析的正确性。</li><li>消息的存储可靠：通过持久化来保证消息的可靠性。</li></ul><hr><h1 id="三、RabbitMQ入门"><a href="#三、RabbitMQ入门" class="headerlink" title="三、RabbitMQ入门"></a>三、RabbitMQ入门</h1><blockquote><p>环境：</p><ul><li>Windows 10</li><li>Docker</li><li>VSCode</li><li>勤劳的双手</li></ul></blockquote><p><em>笔者致力于创作上至老奶奶，下至小狗狗都能看懂的教程！</em></p><h2 id="0-Docker下安装RabbitMQ"><a href="#0-Docker下安装RabbitMQ" class="headerlink" title="0. Docker下安装RabbitMQ"></a>0. Docker下安装RabbitMQ</h2><h3 id="拉取镜像："><a href="#拉取镜像：" class="headerlink" title="拉取镜像："></a>拉取镜像：</h3><p>在cmd中直接输入以下即可，实测不需要打开管理员权限，也不需要切换目录；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker search rabbitMq</span><br><span class="line"></span><br><span class="line">docker pull docker.io/rabbitmq:3.8-management</span><br></pre></td></tr></table></figure><h3 id="创建容器："><a href="#创建容器：" class="headerlink" title="创建容器："></a>创建容器：</h3><p>进入 Docker Desktop 查看镜像ID，当然你也可以<code>docker images</code></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/829e35d4eaca409789a9b316e6a30334~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>将其复制并在cmd中输入以下指令来创建rabbitMq容器：</p><p><code>docker run --name rabbitmq -d -p 15672:15672 -p 5672:5672 818bf18535d7</code></p><p>参数说明：</p><ul><li><code>--name</code>是容器名称，这里我们使用的是<code>rabbitmq</code></li><li><code>-d</code>是令容器后台运行</li><li><code>-p</code>是设置容器内部端口号与主机的映射，web端口默认值为<code>15672</code>，数据通信端口默认值为<code>5672</code></li></ul><p>如果返回一大串容器ID那就说明创建成功啦！</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c90c89a804c04178aa9e10d9bc453eeb~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h3 id="查看状态："><a href="#查看状态：" class="headerlink" title="查看状态："></a>查看状态：</h3><p>这个时候我们可以查看容器是否在运行，当然你也可以使用<code>docker ps</code>来查看</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d09b86a5bfa54900af5361ed1c366de2~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>同样的，我们在这里把容器ID复制下来之后使用<code>docker logs -f &lt;ID&gt;</code>可以查看容器的日志；</p><p>特别地，容器的ID可以简写，前提是保证前缀不与其他容器的相同。</p><p>就像这样：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87bba41248a7409992a835504cd6b1cc~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><hr><h2 id="1-Web端的简单测试"><a href="#1-Web端的简单测试" class="headerlink" title="1. Web端的简单测试"></a>1. Web端的简单测试</h2><h3 id="进入Web端："><a href="#进入Web端：" class="headerlink" title="进入Web端："></a>进入Web端：</h3><p>首先进入cmd输入<code>ipconfig</code>获取本机IP：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7380674c5874444bfa3eab1de3de6c3~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>随后输入<code>&lt;IP&gt;:15672</code>进入RabbitMQ的Web端，</p><p>例如笔者就是<code>192.168.1.4:15672</code>，随后出现如下界面：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1dcada7a7e04ee980a0be35a7d2df24~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>这个时候我们还没有创建任何账户，默认使用<code>guest</code>进行登录（账密都是）：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a42acef3e2544458b6394896a74faef2~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>Oh非常好，我们看到了想要的界面！</p><hr><h3 id="创建新的账户："><a href="#创建新的账户：" class="headerlink" title="创建新的账户："></a>创建新的账户：</h3><p>人活一世，总不能连个名字都没有，接下来我们就来创建一个新的账户，</p><p>毕竟guest有各种访问限制；</p><p>我们首先<strong>进入容器</strong>：<code>docker exec -i -t &lt;容器ID&gt; bin/bash</code></p><p>当然你也可以使用点击即送的方法进入，不过这次并不推荐：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c5f7f91484e429b9c526d4fe7a6de7e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>随后<strong>添加用户</strong>：<code>rabbitmqctl add_user &lt;username&gt; &lt;password&gt;</code></p><p>方便起见，我们就用root了，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@638f5fe7d784:/# rabbitmqctl add_user root 13243546</span><br><span class="line">Adding user &quot;root&quot; ...</span><br><span class="line">Done. Don&#x27;t forget to grant the user permissions to some virtual hosts! See &#x27;rabbitmqctl help set_permissions&#x27; to learn more.</span><br></pre></td></tr></table></figure><p>这个时候root还不是”root”呀，我们不能袖手旁观，需要<strong>赋予权限</strong>：</p><p><code>rabbitmqctl set_permissions -p / root &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</code></p><p>这样可能还不够，还需要给其赋予administrator的角色：</p><p><code>rabbitmqctl set_user_tags root administrator</code></p><h3 id="查看所用用户："><a href="#查看所用用户：" class="headerlink" title="查看所用用户："></a>查看所用用户：</h3><p><code>rabbitmqctl list_users</code></p><p>以上的cmd效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@638f5fe7d784:/# rabbitmqctl set_permissions -p / root &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br><span class="line">Setting permissions for user &quot;root&quot; in vhost &quot;/&quot; ...</span><br><span class="line">root@638f5fe7d784:/# rabbitmqctl set_user_tags root administrator</span><br><span class="line">Setting tags for user &quot;root&quot; to [administrator] ...</span><br><span class="line">root@638f5fe7d784:/# rabbitmqctl list_users</span><br><span class="line">Listing users ...</span><br><span class="line">user    tags</span><br><span class="line">guest   [administrator]</span><br><span class="line">root    [administrator]</span><br></pre></td></tr></table></figure><h3 id="回到Web端，再次登录："><a href="#回到Web端，再次登录：" class="headerlink" title="回到Web端，再次登录："></a>回到Web端，再次登录：</h3><p>这时可以关闭退出容器了，直接<code>exit + 右上角</code>关闭cmd即可；</p><p>然后Log Out一下guest账户，重新输入刚才的账户：</p><p>可以看到，我们卷土重来了！</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afb205703f6b488780a1ca70283d6e25~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><hr><h2 id="2-Go-RabbitMQ实现HelloWorld"><a href="#2-Go-RabbitMQ实现HelloWorld" class="headerlink" title="2. Go + RabbitMQ实现HelloWorld"></a>2. Go + RabbitMQ实现HelloWorld</h2><p>没错，你没有看错，又是<code>HelloWorld</code>，话不多说让我们进入正题：</p><p>打开cmd，进入你想要的项目文件夹，老规矩<code>go mod init &lt;...&gt;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go mod init go-rabbitmq-demo</span><br><span class="line">go: creating new go.mod: module go-rabbitmq-demo</span><br><span class="line">code .  // 打开我们亲爱的VSCode</span><br></pre></td></tr></table></figure><p>随后创建send.go</p><p>引入<code>github.com/streadway/amqp</code>并<code>go mod tidy</code></p><h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><p>定义一个辅助函数用于检查每个amqp调用的返回值；</p><p>发送方和接收方最好都要有；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 定义辅助函数</span><br><span class="line"></span><br><span class="line">func failOnError(err error, msg string) &#123;</span><br><span class="line">   if err != nil &#123;</span><br><span class="line">      log.Fatalf(&quot;%s: %s&quot;, msg, err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="send-go主函数"><a href="#send-go主函数" class="headerlink" title="send.go主函数"></a>send.go主函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    // 建立与 RabbitMQ 的连接</span><br><span class="line">    // 配置连接套接字，定义连接的协议与身份验证</span><br><span class="line">    conn, err := amqp.Dial(&quot;amqp://guest:guest@localhost:5672/&quot;)</span><br><span class="line">    failOnError(err, &quot;Failed to connect to RabbitMQ&quot;)</span><br><span class="line">    defer conn.Close()</span><br><span class="line"></span><br><span class="line">    // 创建通道来传递消息</span><br><span class="line">    ch, err := conn.Channel()</span><br><span class="line">    failOnError(err, &quot;Failed to open a channel&quot;)</span><br><span class="line">    defer ch.Close()</span><br><span class="line"></span><br><span class="line">    // 声明要发送到的队列</span><br><span class="line">    q, err := ch.QueueDeclare(</span><br><span class="line">        &quot;hello&quot;,</span><br><span class="line">        false,</span><br><span class="line">        false,</span><br><span class="line">        false,</span><br><span class="line">        false,</span><br><span class="line">        nil,</span><br><span class="line">    )</span><br><span class="line">    failOnError(err, &quot;Failed to declare a queue&quot;)</span><br><span class="line">    // ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)</span><br><span class="line">    // defer cancel()</span><br><span class="line"></span><br><span class="line">    body := &quot;Hello World!&quot;</span><br><span class="line"></span><br><span class="line">    // 将消息发布到声明的队列</span><br><span class="line">    err = ch.Publish(</span><br><span class="line">        &quot;&quot;,</span><br><span class="line">        q.Name,</span><br><span class="line">        false,</span><br><span class="line">        false,</span><br><span class="line">        amqp.Publishing&#123;</span><br><span class="line">            ContentType: &quot;text/plain&quot;,</span><br><span class="line">            Body:        []byte(body),</span><br><span class="line">        &#125;)</span><br><span class="line">    failOnError(err, &quot;Failed to publish a message&quot;)</span><br><span class="line">    // log.Printf(&quot; [x] Sent %s\n&quot;, body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="receive-go主函数"><a href="#receive-go主函数" class="headerlink" title="receive.go主函数"></a>receive.go主函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    // 建立与 RabbitMQ 的连接</span><br><span class="line">    conn, err := amqp.Dial(&quot;amqp://guest:guest@localhost:5672/&quot;)</span><br><span class="line">    failOnError(err, &quot;Failed to connect to RabbitMQ&quot;)</span><br><span class="line">    defer conn.Close()</span><br><span class="line"></span><br><span class="line">    // 获取通道</span><br><span class="line">    ch, err := conn.Channel()</span><br><span class="line">    failOnError(err, &quot;Failed to open a channel&quot;)</span><br><span class="line">    defer ch.Close()</span><br><span class="line"></span><br><span class="line">    // 声明队列</span><br><span class="line">    q, err := ch.QueueDeclare(</span><br><span class="line">        &quot;hello&quot;,</span><br><span class="line">        false,</span><br><span class="line">        false,</span><br><span class="line">        false,</span><br><span class="line">        false,</span><br><span class="line">        nil,</span><br><span class="line">    )</span><br><span class="line">    failOnError(err, &quot;Failed to declare a queue&quot;)</span><br><span class="line"></span><br><span class="line">    msgs, err := ch.Consume(</span><br><span class="line">        q.Name, // queue</span><br><span class="line">        &quot;&quot;,     // consumer</span><br><span class="line">        true,   // auto-ack</span><br><span class="line">        false,  // exclusive</span><br><span class="line">        false,  // no-local</span><br><span class="line">        false,  // no-wait</span><br><span class="line">        nil,    // args</span><br><span class="line">    )</span><br><span class="line">    failOnError(err, &quot;Failed to register a consumer&quot;)</span><br><span class="line"></span><br><span class="line">    var forever chan struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">        for d := range msgs &#123;</span><br><span class="line">            log.Printf(&quot;Received a message: %s&quot;, d.Body)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    log.Printf(&quot; [*] Waiting for messages. To exit press CTRL+C&quot;)</span><br><span class="line">    &lt;-forever</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="运行！"><a href="#运行！" class="headerlink" title="运行！"></a>运行！</h3><p>分别在两个cmd里面执行<code>go run send.go</code>和<code>go run receive.go</code></p><p>注意，<code>send</code>可以执行多次之后再执行<code>receive</code>，也可以先开启<code>receive</code>，读者不妨自己尝试一下；</p><p>我们可以在Web端看到，Channel中有数据的情况：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9ecbca20ad34c709f77526162c1d41f~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>终端的情况是这样的：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/221f097bdec64106bc3ecc12fe65270a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h3 id="文件目录结构"><a href="#文件目录结构" class="headerlink" title="文件目录结构"></a>文件目录结构</h3><p>很简单，就这四个东西：</p><p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5368c5bc790d41a183dba9283c2b496c~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"  /></p><hr><p>THE END.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;零、前言&quot;&gt;&lt;a href=&quot;#零、前言&quot; class=&quot;headerlink&quot; title=&quot;零、前言&quot;&gt;&lt;/a&gt;零、前言&lt;/h1&gt;&lt;p&gt;本文记录了笔者在学习消息队列和RabbitMQ的基础知识的过程，&lt;/p&gt;
&lt;p&gt;若笔者有任何疏忽纰漏之处，烦请不吝赐教。&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Internet基础丨学习记录</title>
    <link href="https://conqueror712.github.io/post/Internet_All.html"/>
    <id>https://conqueror712.github.io/post/Internet_All.html</id>
    <published>2023-01-30T01:24:31.000Z</published>
    <updated>2023-02-15T14:23:30.575Z</updated>
    
    <content type="html"><![CDATA[<h1 id="零、前言"><a href="#零、前言" class="headerlink" title="零、前言"></a>零、前言</h1><p>本文记录了笔者在学习Internet基础知识的过程，</p><p>若笔者有任何疏忽纰漏之处，烦请不吝赐教。</p><p>本文会不断的补充、修改和完善，期待您的宝贵意见。</p><hr><h1 id="一、互联网是如何工作的？"><a href="#一、互联网是如何工作的？" class="headerlink" title="一、互联网是如何工作的？"></a>一、互联网是如何工作的？</h1><h2 id="谁在运营互联网？"><a href="#谁在运营互联网？" class="headerlink" title="谁在运营互联网？"></a>谁在运营互联网？</h2><p>没有人经营互联网。它被组织为一个分散的网络网络。</p><p>数以千计的公司、大学、政府和其他实体运营自己的网络，并根据<strong>自愿互连协议</strong>相互交换流量。</p><ul><li><strong>IETF</strong>（互联网工程任务组）组织管理了<strong>使互联网工作的共享技术标准</strong>。</li><li><strong>ICANN</strong>（互联网名称与数字地址分配机构）负责分发域名和IP地址（计算机用来在互联网上相互识别的数字），但是并不控制谁可以连接到互联网。</li></ul><p><img src="http://web.stanford.edu/class/msande91si/www-spr04/readings/week1/InternetWhitepaper_files/ruswp_diag4.gif" alt="avatar"></p><h2 id="什么是IPv6？"><a href="#什么是IPv6？" class="headerlink" title="什么是IPv6？"></a>什么是IPv6？</h2><p>目前的互联网标准，称为IPv4，只允许大约4亿个IP地址。这在1970年代被认为是一个很大的数字，但今天，IPv4地址的供应几乎耗尽。</p><p>因此，互联网工程师开发了一种名为IPv6的新标准。IPv6允许数量惊人，确切的数字是<strong>39位数</strong>，确保几乎永远不会再耗尽。</p><p>具体的结构等细节这里不展开叙述。</p><h2 id="无线互联网如何工作？"><a href="#无线互联网如何工作？" class="headerlink" title="无线互联网如何工作？"></a>无线互联网如何工作？</h2><p>无线互联网有两种基本类型：</p><ul><li>WIFI：任何人都可以购买WIFI网络设备，为了防止互相干扰，WIFI网络的功率和范围有严格的限制；</li><li>蜂窝：更加集中，通过将服务区域分解为单元来工作，单元小到一个街区，大到数英里宽，每个单元的重心都有一个塔来提供服务，当设备从一个小区移动到另一个小区时，网络会自动将设备从一个塔转移到另一个塔，允许用户继续通信而不会中断。蜂窝网络使用许可用于其<strong>专用的频谱</strong>，由于该频谱稀缺，因此通常通过拍卖授予。</li></ul><p><img src="http://web.stanford.edu/class/msande91si/www-spr04/readings/week1/InternetWhitepaper_files/ruswp_diag3.gif" alt="avatar"></p><h2 id="什么是云？"><a href="#什么是云？" class="headerlink" title="什么是云？"></a>什么是云？</h2><p>云描述了一种在 2000 年代初流行的计算方法。通过将文件存储在服务器上并通过互联网交付软件，云计算为用户提供了更简单、更可靠的计算体验。</p><h2 id="什么是数据包？"><a href="#什么是数据包？" class="headerlink" title="什么是数据包？"></a>什么是数据包？</h2><p>数据包是通过互联网传输的<strong>信息的基本单位</strong>。将信息拆分成小的、可消化的部分可以更有效地利用网络的容量。</p><p>数据包的组成：</p><ul><li>标头：包含帮助数据包到达其目标的信息，包括<strong>数据包的长度、源和目标</strong>，以及帮助接收方检测数据包在传输过程中是否损坏的<strong>校验和值</strong>。</li><li>实际数据：一个数据包最多可以包含 64 KB 的数据，大约是 20 页的纯文本。</li></ul><p>此外，如果互联网路由器遇到拥塞或其他技术问题，则可以通过简单地丢弃数据包来处理它。发送计算机负责检测数据包未到达其目标并发送另一个副本。这种方法似乎违反直觉，但它简化了互联网的核心基础设施，以更低的成本实现更高的性能。</p><h2 id="什么是SSL？"><a href="#什么是SSL？" class="headerlink" title="什么是SSL？"></a>什么是SSL？</h2><p>SSL是<strong>Secure Sockets Layer安全套接字层</strong>的缩写，是一系列<strong>加密技术</strong>，允许Web用户保护他们通过Internet传输的信息的<strong>隐私</strong>。</p><p>当您访问安全网站时，您会在 URL 旁边看到一个锁，表示您与该网站的通信<strong>已加密</strong>。</p><p><img src="https://s2.loli.net/2023/01/29/6mWG8plUqKEt2O1.png" alt="avatar"></p><p>该锁应该表明<strong>第三方将无法读取您发送或接收的任何信息</strong>。在后台，SSL通过将您的数据转换为只有收件人知道如何破译的编码消息来实现这一点。如果恶意方正在监听对话，它只会看到看似随机的字符串，而不会看到您的电子邮件、Facebook 帖子、信用卡号或其他私人信息的内容。</p><h2 id="什么是域名系统？"><a href="#什么是域名系统？" class="headerlink" title="什么是域名系统？"></a>什么是域名系统？</h2><p>域名系统<code>DNS</code>是您可以通过在浏览器中键入<code>github.com</code>而不是难以记住的数字地址，如216.148.41.12来访问网页的原因。</p><blockquote><p>域名系统由位于加利福尼亚州的非营利组织ICANN 管理。ICANN成立于1998年。它被美国商务部授予对DNS的权力，尽管它越来越多地声称自己独立于美国政府。</p><p>有两种类型的域名。第一个是通用顶级域 （gTLD），例如 .com、.edu、.org 和 .gov。由于互联网起源于美国，因此这些域名往往在那里最受欢迎。这些域的权限通常委托给私人组织。</p><p>还有国家代码顶级域 （ccTLD）。世界上每个国家都有自己的 2 个字母代码。例如，美国的 ccTLD 是 .us，英国的 ccTLD 是 .uk，中国的 ccTLD 是 .cn。这些域名由每个国家&#x2F;地区的当局管理。一些 ccTLD，如 .tv（代表岛国图瓦卢）和 .io（英属印度洋领地），在本国以外的地方很受欢迎。</p></blockquote><p><img src="http://web.stanford.edu/class/msande91si/www-spr04/readings/week1/InternetWhitepaper_files/ruswp_diag6.gif" alt="avatar"></p><hr><h1 id="二、HTTP是什么？"><a href="#二、HTTP是什么？" class="headerlink" title="二、HTTP是什么？"></a>二、HTTP是什么？</h1><h2 id="HTTP概述"><a href="#HTTP概述" class="headerlink" title="HTTP概述"></a>HTTP概述</h2><p><strong>一句话解释</strong>：HTTP 是用于获取 HTML 文档等资源的<strong>协议</strong>。</p><p>它是 Web 上任何数据交换的基础，它是一种客户端-服务器协议，这意味着请求由接收者（通常是 Web 浏览器）发起。 从获取的不同子文档（例如文本、布局描述、图像、视频、脚本等）重建完整的文档。</p><p><img src="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview/fetching_a_page.png" alt="avatar"></p><p>客户端和服务器通过交换单个消息（而不是数据流）进行通信。 </p><ul><li>客户端（通常是 Web 浏览器）发送的消息称为请求；</li><li>服务器作为应答发送的消息称为响应。</li></ul><p><strong>协议</strong>是定义如何在计算机内部或计算机之间交换数据的规则系统。设备之间的通信要求设备就正在交换的数据的格式达成一致。定义格式的规则集称为协议。</p><p><img src="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview/http-layers.png" alt="avatar"></p><hr><h2 id="基于HTTP的系统组件"><a href="#基于HTTP的系统组件" class="headerlink" title="基于HTTP的系统组件"></a>基于HTTP的系统组件</h2><p>HTTP是一种<strong>客户端-服务器协议</strong>：请求由一个实体发送，即用户代理（或代表它的代理）。 大多数情况下，用户代理是一个Web浏览器，但它可以是任何东西。</p><p>每个单独的请求都发送到服务器，服务器处理它并提供称为<strong>响应</strong>的答案。</p><p>在客户端和服务器之间有许多实体，统称为<strong>代理Proxy</strong>，例如，它们执行不同的操作并充当网关or<strong>缓存Cache</strong>。</p><p>实际上，浏览器和处理请求的服务器之间有更多的计算机：有路由器、调制解调器等。 由于Web的分层设计，这些隐藏在网络和传输层中。 HTTP位于应用程序层的<strong>顶部</strong>。 虽然对于诊断网络问题很重要，但底层大多与 HTTP 的描述无关。</p><p><img src="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview/client-server-chain.png" alt="avatar"></p><h3 id="Proxy："><a href="#Proxy：" class="headerlink" title="Proxy："></a>Proxy：</h3><p><strong>代理服务器</strong>是在互联网的不同网络中导航时使用的<strong>中间程序或计算机</strong>。它们<strong>有助于访问万维网上的内容</strong>。</p><p>代理拦截请求并提供回响应；它可以转发或不转发请求（例如在缓存的情况下），并且可以修改请求（例如，在两个网络之间的边界处更改其标头）。</p><p>代理可以位于用户的本地计算机上，也可以位于用户计算机和 Internet 上的目标服务器之间的任何位置。通常有两种主要类型的代理服务器：由于 Web 堆栈的分层结构，其中大多数在传输、网络或物理级别运行，在 HTTP 层变得透明，并可能对性能产生重大影响。</p><ul><li>处理来自和发送到互联网上任何位置的请求的<strong>转发代理</strong>。</li><li>一种<strong>反向代理</strong>，从 Internet 接收请求并将其转发到内部网络中的服务器。</li></ul><p>代理的<strong>功能</strong>：</p><ul><li>缓存（缓存可以是公共的或私有的，就像浏览器缓存一样）</li><li>过滤（如防病毒扫描或家长控制）</li><li>负载平衡（允许多个服务器为不同的请求提供服务）</li><li>身份验证（控制对不同资源的访问）</li><li>日志记录（允许存储历史信息）</li></ul><h3 id="Cache："><a href="#Cache：" class="headerlink" title="Cache："></a>Cache：</h3><p><strong>缓存</strong>（Web 缓存或 HTTP 缓存）是临时存储 HTTP 响应的组件，以便只要满足某些条件，就可以将其用于后续 HTTP 请求。</p><h3 id="客户端：用户代理"><a href="#客户端：用户代理" class="headerlink" title="客户端：用户代理"></a>客户端：用户代理</h3><p>用户代理是代表用户执行操作的任何工具。 </p><p>浏览器<strong>始终</strong>是发起请求的实体，它从来都不是服务器。</p><h3 id="网络服务器"><a href="#网络服务器" class="headerlink" title="网络服务器"></a>网络服务器</h3><p>通信通道的另一端是服务器，它根据客户端的请求<strong>提供文档</strong>。 服务器实际上仅显示为一台计算机；</p><p>但它实际上可能是共享负载（负载平衡）的服务器的<strong>集合</strong>，或者是询问其他计算机（如缓存、数据库服务器或电子商务服务器）的<strong>复杂软件</strong>。</p><hr><h2 id="HTTP的基本方面"><a href="#HTTP的基本方面" class="headerlink" title="HTTP的基本方面"></a>HTTP的基本方面</h2><h3 id="1-HTTP是可扩展的"><a href="#1-HTTP是可扩展的" class="headerlink" title="1. HTTP是可扩展的"></a>1. HTTP是可扩展的</h3><p>HTTP &#x2F; 1.0中引入的<code>HTTP标头</code>使该协议易于扩展和试验。 新功能甚至可以通过客户端和服务器之间关于新标头语义的简单协议来引入。</p><h3 id="2-HTTP是无状态的，但不是无会话的"><a href="#2-HTTP是无状态的，但不是无会话的" class="headerlink" title="2. HTTP是无状态的，但不是无会话的"></a>2. HTTP是无状态的，但不是无会话的</h3><ul><li><p>无状态的：在同一连接上连续执行的两个请求之间没有链接。</p><blockquote><p>具体来说，HTTP是无状态的意味着从客户端到服务器的每个请求都被视为一个独立的事务，不知道之前的任何请求。这意味着服务器不存储客户端的会话信息，也不保留任何来自该客户端的先前请求的内存。客户端负责维护状态，如果有必要，可以在每个请求中向服务器发送信息，例如身份验证凭据或会话ID。这种设计在可扩展性和可靠性方面非常有用，因为它允许服务器独立处理每个请求，并确保在服务器出现故障时不会丢失会话数据。</p></blockquote></li><li><p>有状态会话：HTTP cookie允许使用有状态会话。 使用标头可扩展性，HTTP Cookie 将添加到工作流中，从而允许在每个 HTTP 请求上创建会话以共享相同的上下文或相同的状态。</p></li></ul><h3 id="3-HTTP和连接"><a href="#3-HTTP和连接" class="headerlink" title="3. HTTP和连接"></a>3. HTTP和连接</h3><p>连接在传输层进行控制，因此从根本上超出了 HTTP 的范围。</p><p> HTTP 不要求基础传输协议基于连接;它只要求它是可靠的，或者不丢失消息。</p><p> 在互联网上最常见的两种传输协议中，TCP是可靠的，UDP不是。 因此，<strong>HTTP依赖于基于连接的TCP标准</strong>。</p><hr><h2 id="HTTP可以控制什么"><a href="#HTTP可以控制什么" class="headerlink" title="HTTP可以控制什么?"></a>HTTP可以控制什么?</h2><blockquote><ul><li>缓存： 文档的缓存方式可以通过 HTTP 控制。 服务器可以指示代理和客户端缓存什么以及缓存多长时间。 客户端可以指示中间缓存代理忽略存储的文档。</li><li>放宽原点约束： 为了防止窥探和其他隐私侵犯，Web 浏览器强制在网站之间严格隔离。 只有来自同一来源的页面才能访问网页的所有信息。 虽然这样的约束对服务器来说是一种负担，但 HTTP 标头可以放松服务器端的这种严格分离，允许文档成为来自不同域的信息的拼凑;这样做甚至可能有与安全相关的原因。</li><li>身份验证： 某些页面可能受到保护，以便只有特定用户才能访问它们。 基本身份验证可以通过 HTTP 提供，可以使用 WWW-Authenticate 和类似的标头，也可以通过使用 HTTP cookie 设置特定会话来提供。</li><li>代理和隧道： 服务器或客户端通常位于 Intranet 上，对其他计算机隐藏其真实 IP 地址。 然后，HTTP 请求通过代理来跨越此网络屏障。 并非所有代理都是 HTTP 代理。 例如，SOCKS协议在较低级别运行。 其他协议（如 ftp）可以由这些代理处理。</li><li>会议： 使用 HTTP Cookie 允许您将请求与服务器的状态相关联。 这会创建会话，尽管基本的HTTP是无状态协议。 这不仅对电子商务购物篮有用，而且对允许用户配置输出的任何站点也很有用。</li></ul></blockquote><hr><h2 id="HTTP流"><a href="#HTTP流" class="headerlink" title="HTTP流"></a>HTTP流</h2><p>当客户端想要与服务器，也可能是中间代理通信时，它会执行以下步骤：</p><ol><li><p>打开 TCP 连接：</p><p> TCP 连接用于发送一个或多个请求并接收应答。 客户端可以打开新连接、重用现有连接或打开与服务器的多个 TCP 连接。</p></li><li><p>发送HTTP消息：</p><p> HTTP消息（在HTTP &#x2F; 2之前）是人类可读的。 使用HTTP &#x2F; 2，这些简单的消息被封装在框架中，使它们无法直接读取，但原理保持不变。</p><p> 一个例子：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: developer.mozilla.org</span><br><span class="line">Accept-Language: fr</span><br></pre></td></tr></table></figure></li><li><p>读取服务器发送的响应</p><p> 一个例子：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Sat, 09 Oct 2010 14:28:02 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">Last-Modified: Tue, 01 Dec 2009 20:18:22 GMT</span><br><span class="line">ETag: &quot;51142bc1-7449-479b075b2891b&quot;</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Length: 29769</span><br><span class="line">Content-Type: text/html</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;… (here come the 29769 bytes of the requested web page)</span><br></pre></td></tr></table></figure></li><li><p>关闭或重新使用连接以处理进一步的请求</p></li></ol><hr><h2 id="HTTP消息"><a href="#HTTP消息" class="headerlink" title="HTTP消息"></a>HTTP消息</h2><p>有两种类型的 HTTP 消息：请求和响应，每种都有自己的格式。</p><h3 id="请求："><a href="#请求：" class="headerlink" title="请求："></a>请求：</h3><p><img src="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview/http_request.png" alt="avatar"></p><h3 id="响应："><a href="#响应：" class="headerlink" title="响应："></a>响应：</h3><p><img src="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview/http_response.png" alt="avatar"></p><hr><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>HTTP 是一种易于使用的可扩展协议。</p><p>客户端-服务器结构与添加标头的能力相结合，允许HTTP随着Web的扩展功能而发展。</p><hr><h1 id="三、浏览器的工作原理简述"><a href="#三、浏览器的工作原理简述" class="headerlink" title="三、浏览器的工作原理简述"></a>三、浏览器的工作原理简述</h1><h2 id="0-概述Overview："><a href="#0-概述Overview：" class="headerlink" title="0. 概述Overview："></a>0. 概述Overview：</h2><p>Web性能的两个主要问题：</p><ol><li>与<strong>延迟</strong>有关的问题</li><li>与大多数情况下浏览器是<strong>单线程</strong>的事实有关的问题</li></ol><blockquote><p>延迟是影响我们确保快速加载页面的能力的最大威胁。</p><p>对于流畅的交互，开发人员的目标是确保高性能的网站交互，从平滑滚动到响应触摸。<strong>渲染时间是关键</strong>，要确保主线程能够完成我们投入的所有工作，并且仍然始终可用于处理用户交互。通过了解浏览器的单线程性质并在可能和适当的情况下最小化主线程的职责，可以提高 Web 性能，以确保呈现流畅和对交互的即时响应。</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2c2ce0c78bd4510825974bec7e046d0~tplv-k3u1fbpfcp-zoom-1.image" alt="avatar"></p><hr><h2 id="1-导航Navigation："><a href="#1-导航Navigation：" class="headerlink" title="1. 导航Navigation："></a>1. 导航Navigation：</h2><p>导航是加载网页的第一步；</p><p>每当用户通过在地址栏中输入 URL、单击链接、提交表单以及其他操作来请求页面时，就是导航。</p><p>Web 性能的目标之一是<strong>最大程度地减少完成导航所需的时间</strong>。</p><h3 id="域名解析查找DNS-Lookup："><a href="#域名解析查找DNS-Lookup：" class="headerlink" title="域名解析查找DNS Lookup："></a>域名解析查找DNS Lookup：</h3><p>那么怎么进行导航呢？</p><ol><li>浏览器缓存：首先检查浏览器的DNS缓存，看看是否有缓存的域名解析结果。</li><li>系统缓存：如果浏览器缓存没有结果，系统将检查操作系统的DNS缓存。</li><li>路由器缓存：如果系统缓存没有结果，路由器也会检查其DNS缓存。</li><li>本地DNS服务器：如果路由器缓存没有结果，系统将询问本地DNS服务器，看看它是否已经缓存了域名解析结果。</li><li>根DNS服务器：如果本地DNS服务器没有结果，它将询问根DNS服务器，试图获得域名的解析。</li><li>授权DNS服务器：根DNS服务器会向授权DNS服务器查询，以获取更详细的域名解析信息。</li><li>权威DNS服务器：最后，授权DNS服务器将询问权威DNS服务器，以确定该域名的IP地址。</li><li>缓存结果：找到的结果将被缓存，以便在将来不必再次查询。</li></ol><p><img src="https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work/latency.jpg" alt="avatar"></p><h3 id="TCP三次握手："><a href="#TCP三次握手：" class="headerlink" title="TCP三次握手："></a>TCP三次握手：</h3><p>一旦知道 IP 地址，浏览器就会通过 TCP 三向握手建立与服务器的连接。</p><p>TCP的三向握手技术通常被称为“SYN-SYN-ACK”（或更准确地说是SYN，SYN-ACK，ACK）。</p><p>TCP三次握手是一种网络协议中的握手过程，主要用于确保客户端与服务器之间的可靠通信。步骤如下：</p><ol><li>客户端发送一个SYN（Synchronize）请求报文到服务器，请求建立一个连接。</li><li>服务器收到SYN请求后，回应一个SYN-ACK（Synchronize-Acknowledge）报文，表示同意建立连接。</li><li>客户端收到SYN-ACK报文后，再发送一个ACK（Acknowledge）报文，确认连接建立完成。</li></ol><p>完成三次握手后，客户端与服务器间的连接就建立成功。这样可以确保两端在建立连接前，已经确认了对方的可用性，避免了网络中的垃圾数据或攻击行为。</p><h3 id="TLS协商："><a href="#TLS协商：" class="headerlink" title="TLS协商："></a>TLS协商：</h3><p>对于通过HTTPS建立的安全连接，需要再次“握手”。</p><p>这种握手，或者更确切地说是TLS协商，确定将使用哪种密码来加密通信，验证服务器，并在开始实际数据传输之前建立安全连接。这需要在实际发送内容请求之前再往返服务器三次。</p><p>虽然使连接安全会增加页面加载时间，但安全连接值得延迟费用，因为浏览器和 Web 服务器之间传输的数据无法被第三方解密。</p><p>TLS协商的过程一般包括以下步骤：</p><ol><li>客户端发送”Client Hello”报文给服务器，其中包含了客户端支持的加密协议、会话ID、随机数等信息。</li><li>服务器收到”Client Hello”报文后，会回复”Server Hello”报文给客户端，其中包含了服务器选择的加密协议、会话ID、随机数等信息。</li><li>客户端和服务器通过协商后确定的加密协议进行密钥交换，以确定本次通信的密钥。</li><li>双方确认协商结果后，通信开始加密传输数据。</li></ol><p>TLS协商的过程确保了客户端和服务器之间的通信是安全的，防止了数据在传输过程中的泄露和篡改。</p><p><img src="https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work/ssl.jpg" alt="avatar"></p><hr><h2 id="2-响应Response："><a href="#2-响应Response：" class="headerlink" title="2. 响应Response："></a>2. 响应Response：</h2><p>现在，导航已经结束了，来到了响应的阶段。</p><p>一旦我们与 Web 服务器建立了连接，浏览器就会<strong>代表用户发送初始 HTTP-GET 请求</strong>，</p><p>对于网站来说，该请求通常是 HTML 文件。一旦服务器收到请求，它将回复相关的响应标头和HTML的内容。</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en-US&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>My simple page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;styles.css&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;myscript.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;heading&quot;</span>&gt;</span>My Page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph with a <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://example.com/about&quot;</span>&gt;</span>link<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;myimage.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;image description&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;anotherscript.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="HTTP请求方法："><a href="#HTTP请求方法：" class="headerlink" title="HTTP请求方法："></a>HTTP请求方法：</h3><ul><li>GET 该方法请求指定资源的表示形式。使用的请求应仅检索数据。</li><li>HEAD 该方法请求与请求相同的响应，但没有响应正文。</li><li>POST 该方法将实体提交到指定的资源，这通常会导致服务器的状态更改或副作用。</li><li>PUT 该方法将目标资源的所有当前表示形式替换为请求有效负载。</li><li>DELETE 该方法删除指定的资源。</li><li>CONNECT 该方法建立到目标资源标识的服务器的隧道。</li><li>OPTIONS 该方法描述目标资源的通信选项。</li><li>TRACE 该方法沿目标资源的路径执行消息环回测试。</li><li>PATCH 该方法对资源应用部分修改。</li></ul><h3 id="TCP慢启动-x2F-14KB规则："><a href="#TCP慢启动-x2F-14KB规则：" class="headerlink" title="TCP慢启动 &#x2F; 14KB规则："></a>TCP慢启动 &#x2F; 14KB规则：</h3><p>TCP 慢启动有助于<strong>提高网络能力的传输速度</strong>。</p><p>TCP 慢启动是一种算法，<strong>用于检测数据包传输的可用带宽，并平衡网络连接的速度</strong>。</p><p>它可以防止出现最初功能未知的网络拥塞，并缓慢增加扩散的信息量，直到找到网络的最大容量。</p><p>第一个响应数据包将为 14KB。这是TCP慢启动的一部分，这是一种平衡网络连接速度的算法。</p><p>慢启动会<strong>逐渐增加传输的数据量，直到确定网络的最大带宽</strong>。</p><p>在TCP慢启动中，在收到初始数据包后，服务器将下一个数据包的大小<strong>加倍至28KB</strong>左右。后续数据包的大小会增加，<strong>直到达到预定阈值或遇到拥塞</strong>。</p><p>大概可以理解为逐步试探的倍增过程。</p><h3 id="拥塞控制："><a href="#拥塞控制：" class="headerlink" title="拥塞控制："></a>拥塞控制：</h3><p>当<strong>服务器</strong>以 <strong>TCP 数据包</strong>的形式发送数据时，用户的<strong>客户端</strong>通过<strong>返回确认或 ACK</strong> 来确认传递。</p><p>连接的容量有限，具体取决于硬件和网络条件。如果服务器发送太多数据包太快，它们将<strong>被丢弃</strong>。</p><p>服务器将其注册为缺少的 ACK。拥塞控制算法使用已发送数据包和 ACK 的此流来确定发送速率。</p><hr><h2 id="解析Parsing："><a href="#解析Parsing：" class="headerlink" title="解析Parsing："></a>解析Parsing：</h2><p>一旦浏览器收到第一个数据块，它就可以开始解析收到的信息。</p><p>解析意味着分析程序并将其转换为运行时环境可以实际运行的内部格式，例如浏览器中的 JavaScript 引擎。</p><p>解析是浏览器将它通过网络接收的数据转换为 <strong>DOM</strong> 和 <strong>CSSOM</strong> 的步骤，<strong>渲染器</strong>使用它来将页面绘制到屏幕上。</p><blockquote><p><strong>具体来说</strong>：</p><p>浏览器将 HTML 解析为 DOM 树。HTML 解析涉及标记化和树构造。HTML 标记包括开始和结束标记，以及属性名称和值。如果文档格式正确，则解析它既简单又快速。解析器将标记化的输入解析到文档中，从而构建文档树。</p><p>当 HTML 解析器找到非阻塞资源（如图像）时，浏览器将请求这些资源并继续解析。遇到 CSS 文件时，解析可以继续，但标记（尤其是那些没有异步或属性的标记）会阻止呈现，并暂停 HTML 解析。<code>&lt;script&gt;defer</code></p><p>当浏览器遇到 CSS 样式时，它会将文本解析为 CSS 对象模型（或 CSSOM），这是一种数据结构，然后用于样式布局和绘画。然后，浏览器从这两种结构创建一个呈现树，以便能够将内容绘制到屏幕上。JavaScript 也会被下载、解析，然后执行。</p></blockquote><h3 id="构建DOM树："><a href="#构建DOM树：" class="headerlink" title="构建DOM树："></a>构建DOM树：</h3><p>DOM 树描述文档的内容。<html> 元素是文档树的第一个标记和根节点。</p><p>树反映了不同标签之间的关系和层次结构。嵌套在其他标签中的标签是子节点。</p><p>DOM 节点的数量越多，构建 DOM 树所需的时间就越长。</p><p><img src="https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work/dom.gif" alt="avatar"></p><h3 id="预加载扫描仪Preload-Scanner："><a href="#预加载扫描仪Preload-Scanner：" class="headerlink" title="预加载扫描仪Preload Scanner："></a>预加载扫描仪Preload Scanner：</h3><blockquote><p>当浏览器构建 DOM 树时，此过程占用主线程。</p><p>发生这种情况时，预加载扫描程序将解析可用内容并请求高优先级资源，如 CSS、JavaScript 和 Web 字体。</p><p>多亏了预加载扫描程序，我们不必等到解析器找到对外部资源的引用来请求它。</p><p>它将在后台检索资源，以便在主 HTML 解析器到达请求的资产时，它们可能已经在运行中，或者已被下载。预加载扫查器提供的优化可减少阻塞。</p></blockquote><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;styles.css&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;myscript.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;myimage.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;image description&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;anotherscript.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在此示例中，当主线程解析 HTML 和 CSS 时，预加载扫描程序将找到脚本和图像，并开始下载它们。若要确保脚本不会阻止进程，请添加属性，或者如果 JavaScript 解析和执行顺序很重要，请添加属性。</p><h3 id="构建CSSOM树："><a href="#构建CSSOM树：" class="headerlink" title="构建CSSOM树："></a>构建CSSOM树：</h3><p>关键呈现路径中的第二步是处理 CSS 并构建 CSSOM 树。</p><p>CSS 对象模型类似于 DOM。DOM 和 CSSOM 都是树。它们是独立的数据结构。</p><p>浏览器将 CSS 规则转换为它可以理解和使用的样式映射。浏览器遍历 CSS 中的每个规则集，根据 CSS 选择器创建具有父、子和同级关系的节点树。</p><p><img src="https://s2.loli.net/2023/01/30/wzGjACSikPZ6rWp.png" alt="avatar"></p><p>除此之外，还有一些内容例如JavaScript编译和构建辅助功能树等等，这里不展开叙述。</p><hr><h2 id="渲染Render"><a href="#渲染Render" class="headerlink" title="渲染Render"></a>渲染Render</h2><p>接下来是渲染部分，以下是四个比较重要的内容：</p><h3 id="Style"><a href="#Style" class="headerlink" title="Style"></a>Style</h3><p>关键渲染路径中的第三步是将 DOM 和 CSSOM 组合到渲染树中。计算样式树或渲染树的构造从 DOM 树的根开始，遍历每个可见节点。</p><h3 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h3><p>关键渲染路径中的第四步是在渲染树上运行布局，以计算每个节点的几何体。<em>布局</em>是确定呈现树中所有节点的宽度、高度和位置的过程，也是确定页面上每个对象的大小和位置的过程。<em>重排</em>是页面任何部分或整个文档的任何后续大小和位置确定。</p><h3 id="Paint"><a href="#Paint" class="headerlink" title="Paint"></a>Paint</h3><p>关键渲染路径的最后一步是将各个节点绘制到屏幕上，第一次出现称为第一次有意义的绘制。在绘画或光栅化阶段，浏览器将布局阶段计算的每个框转换为屏幕上的实际像素。绘画涉及将元素的每个视觉部分绘制到屏幕上，包括文本、颜色、边框、阴影以及按钮和图像等替换元素。浏览器需要非常快速地完成此操作。</p><h3 id="Compositing"><a href="#Compositing" class="headerlink" title="Compositing"></a>Compositing</h3><p>一旦主线程完成页面绘制，你会认为我们会“一切就绪”。事实未必如此。如果加载包含 JavaScript，该 JavaScript 已正确延迟，并且仅在 onload 事件触发后执行，则主线程可能繁忙，并且不可用于滚动、触摸和其他交互。</p><p>到这一步，浏览器的工作基本上就算是完成了。</p><hr><h1 id="四、Hosting"><a href="#四、Hosting" class="headerlink" title="四、Hosting"></a>四、Hosting</h1><h2 id="0-概述Overview：-1"><a href="#0-概述Overview：-1" class="headerlink" title="0. 概述Overview："></a>0. 概述Overview：</h2><p>Hosting是指<strong>将网站存储在服务器上</strong>，以便全球用户<strong>通过互联网访问该网站</strong>的服务。它包括：</p><ol><li>服务器租赁：为网站提供存储空间和带宽</li><li>网络架构：确保网站可以连接到互联网</li><li>技术支持：协助解决网站运行问题</li><li>网站维护：保证服务器性能和安全性</li></ol><p>有多种不同的Hosting服务，如共享Hosting，虚拟专用服务器（VPS）和独立专用服务器（Dedicated Server）。</p><p>根据网站的需求，个人或企业可以选择合适的Hosting服务。</p><h2 id="1-Hosting细节："><a href="#1-Hosting细节：" class="headerlink" title="1. Hosting细节："></a>1. Hosting细节：</h2><ol><li>备份：一些Hosting提供商提供定期备份功能，以确保数据安全</li><li>安全：保护网站免受黑客攻击，提供SSL证书等安全功能是一项重要的任务</li><li>可扩展性：随着网站的发展，需要更多的存储空间和带宽，因此要选择可扩展的Hosting服务</li><li>性能：网站速度和可用性对用户体验有很大影响，因此要选择高性能的Hosting服务</li><li>技术支持：良好的技术支持是网站运行的重要保证，选择提供全天候技术支持的Hosting提供商是一个好选择。</li></ol><hr><h1 id="五、DNS-互联网的电话簿"><a href="#五、DNS-互联网的电话簿" class="headerlink" title="五、DNS-互联网的电话簿"></a>五、DNS-互联网的电话簿</h1><h2 id="0-简介："><a href="#0-简介：" class="headerlink" title="0. 简介："></a>0. 简介：</h2><p>DNS（域名系统 Domain Name System ）是互联网连接资源的分层和分散命名系统；</p><p>DNS维护域名列表以及与其关联的资源（如 IP 地址）；</p><p>DNS最突出的功能是将人性化域名转换为数字IP地址；</p><p>将域名映射到相应 IP 地址的过程称为 DNS 查找，相比之下，反向 DNS 查找 （rDNS） 用于确定与 IP 地址关联的域名。</p><h2 id="1-额外的安全层？"><a href="#1-额外的安全层？" class="headerlink" title="1. 额外的安全层？"></a>1. 额外的安全层？</h2><p>默认情况下，DNS查询Request和响应Response以<strong>明文形式</strong>，通过UDP发送，也就是说网络、ISP 或任何能够监控传输的人都可以读取它们。即使网站使用 HTTPS，也会公开导航到该网站所需的 DNS 查询。</p><p>如何解决呢？事实上有两种办法：TLS上的DNS和HTTPS上的DNS，他们都是为加密明文DNS流量而开发的标准。</p><p><img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/7qcyOJwWyOt4EVJykiIRTn/30e34453409eb42fa1ec36680609ad8d/dns-traffic-over-tls-https.svg" alt="avatar"></p><h2 id="2-DNS-x2F-HTTPS-over-DNS"><a href="#2-DNS-x2F-HTTPS-over-DNS" class="headerlink" title="2. DNS &#x2F; HTTPS-over-DNS?"></a>2. DNS &#x2F; HTTPS-over-DNS?</h2><p>TLS 上的 DNS 或 DoT 是加密 DNS 查询以保持其安全和私密性的标准。</p><p>DoT 使用与 HTTPS 网站相同的安全协议 TLS 来加密和验证通信（TLS也称为”SSL”）。</p><p>DoT 在用户数据报协议 UDP 之上添加了 TLS 加密，该协议用于 DNS 查询。</p><p>此外，它还确保 DNS 请求和响应不会因中间人攻击而被篡改或伪造。</p><p>DNS over HTTPS，或DoH，是DoT的替代方案。</p><p>使用 DoH，DNS 查询和响应是加密的，但它们是通过 HTTP 或 HTTP&#x2F;2 协议发送的，而不是直接通过 UDP 发送的。</p><h3 id="有何不同？"><a href="#有何不同？" class="headerlink" title="有何不同？"></a><strong>有何不同</strong>？</h3><p>每个标准都是单独开发的，都有自己的 RFC（征求意见） 文档，</p><p>但 DoT 和 DoH 之间最重要的<strong>区别在于它们使用的端口</strong>。</p><p>DoT 仅使用端口 853，而 DoH 使用端口 443，这是<strong>所有其他 HTTPS 流量使用的端口</strong>。</p><p>由于 DoT 具有专用端口，因此任何具有网络可见性的人都可以看到 DoT 流量的来来去去，即使请求和响应本身是加密的。相比之下，在DoH中，DNS查询和响应伪装在其他HTTPS流量中，因为它们都来自同一端口。</p><h3 id="哪个更好？"><a href="#哪个更好？" class="headerlink" title="哪个更好？"></a>哪个更好？</h3><p>从网络安全的角度来看，DoT可以说更好。它使网络管理员能够监视和阻止 DNS 查询，这对于识别和阻止恶意流量非常重要。同时，DoH查询隐藏在常规HTTPS流量中，这意味着如果不阻止所有其他HTTPS流量，就无法轻松阻止它们。</p><p>但是，从隐私的角度来看，DoH可以说是可取的。使用 DoH，DNS 查询隐藏在较大的 HTTPS 流量中。这降低了网络管理员的可见性，但为用户提供了更多的隐私。</p><hr><h2 id="3-涉及-DNS-的常见攻击有哪些？"><a href="#3-涉及-DNS-的常见攻击有哪些？" class="headerlink" title="3. 涉及 DNS 的常见攻击有哪些？"></a>3. 涉及 DNS 的常见攻击有哪些？</h2><ul><li><strong>DNS 欺骗&#x2F;缓存中毒</strong>：这是一种将伪造的 DNS 数据引入 DNS 解析程序缓存的攻击，导致解析器返回域的错误 IP 地址。流量可以转移到恶意机器或攻击者想要的任何地方，而不是转到正确的网站;通常，这将是用于恶意目的（例如分发恶意软件或收集登录信息）的原始站点的副本。</li><li><strong>DNS 隧道</strong>：此攻击使用其他协议通过 DNS 查询和响应进行隧道传输。攻击者可以使用 SSH、TCP 或 HTTP 将恶意软件或被盗信息传递到 DNS 查询中，而大多数防火墙都不会检测到。</li><li><strong>DNS 劫持</strong>：在 DNS 劫持中，攻击者将查询重定向到其他域名服务器。这可以通过恶意软件或未经授权修改 DNS 服务器来完成。尽管结果与DNS欺骗的结果相似，但这是一种根本不同的攻击，因为它针对的是名称服务器上网站的DNS记录，而不是解析器的缓存。</li><li><strong>NXDOMAIN 攻击</strong>：这是一种 DNS 洪水攻击，攻击者用请求淹没 DNS 服务器，请求不存在的记录，试图导致合法流量的拒绝服务。这可以使用复杂的攻击工具来实现，这些工具可以为每个请求自动生成唯一的子域。NXDOMAIN 攻击还可以针对递归解析器，目的是用垃圾请求填充解析器的缓存。</li><li><strong>幻域攻击</strong>：幻像域攻击的结果与 DNS 解析器上的 NXDOMAIN 攻击类似。攻击者设置了一堆“幻像”域服务器，这些服务器要么响应请求非常慢，要么根本不响应。然后，解析器受到对这些域的大量请求的打击，解析器被占用等待响应，导致性能降低和拒绝服务。</li><li><strong>随机子域攻击</strong>：在这种情况下，攻击者会针对一个合法站点的多个随机、不存在的子域发送 DNS 查询。目标是为域的权威名称服务器创建拒绝服务，从而无法从名称服务器查找网站。作为副作用，为攻击者提供服务的ISP也可能受到影响，因为他们的递归解析器的缓存将加载错误请求。</li><li><strong>域锁定攻击</strong>：攻击者通过设置特殊域和解析器来与其他合法解析器创建 TCP 连接，从而策划这种形式的攻击。当目标解析器发送请求时，这些域会发回缓慢的随机数据包流，从而占用解析器的资源。</li><li><strong>基于僵尸网络的 CPE 攻击</strong>：这些攻击是使用 CPE 设备（客户端设备;这是服务提供商提供的供其客户使用的硬件，例如调制解调器、路由器、电缆盒等）进行的。攻击者破坏CPE，设备成为僵尸网络的一部分，用于对一个站点或域执行随机子域攻击。</li></ul><p><del>（怎么名字都这么帅的）</del></p><p><img src="https://www.cloudflare.com/img/learning/dns/dns-security/dns-hijacking.png" alt="avatar"></p><hr><h2 id="4-域名安全"><a href="#4-域名安全" class="headerlink" title="4. 域名安全"></a>4. 域名安全</h2><p>DNS 安全扩展 （DNSSEC） 是为缓解此问题而创建的安全协议。</p><p>DNSSEC 通过对数据进行数字签名来帮助确保其有效性，从而防止攻击。</p><p>为了确保安全查找，必须在 DNS 查找过程中的<strong>每个级别进行签名</strong>。</p><p>有关 DNSSEC 的更多内容请参考：<a href="https://blog.cloudflare.com/dnssec-an-introduction/?_gl=1*1k44464*_ga*MzE2OTQ0NzY1LjE2NzUxNDM3NzI.*_gid*NjAzODc2NjAyLjE2NzUxNDM3NzI.">DNSSEC: An Introduction (cloudflare.com)</a></p><hr><h2 id="5-其他内容："><a href="#5-其他内容：" class="headerlink" title="5. 其他内容："></a>5. 其他内容：</h2><h3 id="DNS防火墙："><a href="#DNS防火墙：" class="headerlink" title="DNS防火墙："></a>DNS防火墙：</h3><p>DNS firewall 是一种可为 DNS 服务器提供众多安全和性能服务的工具。</p><p>DNS firewall 位于用户的递归解析器与他们正尝试访问的网站或服务的权威性域名服务器之间。</p><p>防火墙可提供速率限制服务，以关闭试图淹没服务器的攻击者。如果服务器确实由于攻击或其他任何原因而停机，则 DNS firewall 可通过提供来自高速缓存的 DNS 响应来使运营商的站点或服务保持正常运行。</p><h3 id="用户隐私："><a href="#用户隐私：" class="headerlink" title="用户隐私："></a>用户隐私：</h3><p>DNS 查询未加密。即使用户使用像 1.1.1.1 这样不跟踪他们活动的 DNS 解析器，DNS 查询也会以明文形式在互联网上传输。这意味着拦截查询的任何人都可以看到用户正在访问哪些网站。</p><p><em>还有诸如DNS高速缓存中毒等内容我们暂且略过。</em></p><hr><h1 id="六、DomainName-域名"><a href="#六、DomainName-域名" class="headerlink" title="六、DomainName-域名"></a>六、DomainName-域名</h1><h2 id="0-简介：-1"><a href="#0-简介：-1" class="headerlink" title="0. 简介："></a>0. 简介：</h2><p>域名是一个文本字符串，映射到一个数字 IP 地址，可用于从客户端软件访问网站。</p><p>简单来说，域名是用户在浏览器窗口中键入以访问特定网站的文本。</p><p>网站的实际地址是一个复杂的数字 IP 地址（例如 103.21.244.0），但由于 DNS 的存在，用户可以输入人类友好的域名并将其路由到他们要查找的网站。此过程称为 DNS 查找。</p><p>域名全部由域名注册管理机构管理。</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/Common_questions/What_is_a_domain_name/2014-10-dns-request2.png" alt="avatar"></p><h2 id="1-与URL的区别？"><a href="#1-与URL的区别？" class="headerlink" title="1. 与URL的区别？"></a>1. 与URL的区别？</h2><p>统一资源定位符（URL）有时也称为网址，包含站点的域名以及其他信息，如传输协议和路径等。</p><p>例如，在 URL<code>https://www.bilibili.com/anime/</code>中，<code>www.bilibili.com</code>是域名，而<code>https</code>是协议，<code>/anime/</code>是指向网站上特定页面的路径。</p><h2 id="2-域名的组成部分？"><a href="#2-域名的组成部分？" class="headerlink" title="2. 域名的组成部分？"></a>2. 域名的组成部分？</h2><p>域名通常分为两个或三个部分，各个部分用一个点分隔。</p><p>从右到左阅读时，域名中的<strong>标识符从最广泛到最具体</strong>。</p><p>域名中最后一个点右边的部分是顶级域 (TLD)。</p><p>其中包括<code>.com、.net和.org </code>等通用TLD，以及<code>.uk</code>和<code>.cn</code>等特定国家&#x2F;地区的 TLD。</p><p>TLD 的左侧是第二级域（2LD），如果 2LD 的左侧有任何内容，则称为第三级域（3LD）。</p><h2 id="3-查找可用域名："><a href="#3-查找可用域名：" class="headerlink" title="3. 查找可用域名："></a>3. 查找可用域名：</h2><p>法一：转到域名注册商的网站。他们中的大多数都提供<code>whois</code>服务，告诉您域名是否可用。</p><p>法二：如果使用具有内置 shell 的系统，请在其中键入命令，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ whois mozilla.org</span><br><span class="line">Domain Name:MOZILLA.ORG</span><br><span class="line">Domain ID: D1409563-LROR</span><br><span class="line">Creation Date: 1998-01-24T05:00:00Z</span><br><span class="line">Updated Date: 2013-12-08T01:16:57Z</span><br><span class="line">Registry Expiry Date: 2015-01-23T05:00:00Z</span><br><span class="line">Sponsoring Registrar:MarkMonitor Inc. (R37-LROR)</span><br><span class="line">Sponsoring Registrar IANA ID: 292</span><br><span class="line">WHOIS Server:</span><br><span class="line">Referral URL:</span><br><span class="line">Domain Status: clientDeleteProhibited</span><br><span class="line">Domain Status: clientTransferProhibited</span><br><span class="line">Domain Status: clientUpdateProhibited</span><br><span class="line">Registrant ID:mmr-33684</span><br><span class="line">Registrant Name:DNS Admin</span><br><span class="line">Registrant Organization:Mozilla Foundation</span><br><span class="line">Registrant Street: 650 Castro St Ste 300</span><br><span class="line">Registrant City:Mountain View</span><br><span class="line">Registrant State/Province:CA</span><br><span class="line">Registrant Postal Code:94041</span><br><span class="line">Registrant Country:US</span><br><span class="line">Registrant Phone:+1.6509030800</span><br></pre></td></tr></table></figure><h2 id="4-其他内容"><a href="#4-其他内容" class="headerlink" title="4. 其他内容"></a>4. 其他内容</h2><p>域名的最长保留期是十年。用户可以持有域名超过十年，因为注册商通常让他们无限期地续订域名。但是，用户从来没有真正拥有过这个域名，他们只是租用了它。</p><p><img src="https://www.cloudflare-cn.com/img/learning/dns/glossary/expired-domains/expired-domain-timeline.svg" alt="avatar"></p><p>如果没有人购买过期的域名，它可能会在一定时间后退回到原来的注册机构。它将不再可用，直到注册表决定释放它。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;零、前言&quot;&gt;&lt;a href=&quot;#零、前言&quot; class=&quot;headerlink&quot; title=&quot;零、前言&quot;&gt;&lt;/a&gt;零、前言&lt;/h1&gt;&lt;p&gt;本文记录了笔者在学习Internet基础知识的过程，&lt;/p&gt;
&lt;p&gt;若笔者有任何疏忽纰漏之处，烦请不吝赐教。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Go + FFmpeg交互丨学习记录</title>
    <link href="https://conqueror712.github.io/post/FFmpeg.html"/>
    <id>https://conqueror712.github.io/post/FFmpeg.html</id>
    <published>2023-01-29T06:07:05.000Z</published>
    <updated>2023-02-15T14:23:56.608Z</updated>
    
    <content type="html"><![CDATA[<h1 id="零、前言"><a href="#零、前言" class="headerlink" title="零、前言"></a>零、前言</h1><p>另附我的掘金主页：<a href="https://juejin.cn/user/1297878069809725">Conqueror712 的个人主页 - 动态 - 掘金 (juejin.cn)</a></p><p><strong>主要思路：</strong></p><blockquote><p>使用 Golang 和 FFmpeg 交互可以分为以下几个步骤：</p><ol><li>安装 FFmpeg: 首先需要安装 FFmpeg，可以在终端中输入命令来安装。</li><li>创建一个Golang项目，并在其中创建一个接收上传视频文件的接口。</li><li>在接口中接收上传的文件，并使用Golang中的 exec 包来执行 FFmpeg 命令来转码视频。</li><li>转码后的文件可以保存在本地或上传到云存储服务器。</li><li>将视频信息存储到 MySQL 数据库中。</li><li>在Golang中使用GORM或其他ORM库来连接数据库并存储数据。</li><li>在代码中使用 exec.Command 函数来执行 FFmpeg 命令。该函数需要 ffmpeg 的完整路径和命令行参数，并返回一个 *exec.Cmd 类型的对象。</li><li>通过使用 .StdoutPipe() 和 .Start() 方法来执行 FFmpeg 命令并获取命令输出。</li><li>使用 io.Copy() 函数将转码后的视频文件写入本地文件或上传到云存储服务器。</li><li>使用GORM将上传视频文件的信息存储到数据库中。</li></ol></blockquote><hr><h1 id="一、本地IO"><a href="#一、本地IO" class="headerlink" title="一、本地IO"></a>一、本地IO</h1><p>以下是一个代码示例，实现<strong>从本地来，到本地去</strong>的功能，<strong>记得改路径和名称！</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os/exec&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 设置视频源文件路径</span></span><br><span class="line">inputFile := <span class="string">&quot;input.mp4&quot;</span></span><br><span class="line"><span class="comment">// 设置转码后文件路径</span></span><br><span class="line">outputFile := <span class="string">&quot;output.mp4&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 ffmpeg 命令行参数</span></span><br><span class="line">args := []<span class="type">string</span>&#123;<span class="string">&quot;-i&quot;</span>, inputFile, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;copy&quot;</span>, outputFile&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 *exec.Cmd</span></span><br><span class="line">cmd := exec.Command(<span class="string">&quot;ffmpeg&quot;</span>, args...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行 ffmpeg 命令</span></span><br><span class="line"><span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;转码成功&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你没有报错的话，可以看到，有输出文件，但是这一来一回有什么用呢？</p><p>事实上目的就是让这个转码后的视频文件是<strong>可以在线播放</strong>的。</p><hr><h1 id="二、保存到数据库"><a href="#二、保存到数据库" class="headerlink" title="二、保存到数据库"></a>二、保存到数据库</h1><p>光从本地来到本地去总是不长久的，我们要打开<strong>数据库</strong>的大门；</p><p>首先需要准备好数据库和表，这里我们同样使用Navicat来操作，具体操作步骤如下，不需要的可以跳过：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">新建连接 -&gt; MySQL -&gt; 连接名随便 -&gt; 密码随便(强烈建议与数据库密码相同否则可能会产生一些错误) -&gt; 双击左侧打开 -&gt; 右键information_schema -&gt; 新建数据库 -&gt; 名称随便 -&gt; 字符集utf8mb4</span><br></pre></td></tr></table></figure><p>然后执行如下代码即可，<strong>注意修改你的路径、名称、数据库名称等信息</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os/exec&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/jinzhu/gorm&quot;</span></span><br><span class="line">_ <span class="string">&quot;github.com/jinzhu/gorm/dialects/mysql&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 Video struct，用来存储视频信息</span></span><br><span class="line"><span class="keyword">type</span> Video <span class="keyword">struct</span> &#123;</span><br><span class="line">gorm.Model</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Path <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 连接数据库</span></span><br><span class="line">db, err := gorm.Open(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;root:password@/database?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;failed to connect to the database&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> db.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建表</span></span><br><span class="line">db.AutoMigrate(&amp;Video&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// FFmpeg命令转换视频</span></span><br><span class="line">cmd := exec.Command(<span class="string">&quot;ffmpeg&quot;</span>, <span class="string">&quot;-i&quot;</span>, <span class="string">&quot;input.mp4&quot;</span>, <span class="string">&quot;-vcodec&quot;</span>, <span class="string">&quot;libx264&quot;</span>, <span class="string">&quot;-acodec&quot;</span>, <span class="string">&quot;aac&quot;</span>, <span class="string">&quot;-strict&quot;</span>, <span class="string">&quot;-2&quot;</span>, <span class="string">&quot;output.mp4&quot;</span>)</span><br><span class="line"></span><br><span class="line">err = cmd.Run()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在数据库里存储视频信息</span></span><br><span class="line">video := Video&#123;Name: <span class="string">&quot;output&quot;</span>, Path: <span class="string">&quot;output.mp4&quot;</span>&#125;</span><br><span class="line">db.Create(&amp;video)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Navicat中效果如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f44cba7872e418cb1d796817ce39873~tplv-k3u1fbpfcp-zoom-1.image" alt="avatar"></p><p>几点说明：</p><ul><li>这个 ffmpeg 示例中的命令是将视频 “input.mp4” 转换为新的视频文件 “output.mp4”。</li><li>在这个命令中，我们使用了 “-i” 参数来指定输入文件，”-vcodec” 和 “-acodec” 参数来指定视频和音频编码，”-strict” 和 “-2” 参数来指定编码标准。</li><li>其中 “-vcodec” 指定了视频编码为 libx264，”-acodec” 指定音频编码为 aac ，这两个编码是在线播放视频常用的编码方式，所以这个转码后的视频文件是可以在线播放的。</li><li>如果你想要转换成其它格式，可以查询ffmpeg的文档和参数来实现。</li></ul><hr><h1 id="三、前端实现与用户交互"><a href="#三、前端实现与用户交互" class="headerlink" title="三、前端实现与用户交互"></a>三、前端实现与用户交互</h1><h2 id="思路一：Nginx"><a href="#思路一：Nginx" class="headerlink" title="思路一：Nginx"></a>思路一：Nginx</h2><p>Nginx 的作用是作为一个<strong>反向代理服务器</strong>，用于将用户的请求转发到后端服务器进行处理。</p><p>反向代理服务器可以帮助实现<strong>负载均衡、安全性、缓存</strong>等功能。</p><p>如果想使用 Nginx 作为 Web 服务器来处理用户的请求并将其转发到后端服务器，可以这样做：</p><ol><li>首先，需要在自己的服务器上安装 Nginx。</li><li>然后，需要编写 Nginx 的配置文件来处理用户的请求。举个例子，如果想将所有的 &#x2F;upload 请求转发到后端服务器的 &#x2F;upload 接口，可以在 Nginx 的配置文件中添加如下代码：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /upload &#123;</span><br><span class="line">    proxy_pass http://backend_server:8000/upload;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在后端服务器上实现对 &#x2F;upload 接口的处理，如接收视频文件并进行转码。可以使用 Gin 或其他框架来实现这个功能，并将转码后的文件存储到数据库中。</li><li>完成以上步骤后，当用户在前端网页上上传视频文件时，这个文件会被发送到 Nginx，然后 Nginx 会将请求转发到后端服务器进行处理。后端服务器接收到请求后会调用 ffmpeg 将视频转码并存储在数据库中。</li></ol><p>如果是在web端指定本地要作为输入的视频路径，这部分需要在前端进行实现，可以在前端页面上使用 HTML input 标签来实现文件选择功能，并在选择文件后使用 JavaScript 来获取文件路径并发送到后端服务器。</p><p>例如，在 HTML 中使用 input 标签来实现文件选择功能：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;input-file&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 JavaScript 代码来获取文件路径并发送到后端服务器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;input-file&quot;</span>);</span><br><span class="line">    input.<span class="title function_">addEventListener</span>(<span class="string">&quot;change&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> file = input.<span class="property">files</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">var</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">        formData.<span class="title function_">append</span>(<span class="string">&quot;file&quot;</span>, file);</span><br><span class="line">        <span class="comment">// send the formData to backend server</span></span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="思路二：GoFTP"><a href="#思路二：GoFTP" class="headerlink" title="思路二：GoFTP"></a>思路二：GoFTP</h2><p>使用 GoFTP 来上传和下载视频，可以在 Go 中使用第三方库：<a href="https://github.com/jlaffaye/ftp">https://github.com/jlaffaye/ftp</a> ；</p><p>使用这个库可以在 Go 中实现 FTP 协议的上传和下载功能，并可以轻松地将视频文件上传到服务器并在服务器上进行转码。如此，可以将文件<strong>上传和转码</strong>的功能放在<strong>同一个服务器</strong>上，而不需要使用反向代理服务器来转发请求。</p><p>使用 GoFTP 来上传和下载视频文件的话不需要使用 HTML 和 JavaScript 。可以使用 Go 程序来直接与 FTP 服务器进行交互。可以使用 GoFTP 库，在 Go 中编写程序来连接到 FTP 服务器实现：连接到FTP服务器，登录，上传文件，下载文件等操作。</p><p>当然，如果需要在web上获取用户选择的视频文件路径，可以使用HTML和JavaScript来实现这部分功能，但是FTP上传和下载操作可以直接在Go程序中实现。</p><p>以下是一个<strong>示例代码</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/jlaffaye/ftp&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 连接到 FTP 服务器</span></span><br><span class="line">conn, err := ftp.Connect(<span class="string">&quot;ftp.example.com:21&quot;</span>)</span><br><span class="line"><span class="comment">// ftp.example.com:21是一个模拟的FTP服务器地址，实际使用中需要替换成真正的FTP服务器的地址。</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Error connecting to FTP server:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Quit()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登录到 FTP 服务器</span></span><br><span class="line"><span class="comment">// 需要提前设置好username and password</span></span><br><span class="line"><span class="keyword">if</span> err := conn.Login(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;password&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Error logging in to FTP server:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开本地文件</span></span><br><span class="line">file, err := os.Open(<span class="string">&quot;example.txt&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Error opening local file:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上传文件到 FTP 服务器</span></span><br><span class="line"><span class="keyword">if</span> err := conn.Stor(<span class="string">&quot;example.txt&quot;</span>, file); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Error uploading file:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;File uploaded successfully!!!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个新的问题出现了，如何搭建一个<strong>本地测试用的服务器</strong>呢？好问题，如下：</p><p>在本地搭建一个测试用的FTP服务器可以使用一些常用的FTP服务器软件来实现，如FileZilla Server， ProFTPD等。</p><ul><li>对于windows系统，可以使用FileZilla Server,下载地址:<a href="https://filezilla-project.org/download.php?type=server">https://filezilla-project.org/download.php?type=server</a> 下载完成后安装，配置好FTP用户名和密码，设置好访问权限，就可以在本地测试使用了。</li><li>对于Linux系统，可以使用ProFTPD, 安装方法可以使用apt-get，yum等安装工具,配置好FTP用户名和密码，设置好访问权限，就可以在本地测试使用了。</li></ul><p><strong>三个注意</strong>：</p><ul><li>首席需要注意的是，在安装和配置FTP服务器的过程中，需要遵循安全原则，如设置强密码，限制访问权限等，以防止未经授权的访问。</li><li>其次还需要注意的是，在使用FTP服务器时需要注意防火墙设置，确保FTP服务器能够正常访问。</li><li>最后需要注意的是，如果您使用的是公网IP地址，需要注意安全性，因为您的FTP服务器可能会被恶意攻击。</li></ul><hr><h2 id="两种方法的对比："><a href="#两种方法的对比：" class="headerlink" title="两种方法的对比："></a>两种方法的对比：</h2><p>使用 Nginx 作为反向代理服务器和使用 GoFTP 上传和下载视频文件，两种方法有一些不同的优缺点。</p><p>使用 Nginx 作为反向代理服务器的优点：</p><ul><li>可以提高系统的安全性，因为 Nginx 可以对用户的请求进行验证和过滤。</li><li>可以实现负载均衡，可以提高系统的可用性和稳定性。</li><li>可以实现缓存功能，可以提高系统的性能。</li></ul><p>使用 Nginx 作为反向代理服务器的缺点：</p><ul><li>可能会增加系统的复杂度。</li><li>可能会增加系统的运维成本。</li></ul><p>使用 GoFTP 上传和下载视频文件的优点：</p><ul><li>不需要使用额外的服务器或框架，可以简化系统的架构。</li><li>可以直接在 Go 程序中实现文件上传和下载功能。</li></ul><p>使用 GoFTP 上传和下载视频文件的缺点：</p><ul><li>可能没有Nginx那么高的安全性，负载均衡和缓存功能。</li><li>可能需要自己手动实现文件上传和下载的功能，运维成本可能更高。</li></ul><p>总结来说，对于需要高安全性，高并发，高可用性的系统，使用 Nginx 作为反向代理服务器可能会更好。但是如果你的系统不需要如此高级的功能，并且希望简化系统架构，减少运维成本，使用 GoFTP 来上传和下载视频文件可能是一个更好的选择。</p><hr><h2 id="两种方法的结合："><a href="#两种方法的结合：" class="headerlink" title="两种方法的结合："></a>两种方法的结合：</h2><p>当然，这两种方法是可以结合起来使用的。</p><ul><li><p>使用 Nginx 作为反向代理服务器，来过滤和验证用户的请求，并将请求转发到 Go 程序中进行处理。</p></li><li><p>在 Go 程序中可以使用 GoFTP 上传和下载视频文件，并在文件上传完成后使用 ffmpeg 进行转码，将转码后的文件保存到数据库。</p></li></ul><p>这样做的好处是，Nginx 可以提供高安全性、高并发、高可用性等功能，而 GoFTP 可以提供简化系统架构、减少运维成本等功能，坏处很显然，就是实现麻烦。</p><hr><h1 id="四、FileZillaServer-X-Plore"><a href="#四、FileZillaServer-X-Plore" class="headerlink" title="四、FileZillaServer + X-Plore"></a>四、FileZillaServer + X-Plore</h1><p>这里介绍一种基于上文<strong>思路二</strong>，使用FileZillaServer + X-Plore实现的<strong>局域网下不同设备之间的文件互传</strong>方法；</p><h2 id="FileZillaServer"><a href="#FileZillaServer" class="headerlink" title="FileZillaServer"></a>FileZillaServer</h2><p><strong>是什么</strong>？</p><p>是能在本地搭建一个测试用的FTP服务器的软件。</p><p><strong>怎么下载怎么用</strong>？</p><p>下载地址：<a href="https://www.filezilla.cn/">FileZilla中文网 - 免费开源的FTP解决方案</a></p><p>前面的安装以及初始化步骤可以参考：</p><p><a href="https://zhuanlan.zhihu.com/p/428058878">FileZilla搭建FTP服务器图解教程 - 知乎 (zhihu.com)</a></p><p>记得第一个要设置为根目录；</p><p>完成设置之后在<strong>本地的资源管理器</strong>中（以前是可以用浏览器的）输入<code>ftp://127.0.0.1</code>进入即可。</p><p>然后就可以看到该用户可以看到的文件列表了。</p><p>这个时候可以为该用户添加<strong>新的可见的非根目录的文件夹</strong>，并且需要人为地指定它在服务器端的路径，例如<code>/myAdditional</code>，随后确定后刷新页面，就可以发现多了一个文件夹，这样就可以做到本地的文件结构和服务器端的不一样。</p><p>有趣的是，这一操作可以让我们<strong>重新组织</strong>本地文件系统下的各个路径。</p><p>还有我们可以使用一个比较方便的可视化的客户端来操作：FileZilla-Client；</p><p>由于操作比较简单这里就不给出介绍了，下载地址同上。</p><hr><h2 id="Android访问FTP服务器"><a href="#Android访问FTP服务器" class="headerlink" title="Android访问FTP服务器"></a>Android访问FTP服务器</h2><p>可供使用的APP有：</p><ul><li>AndFTP</li><li>蚂蚁科技</li><li>Turbo FTP 客户端</li><li>ES 文件资源管理器</li><li>简易 FTP 客户端</li><li>管理员之手应用程序</li><li>Termius - SSH &#x2F; SFTP</li><li>FTP 服务器</li><li>X-Plore</li></ul><p>笔者的选择是X-Plore，非常好用；</p><p>下载之后点击FTP，然后输入刚才在PC端设置的IP（就是cmd中ipconfig的ipv4那个）以及账户+密码，就可以连接到FTP服务器了。</p><p>这个时候我们再运行<strong>思路二中的示例代码</strong>，记得写好要传输的文件，运行即可实现文件互传，非常方便。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;零、前言&quot;&gt;&lt;a href=&quot;#零、前言&quot; class=&quot;headerlink&quot; title=&quot;零、前言&quot;&gt;&lt;/a&gt;零、前言&lt;/h1&gt;&lt;p&gt;另附我的掘金主页：&lt;a href=&quot;https://juejin.cn/user/1297878069809725&quot;&gt;Con</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Docker + VSCode组合丨学习记录</title>
    <link href="https://conqueror712.github.io/post/Docker.html"/>
    <id>https://conqueror712.github.io/post/Docker.html</id>
    <published>2023-01-29T06:06:45.000Z</published>
    <updated>2023-02-15T14:24:23.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="零、前言："><a href="#零、前言：" class="headerlink" title="零、前言："></a>零、前言：</h1><p>本文是笔者从零开始学习Docker的学习记录。</p><p>若笔者有任何疏忽纰漏之处，烦请不吝赐教。</p><p>另附我的掘金主页<a href="https://juejin.cn/user/1297878069809725">Conqueror712 的个人主页 - 动态 - 掘金 (juejin.cn)</a></p><h1 id="一、Docker简介："><a href="#一、Docker简介：" class="headerlink" title="一、Docker简介："></a>一、Docker简介：</h1><p>Docker 是一个应用打包、分发、部署的工具<br>你也可以把它理解为一个轻量的虚拟机，它只虚拟你软件需要的运行环境，多余的一点都不要，<br>而普通虚拟机则是一个完整而庞大的系统，包含各种不管你要不要的软件。</p><p>Docker 的入门知识还有以下几点需要了解：</p><ol><li><p>镜像 (image) 和容器 (container) 的关系：镜像是容器的模板，容器是镜像运行时的实例。</p></li><li><p>Docker Hub：Docker Hub 是一个公共镜像仓库，可以在这里搜索和下载镜像。</p></li><li><p>Dockerfile: 一个Dockerfile 文件是一个文本文件，包含了一条条指令，它告诉Docker如何构建一个镜像.</p></li><li><p>容器网络:Docker支持多种网络模式,包括host,bridge,overlay等.</p></li><li><p>数据管理:Docker支持将容器中的数据挂载到宿主机上,或者将容器间共享数据.</p></li><li><p>使用docker-compose:docker-compose是一个用来管理多个容器的工具,可以通过一个配置文件来管理多个容器,并且可以一键启动和停止.</p></li><li><p>注意事项：</p><ul><li><p>不要在root用户下运行Docker，需要使用sudo</p></li><li><p>在开发过程中，需要注意容器的版本管理，保证不同环境的稳定性</p></li><li><p>需要注意容器的网络配置，确保容器之间可以互相访问</p></li><li><p>容器中的数据需要及时备份</p></li></ul></li></ol><hr><h1 id="二、小试牛刀"><a href="#二、小试牛刀" class="headerlink" title="二、小试牛刀"></a>二、小试牛刀</h1><h2 id="快速开始："><a href="#快速开始：" class="headerlink" title="快速开始："></a>快速开始：</h2><p>一个非常简单的办法，结合vscode：</p><p>以一个Go项目举例：</p><p><code>docker run -dit -v /d/goenv:/root/goenv golang</code><br>注意：地址可以自己更换</p><p><code>docker run</code> 是用来启动一个新的 Docker 容器的命令。</p><ul><li><code>-d</code> : 后台运行容器，即在后台运行容器而不阻塞当前的终端。</li><li><code>-i</code> : 保留标准输入的活性，这样可以在容器中使用命令行</li><li><code>-t</code> : 分配一个伪终端（tty），这样可以在容器中使用命令行</li><li><code>-v /d/goenv:/root/goenv</code> : 使用 <code>-v</code> 选项将主机的 <code>/d/goenv</code> 目录挂载到容器的 <code>/root/goenv</code> 目录。这样就可以在容器中访问主机上的文件。</li><li><code>golang</code> : 指定要使用的 Docker 镜像的名称。</li></ul><p>然后使用VSCODE连接就行了<br>之后就是初始化等等的操作<br><code>go mod init goenv</code><br>编写<code>main.go</code>等等…</p><p><strong>重要概念</strong>：</p><p><strong>镜像</strong>：可以理解为软件安装包，可以方便的进行传播和安装。<br><strong>容器</strong>：软件安装后的状态，每个软件运行环境都是独立的、隔离的，称之为容器。</p><p><strong>常用相关命令</strong>：</p><p><code>docker ps</code> 查看当前运行中的容器<br><code>docker images</code> 查看镜像列表<br><code>docker rm container-id</code> 删除指定 id 的容器<br><code>docker stop/start container-id</code> 停止&#x2F;启动指定 id 的容器<br><code>docker rmi image-id</code> 删除指定 id 的镜像<br><code>docker volume ls</code> 查看 volume 列表<br><code>docker network ls</code> 查看网络列表</p><hr><h2 id="Docker-VS-普通虚拟机："><a href="#Docker-VS-普通虚拟机：" class="headerlink" title="Docker VS 普通虚拟机："></a>Docker VS 普通虚拟机：</h2><table><thead><tr><th>特性</th><th>普通虚拟机</th><th>Docker</th></tr></thead><tbody><tr><td>跨平台</td><td>通常只能在桌面级系统运行，例如 Windows&#x2F;Mac，无法在不带图形界面的服务器上运行</td><td>支持的系统非常多，各类 windows 和 Linux 都支持</td></tr><tr><td>性能</td><td>性能损耗大，内存占用高，因为是把整个完整系统都虚拟出来了</td><td>性能好，只虚拟软件所需运行环境，最大化减少没用的配置</td></tr><tr><td>自动化</td><td>需要手动安装所有东西</td><td>一个命令就可以自动部署好所需环境</td></tr><tr><td>稳定性</td><td>稳定性不高，不同系统差异大</td><td>稳定性好，不同系统都一样部署方式</td></tr></tbody></table><h3 id="开发方面与WSL2的对比："><a href="#开发方面与WSL2的对比：" class="headerlink" title="开发方面与WSL2的对比："></a>开发方面与WSL2的对比：</h3><p>Docker 和 WSL 2 两者都可以在 Windows 系统上提供 Linux 环境，但是它们的工作原理和用途是有区别的。</p><p>WSL 2 是 Windows Subsystem for Linux 的第二版，可以在 Windows 系统上运行 Linux 子系统，并且支持运行原生 Linux 应用程序。WSL 2 可以让开发者在 Windows 上使用 Linux 环境进行开发，并且可以直接访问 Windows 系统上的文件。</p><p>Docker 是一个容器化平台，可以在宿主机上运行多个独立的容器，每个容器都可以运行不同的应用程序。Docker 可以将应用程序和其所需的环境封装在一起，方便进行部署和移植。使用Docker，可以在不同的环境下,方便的部署和调试，并且可以隔离这些环境，不会相互影响.</p><p>总的来说，WSL 2 主要用于在 Windows 上使用 Linux 环境进行开发，而 Docker 则更多用于将应用程序和其所需的环境封装在容器中，方便进行部署和移植。</p><hr><h2 id="镜像加速源："><a href="#镜像加速源：" class="headerlink" title="镜像加速源："></a>镜像加速源：</h2><table><thead><tr><th>镜像加速器</th><th>镜像加速器地址</th></tr></thead><tbody><tr><td>Docker 中国官方镜像</td><td><a href="https://registry.docker-cn.com/">https://registry.docker-cn.com</a></td></tr><tr><td>DaoCloud 镜像站</td><td><a href="http://f1361db2.m.daocloud.io/">http://f1361db2.m.daocloud.io</a></td></tr><tr><td>Azure 中国镜像</td><td><a href="https://dockerhub.azk8s.cn/">https://dockerhub.azk8s.cn</a></td></tr><tr><td>科大镜像站</td><td><a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn</a></td></tr><tr><td>阿里云</td><td>https:&#x2F;&#x2F;<your_code>.mirror.aliyuncs.com</td></tr><tr><td>七牛云</td><td><a href="https://reg-mirror.qiniu.com/">https://reg-mirror.qiniu.com</a></td></tr><tr><td>网易云</td><td><a href="https://hub-mirror.c.163.com/">https://hub-mirror.c.163.com</a></td></tr><tr><td>腾讯云</td><td><a href="https://mirror.ccs.tencentyun.com/">https://mirror.ccs.tencentyun.com</a></td></tr></tbody></table><hr><h2 id="Docker安装软件："><a href="#Docker安装软件：" class="headerlink" title="Docker安装软件："></a>Docker安装软件：</h2><blockquote><h3 id="直接安装的缺点"><a href="#直接安装的缺点" class="headerlink" title="直接安装的缺点"></a>直接安装的缺点</h3><ul><li>安装麻烦，可能有各种依赖，运行报错。例如：WordPress，ElasticSearch，Redis，ELK</li><li>可能对 Windows 并不友好，运行有各种兼容问题，软件只支持 Linux 上跑</li><li>不方便安装多版本软件，不能共存。</li><li>电脑安装了一堆软件，拖慢电脑速度。</li><li>不同系统和硬件，安装方式不一样</li></ul><h3 id="Docker-安装的优点"><a href="#Docker-安装的优点" class="headerlink" title="Docker 安装的优点"></a>Docker 安装的优点</h3><ul><li>一个命令就可以安装好，快速方便</li><li>有大量的镜像，可直接使用</li><li>没有系统兼容问题，Linux 专享软件也照样跑</li><li>支持软件多版本共存</li><li>用完就丢，不拖慢电脑速度</li><li>不同系统和硬件，只要安装好 Docker 其他都一样了，一个命令搞定所有</li></ul></blockquote><hr><h2 id="VSCode-Docker"><a href="#VSCode-Docker" class="headerlink" title="VSCode + Docker"></a>VSCode + Docker</h2><h3 id="使用VSCode打开Docker中已开启的镜像："><a href="#使用VSCode打开Docker中已开启的镜像：" class="headerlink" title="使用VSCode打开Docker中已开启的镜像："></a>使用VSCode打开Docker中已开启的镜像：</h3><p>在VSCode中安装Docker插件之后，直接点击，会看到很多已创建好的镜像，</p><p>右键然后在VSCode里打开就好了（具体的名字可能不是这个，翻译问题）</p><h3 id="code-workspace文件说明："><a href="#code-workspace文件说明：" class="headerlink" title=".code-workspace文件说明："></a>.code-workspace文件说明：</h3><p><code>.code-workspace</code> 文件是 Visual Studio Code 的工作区文件，它用于记录打开的文件夹和已安装的插件等配置信息。</p><p>在 Visual Studio Code 中，你可以通过以下方式生成 <code>.code-workspace</code> 文件：</p><ol><li>在文件资源管理器中，右键单击文件夹并选择 “Save Workspace As…” 来保存当前工作区。</li><li>选择 “File” 菜单中的 “Save Workspace As…” 来保存当前工作区。</li><li>在命令面板中输入 “Save Workspace As…” 并回车来保存当前工作区。</li></ol><p>保存后的工作区文件将会以 <code>.code-workspace</code> 为扩展名保存在你指定的位置.</p><hr><h1 id="三、继续向前"><a href="#三、继续向前" class="headerlink" title="三、继续向前"></a>三、继续向前</h1><h2 id="DockerFile相关："><a href="#DockerFile相关：" class="headerlink" title="DockerFile相关："></a>DockerFile相关：</h2><p>先看一个例子：</p><blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">11</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> easydoc.net</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制代码</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> . /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置容器启动后的默认运行目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行命令，安装依赖</span></span><br><span class="line"><span class="comment"># RUN 命令可以有多个，但是可以用 &amp;&amp; 连接多个命令来减少层级。</span></span><br><span class="line"><span class="comment"># 例如 RUN npm install &amp;&amp; cd /app &amp;&amp; mkdir logs</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm install --registry=https://registry.npm.taobao.org</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CMD 指令只能一个，是容器启动后执行的命令，算是程序的入口。</span></span><br><span class="line"><span class="comment"># 如果还需要运行其他命令可以用 &amp;&amp; 连接，也可以写成一个shell脚本去执行。</span></span><br><span class="line"><span class="comment"># 例如 CMD cd /app &amp;&amp; ./start.sh</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> node app.js</span></span><br></pre></td></tr></table></figure></blockquote><p>Dockerfile 是用来构建 Docker 镜像的配置文件。其中，<code>RUN</code> 指令是用来在镜像构建过程中执行命令的。</p><p>在这个例子中，<code>RUN npm install --registry=https://registry.npm.taobao.org</code> 的作用是安装 npm 包，并将 npm 的镜像源设置为淘宝镜像，为了加速npm 的安装速度。</p><p>这个命令会在Docker容器中执行，会在容器中安装npm的包，在这个命令执行完成后，npm包已经安装在容器中了。</p><p>注意：使用 npm install 命令前需要先使用COPY或者ADD指令将项目文件复制到容器中。</p><p>参考：<a href="https://docs.docker.com/engine/reference/builder/#run">Dockerfile reference | Docker Documentation</a></p><hr><h2 id="目录挂载："><a href="#目录挂载：" class="headerlink" title="目录挂载："></a>目录挂载：</h2><p>目录挂载可以解决的问题：</p><ul><li>使用 Docker 运行后，倘若修改项目代码不会立刻生效，需要重新<code>build</code>和<code>run</code>，很麻烦。</li><li>容器里面产生的数据，例如 log 文件，数据库备份文件，容器删除后就丢失了。</li></ul><p><strong>目录挂载的方式</strong>：</p><ul><li><code>bind mount</code> 直接把宿主机目录映射到容器内，适合挂代码目录和配置文件。可挂到多个容器上</li><li><code>volume</code> 由容器创建和管理，创建在宿主机，所以删除容器不会丢失，官方推荐，更高效，Linux 文件系统，适合存储数据库数据。可挂到多个容器上</li><li><code>tmpfs mount</code> 适合存储临时文件，存宿主机内存中。不可多容器共享。</li></ul><p><code>bind mount</code> 方式用绝对路径 <code>-v D:/code:/app</code></p><p><code>volume</code> 方式，只需要一个名字 <code>-v db-data:/app</code>，注意，这里的<code>db-data</code>就是名字，这块区域由容器自己来创建。</p><p>bind mount例：<code>docker run -p 9090:8080 --name test-hello -v D:/code:/app -d golang:v1</code></p><ul><li>这里是把项目的代码目录挂载到容器里面的<code>/app</code>目录</li><li>把容器的8080暴露到伺服器的9090端口</li><li>容器名字命名为test-hello</li><li>挂载绝对目录</li><li><code>-d</code>表示在后台运行</li><li><code>golang:v1</code>指定镜像的名字和版本</li></ul><p>于是我们的代码就愉快的跑起来了；</p><hr><p>余下内容未完待续…</p><p>谢谢大家的阅读，欢迎互动，也欢迎访问我的博客！</p><p><a href="https://conqueror712.gitee.io/conqueror712.gitee.io/">落雨乄天珀夜 (gitee.io)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;零、前言：&quot;&gt;&lt;a href=&quot;#零、前言：&quot; class=&quot;headerlink&quot; title=&quot;零、前言：&quot;&gt;&lt;/a&gt;零、前言：&lt;/h1&gt;&lt;p&gt;本文是笔者从零开始学习Docker的学习记录。&lt;/p&gt;
&lt;p&gt;若笔者有任何疏忽纰漏之处，烦请不吝赐教。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis丨学习记录</title>
    <link href="https://conqueror712.github.io/post/Redis.html"/>
    <id>https://conqueror712.github.io/post/Redis.html</id>
    <published>2023-01-29T06:00:41.000Z</published>
    <updated>2023-02-15T14:24:56.760Z</updated>
    
    <content type="html"><![CDATA[<h1 id="零、前言"><a href="#零、前言" class="headerlink" title="零、前言"></a>零、前言</h1><p>本文是笔者从零开始学习Redis的学习记录。</p><p>若笔者有任何疏忽纰漏之处，烦请不吝赐教。</p><p>另附我的掘金主页：<a href="https://juejin.cn/user/1297878069809725">Conqueror712 的个人主页 - 动态 - 掘金 (juejin.cn)</a></p><hr><h1 id="一、开门见山"><a href="#一、开门见山" class="headerlink" title="一、开门见山"></a>一、开门见山</h1><p>源码：<a href="https://github.com/redis/redis">https://github.com/redis/redis</a></p><h2 id="Redis是什么？"><a href="#Redis是什么？" class="headerlink" title="Redis是什么？"></a><strong>Redis</strong>是什么？</h2><ul><li><p><strong>基于内存的多模型数据库，毫秒级的延迟</strong></p></li><li><p>Remote Dictionary Server</p></li><li><p>是一个由<code>Salvatore Sanfilippo</code>写的<code>key-value</code>存储系统；</p></li><li><p>是<strong>跨平台的非关系型数据库</strong>；</p></li><li><p>是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的 API。</p></li></ul><h2 id="Redis有什么特点？"><a href="#Redis有什么特点？" class="headerlink" title="Redis有什么特点？"></a>Redis有什么特点？</h2><ul><li>Redis 通常被称为<strong>数据结构服务器</strong>，因为值可以是字符串、哈希、列表、集合和有序集合等类型。</li><li>Redis支持<strong>数据的持久化</strong>，可以将<strong>内存中的数据保存在磁盘中</strong>，重启的时候可以再次加载进行使用。</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47f76ed6d91f496ab5279e68a691b317~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h2 id="Redis的优势有哪些？"><a href="#Redis的优势有哪些？" class="headerlink" title="Redis的优势有哪些？"></a>Redis的优势有哪些？</h2><ul><li>性能极高</li><li>丰富的数据类型，因此你不需要把它塞进一堆表或者JSON文档里</li><li>原子 – Redis的所有操作都是原子性的，意思就是<strong>要么成功执行要么失败完全不执行</strong>。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</li><li>丰富的特性 – Redis还支持 publish&#x2F;subscribe, 通知, key 过期等等特性。</li></ul><h2 id="Redis的其他补充？"><a href="#Redis的其他补充？" class="headerlink" title="Redis的其他补充？"></a>Redis的其他补充？</h2><ul><li>缓存也可以用于存储持久化数据</li><li>传统的关系型数据库没办法做到快速把数据传递给终端用户</li><li>数据总是会在内存上进行修改和读取，而不是在慢得多的硬盘上，但与此同时，它会把数据存储在硬盘上，这样就可以按需对数据进行重建，因此数据库是完全持久化的</li><li>Redis完全可以作为主数据库，并且可以显著地降低复杂度</li><li>多模型——可以通过扩展模块来支持多种数据库范式，可以按需引用，如下图所示：</li></ul><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/111409e98b124e52a3229eb9a02f433b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><hr><h2 id="Redis如何安装？"><a href="#Redis如何安装？" class="headerlink" title="Redis如何安装？"></a>Redis如何安装？</h2><ol><li>在<a href="https://github.com/tporadowski/redis/releases%E4%B8%AD%E9%80%89%E6%8B%A9%60.zip%60%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E5%B9%B6%E8%A7%A3%E5%8E%8B%EF%BC%88%E5%BD%93%E7%84%B6%E4%B9%9F%E5%8F%AF%E4%BB%A5%E9%80%89%E5%88%AB%E7%9A%84%EF%BC%89%EF%BC%8C%E7%84%B6%E5%90%8Erename%E4%B8%BAredis">https://github.com/tporadowski/redis/releases中选择`.zip`格式的文件下载并解压（当然也可以选别的），然后rename为redis</a></li><li>在解压路径下打开<code>cmd</code>并输入<code>redis-server.exe redis.windows.conf</code>，你会看到如下图所示的样子：</li></ol><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/721cdc037d934682b7c19999cd6fde1c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><ol start="3"><li>添加环境变量，地址就是解压地址</li><li>保持上面这个<code>cmd</code>窗口不要关闭的情况下再开启一个<code>cmd</code>，运行<code>redis-cli.exe -h 127.0.0.1 -p &lt;your port num&gt;</code>（好像都是6379？），这里如果报错，你可能需要WIN+R开启cmd而不是用其他的方法</li></ol><p>（Redis的配置暂略，有需要更改的话会再补充相关内容）</p><hr><h1 id="二、继续向前"><a href="#二、继续向前" class="headerlink" title="二、继续向前"></a>二、继续向前</h1><h2 id="Redis命令"><a href="#Redis命令" class="headerlink" title="Redis命令"></a>Redis命令</h2><p>可参考网站：</p><p><a href="http://doc.redisfans.com/">Redis 命令参考 — Redis 命令参考 (redisfans.com)</a></p><p><a href="https://redis.io/commands/">Commands | Redis</a></p><p>在端口启动的情况下，输入<code>redis-cli</code>即可进入redis客户端，输入<code>PING</code>输出<code>PONG</code>即证明成功启动。</p><h2 id="Redis键"><a href="#Redis键" class="headerlink" title="Redis键"></a>Redis键</h2><h4 id="Redis键的基本命令："><a href="#Redis键的基本命令：" class="headerlink" title="Redis键的基本命令："></a>Redis键的基本命令：</h4><ul><li><a href="http://doc.redisfans.com/key/del.html">DEL</a></li><li><a href="http://doc.redisfans.com/key/dump.html">DUMP</a></li><li><a href="http://doc.redisfans.com/key/exists.html">EXISTS</a></li><li><a href="http://doc.redisfans.com/key/expire.html">EXPIRE</a></li><li><a href="http://doc.redisfans.com/key/expireat.html">EXPIREAT</a></li><li><a href="http://doc.redisfans.com/key/keys.html">KEYS</a></li><li><a href="http://doc.redisfans.com/key/migrate.html">MIGRATE</a></li><li><a href="http://doc.redisfans.com/key/move.html">MOVE</a></li><li><a href="http://doc.redisfans.com/key/object.html">OBJECT</a></li><li><a href="http://doc.redisfans.com/key/persist.html">PERSIST</a></li><li><a href="http://doc.redisfans.com/key/pexpire.html">PEXPIRE</a></li><li><a href="http://doc.redisfans.com/key/pexpireat.html">PEXPIREAT</a></li><li><a href="http://doc.redisfans.com/key/pttl.html">PTTL</a></li><li><a href="http://doc.redisfans.com/key/randomkey.html">RANDOMKEY</a></li><li><a href="http://doc.redisfans.com/key/rename.html">RENAME</a></li><li><a href="http://doc.redisfans.com/key/renamenx.html">RENAMENX</a></li><li><a href="http://doc.redisfans.com/key/restore.html">RESTORE</a></li><li><a href="http://doc.redisfans.com/key/sort.html">SORT</a></li><li><a href="http://doc.redisfans.com/key/ttl.html">TTL</a></li><li><a href="http://doc.redisfans.com/key/type.html">TYPE</a></li><li><a href="http://doc.redisfans.com/key/scan.html">SCAN</a></li></ul><h2 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h2><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>特点：</p><ul><li>一个key对应一个value</li><li>string类型是<strong>二进制安全的</strong>，意思是 redis 的 string 可以包含任何数据例如jpg图片或者序列化的对象</li><li>string类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB</li></ul><p>demo：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afbaaffa219b4132a784d18b6e4fb886~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h4 id="string的基本命令："><a href="#string的基本命令：" class="headerlink" title="string的基本命令："></a>string的基本命令：</h4><ul><li><a href="http://doc.redisfans.com/string/append.html">APPEND</a></li><li><a href="http://doc.redisfans.com/string/bitcount.html">BITCOUNT</a></li><li><a href="http://doc.redisfans.com/string/bitop.html">BITOP</a></li><li><a href="http://doc.redisfans.com/string/decr.html">DECR</a></li><li><a href="http://doc.redisfans.com/string/decrby.html">DECRBY</a></li><li><a href="http://doc.redisfans.com/string/get.html">GET</a></li><li><a href="http://doc.redisfans.com/string/getbit.html">GETBIT</a></li><li><a href="http://doc.redisfans.com/string/getrange.html">GETRANGE</a></li><li><a href="http://doc.redisfans.com/string/getset.html">GETSET</a></li><li><a href="http://doc.redisfans.com/string/incr.html">INCR</a></li><li><a href="http://doc.redisfans.com/string/incrby.html">INCRBY</a></li><li><a href="http://doc.redisfans.com/string/incrbyfloat.html">INCRBYFLOAT</a></li><li><a href="http://doc.redisfans.com/string/mget.html">MGET</a></li><li><a href="http://doc.redisfans.com/string/mset.html">MSET</a></li><li><a href="http://doc.redisfans.com/string/msetnx.html">MSETNX</a></li><li><a href="http://doc.redisfans.com/string/psetex.html">PSETEX</a></li><li><a href="http://doc.redisfans.com/string/set.html">SET</a></li><li><a href="http://doc.redisfans.com/string/setbit.html">SETBIT</a></li><li><a href="http://doc.redisfans.com/string/setex.html">SETEX</a></li><li><a href="http://doc.redisfans.com/string/setnx.html">SETNX</a></li><li><a href="http://doc.redisfans.com/string/setrange.html">SETRANGE</a></li><li><a href="http://doc.redisfans.com/string/strlen.html">STRLEN</a></li></ul><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>特点：</p><ul><li>hash是一个键值对集合</li><li>hash是一个string类型的field和value的映射表，特别适合存储对象</li><li>每个 hash 可以存储 2^32 -1 键值对</li></ul><p>demo：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5fb120be05054b8c821f8fc3665fd5bf~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h4 id="hash的基本命令："><a href="#hash的基本命令：" class="headerlink" title="hash的基本命令："></a>hash的基本命令：</h4><ul><li><a href="http://doc.redisfans.com/hash/hdel.html">HDEL</a></li><li><a href="http://doc.redisfans.com/hash/hexists.html">HEXISTS</a></li><li><a href="http://doc.redisfans.com/hash/hget.html">HGET</a></li><li><a href="http://doc.redisfans.com/hash/hgetall.html">HGETALL</a></li><li><a href="http://doc.redisfans.com/hash/hincrby.html">HINCRBY</a></li><li><a href="http://doc.redisfans.com/hash/hincrbyfloat.html">HINCRBYFLOAT</a></li><li><a href="http://doc.redisfans.com/hash/hkeys.html">HKEYS</a></li><li><a href="http://doc.redisfans.com/hash/hlen.html">HLEN</a></li><li><a href="http://doc.redisfans.com/hash/hmget.html">HMGET</a></li><li><a href="http://doc.redisfans.com/hash/hmset.html">HMSET</a></li><li><a href="http://doc.redisfans.com/hash/hset.html">HSET</a></li><li><a href="http://doc.redisfans.com/hash/hsetnx.html">HSETNX</a></li><li><a href="http://doc.redisfans.com/hash/hvals.html">HVALS</a></li><li><a href="http://doc.redisfans.com/hash/hscan.html">HSCAN</a></li></ul><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>特点：</p><ul><li>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部L或者尾部R</li><li>列表最多也可存储 2^32 - 1 元素</li></ul><p>demo：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b062f37a3774659a04f8014bcbe5e69~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h4 id="list的基本命令："><a href="#list的基本命令：" class="headerlink" title="list的基本命令："></a>list的基本命令：</h4><ul><li><a href="http://doc.redisfans.com/list/blpop.html">BLPOP</a></li><li><a href="http://doc.redisfans.com/list/brpop.html">BRPOP</a></li><li><a href="http://doc.redisfans.com/list/brpoplpush.html">BRPOPLPUSH</a></li><li><a href="http://doc.redisfans.com/list/lindex.html">LINDEX</a></li><li><a href="http://doc.redisfans.com/list/linsert.html">LINSERT</a></li><li><a href="http://doc.redisfans.com/list/llen.html">LLEN</a></li><li><a href="http://doc.redisfans.com/list/lpop.html">LPOP</a></li><li><a href="http://doc.redisfans.com/list/lpush.html">LPUSH</a></li><li><a href="http://doc.redisfans.com/list/lpushx.html">LPUSHX</a></li><li><a href="http://doc.redisfans.com/list/lrange.html">LRANGE</a></li><li><a href="http://doc.redisfans.com/list/lrem.html">LREM</a></li><li><a href="http://doc.redisfans.com/list/lset.html">LSET</a></li><li><a href="http://doc.redisfans.com/list/ltrim.html">LTRIM</a></li><li><a href="http://doc.redisfans.com/list/rpop.html">RPOP</a></li><li><a href="http://doc.redisfans.com/list/rpoplpush.html">RPOPLPUSH</a></li><li><a href="http://doc.redisfans.com/list/rpush.html">RPUSH</a></li><li><a href="http://doc.redisfans.com/list/rpushx.html">RPUSHX</a></li></ul><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>特点：</p><ul><li>Redis 的 Set 是 string 类型的无序集合</li><li>set是通过哈希表实现的，所以R U D的复杂度都是 O(1)</li><li>集合的唯一性</li><li>集合中最大的成员数为 2^32 - 1</li></ul><p>demo：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5c0d8e077e548089a934fe1bd9aa35f~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>可以看到是唯一的且无序的</p><h4 id="set的基本命令："><a href="#set的基本命令：" class="headerlink" title="set的基本命令："></a>set的基本命令：</h4><ul><li><a href="http://doc.redisfans.com/set/sadd.html">SADD</a></li><li><a href="http://doc.redisfans.com/set/scard.html">SCARD</a></li><li><a href="http://doc.redisfans.com/set/sdiff.html">SDIFF</a></li><li><a href="http://doc.redisfans.com/set/sdiffstore.html">SDIFFSTORE</a></li><li><a href="http://doc.redisfans.com/set/sinter.html">SINTER</a></li><li><a href="http://doc.redisfans.com/set/sinterstore.html">SINTERSTORE</a></li><li><a href="http://doc.redisfans.com/set/sismember.html">SISMEMBER</a></li><li><a href="http://doc.redisfans.com/set/smembers.html">SMEMBERS</a></li><li><a href="http://doc.redisfans.com/set/smove.html">SMOVE</a></li><li><a href="http://doc.redisfans.com/set/spop.html">SPOP</a></li><li><a href="http://doc.redisfans.com/set/srandmember.html">SRANDMEMBER</a></li><li><a href="http://doc.redisfans.com/set/srem.html">SREM</a></li><li><a href="http://doc.redisfans.com/set/sunion.html">SUNION</a></li><li><a href="http://doc.redisfans.com/set/sunionstore.html">SUNIONSTORE</a></li><li><a href="http://doc.redisfans.com/set/sscan.html">SSCAN</a></li></ul><h3 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h3><p>特点：</p><ul><li>集合的唯一性</li><li>有序集合</li><li>每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</li><li>zset的成员是唯一的,但分数(score)却可以重复。</li></ul><p>demo：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c9b3c2b3f174bc4b890ba562cb7aaba~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>可以看到是唯一的且有序的，但是score可以重复</p><h4 id="zset的基本命令："><a href="#zset的基本命令：" class="headerlink" title="zset的基本命令："></a>zset的基本命令：</h4><ul><li><a href="http://doc.redisfans.com/sorted_set/zadd.html">ZADD</a></li><li><a href="http://doc.redisfans.com/sorted_set/zcard.html">ZCARD</a></li><li><a href="http://doc.redisfans.com/sorted_set/zcount.html">ZCOUNT</a></li><li><a href="http://doc.redisfans.com/sorted_set/zincrby.html">ZINCRBY</a></li><li><a href="http://doc.redisfans.com/sorted_set/zrange.html">ZRANGE</a></li><li><a href="http://doc.redisfans.com/sorted_set/zrangebyscore.html">ZRANGEBYSCORE</a></li><li><a href="http://doc.redisfans.com/sorted_set/zrank.html">ZRANK</a></li><li><a href="http://doc.redisfans.com/sorted_set/zrem.html">ZREM</a></li><li><a href="http://doc.redisfans.com/sorted_set/zremrangebyrank.html">ZREMRANGEBYRANK</a></li><li><a href="http://doc.redisfans.com/sorted_set/zremrangebyscore.html">ZREMRANGEBYSCORE</a></li><li><a href="http://doc.redisfans.com/sorted_set/zrevrange.html">ZREVRANGE</a></li><li><a href="http://doc.redisfans.com/sorted_set/zrevrangebyscore.html">ZREVRANGEBYSCORE</a></li><li><a href="http://doc.redisfans.com/sorted_set/zrevrank.html">ZREVRANK</a></li><li><a href="http://doc.redisfans.com/sorted_set/zscore.html">ZSCORE</a></li><li><a href="http://doc.redisfans.com/sorted_set/zunionstore.html">ZUNIONSTORE</a></li><li><a href="http://doc.redisfans.com/sorted_set/zinterstore.html">ZINTERSTORE</a></li><li><a href="http://doc.redisfans.com/sorted_set/zscan.html">ZSCAN</a></li></ul><hr><h2 id="Redis-HyperLogLog"><a href="#Redis-HyperLogLog" class="headerlink" title="Redis-HyperLogLog"></a>Redis-HyperLogLog</h2><p><strong>简介</strong>：</p><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p><p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p><p>Q：什么是基数？</p><p>A：基数就是集合内去重后元素的个数</p><p>Q：什么是基数估计？</p><p>A：基数估计就是在误差可接受的范围内，快速计算基数。</p><p>demo：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f889cd76071f4c89bed355b3d02d9495~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h3 id="HyperLogLog的基本命令："><a href="#HyperLogLog的基本命令：" class="headerlink" title="HyperLogLog的基本命令："></a>HyperLogLog的基本命令：</h3><table><thead><tr><th align="left">Num</th><th align="left">命令及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">[PFADD key element <a href="https://www.runoob.com/redis/hyperloglog-pfadd.html">element …]</a> ——添加指定元素到 HyperLogLog 中。</td></tr><tr><td align="left">2</td><td align="left">[PFCOUNT key <a href="https://www.runoob.com/redis/hyperloglog-pfcount.html">key …]</a> ——返回给定 HyperLogLog 的基数估算值。</td></tr><tr><td align="left">3</td><td align="left">[PFMERGE destkey sourcekey <a href="https://www.runoob.com/redis/hyperloglog-pfmerge.html">sourcekey …]</a> ——将多个 HyperLogLog 合并为一个 HyperLogLog</td></tr></tbody></table><hr><h2 id="Redis-Pub-x2F-Sub-发布订阅"><a href="#Redis-Pub-x2F-Sub-发布订阅" class="headerlink" title="Redis-Pub&#x2F;Sub-发布订阅"></a>Redis-Pub&#x2F;Sub-发布订阅</h2><p>Redis 发布订阅 (pub&#x2F;sub) 是一种<strong>消息通信模式</strong>：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p><p><strong>图解</strong>：（图源Runoob）</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81c27914648d43f7bfef07cd16b845c6~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>注意：如果需要测试，可能会需要开启多个<code>redis-cli</code>客户端</p><p>demo：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fae085ad25ce4f6b99411775dae75811~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>其中msg的命令是<code>PUBLISH FallenChat &quot;something&quot;</code></p><h3 id="发布订阅的基本命令："><a href="#发布订阅的基本命令：" class="headerlink" title="发布订阅的基本命令："></a>发布订阅的基本命令：</h3><ul><li><a href="http://doc.redisfans.com/pub_sub/psubscribe.html">PSUBSCRIBE</a></li><li><a href="http://doc.redisfans.com/pub_sub/publish.html">PUBLISH</a></li><li><a href="http://doc.redisfans.com/pub_sub/pubsub.html">PUBSUB</a></li><li><a href="http://doc.redisfans.com/pub_sub/punsubscribe.html">PUNSUBSCRIBE</a></li><li><a href="http://doc.redisfans.com/pub_sub/subscribe.html">SUBSCRIBE</a></li><li><a href="http://doc.redisfans.com/pub_sub/unsubscribe.html">UNSUBSCRIBE</a></li></ul><hr><h2 id="Redis-Transaction-事务"><a href="#Redis-Transaction-事务" class="headerlink" title="Redis-Transaction-事务"></a>Redis-Transaction-事务</h2><p>Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：</p><ul><li>批量操作在发送 EXEC 命令前被放入<strong>队列缓存</strong></li><li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。</li><li>在事务执行过程，其他客户端提交的命令请求<strong>不会</strong>插入到事务执行命令序列中</li></ul><p>一个事务从开始到执行会经历以下<strong>三个阶段</strong>：</p><ul><li>开始事务</li><li>命令入队</li><li>执行事务</li></ul><p>demo：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0839a16a7a5547f8a243058a72665233~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>特别地：单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</p><h3 id="事务的基本命令："><a href="#事务的基本命令：" class="headerlink" title="事务的基本命令："></a>事务的基本命令：</h3><ul><li><a href="http://doc.redisfans.com/transaction/discard.html">DISCARD</a></li><li><a href="http://doc.redisfans.com/transaction/exec.html">EXEC</a></li><li><a href="http://doc.redisfans.com/transaction/multi.html">MULTI</a></li><li><a href="http://doc.redisfans.com/transaction/unwatch.html">UNWATCH</a></li><li><a href="http://doc.redisfans.com/transaction/watch.html">WATCH</a></li></ul><hr><h2 id="Redis-Script-脚本"><a href="#Redis-Script-脚本" class="headerlink" title="Redis-Script-脚本"></a>Redis-Script-脚本</h2><p>Redis 脚本使用<code>Lua</code>解释器来执行脚本。 Redis 2.6 版本通过内嵌支持 Lua 环境。</p><p>执行脚本的常用命令为 <strong>EVAL</strong></p><h3 id="Lua简介："><a href="#Lua简介：" class="headerlink" title="Lua简介："></a>Lua简介：</h3><p>Q：Lua？</p><p>A：Lua 是一种轻量小巧的<strong>脚本语言</strong>，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。</p><p>A：其<strong>设计目的</strong>是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。</p><p><strong>Lua特性</strong>：</p><ul><li><strong>轻量级</strong>: 它用标准C语言编写并以源代码形式开放，编译后仅仅一百余K，可以很方便的嵌入别的程序里。</li><li><strong>可扩展</strong>: Lua提供了非常易于使用的扩展接口和机制：由宿主语言(通常是C或C++)提供这些功能，Lua可以使用它们，就像是本来就内置的功能一样。</li><li>其它特性：<ul><li>支持面向过程(procedure-oriented)编程和函数式编程(functional programming)；</li><li>自动内存管理；只提供了一种通用类型的表（table），用它可以实现数组，哈希表，集合，对象；</li><li>语言内置模式匹配；闭包(closure)；函数也可以看做一个值；提供多线程（协同进程，并非操作系统所支持的线程）支持；</li><li>通过闭包和table可以很方便地支持面向对象编程所需要的一些关键机制，比如数据抽象，虚函数，继承和重载等。</li></ul></li></ul><p><strong>Lua应用场景</strong>：</p><ul><li>游戏开发</li><li>独立应用脚本</li><li>Web 应用脚本</li><li>扩展和数据库插件如：MySQL Proxy 和 MySQL WorkBench</li><li>安全系统，如入侵检测系统</li></ul><hr><p>回到Redis</p><p>demo：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb7417415d474aea96ca488dcaa75d37~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h3 id="脚本的基本命令："><a href="#脚本的基本命令：" class="headerlink" title="脚本的基本命令："></a>脚本的基本命令：</h3><ul><li><a href="http://doc.redisfans.com/script/eval.html">EVAL</a></li><li><a href="http://doc.redisfans.com/script/evalsha.html">EVALSHA</a></li><li><a href="http://doc.redisfans.com/script/script_exists.html">SCRIPT EXISTS</a></li><li><a href="http://doc.redisfans.com/script/script_flush.html">SCRIPT FLUSH</a></li><li><a href="http://doc.redisfans.com/script/script_kill.html">SCRIPT KILL</a></li><li><a href="http://doc.redisfans.com/script/script_load.html">SCRIPT LOAD</a></li></ul><hr><h2 id="Redis-Connection-连接"><a href="#Redis-Connection-连接" class="headerlink" title="Redis-Connection-连接"></a>Redis-Connection-连接</h2><p>Redis 连接命令主要是用于连接 redis 服务</p><h3 id="连接的基本命令："><a href="#连接的基本命令：" class="headerlink" title="连接的基本命令："></a>连接的基本命令：</h3><ul><li><a href="http://doc.redisfans.com/connection/auth.html">AUTH</a></li><li><a href="http://doc.redisfans.com/connection/echo.html">ECHO</a></li><li><a href="http://doc.redisfans.com/connection/ping.html">PING</a></li><li><a href="http://doc.redisfans.com/connection/quit.html">QUIT</a></li><li><a href="http://doc.redisfans.com/connection/select.html">SELECT</a></li></ul><hr><h2 id="Redis-Server-服务器"><a href="#Redis-Server-服务器" class="headerlink" title="Redis-Server-服务器"></a>Redis-Server-服务器</h2><p>Redis 服务器命令主要是用于管理 redis 服务</p><p>输入<code>INFO</code>就可以查看，由于内容过多就不一一展示了，下面是一部分</p><p>demo：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3722d8245af4e72aa1b2d6134747903~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h3 id="服务器的基本命令："><a href="#服务器的基本命令：" class="headerlink" title="服务器的基本命令："></a>服务器的基本命令：</h3><ul><li><a href="http://doc.redisfans.com/server/bgrewriteaof.html">BGREWRITEAOF</a></li><li><a href="http://doc.redisfans.com/server/bgsave.html">BGSAVE</a></li><li><a href="http://doc.redisfans.com/server/client_getname.html">CLIENT GETNAME</a></li><li><a href="http://doc.redisfans.com/server/client_kill.html">CLIENT KILL</a></li><li><a href="http://doc.redisfans.com/server/client_list.html">CLIENT LIST</a></li><li><a href="http://doc.redisfans.com/server/client_setname.html">CLIENT SETNAME</a></li><li><a href="http://doc.redisfans.com/server/config_get.html">CONFIG GET</a></li><li><a href="http://doc.redisfans.com/server/config_resetstat.html">CONFIG RESETSTAT</a></li><li><a href="http://doc.redisfans.com/server/config_rewrite.html">CONFIG REWRITE</a></li><li><a href="http://doc.redisfans.com/server/config_set.html">CONFIG SET</a></li><li><a href="http://doc.redisfans.com/server/dbsize.html">DBSIZE</a></li><li><a href="http://doc.redisfans.com/server/debug_object.html">DEBUG OBJECT</a></li><li><a href="http://doc.redisfans.com/server/debug_segfault.html">DEBUG SEGFAULT</a></li><li><a href="http://doc.redisfans.com/server/flushall.html">FLUSHALL</a></li><li><a href="http://doc.redisfans.com/server/flushdb.html">FLUSHDB</a></li><li><a href="http://doc.redisfans.com/server/info.html">INFO</a></li><li><a href="http://doc.redisfans.com/server/lastsave.html">LASTSAVE</a></li><li><a href="http://doc.redisfans.com/server/monitor.html">MONITOR</a></li><li><a href="http://doc.redisfans.com/server/psync.html">PSYNC</a></li><li><a href="http://doc.redisfans.com/server/save.html">SAVE</a></li><li><a href="http://doc.redisfans.com/server/shutdown.html">SHUTDOWN</a></li><li><a href="http://doc.redisfans.com/server/slaveof.html">SLAVEOF</a></li><li><a href="http://doc.redisfans.com/server/slowlog.html">SLOWLOG</a></li><li><a href="http://doc.redisfans.com/server/sync.html">SYNC</a></li><li><a href="http://doc.redisfans.com/server/time.html">TIME</a></li></ul><hr><h2 id="Redis-GEO"><a href="#Redis-GEO" class="headerlink" title="Redis-GEO"></a>Redis-GEO</h2><p>Redis GEO 主要用于存储地理位置信息，并对存储的信息进行操作。（After V3.2）</p><p>Redis GEO 常用的操作方法：</p><ul><li>geoadd：添加地理位置的坐标。</li><li>geopos：获取地理位置的坐标。</li><li>geodist：计算两个位置之间的距离。</li><li>georadius：根据用户给定的经纬度坐标来获取指定范围内的地理位置集合。</li><li>georadiusbymember：根据储存在位置集合里面的某个地点获取指定范围内的地理位置集合。</li><li>geohash：返回一个或多个位置对象的 geohash 值。</li></ul><p>demo待补充</p><hr><h2 id="Redis-Stream"><a href="#Redis-Stream" class="headerlink" title="Redis-Stream"></a>Redis-Stream</h2><p>（After V5.0）</p><blockquote><p>Redis Stream 主要用于消息队列（MQ，Message Queue），Redis 本身是有一个 Redis 发布订阅 (pub&#x2F;sub) 来实现消息队列的功能，但它有个缺点就是<strong>消息无法持久化</strong>，如果出现网络断开、Redis 宕机等，消息就会被丢弃。</p><p>而 Redis Stream 提供了<strong>消息的持久化</strong>和<strong>主备复制</strong>功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。</p></blockquote><p>结构示意图：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a73c211f11bd45f389b5565ef98b12ee~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><ul><li>有一个消息链表</li><li>每个Stream都有唯一的名称，就是key，在首次使用 xadd 指令追加消息时自动创建。</li></ul><blockquote><ul><li><strong>Consumer Group</strong> ：消费组，使用 XGROUP CREATE 命令创建，一个消费组有多个消费者(Consumer)。</li><li><strong>last_delivered_id</strong> ：游标，每个消费组会有个游标 last_delivered_id，任意一个消费者读取了消息都会使游标 last_delivered_id 往前移动。</li><li><strong>pending_ids</strong> ：消费者(Consumer)的状态变量，作用是维护消费者的未确认的 id。 pending_ids 记录了当前已经被客户端读取的消息，但是还没有 ack (Acknowledge character：确认字符）。</li></ul></blockquote><h3 id="消息队列相关命令："><a href="#消息队列相关命令：" class="headerlink" title="消息队列相关命令："></a><strong>消息队列相关命令：</strong></h3><ul><li><strong>XADD</strong> - 添加消息到末尾</li><li><strong>XTRIM</strong> - 对流进行修剪，限制长度</li><li><strong>XDEL</strong> - 删除消息</li><li><strong>XLEN</strong> - 获取流包含的元素数量，即消息长度</li><li><strong>XRANGE</strong> - 获取消息列表，会自动过滤已经删除的消息</li><li><strong>XREVRANGE</strong> - 反向获取消息列表，ID 从大到小</li><li><strong>XREAD</strong> - 以阻塞或非阻塞方式获取消息列表</li></ul><h3 id="消费者组相关命令："><a href="#消费者组相关命令：" class="headerlink" title="消费者组相关命令："></a><strong>消费者组相关命令：</strong></h3><ul><li><strong>XGROUP CREATE</strong> - 创建消费者组</li><li><strong>XREADGROUP GROUP</strong> - 读取消费者组中的消息</li><li><strong>XACK</strong> - 将消息标记为”已处理”</li><li><strong>XGROUP SETID</strong> - 为消费者组设置新的最后递送消息ID</li><li><strong>XGROUP DELCONSUMER</strong> - 删除消费者</li><li><strong>XGROUP DESTROY</strong> - 删除消费者组</li><li><strong>XPENDING</strong> - 显示待处理消息的相关信息</li><li><strong>XCLAIM</strong> - 转移消息的归属权</li><li><strong>XINFO</strong> - 查看流和消费者组的相关信息；</li><li><strong>XINFO GROUPS</strong> - 打印消费者组的信息；</li><li><strong>XINFO STREAM</strong> - 打印流信息</li></ul><p>demo待补充</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;零、前言&quot;&gt;&lt;a href=&quot;#零、前言&quot; class=&quot;headerlink&quot; title=&quot;零、前言&quot;&gt;&lt;/a&gt;零、前言&lt;/h1&gt;&lt;p&gt;本文是笔者从零开始学习Redis的学习记录。&lt;/p&gt;
&lt;p&gt;若笔者有任何疏忽纰漏之处，烦请不吝赐教。&lt;/p&gt;
&lt;p&gt;另附我的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Gin + Gorm实战CRUD丨学习记录</title>
    <link href="https://conqueror712.github.io/post/go-crud-demo.html"/>
    <id>https://conqueror712.github.io/post/go-crud-demo.html</id>
    <published>2023-01-24T03:11:50.000Z</published>
    <updated>2023-02-15T14:25:22.736Z</updated>
    
    <content type="html"><![CDATA[<p>话不多说，先附上Github链接，欢迎star：<a href="https://github.com/Conqueror712/Go_CRUD_demo">Conqueror712&#x2F;Go_CRUD_demo: Gin + Gorm + MySQL + Navicat (github.com)</a></p><p>再附上我的掘金文章链接，欢迎访问：<a href="https://juejin.cn/post/7192053234620432441">Gin + Gorm实战CRUD丨学习记录 - 掘金 (juejin.cn)</a></p><h1 id="零、前言："><a href="#零、前言：" class="headerlink" title="零、前言："></a>零、前言：</h1><h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><p>Q：Gin和Gorm都是干什么的？有什么区别？</p><p>A：Gin 和 Gorm 是 Go 编程语言中流行的开源库。但是，它们服务于不同的目的，通常在 web 开发项目中一起使用。</p><p>Gin 是一个用于构建 HTTP 服务器的 web 框架。它提供了一个简单易用的 API，用于处理 HTTP 请求和响应、路由、中间件和其他常见的 web 应用程序所需的功能。它以其高性能和简约为特点，提供了轻量级和灵活的解决方案来构建 web 服务器。</p><p>Gorm 是 Go 的一个 ORM（对象关系映射）库。它提供了一个简单易用的 API，用于与数据库交互、处理数据库迁移和执行常见的数据库操作，如查询、插入、更新和删除记录。它支持多种数据库后端，包括 MySQL、PostgreSQL、SQLite 等。</p><p>总而言之, Gin 是用于处理 HTTP 请求和响应、路由、中间件和其他与网络相关的东西的 web 框架，而 Gorm 则是用于与数据库交互并执行常见数据库操作的 ORM 库。它们通常一起使用，来处理 HTTP 请求&#x2F;响应并在 web 开发项目中存储或获取数据。</p><h2 id="开发环境："><a href="#开发环境：" class="headerlink" title="开发环境："></a>开发环境：</h2><ul><li>Windows 10</li><li>VSCode</li></ul><hr><h1 id="一、Gin"><a href="#一、Gin" class="headerlink" title="一、Gin"></a>一、Gin</h1><h2 id="0-快速入门："><a href="#0-快速入门：" class="headerlink" title="0. 快速入门："></a>0. 快速入门：</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/thinkerou/favicon&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中间件（拦截器），功能：预处理，登录授权、验证、分页、耗时统计...</span></span><br><span class="line"><span class="comment">// func myHandler() gin.HandlerFunc &#123;</span></span><br><span class="line"><span class="comment">// return func(ctx *gin.Context) &#123;</span></span><br><span class="line"><span class="comment">// // 通过自定义中间件，设置的值，在后续处理只要调用了这个中间件的都可以拿到这里的参数</span></span><br><span class="line"><span class="comment">// ctx.Set(&quot;usersesion&quot;, &quot;userid-1&quot;)</span></span><br><span class="line"><span class="comment">// ctx.Next()  // 放行</span></span><br><span class="line"><span class="comment">// ctx.Abort() // 阻止</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个服务</span></span><br><span class="line">ginServer := gin.Default()</span><br><span class="line">ginServer.Use(favicon.New(<span class="string">&quot;./Arctime.ico&quot;</span>)) <span class="comment">// 这里如果添加了东西然后再运行没有变化，请重启浏览器，浏览器有缓存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载静态页面</span></span><br><span class="line">ginServer.LoadHTMLGlob(<span class="string">&quot;templates/*&quot;</span>) <span class="comment">// 一种是全局加载，一种是加载指定的文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载资源文件</span></span><br><span class="line">ginServer.Static(<span class="string">&quot;/static&quot;</span>, <span class="string">&quot;./static&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相应一个页面给前端</span></span><br><span class="line"></span><br><span class="line">ginServer.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">ctx.HTML(http.StatusOK, <span class="string">&quot;index.html&quot;</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;msg&quot;</span>: <span class="string">&quot;This data is come from Go background.&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 能加载静态页面也可以加载测试文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取请求中的参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统方式：usl?userid=xxx&amp;username=conqueror712</span></span><br><span class="line"><span class="comment">// Rustful方式：/user/info/1/conqueror712</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是传统方式的例子</span></span><br><span class="line">ginServer.GET(<span class="string">&quot;/user/info&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123; <span class="comment">// 这个格式是固定的</span></span><br><span class="line">userid := context.Query(<span class="string">&quot;userid&quot;</span>)</span><br><span class="line">username := context.Query(<span class="string">&quot;username&quot;</span>)</span><br><span class="line"><span class="comment">// 拿到之后返回给前端</span></span><br><span class="line">context.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">&quot;userid&quot;</span>:   userid,</span><br><span class="line"><span class="string">&quot;username&quot;</span>: username,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 此时执行代码之后，在浏览器中可以输入http://localhost:8081/user/info?userid=111&amp;username=666</span></span><br><span class="line"><span class="comment">// 就可以看到返回了JSON格式的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是Rustful方式的例子</span></span><br><span class="line">ginServer.GET(<span class="string">&quot;/user/info/:userid/:username&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line">userid := context.Param(<span class="string">&quot;userid&quot;</span>)</span><br><span class="line">username := context.Param(<span class="string">&quot;username&quot;</span>)</span><br><span class="line"><span class="comment">// 还是一样，返回给前端</span></span><br><span class="line">context.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">&quot;userid&quot;</span>:   userid,</span><br><span class="line"><span class="string">&quot;username&quot;</span>: username,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 指定代码后，只需要在浏览器中http://localhost:8081/user/info/111/555</span></span><br><span class="line"><span class="comment">// 就可以看到返回了JSON数据了，非常方便简洁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化</span></span><br><span class="line"><span class="comment">// 前端给后端传递JSON</span></span><br><span class="line">ginServer.POST(<span class="string">&quot;/json&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// request.body</span></span><br><span class="line">data, _ := ctx.GetRawData()</span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125; <span class="comment">// Go语言中object一般用空接口来表示，可以接收anything</span></span><br><span class="line"><span class="comment">// 顺带一提，1.18以上，interface可以直接改成any</span></span><br><span class="line">_ = json.Unmarshal(data, &amp;m)</span><br><span class="line">ctx.JSON(http.StatusOK, m)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 用apipost或者postman写一段json传到localhost:8081/json里就可以了</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">json示例：</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">&quot;name&quot;: &quot;Conqueror712&quot;,</span></span><br><span class="line"><span class="comment">&quot;age&quot;: 666,</span></span><br><span class="line"><span class="comment">&quot;address&quot;: &quot;Mars&quot;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 看到后端的实时响应里面接收到数据就可以了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理表单请求 这些都是支持函数式编程，Go语言特性，可以把函数作为参数传进来</span></span><br><span class="line">ginServer.POST(<span class="string">&quot;/user/add&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">username := ctx.PostForm(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">password := ctx.PostForm(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">ctx.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">&quot;msg&quot;</span>:      <span class="string">&quot;ok&quot;</span>,</span><br><span class="line"><span class="string">&quot;username&quot;</span>: username,</span><br><span class="line"><span class="string">&quot;password&quot;</span>: password,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路由</span></span><br><span class="line">ginServer.GET(<span class="string">&quot;/test&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 重定向 -&gt; 301</span></span><br><span class="line">ctx.Redirect(<span class="number">301</span>, <span class="string">&quot;https://conqueror712.gitee.io/conqueror712.gitee.io/&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// http://localhost:8081/test</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 404</span></span><br><span class="line">ginServer.NoRoute(<span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">ctx.HTML(<span class="number">404</span>, <span class="string">&quot;404.html&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路由组暂略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器端口，用服务器端口来访问地址</span></span><br><span class="line">ginServer.Run(<span class="string">&quot;:8081&quot;</span>) <span class="comment">// 不写的话默认是8080，也可以更改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>API用法示例</strong>：<code>https://gin-gonic.com/zh-cn/docs/examples/</code></p><hr><h2 id="1-基准测试"><a href="#1-基准测试" class="headerlink" title="1. 基准测试"></a>1. 基准测试</h2><p>Q：基准测试是什么？</p><p>A：基准测试，也称为性能测试或压力测试，是一种<strong>用于测量系统或组件性能的测试</strong>。基准测试的<strong>目的是了解系统或组件在特定条件下的性能，并将结果与其他类似系统或组件进行比较</strong>。基准测试可用于评估各种类型的系统和组件，包括硬件、软件、网络和整个系统。</p><p>Q：什么时候需要基准测试呀？</p><p>A：基准测试通常涉及在被测系统或组件上运行特定工作负载或任务，并测量<strong>吞吐量、延迟时间、CPU使用率、内存使用率</strong>等各种性能指标。基准测试的结果可用于识别瓶颈和性能问题，并做出有关如何优化系统或组件以提高性能的明智决策。</p><p>有许多不同类型的基准测试，每种类型都有自己的指标和工作负载。常见的基准测试类型包括：</p><ul><li>人工基准测试：使用人工工作负载来测量系统或组件的性能。</li><li>真实世界基准测试：使用真实世界的工作负载或场景来测量系统或组件的性能。</li><li>压力测试：旨在将系统或组件推到极限，以确定在正常使用条件下可能不明显的性能问题</li></ul><p>重要的是要知道基准测试不是一次性的活动，而是应该<strong>定期进行</strong>的活动，以评估系统的性能并检测随时间的消耗。</p><p>Q：什么样的基准测试结果是我们想要的呀？</p><p>A：</p><ul><li>在一定的时间内实现的总调用数，越高越好</li><li>单次操作耗时（ns&#x2F;op），越低越好</li><li>堆内存分配 （B&#x2F;op）, 越低越好</li><li>每次操作的平均内存分配次数（allocs&#x2F;op），越低越好</li></ul><hr><h2 id="2-Gin的特性与Jsoniter："><a href="#2-Gin的特性与Jsoniter：" class="headerlink" title="2. Gin的特性与Jsoniter："></a>2. Gin的特性与Jsoniter：</h2><p>Gin v1 稳定的特性:</p><ul><li>零分配路由。</li><li>仍然是最快的 http 路由器和框架。</li><li>完整的单元测试支持。</li><li>实战考验。</li><li>API 冻结，新版本的发布不会破坏你的代码。</li><li>Gin 项目可以轻松部署在任何云提供商上。</li></ul><p>Gin 使用 encoding&#x2F;json 作为默认的 json 包，但是你可以在编译中使用标签将其修改为 jsoniter。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go build -tags=jsoniter .</span><br></pre></td></tr></table></figure><p><strong>Jsoniter是什么？</strong></p><ul><li><code>json-iterator</code>是一款快且灵活的<code>JSON</code>解析器,同时提供<code>Java</code>和<code>Go</code>两个版本。</li><li><code>json-iterator</code>是最快的<code>JSON</code>解析器。它最多能比普通的解析器快10倍之多</li><li>独特的<code>iterator api</code>能够直接遍历<code>JSON</code> ，极致性能、零内存分配</li><li>从dsljson和jsonparser借鉴了大量代码。</li></ul><p>下载依赖：<code>go get github.com/json-iterator/go</code></p><hr><h1 id="二、GORM"><a href="#二、GORM" class="headerlink" title="二、GORM"></a>二、GORM</h1><h2 id="0-特性与安装："><a href="#0-特性与安装：" class="headerlink" title="0. 特性与安装："></a>0. 特性与安装：</h2><ul><li>全功能 ORM</li><li>关联 (Has One，Has Many，Belongs To，Many To Many，多态，单表继承)</li><li>Create，Save，Update，Delete，Find 中钩子方法</li><li>支持 <code>Preload</code>、<code>Joins</code> 的预加载</li><li>事务，嵌套事务，Save Point，Rollback To Saved Point</li><li>Context、预编译模式、DryRun 模式</li><li>批量插入，FindInBatches，Find&#x2F;Create with Map，使用 SQL 表达式、Context Valuer 进行 CRUD</li><li>SQL 构建器，Upsert，数据库锁，Optimizer&#x2F;Index&#x2F;Comment Hint，命名参数，子查询</li><li>复合主键，索引，约束</li><li>Auto Migration</li><li>自定义 Logger</li><li>灵活的可扩展插件 API：Database Resolver（多数据库，读写分离）、Prometheus…</li><li>每个特性都经过了测试的重重考验</li><li>开发者友好</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go get -u gorm.io/gorm</span><br><span class="line">go get -u gorm.io/driver/sqlite</span><br></pre></td></tr></table></figure><p>其他的补充内容：</p><ul><li>Gorm是软删除，为了保证数据库的完整性</li></ul><hr><h1 id="三、Navicat"><a href="#三、Navicat" class="headerlink" title="三、Navicat"></a>三、Navicat</h1><p>破解教程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.jianshu.com/p/9c4c499429da</span><br></pre></td></tr></table></figure><p>新建连接 -&gt; MySQL -&gt; 连接名随便 -&gt; 密码随便 -&gt; 双击左侧打开 -&gt; 右键information_schema -&gt; 新建数据库 -&gt; 名称crud-list -&gt; 字符集utf8mb4</p><p>这里如果打开的时候报错<code>navicat 1045 - access denied for user &#39;root&#39;@&#39;localhost&#39; (using password: &#39;YES&#39;)</code>，则需要查看自己的数据库本身的问题</p><hr><h1 id="四、Gin-Gorm的CRUD"><a href="#四、Gin-Gorm的CRUD" class="headerlink" title="四、Gin+Gorm的CRUD"></a>四、Gin+Gorm的CRUD</h1><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><p>编写测试代码，成功运行即可，但是这个时候还不能查看数据库是否被创建，</p><p>如果要看我们需要定义结构体，然后定义表迁移，具体代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;gorm.io/driver/sqlite&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"><span class="string">&quot;gorm.io/driver/mysql&quot;</span></span><br><span class="line"><span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 如何连接数据库 ? MySQL + Navicat</span></span><br><span class="line"><span class="comment">// 需要更改的内容：用户名，密码，数据库名称</span></span><br><span class="line">dsn := <span class="string">&quot;root:BqV?eGcc_1o+@tcp(127.0.0.1:3306)/crud-list?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span></span><br><span class="line">db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;db = &quot;</span>, db)</span><br><span class="line">fmt.Println(<span class="string">&quot;err = &quot;</span>, err)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接池</span></span><br><span class="line">sqlDB, err := db.DB()</span><br><span class="line"><span class="comment">// SetMaxIdleConns 设置空闲连接池中连接的最大数量</span></span><br><span class="line">sqlDB.SetMaxIdleConns(<span class="number">10</span>)</span><br><span class="line"><span class="comment">// SetMaxOpenConns 设置打开数据库连接的最大数量。</span></span><br><span class="line">sqlDB.SetMaxOpenConns(<span class="number">100</span>)</span><br><span class="line"><span class="comment">// SetConnMaxLifetime 设置了连接可复用的最大时间。</span></span><br><span class="line">sqlDB.SetConnMaxLifetime(<span class="number">10</span> * time.Second) <span class="comment">// 10秒钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体</span></span><br><span class="line"><span class="keyword">type</span> List <span class="keyword">struct</span> &#123;</span><br><span class="line">Name    <span class="type">string</span></span><br><span class="line">State   <span class="type">string</span></span><br><span class="line">Phone   <span class="type">string</span></span><br><span class="line">Email   <span class="type">string</span></span><br><span class="line">Address <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迁移</span></span><br><span class="line">db.AutoMigrate(&amp;List&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口</span></span><br><span class="line">r := gin.Default()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 端口号</span></span><br><span class="line">PORT := <span class="string">&quot;3001&quot;</span></span><br><span class="line">r.Run(<span class="string">&quot;:&quot;</span> + PORT)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义好之后我们运行，没有报错并且在终端显示出来3001就是正确的，这个时候我们可以去Navicat里面查看crud-list下面的”表”，刷新后发现有一个lists产生，那就是对的了。</p><p>但是这个时候我们存在两个问题：</p><ol><li>没有主键：在struct里添加<code>gorm.Model</code>来解决，Ctrl+左键可以查看<code>model</code></li><li>表里面的名称变成了复数：详见文档的高级主题-GORM配置里，在<code>*db*, *err* *:=* gorm.Open(mysql.Open(dsn), *&amp;*gorm.Config&#123;&#125;)</code>里面添加一段话即可</li></ol><p>更改完成之后我们要先在Navicat里面把原来的表<code>lists</code>删掉才能重新创建，这个时候我们重新运行，就会发现表单里面多了很多东西</p><hr><h2 id="结构体定义与优化"><a href="#结构体定义与优化" class="headerlink" title="结构体定义与优化"></a>结构体定义与优化</h2><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`gorm:&quot;type:varchar(20); not null&quot; json:&quot;name&quot; binding:&quot;required&quot;`</span><br></pre></td></tr></table></figure><p>需要注意的是：</p><ol><li>结构体里面的变量(Name)必须首字母大写，否则创建不出列，会被自动忽略</li><li>gorm指定类型</li><li>json表示json接收的时候的名称</li><li>binding required表示必须传入</li></ol><hr><h2 id="CRUD接口"><a href="#CRUD接口" class="headerlink" title="CRUD接口"></a>CRUD接口</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试</span></span><br><span class="line">r.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>: <span class="string">&quot;请求成功&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>编写完这一段之后运行代码，然后去postman里面新建一个GET接口<code>127.0.0.1:3001</code>然后send一下，出现请求成功就请求成功了。</p><hr><p>增也是一样，写好之后直接用如下JSON来测试就可以：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;state&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;在职&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;phone&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;13900000000&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;email&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;6666@qq.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;address&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;二仙桥成华大道&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>返回：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;200&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;ID&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;CreatedAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2023-01-24T09:27:36.73+08:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;UpdatedAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2023-01-24T09:27:36.73+08:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;DeletedAt&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;state&quot;</span><span class="punctuation">:</span> <span class="string">&quot;在职&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;phone&quot;</span><span class="punctuation">:</span> <span class="string">&quot;13900000000&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;6666@qq.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;二仙桥成华大道&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;添加成功&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这时候也可以在数据库里看到这条数据</p><hr><p>删除也是一样，编写完运行之后添加一个DELETE接口，然后输入<code>127.0.0.1:3001/user/delete/2</code>之后send就可以看到返回了（前提是有数据）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;删除成功&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果是删除了不存在的id，就会返回</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">400</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;id没有找到，删除失败&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>顺带一提，事实上这个代码还可以优化，这里的if else太多了，后面优化的时候有错误直接return</p><hr><p>修改也是一样，示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;state&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;离职&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;phone&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;13900000000&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;email&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;6666@qq.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;address&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;二仙桥成华大道&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>返回：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;修改成功&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><hr><p>查询分为两种：</p><ol><li>条件查询</li><li>分页查询</li></ol><p>条件查询的话，直接写好了请求<code>127.0.0.1:3001/user/list/王五</code></p><p>返回：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;200&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;ID&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;CreatedAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2023-01-24T10:06:25.305+08:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;UpdatedAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2023-01-24T10:06:25.305+08:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;DeletedAt&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;王五&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;state&quot;</span><span class="punctuation">:</span> <span class="string">&quot;在职&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;phone&quot;</span><span class="punctuation">:</span> <span class="string">&quot;13100000000&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;8888@qq.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;八仙桥成华大道&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;查询成功&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>全部 &#x2F; 分页查询的话</p><p>譬如说请求是：<code>127.0.0.1:3001/user/list?pageNum=1&amp;pageSize=2</code></p><p>意思就是查询第一页的两个</p><p>返回：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;list&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;ID&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;CreatedAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2023-01-24T10:06:25.305+08:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;UpdatedAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2023-01-24T10:06:25.305+08:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;DeletedAt&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;王五&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;state&quot;</span><span class="punctuation">:</span> <span class="string">&quot;在职&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;phone&quot;</span><span class="punctuation">:</span> <span class="string">&quot;13100000000&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;8888@qq.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;八仙桥成华大道&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;pageNum&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;pageSize&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;查询成功&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果请求是：<code>127.0.0.1:3001/user/list</code></p><p>返回：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;list&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;ID&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;CreatedAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2023-01-24T09:27:36.73+08:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;UpdatedAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2023-01-24T09:55:20.351+08:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;DeletedAt&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;state&quot;</span><span class="punctuation">:</span> <span class="string">&quot;离职&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;phone&quot;</span><span class="punctuation">:</span> <span class="string">&quot;13900000000&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;6666@qq.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;二仙桥成华大道&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;ID&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;CreatedAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2023-01-24T10:06:25.305+08:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;UpdatedAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2023-01-24T10:06:25.305+08:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;DeletedAt&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;王五&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;state&quot;</span><span class="punctuation">:</span> <span class="string">&quot;在职&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;phone&quot;</span><span class="punctuation">:</span> <span class="string">&quot;13100000000&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;8888@qq.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;八仙桥成华大道&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;pageNum&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;pageSize&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;查询成功&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><hr><p>完整代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;gorm.io/driver/sqlite&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"><span class="string">&quot;gorm.io/driver/mysql&quot;</span></span><br><span class="line"><span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line"><span class="string">&quot;gorm.io/gorm/schema&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 如何连接数据库 ? MySQL + Navicat</span></span><br><span class="line"><span class="comment">// 需要更改的内容：用户名，密码，数据库名称</span></span><br><span class="line">dsn := <span class="string">&quot;root:password@tcp(127.0.0.1:3306)/database?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span></span><br><span class="line">db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;</span><br><span class="line">NamingStrategy: schema.NamingStrategy&#123;</span><br><span class="line">SingularTable: <span class="literal">true</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;db = &quot;</span>, db)</span><br><span class="line">fmt.Println(<span class="string">&quot;err = &quot;</span>, err)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接池</span></span><br><span class="line">sqlDB, err := db.DB()</span><br><span class="line"><span class="comment">// SetMaxIdleConns 设置空闲连接池中连接的最大数量</span></span><br><span class="line">sqlDB.SetMaxIdleConns(<span class="number">10</span>)</span><br><span class="line"><span class="comment">// SetMaxOpenConns 设置打开数据库连接的最大数量。</span></span><br><span class="line">sqlDB.SetMaxOpenConns(<span class="number">100</span>)</span><br><span class="line"><span class="comment">// SetConnMaxLifetime 设置了连接可复用的最大时间。</span></span><br><span class="line">sqlDB.SetConnMaxLifetime(<span class="number">10</span> * time.Second) <span class="comment">// 10秒钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体</span></span><br><span class="line"><span class="keyword">type</span> List <span class="keyword">struct</span> &#123;</span><br><span class="line">gorm.Model        <span class="comment">// 主键</span></span><br><span class="line">Name       <span class="type">string</span> <span class="string">`gorm:&quot;type:varchar(20); not null&quot; json:&quot;name&quot; binding:&quot;required&quot;`</span></span><br><span class="line">State      <span class="type">string</span> <span class="string">`gorm:&quot;type:varchar(20); not null&quot; json:&quot;state&quot; binding:&quot;required&quot;`</span></span><br><span class="line">Phone      <span class="type">string</span> <span class="string">`gorm:&quot;type:varchar(20); not null&quot; json:&quot;phone&quot; binding:&quot;required&quot;`</span></span><br><span class="line">Email      <span class="type">string</span> <span class="string">`gorm:&quot;type:varchar(40); not null&quot; json:&quot;email&quot; binding:&quot;required&quot;`</span></span><br><span class="line">Address    <span class="type">string</span> <span class="string">`gorm:&quot;type:varchar(200); not null&quot; json:&quot;address&quot; binding:&quot;required&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迁移</span></span><br><span class="line">db.AutoMigrate(&amp;List&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口</span></span><br><span class="line">r := gin.Default()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="comment">// r.GET(&quot;/&quot;, func(c *gin.Context) &#123;</span></span><br><span class="line"><span class="comment">// c.JSON(200, gin.H&#123;</span></span><br><span class="line"><span class="comment">// &quot;message&quot;: &quot;请求成功&quot;,</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务码约定：正确200，错误400</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 增</span></span><br><span class="line">r.POST(<span class="string">&quot;/user/add&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 定义一个变量指向结构体</span></span><br><span class="line"><span class="keyword">var</span> data List</span><br><span class="line"><span class="comment">// 绑定方法</span></span><br><span class="line">err := ctx.ShouldBindJSON(&amp;data)</span><br><span class="line"><span class="comment">// 判断绑定是否有错误</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">ctx.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;msg&quot;</span>:  <span class="string">&quot;添加失败&quot;</span>,</span><br><span class="line"><span class="string">&quot;data&quot;</span>: gin.H&#123;&#125;,</span><br><span class="line"><span class="string">&quot;code&quot;</span>: <span class="string">&quot;400&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 数据库的操作</span></span><br><span class="line">db.Create(&amp;data) <span class="comment">// 创建一条数据</span></span><br><span class="line">ctx.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;msg&quot;</span>:  <span class="string">&quot;添加成功&quot;</span>,</span><br><span class="line"><span class="string">&quot;data&quot;</span>: data,</span><br><span class="line"><span class="string">&quot;code&quot;</span>: <span class="string">&quot;200&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删</span></span><br><span class="line"><span class="comment">// 1. 找到对应的id对应的条目</span></span><br><span class="line"><span class="comment">// 2. 判断id是否存在</span></span><br><span class="line"><span class="comment">// 3. 从数据库中删除 or 返回id没有找到</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Restful编码规范</span></span><br><span class="line">r.DELETE(<span class="string">&quot;/user/delete/:id&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> data []List</span><br><span class="line"><span class="comment">// 接收id</span></span><br><span class="line">id := ctx.Param(<span class="string">&quot;id&quot;</span>) <span class="comment">// 如果有键值对形式的话用Query()</span></span><br><span class="line"><span class="comment">// 判断id是否存在</span></span><br><span class="line">db.Where(<span class="string">&quot;id = ? &quot;</span>, id).Find(&amp;data)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">0</span> &#123;</span><br><span class="line">ctx.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;msg&quot;</span>:  <span class="string">&quot;id没有找到，删除失败&quot;</span>,</span><br><span class="line"><span class="string">&quot;code&quot;</span>: <span class="number">400</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 操作数据库删除（删除id所对应的那一条）</span></span><br><span class="line"><span class="comment">// db.Where(&quot;id = ? &quot;, id).Delete(&amp;data) &lt;- 其实不需要这样写，因为查到的data里面就是要删除的数据</span></span><br><span class="line">db.Delete(&amp;data)</span><br><span class="line"></span><br><span class="line">ctx.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;msg&quot;</span>:  <span class="string">&quot;删除成功&quot;</span>,</span><br><span class="line"><span class="string">&quot;code&quot;</span>: <span class="number">200</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改</span></span><br><span class="line">r.PUT(<span class="string">&quot;/user/update/:id&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 1. 找到对应的id所对应的条目</span></span><br><span class="line"><span class="comment">// 2. 判断id是否存在</span></span><br><span class="line"><span class="comment">// 3. 修改对应条目 or 返回id没有找到</span></span><br><span class="line"><span class="keyword">var</span> data List</span><br><span class="line">id := ctx.Param(<span class="string">&quot;id&quot;</span>)</span><br><span class="line"><span class="comment">// db.Where(&quot;id = ?&quot;, id).Find(&amp;data) 可以这样写，也可以写成下面那样</span></span><br><span class="line"><span class="comment">// 还可以再Where后面加上Count函数，可以查出来这个条件对应的条数</span></span><br><span class="line">db.Select(<span class="string">&quot;id&quot;</span>).Where(<span class="string">&quot;id = ? &quot;</span>, id).Find(&amp;data)</span><br><span class="line"><span class="keyword">if</span> data.ID == <span class="number">0</span> &#123;</span><br><span class="line">ctx.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;msg&quot;</span>:  <span class="string">&quot;用户id没有找到&quot;</span>,</span><br><span class="line"><span class="string">&quot;code&quot;</span>: <span class="number">400</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 绑定一下</span></span><br><span class="line">err := ctx.ShouldBindJSON(&amp;data)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">ctx.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;msg&quot;</span>:  <span class="string">&quot;修改失败&quot;</span>,</span><br><span class="line"><span class="string">&quot;code&quot;</span>: <span class="number">400</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// db修改数据库内容</span></span><br><span class="line">db.Where(<span class="string">&quot;id = ?&quot;</span>, id).Updates(&amp;data)</span><br><span class="line">ctx.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;msg&quot;</span>:  <span class="string">&quot;修改成功&quot;</span>,</span><br><span class="line"><span class="string">&quot;code&quot;</span>: <span class="number">200</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查</span></span><br><span class="line"><span class="comment">// 第一种：条件查询，</span></span><br><span class="line">r.GET(<span class="string">&quot;/user/list/:name&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 获取路径参数</span></span><br><span class="line">name := ctx.Param(<span class="string">&quot;name&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> dataList []List</span><br><span class="line"><span class="comment">// 查询数据库</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ? &quot;</span>, name).Find(&amp;dataList)</span><br><span class="line"><span class="comment">// 判断是否查询到数据</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(dataList) == <span class="number">0</span> &#123;</span><br><span class="line">ctx.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;msg&quot;</span>:  <span class="string">&quot;没有查询到数据&quot;</span>,</span><br><span class="line"><span class="string">&quot;code&quot;</span>: <span class="string">&quot;400&quot;</span>,</span><br><span class="line"><span class="string">&quot;data&quot;</span>: gin.H&#123;&#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ctx.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;msg&quot;</span>:  <span class="string">&quot;查询成功&quot;</span>,</span><br><span class="line"><span class="string">&quot;code&quot;</span>: <span class="string">&quot;200&quot;</span>,</span><br><span class="line"><span class="string">&quot;data&quot;</span>: dataList,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种：全部查询 / 分页查询</span></span><br><span class="line">r.GET(<span class="string">&quot;/user/list&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> dataList []List</span><br><span class="line"><span class="comment">// 查询全部数据 or 查询分页数据</span></span><br><span class="line">pageSize, _ := strconv.Atoi(ctx.Query(<span class="string">&quot;pageSize&quot;</span>))</span><br><span class="line">pageNum, _ := strconv.Atoi(ctx.Query(<span class="string">&quot;pageNum&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否需要分页</span></span><br><span class="line"><span class="keyword">if</span> pageSize == <span class="number">0</span> &#123;</span><br><span class="line">pageSize = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> pageNum == <span class="number">0</span> &#123;</span><br><span class="line">pageNum = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">offsetVal := (pageNum - <span class="number">1</span>) * pageSize <span class="comment">// 固定写法 记住就行</span></span><br><span class="line"><span class="keyword">if</span> pageNum == <span class="number">-1</span> &amp;&amp; pageSize == <span class="number">-1</span> &#123;</span><br><span class="line">offsetVal = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个总数</span></span><br><span class="line"><span class="keyword">var</span> total <span class="type">int64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询数据库</span></span><br><span class="line">db.Model(dataList).Count(&amp;total).Limit(pageSize).Offset(offsetVal).Find(&amp;dataList)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(dataList) == <span class="number">0</span> &#123;</span><br><span class="line">ctx.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;msg&quot;</span>:  <span class="string">&quot;没有查询到数据&quot;</span>,</span><br><span class="line"><span class="string">&quot;code&quot;</span>: <span class="number">400</span>,</span><br><span class="line"><span class="string">&quot;data&quot;</span>: gin.H&#123;&#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ctx.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;msg&quot;</span>:  <span class="string">&quot;查询成功&quot;</span>,</span><br><span class="line"><span class="string">&quot;code&quot;</span>: <span class="number">200</span>,</span><br><span class="line"><span class="string">&quot;data&quot;</span>: gin.H&#123;</span><br><span class="line"><span class="string">&quot;list&quot;</span>:     dataList,</span><br><span class="line"><span class="string">&quot;total&quot;</span>:    total,</span><br><span class="line"><span class="string">&quot;pageNum&quot;</span>:  pageNum,</span><br><span class="line"><span class="string">&quot;pageSize&quot;</span>: pageSize,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 端口号</span></span><br><span class="line">PORT := <span class="string">&quot;3001&quot;</span></span><br><span class="line">r.Run(<span class="string">&quot;:&quot;</span> + PORT)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>THE END</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;话不多说，先附上Github链接，欢迎star：&lt;a href=&quot;https://github.com/Conqueror712/Go_CRUD_demo&quot;&gt;Conqueror712&amp;#x2F;Go_CRUD_demo: Gin + Gorm + MySQL + Navic</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CloudServer丨学习记录</title>
    <link href="https://conqueror712.github.io/post/ServerLearningNote.html"/>
    <id>https://conqueror712.github.io/post/ServerLearningNote.html</id>
    <published>2023-01-01T13:32:36.000Z</published>
    <updated>2023-02-15T14:25:58.189Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言部分："><a href="#前言部分：" class="headerlink" title="前言部分："></a>前言部分：</h2><h3 id="需要知道的："><a href="#需要知道的：" class="headerlink" title="需要知道的："></a>需要知道的：</h3><ul><li>知道服务器的IP地址（最好是静态IP地址，不会变）</li><li>账号密码的创建，如果是root用户就直接adduser xxx，创建完在&#x2F;home&#x2F;下查看</li></ul><h3 id="使用SSH终端连接服务器："><a href="#使用SSH终端连接服务器：" class="headerlink" title="使用SSH终端连接服务器："></a>使用SSH终端连接服务器：</h3><ul><li>对于Windows，可以用Xmanager，也可以用Termius（界面不错）</li></ul><h3 id="创建自己的虚拟环境："><a href="#创建自己的虚拟环境：" class="headerlink" title="创建自己的虚拟环境："></a>创建自己的虚拟环境：</h3><ul><li>Anaconda &amp; pip</li></ul><h3 id="文件上传下载："><a href="#文件上传下载：" class="headerlink" title="文件上传下载："></a>文件上传下载：</h3><ul><li>可以用xftp或FileZilla</li></ul><h3 id="在服务器上部署代码："><a href="#在服务器上部署代码：" class="headerlink" title="在服务器上部署代码："></a>在服务器上部署代码：</h3><ul><li>可以本地写好后传上去（Pycharm远程调试）</li><li>也可以直接在服务器上写（Vim）</li><li>还可以使用Windows自带的远程桌面，但是需要在服务器端装上Xrdp</li></ul><h3 id="服务器间传输文件scp："><a href="#服务器间传输文件scp：" class="headerlink" title="服务器间传输文件scp："></a>服务器间传输文件scp：</h3><p>​<code>scp -r &lt;filename&gt; user@&lt;target_ip&gt;:Desktop/&lt;filename1&gt;/...</code></p><h3 id="在外地如何连接："><a href="#在外地如何连接：" class="headerlink" title="在外地如何连接："></a>在外地如何连接：</h3><ul><li>例如之前是用的校园网内网，那非校园网环境，没有vpn的情况下就没办法直接访问内网，那么就需要建立用户与内网之间的联系</li><li>或者直接使用远程桌面的软件，ToDesk，TeamViewer，向日葵等等。</li></ul><hr><h2 id="深度学习环境搭建流程："><a href="#深度学习环境搭建流程：" class="headerlink" title="深度学习环境搭建流程："></a>深度学习环境搭建流程：</h2><ol><li>操作系统</li><li>显卡驱动<code>https://www.nvidia.cn/Download/index.aspx?lang=cn</code></li><li>Cuda<code>https://developer.nvidia.com/cuda-toolkit-archive</code></li><li>Cudnn<code>https://developer.nvidia.com/rdp/cudnn-archive</code></li><li>Pytorch &#x2F; Tensorflow<code>https://pytorch.org/get-started/previous-versions/</code></li></ol><h3 id="显卡驱动安装流程："><a href="#显卡驱动安装流程：" class="headerlink" title="显卡驱动安装流程："></a>显卡驱动安装流程：</h3><p>显卡驱动安装完之后应该是一个.run文件，之后应进行如下操作：</p><ol><li>关闭图形界面（否则跑不起来）<code>sudo service lightdm stop</code></li><li>让.run文件可执行<code>sudo chmod a+x NVIDIA-Linux-x86_64-375.39.rum</code>（具体文件名称需要看自己下载的是什么版本）</li><li><code>sudo sh NVIDIA-Linux-x86_64-375.39.run -no-x-check -no-nouveau-check -no-opengl-files</code>（运行.run文件，并不需要对x文件进行检查）</li><li>查看是否安装成功<code>nvidia-smi</code></li></ol><h3 id="CUDA安装流程："><a href="#CUDA安装流程：" class="headerlink" title="CUDA安装流程："></a>CUDA安装流程：</h3><p>对于版本：若有特定需求则按特定需求，否则尽量选择较高版本（但最好不要最新）的整数版本</p><p>下载可以直接<code>wget &lt;网址&gt;</code></p><p>下载下来之后也是一个.run文件，直接<code>sudo sh &lt;文件名&gt;</code>就可以进行安装了</p><p>在安装过程中，当询问是否安装显卡驱动时，选择No即可（因为之前已经安装过了）</p><p>安装成功之后使用<code>nvcc -V</code>进行安装检查</p><p>如果检查报错，则需要配置环境变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cd /home/zhangsan/</span><br><span class="line"></span><br><span class="line">vim .bashrc</span><br><span class="line"></span><br><span class="line">export PATH=/usr/local/cuda-xxx/bin:$PATH</span><br><span class="line"></span><br><span class="line">export LD_LIBRARY_PATH=/usr/local/cuda-xxx/lib64</span><br><span class="line"></span><br><span class="line">source .bashrc</span><br></pre></td></tr></table></figure><h3 id="CUDNN安装流程："><a href="#CUDNN安装流程：" class="headerlink" title="CUDNN安装流程："></a>CUDNN安装流程：</h3><p>进入网址，选择对应自己CUDA版本的CUDNN，再选择Library for Linux(x86_64)</p><p>解压之后是一个cuda文件夹</p><p><code>sudo cp cuda/include/cudnn.h /usr/local/cuda/include/</code></p><p><code>sudo cp cuda/lib64/libcudnn* /usr/local/cuda/lib64/</code></p><h3 id="Pytorch的安装流程："><a href="#Pytorch的安装流程：" class="headerlink" title="Pytorch的安装流程："></a>Pytorch的安装流程：</h3><ol><li>需要有Python</li><li>安装anacocnda（也需要设置环境变量）</li><li>注意安装前需要先创建并激活conda环境</li></ol><hr><h2 id="AutoDL使用笔记："><a href="#AutoDL使用笔记：" class="headerlink" title="AutoDL使用笔记："></a>AutoDL使用笔记：</h2><p>autodl-tmp是数据库</p><p>tf-logs是默认使用tensorflow的tensorboard的使用文件夹</p><p><code>df -h</code>查看文件和目录占用容量信息</p><p><code>nvidia-smi</code>查看GPU监控信息</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言部分：&quot;&gt;&lt;a href=&quot;#前言部分：&quot; class=&quot;headerlink&quot; title=&quot;前言部分：&quot;&gt;&lt;/a&gt;前言部分：&lt;/h2&gt;&lt;h3 id=&quot;需要知道的：&quot;&gt;&lt;a href=&quot;#需要知道的：&quot; class=&quot;headerlink&quot; title=&quot;需</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>DeepLearning - Part1 - 深度学习基础丨学习记录</title>
    <link href="https://conqueror712.github.io/post/DeepLearningNote.html"/>
    <id>https://conqueror712.github.io/post/DeepLearningNote.html</id>
    <published>2023-01-01T13:32:11.000Z</published>
    <updated>2023-02-15T14:26:13.847Z</updated>
    
    <content type="html"><![CDATA[<h1 id="00-Abstract"><a href="#00-Abstract" class="headerlink" title="00-Abstract"></a>00-Abstract</h1><p>本文介绍了笔者在学习《动手学深度学习》课程中的笔记。</p><p>这一Part的内容是深度学习基础。</p><p>后续将会补充更多的公式推导和原理部分。</p><p>敬请期待！</p><hr><h1 id="01-Guide-Topic"><a href="#01-Guide-Topic" class="headerlink" title="01-Guide Topic"></a>01-Guide Topic</h1><p>The most import thing of deep learning is <strong>Neural Network</strong>.</p><p>The Neural Network is a <strong>language</strong>, it is very <strong>flexible</strong>.</p><p>AutoGluon⭐</p><p>Book Version 1: <a href="https://zh/d2.ai/">https://zh/d2.ai/</a></p><p>Book Version 2: <a href="https://zh-v2.d2l.ai/">https://zh-v2.d2l.ai/</a></p><p>Source Code: <a href="https://github.com./d2l-ai/d2l-zh">https://github.com./d2l-ai/d2l-zh</a></p><p>Course Web: <a href="https://courses.d2l.ai/zh-v2">https://courses.d2l.ai/zh-v2</a></p><p>Discuss: <a href="https://discuss.pytorch.org/">https://discuss.pytorch.org/</a> <a href="https://discuss.d2l.ai/c/16">https://discuss.d2l.ai/c/16</a></p><h2 id="Introduce-DeepLearning"><a href="#Introduce-DeepLearning" class="headerlink" title="Introduce DeepLearning"></a>Introduce DeepLearning</h2><p>The target of this course: </p><ul><li>introduce the classic and new model like LeNet, ResNet, LSTM, BERT,…</li><li>Basic Machine Learning</li><li>Practice</li></ul><h2 id="The-Application-of-DL"><a href="#The-Application-of-DL" class="headerlink" title="The  Application of DL"></a>The  Application of DL</h2><p>图片分类：2012年深度学习开始之后错误率迅速降低，目前大约5%</p><p><a href="https://qz.com/1034972/the-data-that-changed-thedirection-of-ai-research-and-possibly-the-world/">https://qz.com/1034972/the-data-that-changed-thedirection-of-ai-research-and-possibly-the-world/</a></p><p>物体检测和分割</p><p>样式迁移：可以初步理解为，加滤镜</p><p>人脸合成</p><p>文字生成图片<a href="https://openai.com/blog/dall-e/">DALL·E: Creating Images from Text (openai.com)</a></p><p>文字生成</p><p>无人驾驶</p><p><em>广告推荐的预测与训练步骤：</em>特征提取→模型→点击率预测→训练数据→特征和用户点击→模型</p><p>模型的可解释性：XAI，DL上做的还不太好，ML上还行</p><h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><p>流程如下：</p><ol><li><p><code>ssh ubuntu@&lt;IP&gt;</code>连接云服务器，如果直接能在服务器的terminal上操作也可以</p></li><li><p><code>sudo apt update</code>更新一下机器，因为一开始就是一个裸的ubuntu啥也没有</p></li><li><p><code>sudo apt install build-essential</code>装一些开发环境，例如gcc</p></li><li><p><code>sudo apt install python3.8</code>安装python</p></li><li><p>miniconda安装，去官网复制对应版本和需求的链接，下载：<code>wget &lt;link&gt;</code> → 安装：<code>bash Miniconda3-latest-Linux-x64_64.sh（根据自己的文件进行替换）</code>默认装在根目录下面就可以</p></li><li><p>进入conda环境：<code>bash</code>（直接在terminal里打bash）之后可以直接在base环境里来用，也可以新创建一个环境。 </p></li><li><p>内部环境的安装：<code>pip install jupyter d2l torch torchvision</code>（本地记得换源）</p></li><li><p>课程记事本的下载：<code>http://zh-v2.d2l.ai</code>→<code>在Jupyter记事本文件这里复制链接</code>→<code>wget &lt;link&gt;</code></p></li><li><p>如果服务器里没有zip，则需要安装一个zip<code>sudo spt install zip</code>，之后<code>ls</code>可以显示一下名称，然后再进行解压即可<code>unzip d2l-zh.zip</code></p><p>之后再<code>ls</code>可以看到解压出来了三个文件夹<code>mxnet pytorch tensorflow</code></p><p>进入pytorch的文件夹查看有什么东西<code>cd pytorch/``ls</code></p></li><li><p>PPT的下载可以直接<code>git clone &lt;link&gt;</code>（链接在github里，是仓库）</p></li><li><p>运行jupyter<code>jupyter notebook</code>（会出现一个链接，需要将远端的<code>link</code>map到本地<code>ssh -L8888:localhost:8888 ubuntu@&lt;IP&gt;</code>）（这里的8888是远程的端口）</p><p>值得一提的是，打开jupyter之后笔记有幻灯片格式，还有非幻灯片格式，若想打开幻灯片格式则需要安装一个插件<code>pip install rise</code></p></li></ol><hr><h1 id="02-Pre-Knowledge"><a href="#02-Pre-Knowledge" class="headerlink" title="02-Pre Knowledge"></a>02-Pre Knowledge</h1><h2 id="Data-Operation"><a href="#Data-Operation" class="headerlink" title="Data Operation"></a>Data Operation</h2><p>机器学习中用到的最多的数据结构：N维数组</p><p>访问元素的几种常用方法：</p><ul><li>一个元素<code>[1, 2]</code></li><li>一行<code>[1, :]</code></li><li>子区域<code>[1:3, 1:]</code></li><li>子区域<code>[::3, ::2]</code></li></ul><p>除此之外，还可以通过<code>-1</code>来访问最后一个元素</p><h3 id="Tensor张量"><a href="#Tensor张量" class="headerlink" title="Tensor张量"></a>Tensor张量</h3><p>张量表示一个数值组成的数组，这个数组可能有多个维度。</p><p><code>x = torch.arange(12)</code></p><p>我们可以通过张量的<code>shape</code>属性来访问张量的形状和<strong>张量</strong>中<strong>元素的总数</strong><br><code>x.shape</code></p><p><code>x.numel</code></p><p>要改变一个张量的形状而不改变元素的数量和数值，我们可以调用<code>reshape</code>函数</p><p><code>X = x.reshape(3, 4)</code></p><p>使用全0，全1或其他常量或者从特定分布中随机采样的数字</p><p><code>torch.zeros((2, 3, 4))</code></p><p><code>torch.ones((2, 3, 4))</code></p><p>也可以直接在定义的时候就赋好初始值，这里不过多赘述；</p><p>常见的四则运算等都可以被升级为按元素运算；</p><p>把多个张量连接在一起</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X = torch.arange(<span class="number">12</span>, dtype=torch.float32).reshape((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">Y = torch.tensor([[<span class="number">2.0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line">torch.cat((X, Y), dim=<span class="number">0</span>), torch.cat((X, Y), dim=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>通过逻辑运算符构建二元张量；</p><p>对张量中所有元素求和会获得一个只有一个元素的张量<code>X.sum()</code>；</p><p>即使形状不同，我们仍然可以通过调用<strong>广播机制</strong>来执行按元素操作； </p><p>还有一些赋值的方法：<code>X[0:2, :]  = 12</code>；</p><p>运行一些操作可能会导致为新结果分配内存：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">before = <span class="built_in">id</span>(Y) <span class="comment"># 在Python中，id()类似于指针的意思</span></span><br><span class="line">Y = Y + X</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(Y) == before)</span><br><span class="line"><span class="comment"># output = False</span></span><br></pre></td></tr></table></figure><p>执行原地内存操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new_Y = torch.zeros_like(Y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;id(new_Y):&quot;</span>, <span class="built_in">id</span>(new_Y))</span><br><span class="line">new_Y[:] = X + Y</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;id(new_Y):&quot;</span>, <span class="built_in">id</span>(new_Y))</span><br></pre></td></tr></table></figure><p>转换为NumPy张量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A = X.numpy()</span><br><span class="line">B = torch.tensor(A)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(A), <span class="built_in">type</span>(B)) <span class="comment"># 查看数据类型</span></span><br><span class="line"><span class="comment"># 将大小为1的张量转换为Python标量：</span></span><br><span class="line">a = torch.tensor([<span class="number">3.5</span>])</span><br><span class="line">a, a.item(), <span class="built_in">float</span>(a), <span class="built_in">int</span>(a)</span><br><span class="line"><span class="comment"># output = (tensor([3.5000]), 3.5, 3.5, 3)</span></span><br></pre></td></tr></table></figure><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>作用：读取csv文件→做一定的特征预处理→变成pytorch能用的一个tenser(张量)</p><p>创建一个人工数据集，并存储在csv（逗号分隔值）文件；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.makedirs(os.path.join(<span class="string">&#x27;..&#x27;</span>, <span class="string">&#x27;data&#x27;</span>), exist_ok=<span class="literal">True</span>)</span><br><span class="line">data_file = os.path.join(<span class="string">&#x27;..&#x27;</span>, <span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;house_tiny.csv&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(data_file, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&#x27;NumRooms,Alley,Price\n&#x27;</span>)  <span class="comment"># 列名</span></span><br><span class="line">    f.write(<span class="string">&#x27;NA,Pave,127500\n&#x27;</span>)  <span class="comment"># 每行表示一个数据样本</span></span><br><span class="line">    f.write(<span class="string">&#x27;2,NA,106000\n&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;4,NA,178100\n&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;NA,NA,140000\n&#x27;</span>)</span><br></pre></td></tr></table></figure><p>从创建的csv文件中加载原始数据集；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = pd.read_csv(data_file)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"><span class="comment"># 事实上这里也可直接写成data，不使用print，会保留HTML格式</span></span><br></pre></td></tr></table></figure><p>处理缺失的数据，典型的方法是<strong>插值</strong>和<strong>删除</strong>，代码就不放了，可以直接看<a href="https://zh-v2.d2l.ai/chapter_preliminaries/pandas.html">2.2. 数据预处理 — 动手学深度学习 2.0.0-beta1 documentation (d2l.ai)</a></p><hr><h2 id="Linear-Algebra"><a href="#Linear-Algebra" class="headerlink" title="Linear Algebra"></a>Linear Algebra</h2><h3 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h3><p>c &#x3D; A * b  hence  ||c|| &lt;&#x3D; ||A|| * ||b||</p><p>取决于如何衡量b和c的长度</p><p>常见范数：</p><ul><li>矩阵范数：最小的满足上面公式的值</li><li>Frobenius范数（具体公式不给出了）</li></ul><p>正定矩阵：如果一个矩阵是正定的，那么它乘上任何一个行向量或者列向量之后值都是大于等于0的；</p><h3 id="哈达玛积"><a href="#哈达玛积" class="headerlink" title="哈达玛积"></a>哈达玛积</h3><p>两个矩阵按元素乘法</p><h3 id="亚导数"><a href="#亚导数" class="headerlink" title="亚导数"></a>亚导数</h3><p>将导数拓展到不可微的函数</p><h3 id="向量链式法则"><a href="#向量链式法则" class="headerlink" title="向量链式法则"></a>向量链式法则</h3><p>略</p><h3 id="自动求导"><a href="#自动求导" class="headerlink" title="自动求导"></a>自动求导</h3><p>自动求导计算一个函数在指定值上的导数</p><p>有别于符号求导和数值求导</p><h3 id="计算图"><a href="#计算图" class="headerlink" title="计算图"></a>计算图</h3><p>将代码分解成操作子</p><p>将计算表示成一个无环图</p><p>（显式构造、隐式构造）</p><hr><h2 id="Matrix-Calculation"><a href="#Matrix-Calculation" class="headerlink" title="Matrix Calculation"></a>Matrix Calculation</h2><h3 id="导数"><a href="#导数" class="headerlink" title="导数"></a>导数</h3><ul><li><p>标量导数（回忆一下即可）</p></li><li><p>亚导数（将导数拓展到不可微的函数）</p></li><li><p>向量的导数（注意方向是如何变化的）<strong>（梯度与等高线正交，指向值变化最大的方向）</strong></p><img src="https://s2.loli.net/2023/01/01/tp45niawvJU9qlo.png" alt="avatar" style="zoom:50%;" /></li><li><p>拓展到矩阵以及更高维度的张量</p><p><img src="https://s2.loli.net/2023/01/01/ZqCuXydNbRKawoQ.png" alt="avatar"></p></li></ul><p>机器学习不关心P问题，只关心NP问题，所以一般不会处理凸函数问题，因为凸函数问题显然可以很容易得到最优解。（下面补充一下P与NP的内容好了）</p><h3 id="P与NP问题"><a href="#P与NP问题" class="headerlink" title="P与NP问题"></a>P与NP问题</h3><blockquote><p>**<em>P类问题*<strong>：所有可以在<a href="https://baike.baidu.com/item/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%97%B6%E9%97%B4?fromModule=lemma_inlink">多项式时间</a>内求解的判定问题构成P类问题。</strong></em>判定问题***<em>：</em>判断是否有一种能够解决某一类问题的能行算法的研究课题。</p><p>**<em>NP类问题*<strong>：所有的非确定性多项式时间可解的判定问题构成NP类问题。</strong></em>非确定性算法***：非确定性算法将问题分解成猜测和验证两个阶段。算法的猜测阶段是非确定性的，算法的验证阶段是确定性的，它验证猜测阶段给出解的正确性。设算法A是解一个判定问题Q的非确定性算法，如果A的验证阶段能在多项式时间内完成，则称A是一个多项式时间非确定性算法。有些计算问题是确定性的，例如加减乘除，只要按照公式推导，按部就班一步步来，就可以得到结果。但是，有些问题是无法按部就班直接地计算出来。比如，找大<a href="https://baike.baidu.com/item/%E8%B4%A8%E6%95%B0?fromModule=lemma_inlink">质数</a>的问题。有没有一个公式能推出下一个<a href="https://baike.baidu.com/item/%E8%B4%A8%E6%95%B0?fromModule=lemma_inlink">质数</a>是多少呢？这种问题的答案，是无法直接计算得到的，只能通过间接的“猜算”来得到结果。这也就是非确定性问题。而这些问题的通常有个算法，它不能直接告诉你答案是什么，但可以告诉你，某个可能的结果是正确的答案还是错误的。这个可以告诉你“猜算”的答案正确与否的算法，假如可以在多项式（polynomial）时间内算出来，就叫做多项式非确定性问题。</p><p>***NPC问题***<strong>：</strong>NP中的某些问题的复杂性与整个类的复杂性相关联.这些问题中任何一个如果存在多项式时间的算法,那么所有NP问题都是多项式时间可解的.这些问题被称为NP-完全问题(NPC问题)。</p></blockquote><hr><h2 id="自动求导-1"><a href="#自动求导-1" class="headerlink" title="自动求导"></a>自动求导</h2><h3 id="向量链式法则-1"><a href="#向量链式法则-1" class="headerlink" title="向量链式法则"></a>向量链式法则</h3><p><img src="https://s2.loli.net/2023/01/01/g5DQzkZC49jmqlF.png" alt="avatar"></p><p>接下来我们看一个例子：</p><p><img src="https://s2.loli.net/2023/01/01/4aYqp7nE9HCgDW6.png" alt="avatar"></p><h3 id="不同的求导："><a href="#不同的求导：" class="headerlink" title="不同的求导："></a>不同的求导：</h3><ul><li>自动求导：计算一个函数在指定值上的导数</li><li>符号求导：显式的一个求导</li><li>数值求导：用数值来拟合，不需要知道具体的表达式</li></ul><h3 id="计算图："><a href="#计算图：" class="headerlink" title="计算图："></a>计算图：</h3><p>计算图是Pytorch内部自动计算导数的一个方式；</p><p>其实等同于用链式法则求导的一个过程，有点像同路相乘异路相加；</p><ul><li>将代码分解成操作子</li><li>将计算表示成一个有向无环图DAG</li></ul><p>构造计算图有显式构造和隐式构造两种方式，数学上一般是显示，Pytorch是隐式；</p><h3 id="自动求导的模式："><a href="#自动求导的模式：" class="headerlink" title="自动求导的模式："></a>自动求导的模式：</h3><p><img src="https://s2.loli.net/2023/01/01/QfPDEl9yCiHLMVt.png" alt="avatar"></p><p><img src="https://s2.loli.net/2023/01/01/FS3pXUNqrdWjEBO.png" alt="avatar"></p><p><strong>其实，反向传播就是人们用手来算复合函数求导的过程，是一样的。</strong></p><p>demo代码如下<a href="https://zh-v2.d2l.ai/chapter_preliminaries/autograd.html#id2">2.5. 自动微分 — 动手学深度学习 2.0.0 documentation (d2l.ai)</a></p><hr><h1 id="03-Linear-NeuralNetwork"><a href="#03-Linear-NeuralNetwork" class="headerlink" title="03-Linear NeuralNetwork"></a>03-Linear NeuralNetwork</h1><h2 id="Linear-Regression"><a href="#Linear-Regression" class="headerlink" title="Linear Regression"></a>Linear Regression</h2><h3 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h3><p>经典的买房例子，成交价是关键因素的加权和：</p><p><code>y = w1x1 + w2x2 + w3x3 + b</code></p><p>权重和偏差的实际值在后面决定；</p><p><img src="https://s2.loli.net/2023/01/02/5hOwMlWQ28zT7fX.png" alt="avatar"></p><p>正因如此，线性模型可以看作是单层的神经网络</p><p>之所以叫单层的神经网络，是因为其带权的层就是1；</p><h3 id="衡量预估质量（平方损失）"><a href="#衡量预估质量（平方损失）" class="headerlink" title="衡量预估质量（平方损失）"></a>衡量预估质量（平方损失）</h3><p><img src="https://s2.loli.net/2023/01/02/y3MvRgoASFd4PeT.png" alt="avatar"></p><h3 id="训练数据"><a href="#训练数据" class="headerlink" title="训练数据"></a>训练数据</h3><p>收集一些数据点来决定参数值（权重和偏差），被称之为<strong>训练数据</strong>，越多越好。</p><h3 id="参数学习"><a href="#参数学习" class="headerlink" title="参数学习"></a>参数学习</h3><p><img src="https://s2.loli.net/2023/01/02/2N8chwA7xUyifPt.png" alt="avatar"></p><h3 id="显式解"><a href="#显式解" class="headerlink" title="显式解"></a>显式解</h3><p><img src="https://s2.loli.net/2023/01/02/1fpJQ6UCFSZu2VT.png" alt="avatar"></p><p>注意 这里导数的最后应该有一个负号；</p><p>总的来说：</p><ul><li>线性回归是对n维输入的加权和，外加偏差</li><li>使用平方损失来衡量预测值和真实值的差异</li><li>线性回归有显式解</li><li>线性回归可以看作是单层的神经网络</li></ul><h2 id="基础优化方法"><a href="#基础优化方法" class="headerlink" title="基础优化方法"></a>基础优化方法</h2><h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><p><img src="https://s2.loli.net/2023/01/02/2rP5oYbRD43aZgd.png" alt="avatar"></p><p>（后面那个导数就是梯度，η就是学习率）</p><p>梯度的负方向就是函数值下降最快的方向；</p><p><strong>超参数</strong>不需要数据来驱动，而是在训练前或者训练中认为的进行调整的参数；</p><p>学习率不能太小（计算梯度太贵了），也不能太大； </p><h3 id="小批量随机梯度下降"><a href="#小批量随机梯度下降" class="headerlink" title="小批量随机梯度下降"></a>小批量随机梯度下降</h3><p><img src="https://s2.loli.net/2023/01/02/ZeTlzFEkm7pKnrN.png" alt="avatar"></p><p><code>batch_size</code></p><p>总结</p><ul><li>梯度下降通过不断延着反梯度方向更新参数求解</li><li>小批量随机梯度下降是深度学习默认的求解算法</li><li>两个重要的超参数是批量大小和学习率</li></ul><p>代码参考：</p><p><a href="https://zh-v2.d2l.ai/chapter_linear-networks/linear-regression-scratch.html">3.2. 线性回归的从零开始实现 — 动手学深度学习 2.0.0 documentation (d2l.ai)</a></p><hr><h2 id="Softmax-Regression"><a href="#Softmax-Regression" class="headerlink" title="Softmax Regression"></a>Softmax Regression</h2><h3 id="Softmax回归"><a href="#Softmax回归" class="headerlink" title="Softmax回归"></a>Softmax回归</h3><p>虽然叫做回归，但其实是一个分类问题；</p><ul><li>回归估计一个连续值</li><li>分类预测一个离散类别</li></ul><p><img src="https://s2.loli.net/2023/01/03/ZQR7a84eKEUn9TY.png" alt="avatar"></p><p><img src="https://s2.loli.net/2023/01/03/GANJgOwtWCTkeUq.png" alt="avatar"></p><p>衡量两个概率的区别——交叉熵</p><p><img src="https://s2.loli.net/2023/01/03/BNYKFAjx7Vu4Rsb.png" alt="avatar"></p><p><strong>划重点： 对于分类问题， 我们不关心非正确类的预测值，我们只关心对于正确类的置信度是否够大。</strong></p><p>顺带一提 log的默认底数好像是2</p><p>总结：</p><ul><li>Softmax回归是一个多类分类模型</li><li>使用Softmax操作子得到每个类的预测置信度</li><li>使用交叉熵来衡量预测和标号的区别</li></ul><hr><h3 id="损失函数Loss-function"><a href="#损失函数Loss-function" class="headerlink" title="损失函数Loss-function"></a>损失函数Loss-function</h3><p>用来衡量预测值和真实值之间的区别；</p><p><img src="https://s2.loli.net/2023/01/03/ShcnVsvTCi1QwWY.png" alt="avatar"></p><p>下面介绍几种常见常用的损失函数：</p><h3 id="均方损失L2-Loss"><a href="#均方损失L2-Loss" class="headerlink" title="均方损失L2 Loss"></a>均方损失L2 Loss</h3><p><img src="https://s2.loli.net/2023/01/03/2cBkAS7meW6CvsO.png" alt="avatar"></p><ul><li>蓝色的线代表y &#x3D; 0的时候y’的函数，显然是一个二次函数</li><li>绿色线是一个标准正态分布</li></ul><hr><h1 id="04-Multilayer-Perceptron"><a href="#04-Multilayer-Perceptron" class="headerlink" title="04-Multilayer Perceptron"></a>04-Multilayer Perceptron</h1><h2 id="感知机"><a href="#感知机" class="headerlink" title="感知机"></a>感知机</h2><p>感知机由两层神经元组成</p><h2 id="多层感知机"><a href="#多层感知机" class="headerlink" title="多层感知机"></a>多层感知机</h2><hr><h2 id="Model-Select"><a href="#Model-Select" class="headerlink" title="Model Select"></a>Model Select</h2><h3 id="欠拟合与过拟合"><a href="#欠拟合与过拟合" class="headerlink" title="欠拟合与过拟合"></a>欠拟合与过拟合</h3><hr><h2 id="Weight-Decay"><a href="#Weight-Decay" class="headerlink" title="Weight Decay"></a>Weight Decay</h2><h3 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h3><hr><h2 id="Numerical-Stability"><a href="#Numerical-Stability" class="headerlink" title="Numerical Stability"></a>Numerical Stability</h2><h3 id="模型初始化与激活函数"><a href="#模型初始化与激活函数" class="headerlink" title="模型初始化与激活函数"></a>模型初始化与激活函数</h3><hr><p><em>预告：下一Part是卷积神经网络</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;00-Abstract&quot;&gt;&lt;a href=&quot;#00-Abstract&quot; class=&quot;headerlink&quot; title=&quot;00-Abstract&quot;&gt;&lt;/a&gt;00-Abstract&lt;/h1&gt;&lt;p&gt;本文介绍了笔者在学习《动手学深度学习》课程中的笔记。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MySQL入门丨学习记录</title>
    <link href="https://conqueror712.github.io/post/MySQL.html"/>
    <id>https://conqueror712.github.io/post/MySQL.html</id>
    <published>2022-09-27T05:46:28.000Z</published>
    <updated>2023-02-15T14:26:33.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="零、MySQL安装与启动"><a href="#零、MySQL安装与启动" class="headerlink" title="零、MySQL安装与启动"></a><strong>零、MySQL安装与启动</strong></h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>直接官网下<code>.msi</code>后安装，一路<code>next</code>即可…</p><p>之后在安装路径处加一个<code>my.ini</code>内容和细节参考<a href="https://www.runoob.com/mysql/mysql-install.html">MySQL 安装 | 菜鸟教程 (runoob.com)</a></p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>首先cd进MySQL的bin目录</p><p><code>net start mysql</code></p><p><code>mysql -u root -p</code> 键入密码即可</p><p>当然，可以选择在<code>my.ini</code>内设置跳过密码输入…</p><p>可以使用<code>exit</code>或<code>quit</code>来退出mysql</p><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>直接启动<code>MySQL Command Line Client</code></p><hr><h1 id="一、MySQL管理"><a href="#一、MySQL管理" class="headerlink" title="一、MySQL管理"></a><strong>一、MySQL管理</strong></h1><h3 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h3><p><code>CREATE USER &#39;用户名&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;用户密码&#39;;</code></p><h3 id="查看用户"><a href="#查看用户" class="headerlink" title="查看用户"></a>查看用户</h3><p><code>select user,host from mysql.user;</code></p><h3 id="查看所有数据库"><a href="#查看所有数据库" class="headerlink" title="查看所有数据库"></a>查看所有数据库</h3><p><code>show DATABASES;</code></p><h3 id="锁定操作数据库"><a href="#锁定操作数据库" class="headerlink" title="锁定操作数据库"></a>锁定操作数据库</h3><p><code>use &lt;数据库名&gt;</code></p><p>在此之后可进行</p><ul><li><strong>显示指定数据库的所有表</strong>操作：<code>SHOW TABLES;</code></li><li><strong>显示数据表的属性</strong>：<code>SHOW COLUMNS FROM &lt;数据表名&gt;</code>;</li><li><strong>显示数据表的详细索引信息</strong>：<code>SHOW INDEX FROM &lt;数据表名&gt;;</code></li></ul><h3 id="授权用户"><a href="#授权用户" class="headerlink" title="授权用户"></a>授权用户</h3><p><em>（暂未成功，也暂未用到）</em></p><p><code>GRANT privileges ON databasename.tablename TO &#39;FALLEN&#39;@&#39;host&#39;;</code></p><ul><li><p>privileges – 用户的操作权限,如SELECT , INSERT , UPDATE  等(详细列表见该文最后面).如果要授予所 的权限则使用ALL说明: </p></li><li><p>databasename –  数据库名</p></li><li><p>tablename-表名,如果要授予该用户对所有数据库和表的相应操作权限则可用* 表示, 如*.*</p></li></ul><h3 id="显示数据表的属性"><a href="#显示数据表的属性" class="headerlink" title="显示数据表的属性"></a>显示数据表的属性</h3><p><code>SHOW COLUMNS FROM &lt;数据表名&gt;</code></p><h3 id="输出数据库管理系统的性能和统计信息"><a href="#输出数据库管理系统的性能和统计信息" class="headerlink" title="输出数据库管理系统的性能和统计信息"></a>输出数据库管理系统的性能和统计信息</h3><p><em>（暂未成功，也暂未用到）</em></p><p><code>SHOW TABLE STATUS [FROM db_name] [LIKE &#39;pattern&#39;] \G;</code></p><hr><h1 id="二、MySQL的基本操作"><a href="#二、MySQL的基本操作" class="headerlink" title="二、MySQL的基本操作"></a><strong>二、MySQL的基本操作</strong></h1><h2 id="MySQL连接"><a href="#MySQL连接" class="headerlink" title="MySQL连接"></a>MySQL连接</h2><p>实际上就是登录，可以直接命令行登录也可以用PHP登录（暂略）。</p><hr><h2 id="MySQL数据库的操作"><a href="#MySQL数据库的操作" class="headerlink" title="MySQL数据库的操作"></a>MySQL数据库的操作</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p><code>CREATE DATABASE &lt;数据库名&gt;;</code></p><p>也可以使用admin直接创建，还可以用PHP创建（暂略）。</p><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><p><code>drop database &lt;数据库名&gt;;</code></p><p>也可以使用admin直接删除，还可以用PHP删除（暂略）。</p><h3 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h3><p><code>use &lt;数据库名&gt;</code></p><p>还可以用PHP删除（暂略）。</p><hr><h2 id="MySQL数据类型"><a href="#MySQL数据类型" class="headerlink" title="MySQL数据类型"></a>MySQL数据类型</h2><ul><li>数值</li><li>日期&#x2F;时间</li><li>字符&#x2F;字符串</li></ul><p>这里就不一一列举了，可以参考：<a href="https://www.runoob.com/mysql/mysql-data-types.html">MySQL 数据类型 | 菜鸟教程 (runoob.com)</a></p><hr><h2 id="MySQL数据表的操作"><a href="#MySQL数据表的操作" class="headerlink" title="MySQL数据表的操作"></a>MySQL数据表的操作</h2><h3 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h3><p><code>CREATE TABLE table_name (colunm_name colunm_type)</code></p><p>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE fallen_tbl(</span><br><span class="line">   -&gt; fallen_id INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">   -&gt; fallen_title VARCHAR(100) NOT NULL,</span><br><span class="line">   -&gt; fallen_author VARCHAR(40) NOT NULL,</span><br><span class="line">   -&gt; submission_date DATE,</span><br><span class="line">   -&gt; PRIMARY KEY ( fallen_id )</span><br><span class="line">   -&gt; )ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><ul><li>如果你不想字段为 <strong>NULL</strong> 可以设置字段的属性为 <strong>NOT NULL</strong>， 在操作数据库时如果输入该字段的数据为<strong>NULL</strong> ，就会报错。</li><li>AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1。</li><li>PRIMARY KEY关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔。</li><li>ENGINE 设置存储引擎，CHARSET 设置编码。</li></ul><p><em>同样可以使用PHP，后文不做提示，一并略之。</em></p><h3 id="删除数据表"><a href="#删除数据表" class="headerlink" title="删除数据表"></a>删除数据表</h3><p><code>DROP TABLE table_name;</code></p><hr><h2 id="MySQL数据操作"><a href="#MySQL数据操作" class="headerlink" title="MySQL数据操作"></a>MySQL数据操作</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO &lt;数据表名&gt; (field1, field2, ..., fieldN)</span><br><span class="line">VALUES</span><br><span class="line">(value1, value2, ..., valueN);</span><br></pre></td></tr></table></figure><p>特别地，如果数据是字符型，必须使用单引号或者双引号，如”value”；</p><p>值得一提的是，我发现这个命令啊，不区分大小写。</p><p><img src="https://s1.328888.xyz/2022/09/28/sp0UX.png" alt="avatar"></p><h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><p>最基本的：<code>SELECT * FROM &lt;数据表名&gt;</code></p><h3 id="WHERE子句"><a href="#WHERE子句" class="headerlink" title="WHERE子句"></a>WHERE子句</h3><p><code>select * from fallen_tbl where fallen_title=&#39;学习MySQL使我快乐&#39;;</code></p><h3 id="UPDATE更新"><a href="#UPDATE更新" class="headerlink" title="UPDATE更新"></a>UPDATE更新</h3><p>用于修改MySQL中的数据</p><p><code>UPDATE fallen_tbl SET fallen_title=&#39;今天中午吃豌豆小面但是有怪东西&#39; WHERE fallen_id=2;</code></p><h3 id="DELETE删除"><a href="#DELETE删除" class="headerlink" title="DELETE删除"></a>DELETE删除</h3><p><code>DELETE FROM fallen_tbl WHERE fallen_id=3;</code></p><h3 id="LIKE子句"><a href="#LIKE子句" class="headerlink" title="LIKE子句"></a>LIKE子句</h3><p><code>SELECT * from fallen_tbl WHERE fallen_title LIKE &#39;%快乐&#39;;</code></p><h3 id="UNION操作符"><a href="#UNION操作符" class="headerlink" title="UNION操作符"></a>UNION操作符</h3><p>UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。多个 SELECT 语句会删除重复的数据，即<strong>去重</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT fallen_author FROM fallen_tbl</span><br><span class="line">    -&gt; UNION</span><br><span class="line">    -&gt; SELECT rain_author FROM rain_tbl</span><br><span class="line">    -&gt; ORDER BY fallen_author;</span><br></pre></td></tr></table></figure><p>特别地，如果在UNION后面加一个ALL，则没有去重功能，将会合并所有值。</p><p>更加特别的，带有WHERE的UNION ALL如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT country, name FROM Websites</span><br><span class="line">WHERE country=&#x27;CN&#x27;</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT country, app_name FROM apps</span><br><span class="line">WHERE country=&#x27;CN&#x27;</span><br><span class="line">ORDER BY country;</span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p><code>select * from fallen_tbl order by submission_date ASC;</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;零、MySQL安装与启动&quot;&gt;&lt;a href=&quot;#零、MySQL安装与启动&quot; class=&quot;headerlink&quot; title=&quot;零、MySQL安装与启动&quot;&gt;&lt;/a&gt;&lt;strong&gt;零、MySQL安装与启动&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;安装&quot;&gt;&lt;a h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Git使用与踩坑丨学习记录</title>
    <link href="https://conqueror712.github.io/post/Git.html"/>
    <id>https://conqueror712.github.io/post/Git.html</id>
    <published>2022-09-26T08:43:04.000Z</published>
    <updated>2023-02-23T13:44:09.433Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">前言与说明：</span><br><span class="line"></span><br><span class="line">鉴于本人比较愚蠢，每次使用Git都会遇到不少的问题，</span><br><span class="line">又因为本人比较懒，不愿意每次都上网查资料来debug，</span><br><span class="line">故开此记录文档来便于查阅。</span><br><span class="line"></span><br><span class="line">前排声明：之所以文字用代码块圈起来了是因为这样不卡，否则当文字量达到5k以上级别的时候Typora就会卡</span><br></pre></td></tr></table></figure><hr><h1 id="0-debug记录"><a href="#0-debug记录" class="headerlink" title="0. debug记录"></a>0. debug记录</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">如果在git commit之后出现：</span><br><span class="line">Please enter the commit message for your changes. Lines starting...</span><br><span class="line">那是因为没写-m &quot;xxxx&quot;，自动给跳转到VIM来让你手动输入参数了，</span><br><span class="line">解决方法：</span><br><span class="line">1. 按i或者insert键，进入&quot;插入模式&quot;</span><br><span class="line">2. 修改最上面那行的黄色合并信息，也可以不改</span><br><span class="line">3. 按下:wq+ENTER提交更新</span><br><span class="line">所以还是推荐写上-m &quot;xxxx&quot;参数</span><br><span class="line"></span><br><span class="line">现在对于大陆墙的测试情况是，当使用VPN时可以正常git push，目前没有bug</span><br></pre></td></tr></table></figure><hr><h1 id="1-版本控制"><a href="#1-版本控制" class="headerlink" title="1. 版本控制"></a>1. 版本控制</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">简而言之就是，在项目的版本迭代过程中，要保留老版本。</span><br><span class="line"></span><br><span class="line">定义：版本控制（Revision Control）是一种在开发过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。</span><br><span class="line"></span><br><span class="line">本地版本控制 -&gt; </span><br><span class="line">集中版本控制(例如SVN，逻辑简单方便使用但是若服务器崩了就寄了) -&gt; </span><br><span class="line">分布式版本控制(例如Git，每个人都拥有全部的代码，可以离线地在本地提交，联网了再扔到服务器上)</span><br></pre></td></tr></table></figure><hr><h1 id="2-Git的配置"><a href="#2-Git的配置" class="headerlink" title="2. Git的配置"></a>2. Git的配置</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Windows: 官网下载，速度慢就配镜像；</span><br><span class="line">Linux: apt -get install git 或 sudo apt install git</span><br><span class="line"></span><br><span class="line">当需要卸载的时候，记得回去清一下环境变量，然后在控制面板卸载就可以了；</span><br><span class="line"></span><br><span class="line">鉴于Git Bash是Linux风格的窗口，故下面贴一些常用且基本的Linux命令，以便查阅：</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/01/13/9DInFLTamokZG3g.png" alt="avatar"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">查看当前目录下的Git配置:</span><br><span class="line">git config -l</span><br><span class="line"></span><br><span class="line">查看系统给我们自动配置的配置（什么话啊）：</span><br><span class="line">git config --system --list</span><br><span class="line"></span><br><span class="line">查看用户自己配的配置：</span><br><span class="line">git config --global --list</span><br><span class="line">会出现user.name &amp; user.email，这是必须要配置的</span><br><span class="line">如何配置？很简单：</span><br><span class="line">git config --global user.name &quot;Conqueror712&quot;</span><br><span class="line">git config --global user.email 12345678@qq.com</span><br><span class="line">如何删除？很简单，因为保存在本地了</span><br><span class="line">Git\etc\gitconfig （安装目录） --system系统级</span><br><span class="line">C:\Users\Administrator\.gitconfig   --global全局</span><br></pre></td></tr></table></figure><hr><h1 id="3-Git基本理论（核心）"><a href="#3-Git基本理论（核心）" class="headerlink" title="3. Git基本理论（核心）"></a>3. Git基本理论（核心）</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Git本地有三个工作区域：</span><br><span class="line">1. 工作目录(Working Directory):就是平时存放项目代码的地方</span><br><span class="line">2. 暂存区(Stage/Index):用于临时存放你的改动，事实上只是一个文件，保存即将提交到文件列表信息</span><br><span class="line">3. 资源库(Repository或Git Directory):安全存放数据的位置，这里有提交到所有版本的数据，HEAD指向最新放入仓库的版本</span><br><span class="line">Git远程有一个工作区域：</span><br><span class="line">1. 远程Git仓库(Remote Directory)：托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</span><br><span class="line"></span><br><span class="line">一个重要的原理图：</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/01/13/WwsykcjUFqv9TQb.png" alt="avatar"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">在工作目录里面的隐藏的git文件夹里面有一个HEAD文件，里面大概是这样的内容：</span><br><span class="line">ref: refs/heads/master</span><br><span class="line">这个master是主分支的意思</span><br><span class="line">当然，现在版本(2020.10.01之后)大概是变成了/main 意思是一样的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Git的工作流程：</span><br><span class="line">1. 在工作目录中添加、修改文件 -&gt; 有一个UserMapper.xml文件</span><br><span class="line">2. 将需要进行版本管理的文件放入暂存区域 -&gt; git add .</span><br><span class="line">3. 将暂存区域的文件提交到Git仓库 -&gt; git commit</span><br><span class="line">因此，Git管理的文件有三种状态</span><br><span class="line">1. 已修改(modified)</span><br><span class="line">2. 已暂存(staged)</span><br><span class="line">3. 已提交(committed)</span><br></pre></td></tr></table></figure><hr><h1 id="4-Git项目搭建"><a href="#4-Git项目搭建" class="headerlink" title="4. Git项目搭建"></a>4. Git项目搭建</h1><p><img src="https://s2.loli.net/2023/01/13/w8THEhXqWjRfUQp.png" alt="avatar"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">上面的部分和之前的一张图片有一点差别，暂时先不去管；</span><br><span class="line"></span><br><span class="line">查看当前暂存区状态：git status</span><br><span class="line"></span><br><span class="line">创建本地仓库的两种方式：</span><br><span class="line">1. 创建全新的仓库，需要用Git管理的项目的根目录执行</span><br><span class="line">    在当前目录新建一个Git代码库，在Git Bash中</span><br><span class="line">    git init</span><br><span class="line">执行之后就可以看到多了一个.git目录</span><br><span class="line"></span><br><span class="line">2. 另一种方式是克隆远程目录</span><br><span class="line">克隆一个项目和它的整个代码历史版本（版本信息）</span><br><span class="line">git clone [url]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">创建仓库的时候，许可证推荐选择GPL-3.0，具体的细则可以点进去自己看。</span><br><span class="line"></span><br><span class="line">SSH的获取ssh-keygen</span><br><span class="line">如果需要加密算法那就是ssh-keygen -t rsa</span><br><span class="line"></span><br><span class="line">在C盘的/user/administrator/.ssh/id_rsa.pub找到，复制之后扔到Github的对应位置</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">克隆远程仓库到本地，复制地址之后git clone [url]就好了</span><br></pre></td></tr></table></figure><hr><h1 id="5-Git文件操作"><a href="#5-Git文件操作" class="headerlink" title="5. Git文件操作"></a>5. Git文件操作</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">文件的4种状态：</span><br><span class="line">1. Untracked:未跟踪，此文件在文件夹中，但并没有加入到Git库，不参与版本控制，通过git add状态变为Staged</span><br><span class="line">2. Unmodify:文件已经入库，未修改，即版本库中的文件快照内容与文件夹中完全一致。这种类型的文件有两种去处：</span><br><span class="line">1. 如果它被修改，而变为Modified；</span><br><span class="line">2. 如果使用git rm移除版本库，则变为Untracked文件</span><br><span class="line">3. Modified:文件已修改，仅仅是修改，并没有进行其他的操作，这个文件也有两个去处：</span><br><span class="line">1. 通过git add可进入暂存Staged状态</span><br><span class="line">2. 使用git checkout则丢弃修改过，返回到Unmodify状态。git checkout即从库中取出文件，覆盖当前修改。</span><br><span class="line">4. Staged:暂存状态，执行git commit则将修改同步到库中，这时库中的文件和本地文件又变为一致，文件为Unmodify状态，执行git reset HEAD filename取消暂存，文件状态为Modified</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查看文件状态：</span><br><span class="line">1. 查看指定文件状态git status [filename]</span><br><span class="line">2. 查看所有文件状态git status</span><br><span class="line"></span><br><span class="line">git add . # 添加所有文件到暂存区</span><br><span class="line">git commit -m &quot;我是信息我是信息&quot; # 提交暂存区中的内容到本地仓库 -m的意思是提交信息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">忽略文件：</span><br><span class="line">有些时候我们并不想把所有的文件都纳入版本控制中，比如数据库文件、临时文件、设计文件等</span><br><span class="line"></span><br><span class="line">应当在主目录下建立.gitignore文件，并且有以下规则：</span><br><span class="line">1. 忽略文件中的空行或以#开始的行将会被忽略</span><br><span class="line">2. 可以使用Linux通配符，这里不过多展开</span><br><span class="line">3. 如果名称的最前面有一个！表示例外规则，将不被忽略</span><br><span class="line">4. 如果名称的最前面是一个路径分隔符/，表示要忽略的文件在此目录下，而子目录中的文件不忽略</span><br><span class="line">5. 如果名称的最后面是一个路径分隔符/，表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）</span><br><span class="line"></span><br><span class="line">*.txt# 忽略所有.txt结尾的文件</span><br><span class="line">!lib.txt# 但lib.txt除外</span><br><span class="line">/temp# 仅忽略项目根目录下的TODO文件，不包括其他目录temp</span><br><span class="line">build/# 忽略build/目录下的所有文件</span><br><span class="line">doc/*.txt# 会忽略doc/notes.txt但不包括doc/server/arch.txt</span><br></pre></td></tr></table></figure><hr><h1 id="6-Git分支说明"><a href="#6-Git分支说明" class="headerlink" title="6. Git分支说明"></a>6. Git分支说明</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Git分支中常用的命令：</span><br><span class="line"></span><br><span class="line">列出所有本地分支git branch</span><br><span class="line"></span><br><span class="line">列出所有远程分支git branch -r</span><br><span class="line"></span><br><span class="line">新建一个分支，但依然停留在当前分支git branch [branch-name]</span><br><span class="line"></span><br><span class="line">新建一个分支，并切换到该分支git checkout -b [branch]</span><br><span class="line"></span><br><span class="line">合并指定分支到当前分支git merge [branch]</span><br><span class="line"></span><br><span class="line">删除分支git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line">删除远程分支</span><br><span class="line">git push origin --delete [branch-name]</span><br><span class="line">git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">特别的，如果多个分支并行执行，就会导致我们代码不冲突，也就是同时存在多个版本</span><br><span class="line">这里暂时不特别管这部分...</span><br></pre></td></tr></table></figure><hr><h1 id="7-其他"><a href="#7-其他" class="headerlink" title="7. 其他"></a>7. 其他</h1><h2 id="Fork-与上游仓库同步"><a href="#Fork-与上游仓库同步" class="headerlink" title="Fork 与上游仓库同步"></a>Fork 与上游仓库同步</h2><p>要将您的 Fork 与上游仓库同步，您需要执行以下步骤：</p><p>首先，将上游仓库的 URL 添加为远程仓库。在终端或命令行中，进入您的本地仓库并运行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add upstream &lt;upstream_repository_url&gt;</span><br></pre></td></tr></table></figure><p>这将把上游仓库的 URL 添加为一个名为“upstream”的远程仓库。</p><p>接下来，获取上游仓库的更新。运行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch upstream</span><br></pre></td></tr></table></figure><p>这将获取上游仓库的更新，但并不会自动将其合并到您的本地分支中。</p><p>现在，将您的本地分支切换到主分支（通常是 <code>master</code>）。运行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><p>接下来，将上游仓库的更改合并到您的本地分支中。运行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge upstream/master</span><br></pre></td></tr></table></figure><p>这将在您的本地分支中合并上游仓库的更改。</p><p>最后，将更新后的本地分支推送到您的 Fork 上。运行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>这将将更新后的本地分支推送到您的 Fork 上。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>计算机组成原理丨学习记录</title>
    <link href="https://conqueror712.github.io/post/Principles-Of-Computer-Composition.html"/>
    <id>https://conqueror712.github.io/post/Principles-Of-Computer-Composition.html</id>
    <published>2022-08-21T02:51:33.000Z</published>
    <updated>2023-02-15T14:27:18.403Z</updated>
    
    <content type="html"><![CDATA[<h2 id="课程内容："><a href="#课程内容：" class="headerlink" title="课程内容："></a>课程内容：</h2><ul><li>计算机概述<ul><li>性能指标、层次结构</li></ul></li><li>数据表示与运算器<ul><li>数据的表示、运算器</li><li>浮点运算方法</li></ul></li><li>存储器<ul><li>存储器系统、存储器控制器</li><li>Cache、虚拟存储器</li></ul></li><li>指令系统<ul><li>指令集架构、寻址方式</li><li>典型指令</li></ul></li><li>中央处理器<ul><li>CPU模型机、指令执行过程、微程序控制器</li><li>硬布线控制器</li></ul></li><li>总线<ul><li>总线分类、总线仲裁</li><li>总线定时</li></ul></li><li>外围设备<ul><li>磁盘、显示</li></ul></li><li>输入输出系统<ul><li>程序查询、中断、DMA</li><li>通道方式</li></ul></li></ul><hr><h1 id="零、导论"><a href="#零、导论" class="headerlink" title="零、导论"></a><strong>零、导论</strong></h1><p><img src="https://s2.loli.net/2022/08/25/OsGpmBU3XxlAiyW.png" alt="avatar"></p><hr><h1 id="一、计算机系统体系结构"><a href="#一、计算机系统体系结构" class="headerlink" title="一、计算机系统体系结构"></a><strong>一、计算机系统体系结构</strong></h1><img src="https://s2.loli.net/2022/08/21/7eFLWu3gxnmpIzb.png" alt="avatar" style="zoom:50%;" /><p>一般来说，组成一词比体系结构要更加偏向底层；</p><p><img src="https://s2.loli.net/2022/09/02/SUavEFcVu3eZb6T.png" alt="avatar"></p><p><img src="https://s2.loli.net/2022/08/21/kxOe4jfuYpyrHWD.png" alt="avatar"></p><hr><h2 id="计算机的发展历史："><a href="#计算机的发展历史：" class="headerlink" title="计算机的发展历史："></a>计算机的发展历史：</h2><p><img src="https://s2.loli.net/2022/09/02/WZYy7ACMLgoskPQ.png" alt="avatar"></p><p>第一台<strong>电子数字</strong>计算机：ENIAC(1946)（电子管）</p><p><img src="https://s2.loli.net/2022/09/02/RX62aQxklEtvYfz.png" alt="avatar"></p><h3 id="冯诺依曼结构"><a href="#冯诺依曼结构" class="headerlink" title="冯诺依曼结构"></a>冯诺依曼结构</h3><p>以<strong>运算器</strong>为核心</p><p>“存储程序”的概念是指<strong>将指令以二进制代码的形式事先输入计算机的主存储器</strong>，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。</p><p>第一台采用冯诺依曼结构的计算机：EDVAC</p><p><img src="https://s2.loli.net/2022/09/02/Qp5Ini9DBsJT1Oq.png" alt="avatar"></p><h3 id="现代计算机结构"><a href="#现代计算机结构" class="headerlink" title="现代计算机结构"></a>现代计算机结构</h3><p>以<strong>存储器</strong>为核心</p><p>CPU &#x3D; 运算器 + 控制器（合二为一）</p><p><img src="https://s2.loli.net/2022/09/02/YLcFVW13xfkjuln.png" alt="avatar"></p><p><img src="https://s2.loli.net/2022/09/02/OoiWevhbEfjqwYc.png" alt="avatar"></p><p>注意，这里的主机和很大的那个主机箱子不是一个概念，这里的主机只包括CPU和主存。</p><p><img src="https://s2.loli.net/2022/09/02/vNOQWzVqiMHY8jP.png" alt="avatar"></p><hr><h2 id="主要硬件结构的简要介绍"><a href="#主要硬件结构的简要介绍" class="headerlink" title="主要硬件结构的简要介绍"></a>主要硬件结构的简要介绍</h2><h3 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h3><p>包括存储体、MAR（存储地址寄存器Memory Address Register）、MDR（存储数据寄存器Memory Data Register）</p><p>读取一个位于存储体内的信息的时候，顺序是<code>-&gt;MAR-&gt;存储体-&gt;MDR-&gt;</code></p><p>存储体内部的大致结构如下：</p><img src="https://s2.loli.net/2022/09/02/bON3eZLIr8kmvjB.png" alt="avatar" style="zoom:50%;" /><p>存储字长的例子 以及 字和字节的区别：B与b是不一样的，字与字节是不一样的，字节是<strong>死的</strong>，字是<strong>活的</strong>。</p><img src="https://s2.loli.net/2022/09/02/oWqHd6FfPRjS2Z8.png" alt="avatar" style="zoom:50%;" /><h3 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h3><p><img src="https://s2.loli.net/2022/09/02/2T8HZgBKGeRrwzE.png" alt="avatar"></p><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><p><img src="https://s2.loli.net/2022/09/02/sZpBEF4LICHXl6m.png" alt="avatar"></p><p>完成一条指令：<code>PC取指令-&gt;IR分析指令-&gt;CU执行指令</code>。其中前两步也被称为<strong>取指</strong>操作，最后一步也被称为<strong>执行</strong>操作。</p><p>除此之外，还有条件码寄存器(Status Register)，用里面的一个一个标记位，存放CPU进行算术或者逻辑运算的结果。</p><h3 id="计算机的工作过程示例："><a href="#计算机的工作过程示例：" class="headerlink" title="计算机的工作过程示例："></a>计算机的工作过程示例：</h3><p><img src="https://s2.loli.net/2022/09/02/NaCXPqoTULfI7OR.png" alt="avatar"></p><p><img src="https://s2.loli.net/2022/09/02/8NFmjOYRDgT9G1U.png" alt="avatar"></p><p>指令的执行分为必经步骤和有选择性的步骤。</p><img src="https://s2.loli.net/2022/09/02/7KkIeyd2YJgoG8Q.png" alt="avatar" style="zoom:50%;" /><p>需要特别说明的是，现代的计算机往往会把MAR和MDR集成到CPU里面去，所以有可能有的题目会画在一起。</p><p>还有一点：在高级语言中的<code>if</code> <code>else</code> <code>for</code>实际上会被编译成<code>cmp(compare)</code>和<code>jne(jump if not equal)</code>，所以本质上是<code>goto</code>；</p><p>函数调用的原理：Stack LIFO</p><p><strong>总结：</strong></p><p><img src="https://s2.loli.net/2022/09/02/623vjFNMypiCquH.png" alt="avatar"></p><h2 id="计算机系统的多级层次结构"><a href="#计算机系统的多级层次结构" class="headerlink" title="计算机系统的多级层次结构"></a>计算机系统的多级层次结构</h2><p><img src="https://s2.loli.net/2022/09/02/JqHkDbm5TatPBjl.png" alt="avatar"></p><p><img src="https://s2.loli.net/2022/09/02/p7Xc4k8FaxotjrE.png" alt="avatar"></p><h3 id="编译程序："><a href="#编译程序：" class="headerlink" title="编译程序："></a>编译程序：</h3><p>将高级语言编写的源程序全部语句一次全部翻译成机器语言程序，而后再执行机器语言程序（只需翻译一次)解释程序:将源程序的一条语句翻译成对应于机器语言的语句，并立即执行。紧接着再翻译下一句(每次执行都要翻译)。</p><p><img src="https://s2.loli.net/2022/09/02/bx4EdoM7CpPzBhL.png" alt="avatar"></p><h2 id="计算机的性能指标"><a href="#计算机的性能指标" class="headerlink" title="计算机的性能指标"></a>计算机的性能指标</h2><h3 id="储存器的性能指标"><a href="#储存器的性能指标" class="headerlink" title="储存器的性能指标"></a>储存器的性能指标</h3><p>需要注意的一点是：在实际情况中MAR的位数不一定能计算出存储器的真正大小。理论值是峰值。</p><p>MAR位数反应<strong>存储单元的个数</strong>（最多支持的个数），例如32位MAR，<strong>最多</strong>存储单元个数：<code>2^32</code></p><p>MDR位数 &#x3D; <strong>存储字长</strong> &#x3D; 每个存储单元的大小</p><p>故<code>总容量 = 存储单元个数 * 存储字长</code>，单位是<code>bit</code>，若转换成字节则<code>/8</code>；</p><p><code>K: 2^10</code>  <code>M: 2^20</code>  <code>G: 2^30</code>  <code>T: 2^40</code></p><p><strong>CPI</strong> (Clock cycle Per Instruction)：执行一条指令所需的<strong>时钟周期数</strong>；</p><p>​不同的指令，CPI不同。甚至相同的指令，CPI也有可能发生变化；</p><p>​所以通常提到CPI的时候都是指的<strong>平均值</strong>；</p><p><strong>执行一条指令的耗时</strong>： <code>指令数 * CPI * CPU时钟周期(ClockCycleTime)</code></p><p><strong>IPS</strong> (Instructions Per Second)：每秒执行多少条指令；</p><p>​<code>IPS = 主频 / 平均CPI</code></p><p>​有时，也会在IPS FLOPS前面加上K M G T，有别于刚才的存储大小；</p><p>​<code>K = Kilo = 1e3</code></p><p>​<code>M = Million = 1e6</code></p><p>​<code>G = Giga = 1e9</code></p><p>​<code>T = Tera = 1e12</code></p><p><strong>FLOPS</strong> (Floating-point Operations Per Second)：每秒执行多少次浮点运算</p><p><strong>数据通路带宽</strong>：</p><p>数据总线一次所能并行传送信息的位数；（各硬件部件通过数据总线传输数据）</p><p><strong>吞吐量（率）</strong>：指系统在单位时间内处理请求的数量</p><p>它取决于信息能多快地存入内存，CPU能多快地取指令，数据能多快地从内存取出或存入，以及所得结果能多快地从内存送给一台外部设备。这些步骤中的每一步都关系到主存，因此，系统吞吐量主要取决于主存的存取周期。</p><p><strong>响应时间</strong>：指从用户向计算机发送一个请求，到系统对该请求做出相应并获得他所需要的结果的等待时间。</p><p>通常包括<strong>CPU时间</strong>（运行一个程序所花费的时间）与<strong>等待时间</strong>（用于磁盘访问、存储器访问、I&#x2F;O操作、操作系统开销等时间）。</p><p>值得一提的是，一般来说，我们会定义<code>性能 = 1 / 响应时间</code></p><p><strong>功耗问题</strong>：</p><img src="https://s1.328888.xyz/2022/09/06/1v7PC.png" alt="avatar" style="zoom:50%;" /><p><code>功耗 ≈ 1/2 × 负载电容 × 电压的平方 × 开关频率 × 晶体管数量</code></p><p>所以有了<em>通过并行提高性能</em>的方式。</p><p>综上所述，我们可以用一个<em>基准程序</em>来测量计算机处理速度，也就是所谓的<em>跑分软件</em>。</p><p><img src="https://s1.328888.xyz/2022/09/03/kXfrg.png" alt="avatar"></p><hr><h2 id="计算机的一些基础名词："><a href="#计算机的一些基础名词：" class="headerlink" title="计算机的一些基础名词："></a>计算机的一些基础名词：</h2><h3 id="机器字长"><a href="#机器字长" class="headerlink" title="机器字长"></a>机器字长</h3><p>计算机<strong>一次</strong>整数运算所能处理的二进制位数</p><h3 id="微处理器"><a href="#微处理器" class="headerlink" title="微处理器"></a><strong>微处理器</strong></h3><p>​微处理器是在单个硅片上实现的CPU，围绕其构建的计算机被称为<strong>微机</strong>。</p><h3 id="硬盘与储存系统"><a href="#硬盘与储存系统" class="headerlink" title="硬盘与储存系统"></a><strong>硬盘与储存系统</strong></h3><p>​如今，半导体硬盘 即固态SSD开始取代传统的机械硬盘，这有助于硬盘的性能（主要是访问时间）。</p><p>​如果不能将程序储存在合适的储存器中，CPU的速度再快也<strong>毫无用处</strong>。</p><p>​<strong>便宜的Flash储存器（俗称闪存）</strong>使得MP3、数码相机、电子书和ipad等数码产品获得了巨大成功。</p><p><img src="https://s2.loli.net/2022/08/21/AvTiyVapcUtFqle.png" alt="avatar"></p><h3 id="图灵完备"><a href="#图灵完备" class="headerlink" title="图灵完备"></a><strong>图灵完备</strong></h3><p>如果一台计算机能够模拟图灵机，那么它就是图灵完备的。</p><p>如今的计算机都是如此了。</p><p><img src="https://s2.loli.net/2022/08/21/SZyOibjwTtWRXEp.png" alt="avatar"><img src="https://s2.loli.net/2022/08/21/RTPLsmdaNVeti2c.png" alt="avatar"></p><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a><strong>总线</strong></h3><p>一些计算机系统使用总线扩展接口或桥接技术，以此来在不同类型的总线之间交换数据。（USB Type-C转接就是如此）</p><h3 id="信息"><a href="#信息" class="headerlink" title="信息"></a><strong>信息</strong></h3><p>信息这一词表示计算机中的指令和数据</p><p>如右图，双向箭头代表这条通路商的信息是双向的；</p><p>分为<strong>读周期</strong>和<strong>写周期</strong>，会让信息流的方向不同。</p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a><strong>寄存器</strong></h3><p>寄存器是CPU内部用来存放一个单位的数据的存储单元。</p><p>由多个**触发器(Flip-Flop)<strong>和</strong>锁存器(Latches)**组成的简单电路。</p><p>寄存器通常用它所保存的数据的位数来描述（8位 16位 32位 64位）。</p><p>寄存器和<strong>存储器</strong>中的<strong>字存储单元</strong>没有本质区别；</p><p>实际差别在于，寄存器位于CPU内，它的访问速度<strong>远远快于</strong>访问CPU外的存储器。</p><img src="https://s2.loli.net/2022/08/21/dXS5uDTgCA4Lo3x.png" alt="avatar" style="zoom:33%;" /><h3 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a><strong>时钟</strong></h3><p>绝大多数数字电子电路都带有一个时钟，用以生成<strong>连续的间隔固定的</strong>电脉冲流。</p><p>之所以被称作时钟，是因为可用这些电脉冲来<strong>计时</strong>或确定计算机内所有事件的<strong>顺序</strong>。</p><p>时钟提供了脉冲流，所有的内部操作都是在时钟脉冲的触发下进行的；</p><p>时钟的频率是决定计算机速度的一个因素，目前一般为3.2GHz（32亿）。</p><p>事件由时钟信号触发的数字电路被称作<strong>同步的</strong>，因为它们由时钟信号来同步。</p><p>有些事件则是<strong>异步的</strong>，因为它们可以在任何时间发生。</p><p>​<em>例如，如果移动一下鼠标，它会向计算机发送一个信号，这是一个异步事件（先动，后发）；</em></p><p><em>然而，计算机可以在每个时钟脉冲检测鼠标的状态，这是一个异步事件。</em></p><p><img src="https://s2.loli.net/2022/08/21/8t4qJypExLHXYFR.png" alt="avatar"></p><p>后续还会学到真正的计算机如何在完成一条指令之前就开始执行一条新的指令（我觉得它叫并行）。</p><p>计算机会将数据和指令放在不同的存储器中（或使用不同的总线传输数据和指令）；</p><p>这样的结构叫做 <em>哈佛体系机构</em>。</p><p><img src="https://s2.loli.net/2022/08/21/EODCfNRylZ9pXWx.png" alt="avatar"></p><h3 id="光刻机"><a href="#光刻机" class="headerlink" title="光刻机"></a>光刻机</h3><p>原理简要示意图：</p><p><img src="https://s2.loli.net/2022/08/21/PDIoUCpTB6XubHr.png" alt="avatar"></p><p>一层一层更改顶部的化学覆盖层，然后用光来照射…</p><p><img src="https://s2.loli.net/2022/08/21/MpCysI7u3gY4SGN.png" alt="avatar"></p><h3 id="普适计算"><a href="#普适计算" class="headerlink" title="普适计算"></a><strong>普适计算</strong></h3><p>简单释义：计算是无处不在的</p><p>​也被称为功耗感知的计算(power-aware)——低功耗计算</p><p>特征：趋同性</p><p>实例：eBook中的E-ink，即电子墨水</p><hr><h2 id="存储程序计算机的概念"><a href="#存储程序计算机的概念" class="headerlink" title="存储程序计算机的概念"></a>存储程序计算机的概念</h2><p>计算机的存储器应当视为一个存放信息的表格或目录（<strong>有序的</strong>）。</p><p>人类的记忆往往不是有序的，是神经元之间的复杂连接构成的非线性结构，这种结构并不利于计算机检索，故计算机采用连续的储存方式。</p><p><img src="https://s2.loli.net/2022/08/25/xMVFeJp4z3DdR7X.png" alt="avatar"></p><h3 id="寄存器传输语言RTL"><a href="#寄存器传输语言RTL" class="headerlink" title="寄存器传输语言RTL"></a>寄存器传输语言RTL</h3><p>由于使用文字描述计算机的操作很不方便，故有了RTL，这样可以更加容易地定义计算机内发生的操作。</p><p>注意：RTL并不是一种计算机语言，它只是一种用来<strong>定义计算机操作的符号</strong>。</p><p>RTL可以很方便地<strong>区分</strong>存储单元的地址和它的内容，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[15] = Max_Run</span><br><span class="line">含义是：地址为15的存储单元保存了变量Max_Run的值</span><br><span class="line"></span><br><span class="line">[15] ← [15] + 1</span><br><span class="line">含义是将地址为15的存储单元的值+1，并将结果写回地址为15的存储单元</span><br><span class="line">其中 ← 符号的含义是数据传送</span><br></pre></td></tr></table></figure><p>自计算机诞生，直至20世纪70年代，计算机采用的运行过程都是<strong>单线程顺序</strong>的，而今天的计算机已经可以做到<strong>并行</strong>和<strong>乱序</strong>地完成内部操作了。</p><p>在当时，机器上执行一条指令需要至少两次访存：</p><ol><li>读取指令</li><li>从存储器中读出指令需要的数据  ||  将它之前的指令产生的或修改过的数据写回存储器</li></ol><p>这一过程也被称为<strong>读取&#x2F;执行</strong>周期的两阶段模式。</p><p>这一情况当时人们用<strong>冯 · 诺依曼平瓶颈</strong>来表明CPU与存储器之间的通路是存储程序计算机的制约因素之一，下面是一个可视化的例子：</p><p><img src="https://s2.loli.net/2022/08/25/xDsjSgO6A58FKMC.png" alt="avatar"></p><h4 id="两地址指令："><a href="#两地址指令：" class="headerlink" title="两地址指令："></a>两地址指令：</h4><p>采用两地址指令来进行两数之和操作会破坏其中一个地址所存储的数的原始值，不难理解。</p><h4 id="单地址指令："><a href="#单地址指令：" class="headerlink" title="单地址指令："></a>单地址指令：</h4><p>由于指令中只提供了一个操作数地址而指令至少需要两个地址，处理器不得不使用一个<strong>不需要显式地址</strong>的第二操作数。第二个操作数来自于CPU内一个叫<strong>累加器</strong>的<strong>寄存器</strong>，由于所有的操作数都要流过它累加器，导致现在很少用了。</p><h3 id="计算机的分类"><a href="#计算机的分类" class="headerlink" title="计算机的分类"></a>计算机的分类</h3><ul><li>存储器 - 存储器型</li><li>寄存器 - 存储器型</li><li>寄存器 - 寄存器型</li></ul><h2 id="计算机系统概览"><a href="#计算机系统概览" class="headerlink" title="计算机系统概览"></a>计算机系统概览</h2><p>计算机科学家们将存储器是做一个巨大的通过地址访问的数组。</p><p><strong>存储墙</strong>一词，用来说明如今存储性能远落后于处理器性能，最终会制约处理器的性能。</p><h3 id="存储层次："><a href="#存储层次：" class="headerlink" title="存储层次："></a>存储层次：</h3><p><img src="https://s2.loli.net/2022/08/25/T2QvK4uIdwzVxHp.png" alt="avatat"></p><ul><li>寄存器存放处理器的工作数据；</li><li>Cache是缓存常用数据的快速存储器，是决定计算机性能的关键模块；<ul><li>Cache系统与计算机的地址总线和数据总线相连，监听着CPU与存储器之间的事务；</li><li>有些Cache分多级，查找顺序为一级 → 二级 → … → 主存；</li></ul></li><li>DRAM存放工作数据块（动态随机访问存储器Dynamic Random Access Memory）；<ul><li>易失性半导体：掉电的时候其中的数据都会丢失；</li></ul></li><li>硬盘用来保存程序和数据；</li></ul><p>值得一提的是，虽然硬盘的容量是寄存器的4000万倍，但是速度却比寄存器慢2000万倍。</p><p><img src="https://s2.loli.net/2022/08/25/xPkvifM4eugYaAH.png" alt="avatar"></p><h3 id="总线-1"><a href="#总线-1" class="headerlink" title="总线"></a>总线</h3><p>总线将计算机或外部设备的两个或多个功能单元连接在一起并允许他们相互交换数据，例如CPU与显卡之间的总线。</p><p><img src="https://s2.loli.net/2022/08/25/4YZclWAF7m5H3sk.png" alt="avatar"></p><h4 id="仲裁器"><a href="#仲裁器" class="headerlink" title="仲裁器"></a>仲裁器</h4><p>一些系统使用仲裁器来决定允许在总线冲突的时候哪个设备继续工作，其余设备等待之。</p><h4 id="宽度"><a href="#宽度" class="headerlink" title="宽度"></a>宽度</h4><p>一般用<strong>并行数据通路的数量</strong>来定义总线的宽度；</p><p>​例如一条64位宽的总线一次能够传送64（8byte）bit的信息；</p><h4 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h4><p>总线带宽是衡量<strong>信息在总线上的传输速率</strong>的一项指标；</p><p>​单位一般是b&#x2F;s或者B&#x2F;s；</p><p>​在保持<strong>数据传输率</strong>不变的情况下增加总线的宽度，可以提高带宽；</p><h4 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h4><p>延迟是从发出数据传输请求到实际数据传输的时间间隔；</p><p>​总线延迟通常包括传输开始之前进行总线仲裁的时间；</p><hr><h1 id="二、数据的表示与运算"><a href="#二、数据的表示与运算" class="headerlink" title="二、数据的表示与运算"></a><strong>二、数据的表示与运算</strong></h1><h2 id="数据、数字与数字逻辑电路"><a href="#数据、数字与数字逻辑电路" class="headerlink" title="数据、数字与数字逻辑电路"></a>数据、数字与数字逻辑电路</h2><h3 id="电路的基本原理与加法器的设计"><a href="#电路的基本原理与加法器的设计" class="headerlink" title="电路的基本原理与加法器的设计"></a>电路的基本原理与加法器的设计</h3><hr><h3 id="数据的存储与排列"><a href="#数据的存储与排列" class="headerlink" title="数据的存储与排列"></a>数据的存储与排列</h3><hr><h2 id="进制、编码与乘除法"><a href="#进制、编码与乘除法" class="headerlink" title="进制、编码与乘除法"></a>进制、编码与乘除法</h2><p>每个二进制数位称为一个bit</p><h3 id="进位计数制"><a href="#进位计数制" class="headerlink" title="进位计数制"></a>进位计数制</h3><p><img src="https://s1.328888.xyz/2022/09/03/1OTB6.png" alt="avatar"></p><p>需要注意的是：有的十进制小数无法用二进制精确表示，如0.3</p><hr><h3 id="BCD码"><a href="#BCD码" class="headerlink" title="BCD码"></a>BCD码</h3><p>Binary-Coded Decimal 用二进制编码的十进制<em>数字电路梦幻联动</em></p><ul><li>8421码  （需要掌握加法运算）</li><li>余3码</li><li>2421码</li></ul><p>首先我们来看<strong>8421</strong>码，用4位二进制来表示0~9十个数，显然是有冗余，因为2^4 &#x3D; 16，多了6种状态，不过这不重要。</p><p>假设我们要表示985，那么用8421码来存储就是：1001 1000 0101，8421码是一种<strong>有权码</strong>，每一位的权值固定。</p><p>8421码进行相加，实际上也是对应位相加，不过在实际做题中可以投机取巧，转化成十进制算完了再转回来（）。</p><p>很重要的一点是，当加法得到的结果超出了8421码的表示范围时，也就是落在了<code>[1010, 1111]</code>内，</p><p>那么计算机会自动把结果<code>+6</code>以<strong>进位</strong>，最后得到的位于原位的四位二进制数就是原本的数的<strong>个位</strong>（很神奇吧），例如：</p><img src="https://s1.328888.xyz/2022/09/03/1jlwE.png" alt="avatar"  /><p>对映射的方式稍作修改就会得到别的编码方式</p><p>例如<strong>余3码</strong>就是在8421码的基础上再<code>+3</code>，即<code>+0011</code>，在余3码中，每一位并没有一个固定的权值，称为<strong>无权码</strong>。</p><p><img src="https://s1.328888.xyz/2022/09/03/1jhvp.png" alt="avatar"></p><p>总结一下：</p><p><img src="https://s1.328888.xyz/2022/09/03/1j2wR.png" alt="avatar"></p><hr><h3 id="字符与字符串"><a href="#字符与字符串" class="headerlink" title="字符与字符串"></a>字符与字符串</h3><p><strong>ASCII码：</strong></p><p><img src="https://s1.328888.xyz/2022/09/04/13eWK.png" alt="avatar"></p><p>汉字编码：<code>94 * 94</code><code>GB 2312-80</code>（只是其中一种方式）</p><p><img src="https://s1.328888.xyz/2022/09/04/1BEBs.png" alt="avatar"></p><p>值得一提的是，汉字要输出的话需要用<strong>汉字字形码</strong>，说白了就是像素画。</p><p>关于字符串，存储方式如下：</p><p><img src="https://s1.328888.xyz/2022/09/04/1BLf0.png" alt="avatar"></p><p>带有汉字的字符串，有两种存储方式：<strong>大端模式</strong>和<strong>小端模式</strong>；</p><p>汉字占两个字节</p><p><img src="https://s1.328888.xyz/2022/09/04/1Bm0o.png" alt="avatar"></p><p>总结一下：</p><p><img src="https://s1.328888.xyz/2022/09/04/1BD2F.png" alt="avatar"></p><hr><h3 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h3><p>在数据的传输过程中，有可能会发生错误，例如把<code>01</code>传输成了<code>00</code>，这种错误被称为<strong>位错误</strong>；</p><p>为了避免这种错误，或者说想要知道错误发生了，我们需要用多一些bit位来存储信息；</p><p>例如3bit映射到4个合法状态，就有了4种冗余的非法状态，当接收方获得非法状态的信息时，就能知道发生了错误。</p><table><thead><tr><th align="center">信息</th><th align="center">A</th><th align="center">B</th><th align="center">C</th><th align="center">D</th></tr></thead><tbody><tr><td align="center"><strong>编码</strong></td><td align="center"><strong>100</strong></td><td align="center"><strong>001</strong></td><td align="center"><strong>010</strong></td><td align="center"><strong>111</strong></td></tr></tbody></table><p>由若干位代码组成的一个字叫<strong>码字</strong>，比如上表中的100, 001都是；</p><p>将两个码字逐位进行对比，具有不同的位的个数称为<strong>两个码字间的距离</strong>；</p><p>一种编码方案可能有若干个合法码字，<strong>各</strong>合法码字间的最小距离称为**”码距”**，用<code>d</code>表示；</p><ul><li>当<code>d=1</code>时，无检错能力；</li><li>当<code>d=2</code>时，有检错能力；</li><li>当<code>d&gt;3</code>时，若设计合理，可能具有检错、纠错能力；</li></ul><img src="https://s1.328888.xyz/2022/09/12/KM37X.png" alt="avatar" style="zoom:67%;" /><p>偶校验的硬件实现：</p><p>各信息进行异或（模2加）运算，得到的结果即为偶校验位。</p><img src="https://s1.328888.xyz/2022/09/12/KMCZK.png" alt="avatar" style="zoom:67%;" /><p>只因校验的硬件实现类似，不过是反过来了。</p><hr><h3 id="海明校验码"><a href="#海明校验码" class="headerlink" title="海明校验码"></a>海明校验码</h3><p>设计思路：将信息位分组进行<strong>偶校验</strong>，有多个校验位，校验位能<strong>携带多种状态信息</strong>（对与错，错在哪）；</p><p>校验位的个数：<code>2^k &gt;= n + k + 1</code>，信息位n，校验位k，n+k位中任何一位都可能出错，1种正确状态；</p><p>海明码<strong>求解步骤</strong>：（详细过程待补充）</p><ol><li>确定校验位数量</li><li>确定校验位的分布</li><li>求校验位的值</li><li>检错纠错</li></ol><p><em>海明码有1位纠错，2位检错能力</em></p><hr><h3 id="循环冗余校验码"><a href="#循环冗余校验码" class="headerlink" title="循环冗余校验码"></a>循环冗余校验码</h3><p>又称<strong>CRC码</strong></p><p><strong>主体思想</strong>：除法的余数</p><ol><li>数据发送、接收方约定一个“除数”</li><li>K个信息位和R和校验位作为“被除数”，添加校验位后需保证除法的余数 &#x3D;&#x3D; 0</li><li>收到数据后，进行二进制除法检验余数是否为0</li><li>若余数 !&#x3D; 0 则出错，进行纠错or重传</li></ol><p><strong>计算过程</strong>：</p><ol><li>确定K、R以及<strong>生成多项式</strong>对应的二进制码（生成多项式的系数就是除数）（R &#x3D; 生成多项式的最高次幂）</li><li>移位：信息码左移R位，低位补0，也就是在原本的信息码后面填上R个0即可</li><li>相除：对移位后的信息码，用生成多项式进行<strong>模2除法</strong>，产生余数</li><li>检错和纠错：如果最后得到的余数为000，则没有出错</li></ol><p><strong>检错</strong>：</p><p>模2除之后得到的余数的循环节为7，可以对应从1k~7k的出错位（K∈N+）（并不是二进制）；</p><p>一般来说，CRC码只用于计算机网络的检错，其纠错功能一般不用；</p><ol><li>可检测出所有奇数个错误；</li><li>可检测出所有双比特的错误；</li><li>可检测出所有小于等于校验位长度的连续错误；</li></ol><p><strong>模2除法演示</strong>：</p><p><img src="https://s1.328888.xyz/2022/09/20/2GsEB.png" alt="avatar"></p><hr><h3 id="原码反码补码及其移位、溢出、四则运算"><a href="#原码反码补码及其移位、溢出、四则运算" class="headerlink" title="原码反码补码及其移位、溢出、四则运算"></a>原码反码补码及其移位、溢出、四则运算</h3><hr><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><hr><h2 id="定点数与浮点数：如何用有限的Bit位表示尽可能多的信息"><a href="#定点数与浮点数：如何用有限的Bit位表示尽可能多的信息" class="headerlink" title="定点数与浮点数：如何用有限的Bit位表示尽可能多的信息"></a>定点数与浮点数：如何用有限的Bit位表示尽可能多的信息</h2><h3 id="对于定点数："><a href="#对于定点数：" class="headerlink" title="对于定点数："></a>对于<strong>定点数：</strong></h3><p>首先我们看看BCD码的缺陷：浪费位数，没法同时表示很大和很小的数</p><h3 id="对于浮点数："><a href="#对于浮点数：" class="headerlink" title="对于浮点数："></a>对于<strong>浮点数</strong>：</h3><p>我们有科学计数法，用来节省空间；</p><p><strong>IEEE标准</strong>：（定义了两个基本的格式）</p><ul><li>用32Bit表示单精度的浮点数<code>float || float32</code></li><li>用64Bit表示双精度的浮点数<code>double || float64</code></li></ul><p>用单精度类型举例（双精度类似）：</p><table><thead><tr><th align="center">s &#x3D; 符号位</th><th align="center">e &#x3D; 指数位</th><th align="center">f &#x3D; 有效数位</th></tr></thead><tbody><tr><td align="center">1 Bit</td><td align="center">8 Bit</td><td align="center">23 Bit</td></tr></tbody></table><p>特别地，对于指数位，我们用1<del>254映射到-126</del>127上，0和255另有用处；</p><p>于是，浮点数就可以表示成：<code>(-1)^s * 1.f * 2^e</code></p><p><img src="https://s1.328888.xyz/2022/10/04/PIqWP.png" alt="avatar"></p><h3 id="浮点数的二进制转化"><a href="#浮点数的二进制转化" class="headerlink" title="浮点数的二进制转化"></a>浮点数的二进制转化</h3><p><code>s + e + f</code></p><p>逐个转化成二进制然后拼接即可</p><h3 id="浮点数的加法和精度损失"><a href="#浮点数的加法和精度损失" class="headerlink" title="浮点数的加法和精度损失"></a>浮点数的加法和精度损失</h3><p>浮点数加法：（利用半加器和全加器就可以实现）</p><ul><li>先<strong>对齐</strong> 再运算</li><li>对齐指数位原则：<code>e = max(e1, e2)</code></li><li>对其指数位后，有效位应做相应左移右移</li></ul><p>在右移的过程中，最右侧的有效位被丢弃掉了，这一步是<strong>丢失精度</strong>的原因所在。</p><h3 id="Kahan-Summation算法解决精度丢失"><a href="#Kahan-Summation算法解决精度丢失" class="headerlink" title="Kahan Summation算法解决精度丢失"></a>Kahan Summation算法解决精度丢失</h3><p>解决”大数吃小数”的问题；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KahanSummation</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line"><span class="type">float</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0.0f</span>; <span class="type">float</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0.0f</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20000000</span>; i++) &#123; </span><br><span class="line"><span class="type">float</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1.0f</span>; </span><br><span class="line"><span class="type">float</span> <span class="variable">y</span> <span class="operator">=</span> x - c; </span><br><span class="line"><span class="type">float</span> <span class="variable">t</span> <span class="operator">=</span> sum + y;</span><br><span class="line">c = (t-sum)-y; </span><br><span class="line">sum = t;</span><br><span class="line">&#125; </span><br><span class="line">System.out.println(<span class="string">&quot;sum is &quot;</span> + sum); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其实这个算法的原理其实并不复杂，</span></span><br><span class="line"><span class="comment">就是在每次的计算过程中，都用一次减法，</span></span><br><span class="line"><span class="comment">把当前加法 计算中损失的精度记录下来，</span></span><br><span class="line"><span class="comment">然后在后面的循环中，把这个精度损失放在要加的小数上，再做一次运算。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h2 id="算术逻辑单元ALU"><a href="#算术逻辑单元ALU" class="headerlink" title="算术逻辑单元ALU"></a>算术逻辑单元ALU</h2><h3 id="加法器、乘法器与ALU的改进"><a href="#加法器、乘法器与ALU的改进" class="headerlink" title="加法器、乘法器与ALU的改进"></a>加法器、乘法器与ALU的改进</h3><p><strong>半加器：</strong></p><p>通过一个异或门计算出个位，通过一个与门计算出是否进位，我们就通过电路算出了 一个一位数的加法。</p><p>于是，<strong>我们把两个门电路打包，给它取一个名字，就叫作半加器</strong>（Half Adder）。</p><p><img src="https://s1.328888.xyz/2022/10/04/Ps9Vi.png" alt="avatar"></p><p><strong>全加器：</strong></p><p>由于半加器只能处理1位的加法问题，所以很容易想到，如果要进行多Bit的加法运算，则需要多个半加器组合工作。</p><p><strong>我们用两个半加器和一个或门，就能组合成一个全加器。</strong></p><p><img src="https://s1.328888.xyz/2022/10/04/PsoOh.png" alt="avatar"></p><p>有了全加器，我们要进行对应的两个 8 bit 数的加法就很容易了。我们只要把 8 个全加器串联起来就好了。</p><p><img src="https://s1.328888.xyz/2022/10/04/PsI7s.png" alt="avatar"></p><p>值得一提的是，实际CPU里面的加法器，会更复杂一些，被称为<strong>超前进位加法器</strong>，这里先不做过多介绍。</p><p>至于ALU，则是由加法器再进行组合设计封装的产物了。</p><p><em><strong>NOW, WE HAVE A NEW LEVEL OF ABSTRACTION!</strong></em></p><p><strong>乘法器：</strong></p><p>虽然我们可以多次使用加法器来达到乘法运算的效果，但是毕竟时间空间材料都很宝贵，于是乘法器就应运而生了。</p><p>首先需要了解的是：<strong>二进制乘法</strong></p><p>很简单，一张图就能解释：</p><p>操作只有2种：复制 or 置0，最后再全部加起来即可</p><p><img src="https://s1.328888.xyz/2022/10/04/PMFch.png" alt="avatar"></p><p>实际上我们并不需要把每一位的运算结果都记录下来，那样的话实在是太浪费材料了，我们只需要维护一个动态的结果即可；</p><p><img src="https://s1.328888.xyz/2022/10/04/PM4xp.png" alt="avatar"></p><p>但是这样也有一个显著的缺点：<strong>慢！</strong></p><p>复杂度有O(N)，N为位数；</p><p><em><strong>所谓时间换空间，空间换时间…</strong></em></p><p><strong>电路设计改进——并行加速方法：</strong></p><p>实际上就是让多位同时计算，会获得O(logN)的时间复杂度，但相应的，<strong>代价</strong>是需要更多的晶体管开关来存放中间计算结果。</p><p>等待前面的步骤的等待时间，被称为**门延迟(Gate Delay)**。</p><blockquote><p>我们只要把进位部分的电路完全展开就好了。</p><p>我们的半加器到全加器，再到加法器，都是用最基础的门电路组合而成的。</p><p>门电路的计算逻辑，可以像我们做数学里面的多项式乘法一样 完全展开。</p><p>在展开之后呢，我们可以把原来需要较少的，但是有较多层前后计算依赖关系的门电路，</p><p>展开成需要较多的，但是依赖关系更少的门电路。</p></blockquote><hr><h1 id="三、存储系统"><a href="#三、存储系统" class="headerlink" title="三、存储系统"></a><strong>三、存储系统</strong></h1><h2 id="存储器的基本概念"><a href="#存储器的基本概念" class="headerlink" title="存储器的基本概念"></a>存储器的基本概念</h2><p><strong>存储介质：</strong>磁芯、磁表面、半导体、光…</p><p><strong>存取方式：</strong></p><ul><li>随机存取——RAM ROM</li><li>串行访问：<ul><li>顺序存取：磁带</li><li>直接存取：磁盘</li></ul></li></ul><p><strong>性能指标：</strong></p><ul><li>存储容量——存储字数 * 字长</li><li>单位成本——每位价格 &#x3D; 总成本 &#x2F; 总容量</li><li>存储速度——数据传输率（主存带宽） &#x3D; 数据宽度 &#x2F; 存储周期</li></ul><h3 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h3><ul><li>Cache - 主存层次：硬件实现，解决速度不匹配的问题</li><li>主存 - 辅存层次：硬件 + 操作系统实现，解决容量问题，逐渐形成虚拟存储系统</li></ul><p><strong>寄存器</strong>非常快，但也非常小；</p><p>CPU Cache使用<strong>SRAM(Static Random Access Memory静态随机存取存储器)</strong></p><p><strong>静态：</strong>通电状态数据保持存在，断电丢失</p><p>SRAM内1Bit数据需要6~8个晶体管，导致存储密度不高，空间有限，但是因为电路简单，故访问速度很快。</p><p>L1 L2 L3三层高速缓存，L1分为指令缓存和数据缓存</p><p>L1往往嵌在CPU核心内部，很快</p><p>L2不在核心内部，慢一些</p><p>L3是多个CPU核心公用的，尺寸更大，访问速度更慢</p><p>内存的芯片<strong>DRAM(Dynamic Random Access Memory动态随机存取存储器)</strong></p><p>相比SARM，密度↑，容量↑，价格↓，数据访问电路复杂度↑，刷新电路复杂度↑，访问延时↑</p><p>DARM需要不断**”刷新”**才能保持数据被存储起来。</p><p>1Bit只需要一个晶体管和一个电容，数据存在电容里，电容会不断漏电，所以需要定时刷新充电才能保护数据。</p><p><strong>SSD(Solid State Drive固态硬盘)</strong>HDD(Hard Disk Drive硬盘)：最大最慢</p><p>各个存储器只和相邻的一层存储器打交道，并且随着一层层往外，容量↑，速度↓，价格↓；</p><p><strong>局部性原理：</strong>（时间局部性 空间局部性）</p><p><em>高速度 大容量 低价格兼得</em></p><p>时间局部性：如果一个数据被访问了，那么它在短时间内还会被再次访问；</p><p>空间局部性：如果一个数据被访问了，那么和它相邻的数据也很快会被访问；</p><p>这样根据访问频率来决定将数据存储到速度快的存储器还是慢的就可以了。</p><p><strong>LRU(Least Recently Used)缓存算法</strong></p><p>​缓存命中率(Hit Rate)：访问的数据中 可以在我们设置的内存缓存中找到的占有多大的比例；</p><hr><hr><hr><h1 id="四、指令系统"><a href="#四、指令系统" class="headerlink" title="四、指令系统"></a><strong>四、指令系统</strong></h1><hr><h1 id="五、中央处理器CPU"><a href="#五、中央处理器CPU" class="headerlink" title="五、中央处理器CPU"></a><strong>五、中央处理器CPU</strong></h1><hr><h1 id="六、总线"><a href="#六、总线" class="headerlink" title="六、总线"></a><strong>六、总线</strong></h1><hr><h1 id="七、IO设备"><a href="#七、IO设备" class="headerlink" title="七、IO设备"></a><strong>七、IO设备</strong></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;课程内容：&quot;&gt;&lt;a href=&quot;#课程内容：&quot; class=&quot;headerlink&quot; title=&quot;课程内容：&quot;&gt;&lt;/a&gt;课程内容：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;计算机概述&lt;ul&gt;
&lt;li&gt;性能指标、层次结构&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据表示与运算</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>GoLang基础丨学习记录</title>
    <link href="https://conqueror712.github.io/post/GoLang.html"/>
    <id>https://conqueror712.github.io/post/GoLang.html</id>
    <published>2022-07-23T13:45:05.000Z</published>
    <updated>2023-02-15T14:28:00.237Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言与更新日志："><a href="#前言与更新日志：" class="headerlink" title="前言与更新日志："></a><strong>前言与更新日志：</strong></h1><p>关于Go：</p><p>​它没有隐式的数值转换，没有构造函数和析构函数，没有运算符重载，没有默认参数，也没有继承，没有泛型，没有异常，没有宏，没有函数修饰，更没有线程局部存储。但是，语言本身是成熟和稳定的，而且承诺保证向后兼容：用之前的Go语言编写程序可以用新版本的Go语言编译器和标准库直接构建而不需要修改代码。</p><p>​Go语言有足够的类型系统以避免动态语言中那些粗心的类型错误，但是，Go语言的类型系统相比传统的强类型语言又要简洁很多。</p><hr><p>2022.07.23 本文初稿。</p><p>2022.07.25 基于版本问题做了一些修复。</p><p>2022.07.26 更新至循环部分，完善了目录。</p><p>2022.08.20 更新了函数、数组和并发的相关内容。</p><p>2022.08.21 更新了切片的相关内容。</p><p>2022.08.27 更新了类型转换等剩余部分。</p><p>2022.08.28 完成了基础语法部分的更新，并整合于一个篇章内。</p><p>2022.08.29 更新了有关并发深入的内容。</p><p>2022.09.01 完善了并发深入的内容，更新了有关标准库的内容。</p><hr><h1 id="引言-·-让我们从Helloworld开始："><a href="#引言-·-让我们从Helloworld开始：" class="headerlink" title="引言 · 让我们从Helloworld开始："></a><strong>引言 · 让我们从Helloworld开始：</strong></h1><p>首先需要下载GoLang的安装包，解压后配置环境变量：</p><p><code>GOPATH</code>由于是<strong>旧版适用</strong>，所以我们这里不装。</p><p><code>GOROOT</code>是直接在系统变量里新建，路径分别是项目地址和安装地址；</p><p>以及<code>GOPROXY = &quot;https://proxy.golang.com.cn,direct&quot;</code> &amp; <code>GO111MODULE = on</code></p><p>（GOPROXY的地址可能会随时间变化，具体请看<a href="https://goproxy.io/zh/">GOPROXY.IO - 一个全球代理 为 Go 模块而生</a>）</p><p>还有一个需要在Path里添加bin的地址；</p><p>完成了这些之后我们需要明确一个项目的<strong>路径规范</strong>，（适合自己就好）；</p><p>到这里，我们已经基本完成了上述流程。</p><p>不妨运行下面的代码试试看吧？（Terminal）</p><p>（需要在VSC里安装插件：go &amp; run）</p><p>然后要在你的项目路径下打开终端，对于1.11以后的版本需要这样做：</p><p><code>go mod init &lt;filename&gt;</code></p><p>例如我写的就是<code>go mod init test</code></p><p>之后就会生成一个<code>go.mod</code>文件，然后就不需要旧版本的<code>GOPATH</code>来运行了（记得让<code>GO111MODULE = on</code>）。</p><p>（PS：如果是off的话，还是需要配置GOPATH环境变量）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main<span class="comment">//每一个程序文件都要归属于一个包</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span><span class="comment">//引入一个叫fmt为了使用这个包的函数 例如Println()</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Helloworld!&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;落雨乄天珀夜&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过go build命令对该go文件进行编译，生成.exe文件</span></span><br><span class="line"><span class="comment">//例子：go build Helloworld.go</span></span><br><span class="line"><span class="comment">//通过go run命令可以直接运行.go程序，类似于一个脚本文件（速度慢）</span></span><br></pre></td></tr></table></figure><p>如果，我是说如果，环境安装完了以后右下角频频报错说install什么什么，那就开科学上网然后Install ALL然后重启VSC就可以了。</p><p>值得一提的是，我们可以用自动代码补全<code>pkgm</code>&amp;<code>fp</code>等等…</p><p>可以使用终端+<code>code .</code>的方式打开go项目文件夹，这样不会报go.mod的错误。</p><hr><h1 id="初识-·-基础语法篇"><a href="#初识-·-基础语法篇" class="headerlink" title="初识 · 基础语法篇"></a><strong>初识 · 基础语法篇</strong></h1><h2 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x, y <span class="type">int</span> = <span class="number">5</span>, <span class="number">15</span> <span class="comment">//声明全局变量</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">aa <span class="type">int</span>       = <span class="number">10</span></span><br><span class="line">bb <span class="type">complex64</span> = <span class="number">100</span> <span class="comment">//全局变量实际上是允许只声明不使用的</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Helloworld!&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;你好！我的昵称是：&quot;</span> + <span class="string">&quot;落雨乄天珀夜&quot;</span>) <span class="comment">//字符串的拼接</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> id = <span class="number">5201314</span></span><br><span class="line"><span class="keyword">var</span> bir = <span class="string">&quot;1900-01-01&quot;</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="string">&quot;我的学号是:%d， 我的生日是:%s&quot;</span></span><br><span class="line"><span class="keyword">var</span> target_url = fmt.Sprintf(url, id, bir) <span class="comment">//格式化字符串</span></span><br><span class="line">fmt.Println(target_url)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a, b, c <span class="type">int64</span> = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">fmt.Print(<span class="string">&quot;a + b + c = &quot;</span>)</span><br><span class="line">fmt.Println(a + b + c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d <span class="type">int8</span></span><br><span class="line">fmt.Print(<span class="string">&quot;如果不对变量进行初始化，默认为零  d = &quot;</span>)</span><br><span class="line">fmt.Println(d)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ok <span class="type">bool</span> = <span class="literal">true</span></span><br><span class="line">fmt.Print(<span class="string">&quot;ok = &quot;</span>)</span><br><span class="line">fmt.Println(ok)</span><br><span class="line"></span><br><span class="line">tmp_val := <span class="number">114514</span> <span class="comment">//一种简便的变量声明方式</span></span><br><span class="line">fmt.Println(tmp_val)</span><br><span class="line">fmt.Println(&amp;tmp_val) <span class="comment">//引用 可以显示地址</span></span><br><span class="line"></span><br><span class="line">_ = aa <span class="comment">//_实际上是一个只写变量 你不能得到它的值</span></span><br><span class="line">_ = bb</span><br><span class="line">_ = x</span><br><span class="line">_ = y <span class="comment">//把声明但未使用的变量使用掉</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在包一级声明语句声明的名字可在整个包对应的每个源文件中访问，而不是仅仅在其声明语句所在的源文件中访问。相比之下，局部声明的名字就只能在函数内部很小的范围被访问。</p><h2 id="常量-运算符-条件语句与循环"><a href="#常量-运算符-条件语句与循环" class="headerlink" title="常量  运算符  条件语句与循环"></a><strong>常量  运算符  条件语句与循环</strong></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> N <span class="type">int</span> = <span class="number">100010</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;常量N = %d&quot;</span>, N)</span><br><span class="line">fmt.Println()</span><br><span class="line">fmt.Println(<span class="string">&quot;iota是一种特殊的常量，可以认为是一个可以被编译器修改的常量。&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，</span></span><br><span class="line"><span class="comment">//const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">a = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">b        <span class="comment">//1</span></span><br><span class="line">c        <span class="comment">//2</span></span><br><span class="line">d = <span class="string">&quot;ha&quot;</span> <span class="comment">//独立值，iota += 1</span></span><br><span class="line">e        <span class="comment">//&quot;ha&quot;   iota += 1</span></span><br><span class="line">f = <span class="number">100</span>  <span class="comment">//iota +=1</span></span><br><span class="line">g        <span class="comment">//100  iota +=1</span></span><br><span class="line">h = <span class="literal">iota</span> <span class="comment">//7,恢复计数</span></span><br><span class="line">i        <span class="comment">//8</span></span><br><span class="line">)</span><br><span class="line">fmt.Println(a, b, c, d, e, f, g, h, i) <span class="comment">//虽然目前我并不知道这个东西有什么用</span></span><br><span class="line"><span class="comment">//运算符没什么好说的</span></span><br><span class="line"><span class="comment">//+ - * / % ++ -- == != &gt; &lt; &gt;= &lt;= &amp;&amp; || ! &amp; | ^ &lt;&lt; &gt;&gt; = += -= *= /= %= &lt;&lt;= &gt;&gt;= &amp;= ^= |= &amp;p *p</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;条件语句：&quot;</span>)</span><br><span class="line"><span class="comment">//select比较特殊</span></span><br><span class="line"><span class="comment">//select 语句类似于 switch 语句，但是select会随机执行一个可运行的case</span></span><br><span class="line"><span class="comment">//如果没有case可运行，它将阻塞，直到有case可运行。</span></span><br><span class="line">ok := <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;对的对的&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//必须这样写</span></span><br><span class="line">fmt.Println(<span class="string">&quot;不对不对&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;循环语句：&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Print(i, <span class="string">&quot; &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line">numbers := [<span class="number">6</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, x := <span class="keyword">range</span> numbers &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;第 %d 位 x 的值 = %d\n&quot;</span>, i, x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for 循环的 range 格式可以省略 key 和 value</span></span><br><span class="line"><span class="comment">//暂时没有接触到 不做展开</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i, j = j, i <span class="comment">// 交换 i 和 j 的值</span></span><br></pre></td></tr></table></figure><h2 id="函数-数组-指针与结构体"><a href="#函数-数组-指针与结构体" class="headerlink" title="函数  数组  指针与结构体"></a><strong>函数  数组  指针与结构体</strong></h2><h3 id="函数定义："><a href="#函数定义：" class="headerlink" title="函数定义："></a>函数定义：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function_name</span><span class="params">( [parameter list] )</span></span> [return_types] &#123;</span><br><span class="line">   函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数调用："><a href="#函数调用：" class="headerlink" title="函数调用："></a>函数调用：</h3><p>和C一样，略；</p><h3 id="函数返回多个值："><a href="#函数返回多个值：" class="headerlink" title="函数返回多个值："></a>函数返回多个值：</h3><p> Go的特性；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">string</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a, b := swap(<span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Runoob&quot;</span>)</span><br><span class="line">   fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数参数："><a href="#函数参数：" class="headerlink" title="函数参数："></a>函数参数：</h3><p>基本概念：函数如果使用参数，该变量可称为函数的形参；形参就像定义在函数体内的局部变量。</p><p>也分为值传递和引用传递两种，但其实默认使用和使用更多的是值传递（貌似）；</p><h3 id="函数用法："><a href="#函数用法：" class="headerlink" title="函数用法："></a>函数用法：</h3><p>有闭包等神奇的用法，等到用到的时候再写；</p><hr><h3 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h3><p>数组的声明如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> variable_name [SIZE] variable_type</span><br></pre></td></tr></table></figure><p>实例1：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>]<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; i++ &#123;</span><br><span class="line">a[i] = i</span><br><span class="line">fmt.Println(a[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例2：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr := [...]<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>&#125;</span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; i++ &#123;</span><br><span class="line">fmt.Println(arr[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多维数组："><a href="#多维数组：" class="headerlink" title="多维数组："></a>多维数组：</h3><p>其实和其他语言很类似…</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> variable_name [SIZE1][SIZE2]...[SIZEN] variable_type</span><br></pre></td></tr></table></figure><hr><h3 id="Go指针："><a href="#Go指针：" class="headerlink" title="Go指针："></a>Go指针：</h3><p>变量的地址：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="number">1</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;The address of &#x27;a&#x27; is: %x\n&quot;</span>, &amp;a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个指针变量指向了一个值的内存地址；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> var_name *<span class="keyword">var</span>-<span class="keyword">type</span></span><br></pre></td></tr></table></figure><p>指针使用实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> it *<span class="type">int</span></span><br><span class="line">it = &amp;a</span><br><span class="line">fmt.Println(it)</span><br><span class="line">fmt.Println(*it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺带一提，如果不给指针变量赋值，其值为<code>nil</code>，大小为0；</p><p>可以通过语句来判断一个指针是值为0还是是空指针：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ptr != <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="Go语言结构体："><a href="#Go语言结构体：" class="headerlink" title="Go语言结构体："></a>Go语言结构体：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> struct_variable_type <span class="keyword">struct</span> &#123;</span><br><span class="line">   member definition</span><br><span class="line">   member definition</span><br><span class="line">   ...</span><br><span class="line">   member definition</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个简单的实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">name  <span class="type">string</span></span><br><span class="line">ID    <span class="type">string</span></span><br><span class="line">score <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新的结构体</span></span><br><span class="line">fmt.Println(Student&#123;<span class="string">&quot;Lihua&quot;</span>, <span class="string">&quot;110&quot;</span>, <span class="string">&quot;59&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以使用 key =&gt; value 格式</span></span><br><span class="line">fmt.Println(Student&#123;name: <span class="string">&quot;XiaoLihua&quot;</span>, ID: <span class="string">&quot;250&quot;</span>, score: <span class="string">&quot;99&quot;</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="切片Slice"><a href="#切片Slice" class="headerlink" title="切片Slice"></a><strong>切片Slice</strong></h2><h3 id="定义切片："><a href="#定义切片：" class="headerlink" title="定义切片："></a>定义切片：</h3><p>切片实质上就是一个变长数组；</p><p>声明一个未指定大小的数组来定义切片：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> identifier []<span class="keyword">type</span></span><br></pre></td></tr></table></figure><p>或者使用make()函数来创建切片：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice1 []<span class="keyword">type</span> = <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br><span class="line"><span class="comment">//也可以简写为</span></span><br><span class="line">slice1 := <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br></pre></td></tr></table></figure><p>当然，必要时也可以指定容量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T, length, capacity)</span><br></pre></td></tr></table></figure><h3 id="len-和cap-函数："><a href="#len-和cap-函数：" class="headerlink" title="len()和cap()函数："></a>len()和cap()函数：</h3><p>应用实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> numbers = <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">   printSlice(numbers)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="空-nil-切片："><a href="#空-nil-切片：" class="headerlink" title="空(nil)切片："></a>空(nil)切片：</h3><p>一个切片在未初始化之前默认为 nil，长度为 0，实例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> numbers []<span class="type">int</span></span><br><span class="line"></span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(numbers == <span class="literal">nil</span>)&#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;切片是空的&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="切片截取："><a href="#切片截取：" class="headerlink" title="切片截取："></a>切片截取：</h3><p>demo：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;len = %d cap = %d slice = %v\n&quot;</span>, <span class="built_in">len</span>(x), <span class="built_in">cap</span>(x), x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//Create the slice</span></span><br><span class="line">num := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line">printSlice(num)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Print the original slice</span></span><br><span class="line">fmt.Println(<span class="string">&quot;num = &quot;</span>, num)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Print sub_slice from idx1(include) to idx4(not include)</span></span><br><span class="line">fmt.Println(<span class="string">&quot;num[1:4] == &quot;</span>, num[<span class="number">1</span>:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">//If the r_index is not defined, it will be 0 and len(s), just like:</span></span><br><span class="line">fmt.Println(<span class="string">&quot;num[:3] == &quot;</span>, num[:<span class="number">3</span>])</span><br><span class="line">fmt.Println(<span class="string">&quot;num[4:] == &quot;</span>, num[<span class="number">4</span>:])</span><br><span class="line"></span><br><span class="line">num1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">printSlice(num1)</span><br><span class="line"></span><br><span class="line">num2 := num[:<span class="number">2</span>]</span><br><span class="line">printSlice(num2)</span><br><span class="line"></span><br><span class="line">num3 := num[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">printSlice(num3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="append-和copy-函数："><a href="#append-和copy-函数：" class="headerlink" title="append()和copy()函数："></a>append()和copy()函数：</h3><p>demo：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;len = %d cap = %d slice = %v\n&quot;</span>, <span class="built_in">len</span>(x), <span class="built_in">cap</span>(x), x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> num []<span class="type">int</span></span><br><span class="line">printSlice(num)</span><br><span class="line"></span><br><span class="line">num = <span class="built_in">append</span>(num, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">printSlice(num)</span><br><span class="line"></span><br><span class="line">num1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(num), (<span class="built_in">cap</span>(num))*<span class="number">2</span>)</span><br><span class="line"><span class="built_in">copy</span>(num1, num)</span><br><span class="line">printSlice(num1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="范围Range"><a href="#范围Range" class="headerlink" title="范围Range"></a><strong>范围Range</strong></h2><p>range 关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。在数组和切片中它返回元素的索引和索引对应的值，在集合中返回 key-value 对。</p><p>实际上也可以省略，这里先不省略；</p><p>demo：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num1 = [...]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//num2 := [9]int&#123;9, 8, 7, 6, 5, 4, 3, 2, 1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i, val := <span class="keyword">range</span> num1 &#123;</span><br><span class="line">fmt.Println(i, <span class="string">&quot; &quot;</span>, val)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">8</span>; i++ &#123;</span><br><span class="line">fmt.Print(num1[i], <span class="string">&quot; &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="集合Map"><a href="#集合Map" class="headerlink" title="集合Map"></a><strong>集合Map</strong></h2><p>Map 是一种<strong>无序</strong>的键值对的集合。Map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。</p><p>Map 是一种集合，所以我们可以像迭代数组和切片那样迭代它。不过，Map 是无序的，我们无法决定它的返回顺序，这是因为 Map 是使用 hash 表来实现的。</p><h3 id="定义Map："><a href="#定义Map：" class="headerlink" title="定义Map："></a>定义Map：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map_variable := <span class="built_in">make</span>(<span class="keyword">map</span>[key_data_type]value_data_type)<span class="comment">//init</span></span><br></pre></td></tr></table></figure><p>demo：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> StudentNumber <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span></span><br><span class="line">StudentNumber = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">StudentNumber[<span class="number">1</span>] = <span class="string">&quot;小明&quot;</span></span><br><span class="line">StudentNumber[<span class="number">2</span>] = <span class="string">&quot;草泥马&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> num := <span class="keyword">range</span> StudentNumber &#123;</span><br><span class="line">fmt.Println(StudentNumber[num], <span class="string">&quot;的学号是&quot;</span>, num)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="delete-函数："><a href="#delete-函数：" class="headerlink" title="delete()函数："></a>delete()函数：</h3><p>注意，删除的是key，而不是value（其实也很好理解）</p><p>demo：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//var StudentNumber map[int]string</span></span><br><span class="line">StudentNumber := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">StudentNumber[<span class="number">1</span>] = <span class="string">&quot;小明&quot;</span></span><br><span class="line">StudentNumber[<span class="number">2</span>] = <span class="string">&quot;草泥马&quot;</span></span><br><span class="line">StudentNumber[<span class="number">3</span>] = <span class="string">&quot;仙人&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> num := <span class="keyword">range</span> StudentNumber &#123;</span><br><span class="line">fmt.Println(StudentNumber[num], <span class="string">&quot;的学号是&quot;</span>, num)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;---------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">delete</span>(StudentNumber, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> num := <span class="keyword">range</span> StudentNumber &#123;</span><br><span class="line">fmt.Println(StudentNumber[num], <span class="string">&quot;的学号是&quot;</span>, num)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="类型转换与接口"><a href="#类型转换与接口" class="headerlink" title="类型转换与接口"></a><strong>类型转换与接口</strong></h2><h3 id="类型转换："><a href="#类型转换：" class="headerlink" title="类型转换："></a>类型转换：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum <span class="type">int</span> = <span class="number">13</span></span><br><span class="line">    <span class="keyword">var</span> cnt <span class="type">int</span> = <span class="number">5</span></span><br><span class="line">    <span class="keyword">var</span> ans <span class="type">float32</span></span><br><span class="line">    </span><br><span class="line">    ans = <span class="type">float32</span>(sum) / <span class="type">float32</span>(cnt)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;ans = %f\n&quot;</span>, cnt)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口："><a href="#接口：" class="headerlink" title="接口："></a>接口：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">interface</span> &#123; <span class="comment">//定义接口</span></span><br><span class="line">call()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NokiaPhone <span class="keyword">struct</span> &#123; <span class="comment">//定义结构体</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IPhone <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nokia1 NokiaPhone)</span></span> call() &#123; <span class="comment">//实现接口方法</span></span><br><span class="line">fmt.Println(<span class="string">&quot;I am NOKIA god, I will punish you!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(iphone1 IPhone)</span></span> call() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;I am APPLE god, I will punish you!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> phone Phone</span><br><span class="line">phone = <span class="built_in">new</span>(NokiaPhone)</span><br><span class="line">phone.call()</span><br><span class="line"></span><br><span class="line">phone = <span class="built_in">new</span>(IPhone)</span><br><span class="line">phone.call()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="错误处理与大并发"><a href="#错误处理与大并发" class="headerlink" title="错误处理与大并发"></a><strong>错误处理与大并发</strong></h2><h3 id="错误处理："><a href="#错误处理：" class="headerlink" title="错误处理："></a>错误处理：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个 DivideError 结构</span></span><br><span class="line"><span class="keyword">type</span> DivideError <span class="keyword">struct</span> &#123;</span><br><span class="line">dividee <span class="type">int</span></span><br><span class="line">divider <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 `error` 接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(de *DivideError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">strFormat := <span class="string">`</span></span><br><span class="line"><span class="string">    Cannot proceed, the divider is zero.</span></span><br><span class="line"><span class="string">    dividee: %d</span></span><br><span class="line"><span class="string">    divider: 0</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(strFormat, de.dividee)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 `int` 类型除法运算的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Divide</span><span class="params">(varDividee <span class="type">int</span>, varDivider <span class="type">int</span>)</span></span> (result <span class="type">int</span>, errorMsg <span class="type">string</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> varDivider == <span class="number">0</span> &#123;</span><br><span class="line">dData := DivideError&#123;</span><br><span class="line">dividee: varDividee,</span><br><span class="line">divider: varDivider,</span><br><span class="line">&#125;</span><br><span class="line">errorMsg = dData.Error()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> varDividee / varDivider, <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常情况</span></span><br><span class="line"><span class="keyword">if</span> result, errorMsg := Divide(<span class="number">100</span>, <span class="number">10</span>); errorMsg == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;100/10 = &quot;</span>, result)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当除数为零的时候会返回错误信息</span></span><br><span class="line"><span class="keyword">if</span> _, errorMsg := Divide(<span class="number">100</span>, <span class="number">0</span>); errorMsg != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;errorMsg is: &quot;</span>, errorMsg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并发初步："><a href="#并发初步：" class="headerlink" title="并发初步："></a>并发初步：</h3><p>通过go关键字来开启goroutine;</p><p>goroutine是一个<strong>轻量级线程</strong>，其调度是由Golang运行时进行管理的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(str <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">fmt.Println(str)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> say(<span class="string">&quot;World&quot;</span>)</span><br><span class="line">say(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此，就会无序交替输出<code>World</code>以及 <code>Hello</code>；</p><h3 id="通道-channel-："><a href="#通道-channel-：" class="headerlink" title="通道(channel)："></a>通道(channel)：</h3><p>通道是用来传递数据的一个<strong>数据结构</strong>，可以用于两个goroutine之间，通过传递一个指定类型的值来同步运行和通讯。</p><p>操作符<code>&lt;-</code>用于指定通道的<strong>方向</strong>，实现发送or接收；</p><p>特别地，若未指定方向，则为<strong>双向通道</strong>；</p><p>通道在使用前必须先创建；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- v    <span class="comment">// 把 v 发送到通道 ch</span></span><br><span class="line">v := &lt;-ch  <span class="comment">// 从 ch 接收数据   并把值赋给 v</span></span><br></pre></td></tr></table></figure><p>通道使用实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(s []<span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">sum += v</span><br><span class="line">&#125;</span><br><span class="line">c &lt;- sum <span class="comment">//将sum发送到通道c</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) <span class="comment">//声明通道</span></span><br><span class="line"><span class="keyword">go</span> sum(s[:<span class="built_in">len</span>(s)/<span class="number">2</span>], c)</span><br><span class="line"><span class="keyword">go</span> sum(s[<span class="built_in">len</span>(s)/<span class="number">2</span>:], c)</span><br><span class="line">x, y := &lt;-c, &lt;-c <span class="comment">//从通道c中接收</span></span><br><span class="line">fmt.Println(x, y, x+y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通道缓冲区："><a href="#通道缓冲区：" class="headerlink" title="通道缓冲区："></a>通道缓冲区：</h3><p>在用make声明通道的时候可以通过添加第二个参数来指定<strong>缓冲区的大小</strong>；</p><p><em>如果通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。**——runoob</em></p><p>缓冲区应用实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 这里我们定义了一个可以存储整数类型的带缓冲通道</span></span><br><span class="line"><span class="comment">// 缓冲区大小为2</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为 ch 是带缓冲的通道，我们可以同时发送两个数据</span></span><br><span class="line"><span class="comment">// 而不用立刻需要去同步读取数据</span></span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">ch &lt;- <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取这两个数据</span></span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Go-遍历通道与关闭通道"><a href="#Go-遍历通道与关闭通道" class="headerlink" title="Go 遍历通道与关闭通道"></a>Go 遍历通道与关闭通道</h3><p>通过 range 关键字来实现遍历读取到的数据；</p><p>样例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">c &lt;- x</span><br><span class="line">x, y = y, x+y</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line"><span class="comment">// range 函数遍历每个从通道接收到的数据，因为 c 在发送完 10 个</span></span><br><span class="line"><span class="comment">// 数据之后就关闭了通道，所以这里我们 range 函数在接收到 10 个数据</span></span><br><span class="line"><span class="comment">// 之后就结束了。如果上面的 c 通道不关闭，那么 range 函数就不</span></span><br><span class="line"><span class="comment">// 会结束，从而在接收第 11 个数据的时候就阻塞了。</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="前进-·-并发深入与内置函数："><a href="#前进-·-并发深入与内置函数：" class="headerlink" title="前进 · 并发深入与内置函数："></a><strong>前进 · 并发深入与内置函数：</strong></h1><h2 id="内置函数："><a href="#内置函数：" class="headerlink" title="内置函数："></a>内置函数：</h2><h3 id="计时器："><a href="#计时器：" class="headerlink" title="计时器："></a>计时器：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">startTime := time.Now()</span><br><span class="line">...</span><br><span class="line">elapsedTime := time.Since(startTime)</span><br><span class="line">fmt.Println(<span class="string">&quot;time pass: &quot;</span>, elapsedTime)</span><br></pre></td></tr></table></figure><p>另一种：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StartTime := time.Now().UnixNano()</span><br><span class="line">...</span><br><span class="line">EndTime := time.Now().UnixNano()</span><br><span class="line">NanoSecond := <span class="type">float64</span>(Endtime - Starttime)</span><br><span class="line">fmt.Println(NanoSecond)</span><br></pre></td></tr></table></figure><hr><h3 id="defer语句："><a href="#defer语句：" class="headerlink" title="defer语句："></a>defer语句：</h3><p>加上defer之后就会进入一个栈内，如下程序输出结果就是333 222 111</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;111&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;222&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;333&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="init函数："><a href="#init函数：" class="headerlink" title="init函数："></a>init函数：</h3><p>程序初始化顺序：<code>变量初始化</code> -&gt; <code>init()</code> -&gt; <code>main()</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v <span class="type">int</span> = VarInit()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;INITIALIZE!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">VarInit</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;The initialize of var is completed!&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">110</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;111&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;222&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;333&quot;</span>)</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="并发的深入："><a href="#并发的深入：" class="headerlink" title="并发的深入："></a>并发的深入：</h2><h3 id="再遇channel："><a href="#再遇channel：" class="headerlink" title="再遇channel："></a>再遇channel：</h3><h4 id="channel的遍历（多方法）"><a href="#channel的遍历（多方法）" class="headerlink" title="channel的遍历（多方法）"></a>channel的遍历（多方法）</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法1：for循环 + if判断</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">//通过go命令发起的轻量级线程的匿名函数</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">c &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> data, ok := &lt;-c; ok &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;data: %v\n&quot;</span>, data)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2：for + range</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">//通过go命令发起的轻量级线程的匿名函数</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">c &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> data := <span class="keyword">range</span> c &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;data: %v\n&quot;</span>, data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得一提的是，如果没有<code>close(c)</code>来关闭通道，则会出现死锁输出：</p><p><code>fatal error: all goroutines are asleep - deadlock!</code></p><hr><h3 id="WaitGroup实现同步："><a href="#WaitGroup实现同步：" class="headerlink" title="WaitGroup实现同步："></a>WaitGroup实现同步：</h3><p>同步的含义：两个或多个协程之间互相等待，而不是顺次执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ECHO</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">fmt.Println(<span class="string">&quot;VOICE_ECHO&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> ECHO(i)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="runtime包："><a href="#runtime包：" class="headerlink" title="runtime包："></a>runtime包：</h3><p>runtime包里面定义了一些携程管理相关的API</p><h3 id="runtime-Gosched"><a href="#runtime-Gosched" class="headerlink" title="runtime.Gosched()"></a>runtime.Gosched()</h3><p><strong>高风亮节</strong>地让出CPU时间片，重新等待安排任务；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i &gt;= <span class="number">5</span> &#123;</span><br><span class="line">runtime.Goexit()</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;i: %v\n&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;I am the function show()&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> show()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="runtime-Goexit"><a href="#runtime-Goexit" class="headerlink" title="runtime.Goexit()"></a>runtime.Goexit()</h4><p>可以退出当前协程，目前还不知道有什么特别好的用处…</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i &gt;= <span class="number">5</span> &#123;</span><br><span class="line">runtime.Goexit()</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;i: %v\n&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;I am the function show()&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> show()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="runtime-GOMAXPROCS"><a href="#runtime-GOMAXPROCS" class="headerlink" title="runtime.GOMAXPROCS"></a>runtime.GOMAXPROCS</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;a: %v  &quot;</span>, i)</span><br><span class="line"><span class="comment">//当然 如果在每一次输出之后都sleep一小会儿，即使使用单核也会交替输出</span></span><br><span class="line"><span class="comment">//time.Sleep(time.Millisecond * 100)</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;b: %v  &quot;</span>, i)</span><br><span class="line"><span class="comment">//time.Sleep(time.Millisecond * 100)</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;runtime.NumCPU() = &quot;</span>, runtime.NumCPU())</span><br><span class="line"><span class="comment">//runtime.GOMAXPROCS(1)</span></span><br><span class="line"><span class="keyword">go</span> a()</span><br><span class="line"><span class="keyword">go</span> b()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Mutex互斥锁实现同步："><a href="#Mutex互斥锁实现同步：" class="headerlink" title="Mutex互斥锁实现同步："></a>Mutex互斥锁实现同步：</h3><p>除了使用channel实现同步之外，还可以使用Mutex互斥锁来实现同步。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m <span class="type">int</span> = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lock sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wt sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Addfunc</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wt.Done()</span><br><span class="line">lock.Lock()</span><br><span class="line">m += <span class="number">1</span></span><br><span class="line">time.Sleep(time.Millisecond * <span class="number">10</span>)</span><br><span class="line">lock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Subfunc</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wt.Done()</span><br><span class="line">lock.Lock()</span><br><span class="line">time.Sleep(time.Millisecond * <span class="number">2</span>)</span><br><span class="line">m -= <span class="number">1</span></span><br><span class="line">lock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">wt.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> Addfunc()</span><br><span class="line">wt.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> Subfunc()</span><br><span class="line"><span class="keyword">if</span> i%<span class="number">1000</span> == <span class="number">0</span> &#123;</span><br><span class="line">fmt.Println(m)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//wt.Wait()</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;End val: &quot;</span>, m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到两个进程同时交替进行，输出结果有来有回。</p><hr><h3 id="select："><a href="#select：" class="headerlink" title="select："></a>select：</h3><p>select是Go中的一个控制结构，类似于switch的功能，用于处理<em>异步IO操作</em>；</p><p>select会监听case语句中channel的读写操作；</p><p>当case中channel读写操作为非阻塞状态时，则会触发相应动作。</p><p>特别说明：</p><p><code>select中的case语句必须是一个channel操作</code></p><p><code>select中的default子句总是可运行的</code></p><p><code>如果有多个case都可运行，select会随机公平地选出一个执行</code></p><p><code>如果没有可运行的case语句，但是有default语句，则会直接执行default语句</code></p><p><code>如果没有可运行的case语句，并且没有default语句，则select会阻塞直至某个case可以运行</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> chanInt = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">var</span> chanStr = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">chanInt &lt;- <span class="number">100</span></span><br><span class="line">chanStr &lt;- <span class="string">&quot;MAGA&quot;</span></span><br><span class="line"><span class="built_in">close</span>(chanInt)</span><br><span class="line"><span class="built_in">close</span>(chanStr)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> r := &lt;-chanInt:</span><br><span class="line">fmt.Printf(<span class="string">&quot;chanInt: %v\n&quot;</span>, r)</span><br><span class="line"><span class="keyword">case</span> r := &lt;-chanStr:</span><br><span class="line">fmt.Printf(<span class="string">&quot;chanStr: %v\n&quot;</span>, r)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;DEFAULT!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Timer："><a href="#Timer：" class="headerlink" title="Timer："></a>Timer：</h3><p>定时器，内部通过channel实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">timer1 := time.NewTimer(time.Second * <span class="number">2</span>)</span><br><span class="line">t1 := time.Now()</span><br><span class="line">fmt.Printf(<span class="string">&quot;t1: %v\n&quot;</span>, t1) <span class="comment">//看看当前的时间</span></span><br><span class="line"></span><br><span class="line">t2 := &lt;-timer1.C <span class="comment">//这个C是管道的意思</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;t2: %v\n&quot;</span>, t2)</span><br><span class="line"></span><br><span class="line">&lt;-time.After(time.Second * <span class="number">1</span>) <span class="comment">//time.After的返回值是chan Time</span></span><br><span class="line">fmt.Println(<span class="string">&quot;时间流逝了一会儿...&quot;</span>)</span><br><span class="line"></span><br><span class="line">timer2 := time.NewTimer(time.Second)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">&lt;-timer2.C</span><br><span class="line">fmt.Println(<span class="string">&quot;This is timer2&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">stop := timer2.Stop() <span class="comment">//停止定时器</span></span><br><span class="line"><span class="comment">//阻止timer事件发生，当该函数执行后，timer计时器停止，相应的事件不再执行</span></span><br><span class="line"><span class="keyword">if</span> stop &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Timer is stopped!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;&gt;&gt;&gt;BEFORE&quot;</span>)</span><br><span class="line">timer3 := time.NewTimer(time.Second * <span class="number">5</span>)</span><br><span class="line">timer3.Reset(time.Second * <span class="number">1</span>)</span><br><span class="line">&lt;-timer3.C</span><br><span class="line">fmt.Println(<span class="string">&quot;AFTER&lt;&lt;&lt;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Ticket："><a href="#Ticket：" class="headerlink" title="Ticket："></a>Ticket：</h3><p>Timer只执行一次，Ticker可以周期地执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ticker := time.NewTicker(time.Second)</span><br><span class="line">counter := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> _ = <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;ticker 1&quot;</span>)</span><br><span class="line">counter++</span><br><span class="line"><span class="keyword">if</span> counter &gt;= <span class="number">5</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ticker.Stop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">chanInt := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">ticker := time.NewTicker(time.Second)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _ = <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> chanInt &lt;- <span class="number">1</span>:</span><br><span class="line"><span class="keyword">case</span> chanInt &lt;- <span class="number">2</span>:</span><br><span class="line"><span class="keyword">case</span> chanInt &lt;- <span class="number">3</span>:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> chanInt &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Receive: %v\n&quot;</span>, v)</span><br><span class="line">sum += v</span><br><span class="line"><span class="keyword">if</span> sum &gt;= <span class="number">10</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;sum: %v\n&quot;</span>, sum)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="原子变量与原子操作："><a href="#原子变量与原子操作：" class="headerlink" title="原子变量与原子操作："></a>原子变量与原子操作：</h3><p>一个简单的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x <span class="type">int32</span> = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//atomic内部是一个compare ans swap, 简称cas, 会在加减操作之前先比较old new两个值再进行操作</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f_add</span><span class="params">()</span></span> &#123;</span><br><span class="line">atomic.AddInt32(&amp;x, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f_sub</span><span class="params">()</span></span> &#123;</span><br><span class="line">atomic.AddInt32(&amp;x, <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">f_add()</span><br><span class="line">f_sub()</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;x: %v\n&quot;</span>, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>atomic提供的原子操作能够确保任意时刻只有一个goroutine对变量进行操作，</p><p>善用atomic能够避免程序中出现大量的锁操作。</p><p>atomic的常见操作：</p><ul><li>增减</li><li>载入 read</li><li>cas</li><li>交换</li><li>存储 write</li></ul><hr><h1 id="探索-·-GoLang标准库"><a href="#探索-·-GoLang标准库" class="headerlink" title="探索 · GoLang标准库"></a><strong>探索 · GoLang标准库</strong></h1><p>可以参考：<a href="https://pkg.go.dev/std">https://pkg.go.dev/std</a></p><h2 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a>os模块</h2><p>os标准库实现了平台（操作系统）无关的编程接口。</p><h3 id="文件目录相关"><a href="#文件目录相关" class="headerlink" title="文件目录相关"></a>文件目录相关</h3><p>demo1：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateFile</span><span class="params">()</span></span> &#123;</span><br><span class="line">f, err0 := os.Create(<span class="string">&quot;CreateFileTest.txt&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err0 != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;err: &quot;</span>, err0)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;f: &quot;</span>, f)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//值得一提的是，如果同名文件已经存在，则此操作会进行覆盖</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeDir</span><span class="params">()</span></span> &#123;</span><br><span class="line">err1 := os.Mkdir(<span class="string">&quot;MakeDirTest&quot;</span>, os.ModePerm)</span><br><span class="line"><span class="keyword">if</span> err1 != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;err1: %v\n&quot;</span>, err1)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RemoveDir</span><span class="params">()</span></span> &#123;</span><br><span class="line">err2 := os.RemoveAll(<span class="string">&quot;MakeDirTest&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err2 != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;err2: %v\n&quot;</span>, err2)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetWorkDir</span><span class="params">()</span></span> &#123;</span><br><span class="line">dir, err3 := os.Getwd()</span><br><span class="line"><span class="keyword">if</span> err3 != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;err3: %v\n&quot;</span>, err3)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;dir: %v\n&quot;</span>, dir)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ChangeWorkDir</span><span class="params">()</span></span> &#123;</span><br><span class="line">err4 := os.Chdir(<span class="string">&quot;D:/Coding/Git&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err4 != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;err4: %v\n&quot;</span>, err4)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(os.Getwd())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetTempDir</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := os.TempDir()</span><br><span class="line">fmt.Printf(<span class="string">&quot;s: %v\n&quot;</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RenameFile</span><span class="params">()</span></span> &#123;</span><br><span class="line">err5 := os.Rename(<span class="string">&quot;CreateFileTest.txt&quot;</span>, <span class="string">&quot;RenameTest.txt&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err5 != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;err5: %v\n&quot;</span>, err5)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">()</span></span> &#123;</span><br><span class="line">str, err6 := os.ReadFile(<span class="string">&quot;IO.txt&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err6 != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;err6: %v\n&quot;</span>, err6)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;string(str[:]):\n%v\n&quot;</span>, <span class="type">string</span>(str[:])) <span class="comment">//获取了一个切片</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteFile</span><span class="params">()</span></span> &#123;</span><br><span class="line">str1 := <span class="string">&quot;YOUR MAMA BOOM!&quot;</span></span><br><span class="line">os.WriteFile(<span class="string">&quot;IO.txt&quot;</span>, []<span class="type">byte</span>(str1), os.ModePerm)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//CreateFile()</span></span><br><span class="line"><span class="comment">//MakeDir()</span></span><br><span class="line"><span class="comment">//RemoveDir()</span></span><br><span class="line"><span class="comment">//GetWorkDir()</span></span><br><span class="line"><span class="comment">//GetTempDir()</span></span><br><span class="line"><span class="comment">//RenameFile()</span></span><br><span class="line"><span class="comment">//ReadFile()</span></span><br><span class="line"><span class="comment">//WriteFile()</span></span><br><span class="line"><span class="comment">//ReadFile()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demo2：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenCloseFile</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//Only read</span></span><br><span class="line">f1, err1 := os.Open(<span class="string">&quot;IO.txt&quot;</span>) <span class="comment">//err如果写成_的意思是不做处理</span></span><br><span class="line"><span class="keyword">if</span> err1 != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;err1: %v\n&quot;</span>, err1)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;f1.Name(): %v\n&quot;</span>, f1.Name())</span><br><span class="line">f1.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//还有一种更加高级且更直接的打开文件的方式，并且根据第二个参数 可以读写or创建，权限设置与Linux相同</span></span><br><span class="line">f2, err2 := os.OpenFile(<span class="string">&quot;IO1.txt&quot;</span>, os.O_RDWR|os.O_CREATE, <span class="number">0755</span>) <span class="comment">//可读可写，没有就创建一个，0755的权限设置</span></span><br><span class="line"><span class="keyword">if</span> err2 != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;err2: %v\n&quot;</span>, err2)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;f2.Name(): %v\n&quot;</span>, f2.Name())</span><br><span class="line">f2.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateFile</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 等价于OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, 0666)</span></span><br><span class="line">f1, err1 := os.Create(<span class="string">&quot;CreateFileTest.txt&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err1 != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;err1: %v\n&quot;</span>, err1)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;f1.Name(): %v\n&quot;</span>, f1.Name())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第1个参数 目录默认：Temp 第2个参数 文件名前缀</span></span><br><span class="line">f2, err2 := os.CreateTemp(<span class="string">&quot;&quot;</span>, <span class="string">&quot;Temp&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err2 != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;err2: %v\n&quot;</span>, err2)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;f2.Name(): %v\n&quot;</span>, f2.Name())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadOps</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//由于我们多数情况下并不知道要读的文件有多大，所以防止读取不全的情况发生，采用循环读取的方法</span></span><br><span class="line">f, _ := os.Open(<span class="string">&quot;IO.txt&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">10</span>) <span class="comment">//缓冲区的创建</span></span><br><span class="line">n, err := f.Read(buf)</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;n: %v\n&quot;</span>, n)</span><br><span class="line">fmt.Printf(<span class="string">&quot;string(buf): %v\n&quot;</span>, <span class="type">string</span>(buf))</span><br><span class="line">&#125;</span><br><span class="line">f.Close()</span><br><span class="line"></span><br><span class="line">f1, _ := os.Open(<span class="string">&quot;IO.txt&quot;</span>)</span><br><span class="line">buf1 := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">5</span>)</span><br><span class="line">n1, _ := f1.ReadAt(buf1, <span class="number">2</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;\n--------------------------------&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;n1: %v\n&quot;</span>, n1)</span><br><span class="line">fmt.Printf(<span class="string">&quot;string(buf1): %v\n&quot;</span>, <span class="type">string</span>(buf1))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Read_Dir</span><span class="params">()</span></span> &#123;</span><br><span class="line">de, _ := os.ReadDir(<span class="string">&quot;pkg&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> de &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;v.IsDir(): %v\n&quot;</span>, v.IsDir())</span><br><span class="line">fmt.Printf(<span class="string">&quot;v.Name(): %v\n&quot;</span>, v.Name())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Locate</span><span class="params">()</span></span> &#123;</span><br><span class="line">f, _ := os.Open(<span class="string">&quot;IO.txt&quot;</span>)</span><br><span class="line">f.Seek(<span class="number">4</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">//Seek设置下一次读/写的位置。</span></span><br><span class="line"><span class="comment">//offset为相对偏移量，而whence决定相对位置：0为相对文件开头，1为相对当前位置，2为相对文件结尾。</span></span><br><span class="line"><span class="comment">//它返回新的偏移量（相对开头）和可能的错误。</span></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">10</span>)</span><br><span class="line">n, _ := f.Read(buf)</span><br><span class="line">fmt.Printf(<span class="string">&quot;n: %v\n&quot;</span>, n)</span><br><span class="line">fmt.Printf(<span class="string">&quot;string(buf): %v\n&quot;</span>, <span class="type">string</span>(buf))</span><br><span class="line">f.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//OpenCloseFile()</span></span><br><span class="line"><span class="comment">//CreateFile()</span></span><br><span class="line"><span class="comment">//ReadOps()</span></span><br><span class="line"><span class="comment">//Read_Dir()</span></span><br><span class="line">Locate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="io包"><a href="#io包" class="headerlink" title="io包"></a>io包</h2><hr><h2 id="ioutil包"><a href="#ioutil包" class="headerlink" title="ioutil包"></a>ioutil包</h2><hr><h2 id="bufio"><a href="#bufio" class="headerlink" title="bufio"></a>bufio</h2><hr><h2 id="log"><a href="#log" class="headerlink" title="log"></a>log</h2><hr><h2 id="builtin"><a href="#builtin" class="headerlink" title="builtin"></a>builtin</h2><hr><h2 id="bytes"><a href="#bytes" class="headerlink" title="bytes"></a>bytes</h2><hr><h2 id="errors"><a href="#errors" class="headerlink" title="errors"></a>errors</h2><hr><h2 id="sort包"><a href="#sort包" class="headerlink" title="sort包"></a>sort包</h2><hr><h2 id="time"><a href="#time" class="headerlink" title="time"></a>time</h2><hr><h2 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h2><hr><h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><hr><h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a><strong>HTTP协议</strong></h1><p>超文本传输协议(Hyper Text Transfer Protocol)是一种用于分布式、协作式和超媒体信息系统的<strong>应用层协议</strong>。HTTP是万维网的数据通信的基础。它是基于<strong>TCP协议</strong>的应用层传输协议，简单来说就是客户端和服务端进行<strong>数据传输</strong>的一种规则。</p><p>详细内容可以参考：<a href="https://zhuanlan.zhihu.com/p/45173862">深入理解HTTP协议 - 知乎 (zhihu.com)</a></p><h2 id="HTTP协议概述"><a href="#HTTP协议概述" class="headerlink" title="HTTP协议概述"></a>HTTP协议概述</h2><p><code>HTTP</code> 是一种<strong>无状态</strong> (stateless) 协议, <code>HTTP</code>协议本身<em>不会对发送过的请求和相应的通信状态进行持久化处理</em>。</p><p>这样做的目的是为了保持HTTP协议的<strong>简单性</strong>，从而能够快速处理大量的事务, 提高效率。</p><p>然而，在许多应用场景中，我们需要保持用户登录的状态或记录用户购物车中的商品。</p><p>由于<code>HTTP</code>是无状态协议，所以必须引入一些技术来记录管理状态，例如<code>Cookie</code>。</p><h2 id="HTTP工作原理"><a href="#HTTP工作原理" class="headerlink" title="HTTP工作原理"></a>HTTP工作原理</h2><p>请求request - 响应response</p><p>HTTP请求由<strong>请求行</strong>，<strong>消息报头</strong>，<strong>请求正文</strong>三部分构成。</p><p>​其中，<strong>请求行</strong>由请求<code>Method</code>, <code>URL</code> 字段和<code>HTTP Version</code>三部分构成, 总的来说请求行就是定义了本次请求的请求方式, 请求的地址, 以及所遵循的HTTP协议版本例如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /example.html HTTP/1.1 (CRLF)</span><br></pre></td></tr></table></figure><h3 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h3><h3 id="无连接"><a href="#无连接" class="headerlink" title="无连接"></a>无连接</h3><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><h2 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h2><p>HTTP协议的方法有： </p><ul><li><code>GET</code>： 请求<strong>获取</strong>Request-URI所标识的资源</li><li><code>POST</code>： 在Request-URI所标识的资源后<strong>增加</strong>新的数据 </li><li><code>HEAD</code>： 请求获取由Request-URI所标识的资源的<strong>响应消息报头</strong></li><li><code>PUT</code>： 请求服务器<strong>存储或修改</strong>一个资源，并用Request-URI作为其标识</li><li><code>DELETE</code>： 请求服务器<strong>删除</strong>Request-URI所标识的资源</li><li><code>TRACE</code>： 请求服务器回送收到的请求信息，主要用于<strong>测试或诊断</strong> </li><li><code>CONNECT</code>： 保留将来使用</li><li><code>OPTIONS</code>： 请求查询服务器的性能，或者查询与资源关的选项和需求</li></ul><h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><p>状态代码有三位数字组成，第一个数字定义了响应的<strong>类别</strong>，且有五种可能取值：</p><ul><li><code>1xx</code>：<strong>指示信息</strong> - 表示请求已接收，继续处理</li><li><code>2xx</code>：<strong>成功</strong> - 表示请求已被成功接收、理解、接受 </li><li><code>3xx</code>：<strong>重定向</strong> - 要完成请求必须进行更进一步的操作</li><li><code>4xx</code>：<strong>客户端错误</strong> - 请求有语法错误或请求无法实现</li><li><code>5xx</code>：<strong>服务器端错误</strong> - 服务器未能实现合法的请求</li></ul><p>常见状态代码、状态描述、说明：</p><ul><li><code>200</code>： <strong>OK</strong> - 客户端请求成功</li><li><code>400</code>： <strong>Bad Request</strong> - 客户端请求有语法错误，不能被服务器所理解</li><li><code>401</code>： <strong>Unauthorized</strong> - 请求未经授权，这个状态代码必须和<code>WWW-Authenticate</code>报头域一起使用</li><li><code>403</code>： <strong>Forbidden</strong> - 服务器收到请求，但是拒绝提供服务</li><li><code>404</code>： <strong>Not Found</strong> - 请求资源不存在，eg：输入了错误的URL</li><li><code>500</code>： <strong>Internal Server Error</strong> - 服务器发生不可预期的错误</li><li><code>503</code>： <strong>Server Unavailable</strong> - 服务器当前不能处理客户端的请求，一段时间后,可能恢复正常</li></ul><h2 id="Restful风格编程"><a href="#Restful风格编程" class="headerlink" title="Restful风格编程"></a>Restful<strong>风格编程</strong></h2><p>REST (Representational State Transfer)描述了一个架构样式的网络系统，例如web应用程序。</p><p>基本理念：合理并简洁的设计URL，并且能对资源进行<code>POST</code> <code>DELETE</code> <code>PUT</code> <code>GET</code>增删改查的操作。</p><hr><h1 id="GoLang-HTTP标准库"><a href="#GoLang-HTTP标准库" class="headerlink" title="GoLang HTTP标准库"></a><strong>GoLang HTTP标准库</strong></h1><p>市面上所有的GoLangWeb框架都是基于HTTP标准库实现的。</p><h2 id="HTTP标准库客户端功能"><a href="#HTTP标准库客户端功能" class="headerlink" title="HTTP标准库客户端功能"></a>HTTP标准库客户端功能</h2><h3 id="发出GET请求"><a href="#发出GET请求" class="headerlink" title="发出GET请求"></a>发出GET请求</h3><p>使用API，需要知道<code>请求key</code></p><p>新建一个Go_Project，用VSCode打开，在终端输入<code>go mod init 网址</code>就可以初始化go.mod；</p><p>紧接着<code>go mod tidy</code>进行清除操作</p><p>测试代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGet</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//https://www.juhe.cn/box/index/id/73</span></span><br><span class="line">url := <span class="string">&quot;https://conqueror712.gitee.io/conqueror712.gitee.io/&quot;</span> <span class="comment">//接口地址</span></span><br><span class="line">response, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> response.Body.Close()           <span class="comment">//函数结束后关闭响应</span></span><br><span class="line">b, _ := ioutil.ReadAll(response.Body) <span class="comment">//返回字节切片</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;b: %v\n&quot;</span>, <span class="type">string</span>(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，还有一种方法可以把GET请求的一些参数<strong>做成变量</strong>，而不是直接放到URL中；</p><p>需要用<code>params</code>中文内容需要<code>Encode</code>，返回结果和上面的方法是一样，这里就不贴代码了。</p><h3 id="解析JSON格式"><a href="#解析JSON格式" class="headerlink" title="解析JSON格式"></a>解析JSON格式</h3><p>以结构体形式输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestParseJSON</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">Args    <span class="type">string</span>            <span class="string">`json:&quot;args&quot;`</span></span><br><span class="line">Headers <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span> <span class="string">`json:&quot;headers&quot;`</span></span><br><span class="line">Origin  <span class="type">string</span>            <span class="string">`json:&quot;origin&quot;`</span></span><br><span class="line">Url     <span class="type">string</span>            <span class="string">`json:&quot;url&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line">resp, err := http.Get(<span class="string">&quot;http://httpbin.org/get&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">body, _ := ioutil.ReadAll(resp.Body)</span><br><span class="line">fmt.Println(<span class="type">string</span>(body))</span><br><span class="line"><span class="keyword">var</span> res result</span><br><span class="line">_ = json.Unmarshal(body, &amp;res)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v&quot;</span>, res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GET请求添加请求头"><a href="#GET请求添加请求头" class="headerlink" title="GET请求添加请求头"></a>GET请求添加请求头</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAddHeader</span><span class="params">()</span></span> &#123;</span><br><span class="line">client := &amp;http.Client&#123;&#125;</span><br><span class="line">req, _ := http.NewRequest(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://httpbin.org/get&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">req.Header.Add(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;落雨&quot;</span>)</span><br><span class="line">req.Header.Add(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;110&quot;</span>)</span><br><span class="line">resp, _ := client.Do(req)</span><br><span class="line">body, _ := ioutil.ReadAll(resp.Body)</span><br><span class="line">fmt.Printf(<span class="type">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发出POST请求"><a href="#发出POST请求" class="headerlink" title="发出POST请求"></a>发出POST请求</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestPost</span><span class="params">()</span></span> &#123;</span><br><span class="line">urlstr := <span class="string">&quot;http://v.juhe.cn/hisWeather/province&quot;</span></span><br><span class="line">values := url.Values&#123;&#125;</span><br><span class="line">values.Set(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;000&quot;</span>) <span class="comment">//这里的key是错的</span></span><br><span class="line">values.Set(<span class="string">&quot;city&quot;</span>, <span class="string">&quot;北京&quot;</span>)</span><br><span class="line">r, err := http.PostForm(urlstr, values)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> r.Body.Close()</span><br><span class="line">b, _ := ioutil.ReadAll(r.Body)</span><br><span class="line">fmt.Printf(<span class="string">&quot;b: %v\n&quot;</span>, <span class="type">string</span>(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，还有另一种用键值对的方法，不过可读性比较差，这里就不给出代码了。</p><h3 id="发送JSON数据的POST请求"><a href="#发送JSON数据的POST请求" class="headerlink" title="发送JSON数据的POST请求"></a>发送JSON数据的POST请求</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestPostJSON</span><span class="params">()</span></span> &#123;</span><br><span class="line">data := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">data[<span class="string">&quot;site&quot;</span>] = <span class="string">&quot;https://conqueror712.gitee.io/conqueror712.gitee.io/&quot;</span></span><br><span class="line">data[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;落雨的博客&quot;</span></span><br><span class="line">bytesData, _ := json.Marshal(data)</span><br><span class="line">resp, _ := http.Post(<span class="string">&quot;http://httpbin.org/post&quot;</span>, <span class="string">&quot;application/json&quot;</span>, bytes.NewReader(bytesData))</span><br><span class="line">body, _ := ioutil.ReadAll(resp.Body)</span><br><span class="line">fmt.Println(<span class="type">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用Client自定义请求"><a href="#使用Client自定义请求" class="headerlink" title="使用Client自定义请求"></a>使用Client自定义请求</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestClient</span><span class="params">()</span></span> &#123;</span><br><span class="line">client := http.Client&#123;</span><br><span class="line">Timeout: time.Second * <span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line">url := <span class="string">&quot;http://v.juhe.cn/hisWeather/weather?key=&amp;city_id=1157&amp;weather_date=2017-07-15&quot;</span></span><br><span class="line">req, err := http.NewRequest(http.MethodGet, url, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">req.Header.Add(<span class="string">&quot;referer&quot;</span>, <span class="string">&quot;http://apis.juhe.cn/&quot;</span>)</span><br><span class="line">res, err2 := client.Do(req)</span><br><span class="line"><span class="keyword">if</span> err2 != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> res.Body.Close()</span><br><span class="line">b, _ := ioutil.ReadAll(res.Body)</span><br><span class="line">fmt.Printf(<span class="string">&quot;b: %v\n&quot;</span>, <span class="type">string</span>(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HTTP-Server"><a href="#HTTP-Server" class="headerlink" title="HTTP Server"></a>HTTP Server</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHttpServer</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//实现一个http server</span></span><br><span class="line"><span class="comment">//请求处理函数</span></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">io.WriteString(resp, <span class="string">&quot;HelloWorld你好世界&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//响应路径（斜杠是必要的）</span></span><br><span class="line">http.HandleFunc(<span class="string">&quot;/Hello&quot;</span>, f)</span><br><span class="line"><span class="comment">//设置监听端口，并监听（冒号是必要的）</span></span><br><span class="line">err := http.ListenAndServe(<span class="string">&quot;:9999&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//随后在浏览器内输入 http://localhost:9999/Hello 即可查看运行结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用Handler实现并发处理"><a href="#使用Handler实现并发处理" class="headerlink" title="使用Handler实现并发处理"></a>使用Handler实现并发处理</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该代码存在问题，请谨慎参考</span></span><br><span class="line"><span class="keyword">type</span> CountHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">mu sync.Mutex <span class="comment">//guards n</span></span><br><span class="line">n  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *CountHandler)</span></span> ServerHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">h.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> h.mu.Unlock()</span><br><span class="line">h.n++</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;count is %d\n&quot;</span>, h.n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHttpServerHandler</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.Handle(<span class="string">&quot;/Count&quot;</span>, <span class="built_in">new</span>(CountHandler))</span><br><span class="line">log.Fatal(http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;html/template&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">name := <span class="string">&quot;Conqueror712&quot;</span></span><br><span class="line">templateStr := <span class="string">&quot;Hello, &#123;&#123;.&#125;&#125;&quot;</span> <span class="comment">//只有一个变量 用.即可</span></span><br><span class="line">t := template.New(<span class="string">&quot;Test&quot;</span>)</span><br><span class="line">t2, err := t.Parse(templateStr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">t2.Execute(os.Stdout, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="工具之旅"><a href="#工具之旅" class="headerlink" title="工具之旅"></a>工具之旅</h1><h3 id="标准库flag的基本使用和长短选项"><a href="#标准库flag的基本使用和长短选项" class="headerlink" title="标准库flag的基本使用和长短选项"></a>标准库flag的基本使用和长短选项</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;flag&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line">flag.StringVar(&amp;name, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Go_Coding_Travel1&quot;</span>, <span class="string">&quot;Help&quot;</span>) <span class="comment">//调用标准库flag的StringVar实现对命令行参数name的解析和绑定</span></span><br><span class="line">flag.StringVar(&amp;name, <span class="string">&quot;n&quot;</span>, <span class="string">&quot;Go_Coding_Travel2&quot;</span>, <span class="string">&quot;Help&quot;</span>)    <span class="comment">//形参分别是：命令行标识位的名称 默认值和帮助信息</span></span><br><span class="line">flag.Parse()                                               <span class="comment">//解析</span></span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">&quot;name: %s&quot;</span>, name)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">三种命令行标志语法</span></span><br><span class="line"><span class="comment">-flag</span></span><br><span class="line"><span class="comment">-flag x</span></span><br><span class="line"><span class="comment">-flag=x</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//运行后发现是以最后一个赋值的变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="子命令的使用"><a href="#子命令的使用" class="headerlink" title="子命令的使用"></a>子命令的使用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;flag&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//CLI: 命令行界面 命令行解释器 命令行输入</span></span><br><span class="line"><span class="comment">//子命令的使用是CLI中最常见的功能</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">flag.Parse()                                     <span class="comment">//将命令行解析为定义的标志，以便后续的参数调用</span></span><br><span class="line">goCmd := flag.NewFlagSet(<span class="string">&quot;go&quot;</span>, flag.ExitOnError) <span class="comment">//返回带有指定名称和错误处理属性的空命令集，相当于创建一个新的命令集去支持子命令</span></span><br><span class="line">goCmd.StringVar(&amp;name, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;GoLang&quot;</span>, <span class="string">&quot;Help&quot;</span>)</span><br><span class="line">phpCmd := flag.NewFlagSet(<span class="string">&quot;php&quot;</span>, flag.ExitOnError)</span><br><span class="line">phpCmd.StringVar(&amp;name, <span class="string">&quot;n&quot;</span>, <span class="string">&quot;PHPLang&quot;</span>, <span class="string">&quot;Help&quot;</span>)</span><br><span class="line"></span><br><span class="line">args := flag.Args()</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(args) &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> args[<span class="number">0</span>] &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;go&quot;</span>:</span><br><span class="line">_ = goCmd.Parse(args[<span class="number">1</span>:])</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;php&quot;</span>:</span><br><span class="line">_ = phpCmd.Parse(args[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">&quot;name: %s&quot;</span>, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> D:\Coding\GoLang\Go_Tour_U1&gt; go run Test_flag.go php <span class="literal">-n</span>=<span class="number">22222</span></span><br><span class="line"><span class="number">2022</span>/<span class="number">09</span>/<span class="number">23</span> <span class="number">20</span>:<span class="number">42</span>:<span class="number">33</span> name: <span class="number">22222</span></span><br><span class="line"><span class="built_in">PS</span> D:\Coding\GoLang\Go_Tour_U1&gt; go run Test_flag.go go <span class="literal">-name</span>=<span class="number">22222</span></span><br><span class="line"><span class="number">2022</span>/<span class="number">09</span>/<span class="number">23</span> <span class="number">20</span>:<span class="number">42</span>:<span class="number">57</span> name: <span class="number">22222</span></span><br><span class="line"><span class="built_in">PS</span> D:\Coding\GoLang\Go_Tour_U1&gt; go run Test_flag.go go <span class="literal">-n</span>=<span class="number">22222</span>   </span><br><span class="line">flag provided but not defined: <span class="literal">-n</span></span><br><span class="line">Usage of go:</span><br><span class="line">  <span class="literal">-name</span> string</span><br><span class="line">        Help (default <span class="string">&quot;GoLang&quot;</span>)</span><br><span class="line"><span class="keyword">exit</span> status <span class="number">2</span></span><br><span class="line"><span class="built_in">PS</span> D:\Coding\GoLang\Go_Tour_U1&gt; </span><br></pre></td></tr></table></figure><hr><h1 id="Gin框架初体验"><a href="#Gin框架初体验" class="headerlink" title="Gin框架初体验"></a>Gin框架初体验</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/thinkerou/favicon&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中间件（拦截器），功能：预处理，登录授权、验证、分页、耗时统计...</span></span><br><span class="line"><span class="comment">// func myHandler() gin.HandlerFunc &#123;</span></span><br><span class="line"><span class="comment">// return func(ctx *gin.Context) &#123;</span></span><br><span class="line"><span class="comment">// // 通过自定义中间件，设置的值，在后续处理只要调用了这个中间件的都可以拿到这里的参数</span></span><br><span class="line"><span class="comment">// ctx.Set(&quot;usersesion&quot;, &quot;userid-1&quot;)</span></span><br><span class="line"><span class="comment">// ctx.Next()  // 放行</span></span><br><span class="line"><span class="comment">// ctx.Abort() // 阻止</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个服务</span></span><br><span class="line">ginServer := gin.Default()</span><br><span class="line">ginServer.Use(favicon.New(<span class="string">&quot;./Arctime.ico&quot;</span>)) <span class="comment">// 这里如果添加了东西然后再运行没有变化，请重启浏览器，浏览器有缓存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载静态页面</span></span><br><span class="line">ginServer.LoadHTMLGlob(<span class="string">&quot;templates/*&quot;</span>) <span class="comment">// 一种是全局加载，一种是加载指定的文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载资源文件</span></span><br><span class="line">ginServer.Static(<span class="string">&quot;/static&quot;</span>, <span class="string">&quot;./static&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相应一个页面给前端</span></span><br><span class="line"></span><br><span class="line">ginServer.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">ctx.HTML(http.StatusOK, <span class="string">&quot;index.html&quot;</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;msg&quot;</span>: <span class="string">&quot;This data is come from Go background.&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 能加载静态页面也可以加载测试文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取请求中的参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统方式：usl?userid=xxx&amp;username=conqueror712</span></span><br><span class="line"><span class="comment">// Rustful方式：/user/info/1/conqueror712</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是传统方式的例子</span></span><br><span class="line">ginServer.GET(<span class="string">&quot;/user/info&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123; <span class="comment">// 这个格式是固定的</span></span><br><span class="line">userid := context.Query(<span class="string">&quot;userid&quot;</span>)</span><br><span class="line">username := context.Query(<span class="string">&quot;username&quot;</span>)</span><br><span class="line"><span class="comment">// 拿到之后返回给前端</span></span><br><span class="line">context.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">&quot;userid&quot;</span>:   userid,</span><br><span class="line"><span class="string">&quot;username&quot;</span>: username,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 此时执行代码之后，在浏览器中可以输入http://localhost:8081/user/info?userid=111&amp;username=666</span></span><br><span class="line"><span class="comment">// 就可以看到返回了JSON格式的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是Rustful方式的例子</span></span><br><span class="line">ginServer.GET(<span class="string">&quot;/user/info/:userid/:username&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line">userid := context.Param(<span class="string">&quot;userid&quot;</span>)</span><br><span class="line">username := context.Param(<span class="string">&quot;username&quot;</span>)</span><br><span class="line"><span class="comment">// 还是一样，返回给前端</span></span><br><span class="line">context.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">&quot;userid&quot;</span>:   userid,</span><br><span class="line"><span class="string">&quot;username&quot;</span>: username,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 指定代码后，只需要在浏览器中http://localhost:8081/user/info/111/555</span></span><br><span class="line"><span class="comment">// 就可以看到返回了JSON数据了，非常方便简洁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化</span></span><br><span class="line"><span class="comment">// 前端给后端传递JSON</span></span><br><span class="line">ginServer.POST(<span class="string">&quot;/json&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// request.body</span></span><br><span class="line">data, _ := ctx.GetRawData()</span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125; <span class="comment">// Go语言中object一般用空接口来表示，可以接收anything</span></span><br><span class="line"><span class="comment">// 顺带一提，1.18以上，interface可以直接改成any</span></span><br><span class="line">_ = json.Unmarshal(data, &amp;m)</span><br><span class="line">ctx.JSON(http.StatusOK, m)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 用apipost或者postman写一段json传到localhost:8081/json里就可以了</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">json示例：</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">&quot;name&quot;: &quot;Conqueror712&quot;,</span></span><br><span class="line"><span class="comment">&quot;age&quot;: 666,</span></span><br><span class="line"><span class="comment">&quot;address&quot;: &quot;Mars&quot;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 看到后端的实时响应里面接收到数据就可以了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理表单请求 这些都是支持函数式编程，Go语言特性，可以把函数作为参数传进来</span></span><br><span class="line">ginServer.POST(<span class="string">&quot;/user/add&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">username := ctx.PostForm(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">password := ctx.PostForm(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">ctx.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">&quot;msg&quot;</span>:      <span class="string">&quot;ok&quot;</span>,</span><br><span class="line"><span class="string">&quot;username&quot;</span>: username,</span><br><span class="line"><span class="string">&quot;password&quot;</span>: password,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路由</span></span><br><span class="line">ginServer.GET(<span class="string">&quot;/test&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 重定向 -&gt; 301</span></span><br><span class="line">ctx.Redirect(<span class="number">301</span>, <span class="string">&quot;https://conqueror712.gitee.io/conqueror712.gitee.io/&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// http://localhost:8081/test</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 404</span></span><br><span class="line">ginServer.NoRoute(<span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">ctx.HTML(<span class="number">404</span>, <span class="string">&quot;404.html&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路由组暂略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器端口，用服务器端口来访问地址</span></span><br><span class="line">ginServer.Run(<span class="string">&quot;:8081&quot;</span>) <span class="comment">// 不写的话默认是8080，也可以更改</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言与更新日志：&quot;&gt;&lt;a href=&quot;#前言与更新日志：&quot; class=&quot;headerlink&quot; title=&quot;前言与更新日志：&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言与更新日志：&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;关于Go：&lt;/p&gt;
&lt;p&gt;​	它没有隐式的数值转换，没有构</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux + Shell丨学习记录</title>
    <link href="https://conqueror712.github.io/post/Linux.html"/>
    <id>https://conqueror712.github.io/post/Linux.html</id>
    <published>2022-07-18T05:44:32.000Z</published>
    <updated>2023-02-15T14:28:19.397Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a><strong>前言：</strong></h1><p>目前主流的Linux环境搭建，除了暴力方法（使用钞能力购买一台Linux系统的PC），我们大致有<strong>5种</strong>方案：</p><table><thead><tr><th align="center">方案</th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">单主机安装双系统</td><td align="center">真实的操作系统</td><td align="center">切换麻烦需重启</td></tr><tr><td align="center">双主机安装双系统</td><td align="center">物理隔离</td><td align="center">钞能力</td></tr><tr><td align="center">远程服务器</td><td align="center">真实的操作系统</td><td align="center">性能 带宽 流量 权限有局限</td></tr><tr><td align="center">虚拟机</td><td align="center">完整的使用体验</td><td align="center">资源消耗大 启动缓慢 卡顿 运行效率低</td></tr><tr><td align="center">WSL</td><td align="center">资源消耗小 + 启动迅速 + 无缝切换</td><td align="center">使用体验不完整 部分软件不支持</td></tr></tbody></table><p>​（该表格参考自互联网）</p><p>下面就我自身而言，说一说我试过的方案。</p><hr><h1 id="更新日志："><a href="#更新日志：" class="headerlink" title="更新日志："></a><strong>更新日志：</strong></h1><p>2022.07.18 创建了该文档，写了一些基本的内容。</p><p>2022.07.19 更新了WSL的安装部分和Docker的安装部分。</p><p>2022.07.20 更新了Linux文件基本属性部分。</p><p>2022.07.22 更新了Linux剩余部分，包括文件内容查看、用户和用户组管理、磁盘管理、vi&#x2F;vim、yum以及apt命令。</p><p>2022.07.23 更新了Shell的简介、变量部分。</p><hr><h1 id="安装部分："><a href="#安装部分：" class="headerlink" title="安装部分："></a><strong>安装部分：</strong></h1><h2 id="单主机安装双系统："><a href="#单主机安装双系统：" class="headerlink" title="单主机安装双系统："></a>单主机安装双系统：</h2><p>本人参考了这位大佬的教程，简单易懂，小狗狗看了都说学会了。</p><p><a href="https://www.bilibili.com/video/BV1554y1n7zv?p=1&totalPage=16">Windows 和 Ubuntu 双系统从安装到卸载_哔哩哔哩_bilibili</a></p><p>系统的安装文件在这里：</p><p><a href="https://cn.ubuntu.com/">企业开源和Linux | Ubuntu</a></p><hr><h2 id="WSL："><a href="#WSL：" class="headerlink" title="WSL："></a>WSL：</h2><p>本人使用的是WSL 2，具体的安装过程有两种办法：</p><p>​直接在Windows控制台中输入<code>wsl --install -d &lt;你想安装的发行版本&gt;</code>，例如<code>ubuntu</code>；</p><p>紧接着等待安装后输入用户名和密码然后重启即可，注意，用户名首字母不能大写；</p><p>重启之后，我们在开始菜单里输入Ubuntu就可以看到已经安装好了，进入即可。</p><p>我们可以看到的是，在打开的Ubuntu命令行中输入python3会直接进入预装的Python中，我这里的版本是3.8。</p><p>我们也可以键入<code>sudo apt-get update</code>来更新一些东西。</p><hr><h2 id="Docker："><a href="#Docker：" class="headerlink" title="Docker："></a>Docker：</h2><p>傻瓜式安装好Docker之后，如果弹出类似于WSL 2 installation is incomplete之类的东西，然后让你restart的话，那么可以在控制面板中找到Windows功能，勾选上适用于<strong>Linux的Windows子系统</strong>之后再下载一个更新包，更新之后restart即可。</p><p>更新包地址：<a href="https://link.zhihu.com/?target=https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi">https://link.zhihu.com/?target=https%3A//wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi</a></p><hr><h1 id="1-Linux文件基本属性"><a href="#1-Linux文件基本属性" class="headerlink" title="1 .Linux文件基本属性"></a><strong>1 .Linux文件基本属性</strong></h1><ul><li>chown (change owner) ： 修改所属用户与组。</li><li>chmod (change mode) ： 修改用户的权限。</li></ul><h2 id="查看文件属性："><a href="#查看文件属性：" class="headerlink" title="查看文件属性："></a>查看文件属性：</h2><p>查看文件的属性以及文件所属的用户和组（Linux系统是一种典型的多用户系统，不同的用户拥有不同的权限）：</p><p><img src="https://s2.loli.net/2022/07/20/KdjuM2pOF6VeGYA.png" alt="avatar"></p><p>对于第0个字符：</p><ul><li>当为 <strong>d</strong> 则是目录</li><li>当为 <strong>-</strong> 则是文件；</li><li>若是 <strong>l</strong> 则表示为链接文档(link file)；</li><li>若是 <strong>b</strong> 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；</li><li>若是 <strong>c</strong> 则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。</li></ul><h2 id="更改文件属性："><a href="#更改文件属性：" class="headerlink" title="更改文件属性："></a>更改文件属性：</h2><h3 id="数字更改法："><a href="#数字更改法：" class="headerlink" title="数字更改法："></a>数字更改法：</h3><ul><li><p>chgrp：更改文件属组：</p><p><code>chgrp [-R] 属组名 文件名</code>（-R是递归更改文件的属组，该目录下的所有文件的属组都会更改）</p></li><li><p>chown：更改文件属主（也可以同时更改文件属组）：</p><p><code>chown [-R] 属主名 文件名</code></p><p><code>chown [-R] 属主名: 属组名 文件名</code></p></li><li><p>chmod：更改文件9个属性  ：</p><table><thead><tr><th align="center"></th><th align="center">owner(user)</th><th align="center">group</th><th align="center">others</th></tr></thead><tbody><tr><td align="center"><strong>read</strong></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>write</strong></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>execute</strong></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p>我们用数字来代表各个权限：r &#x3D; 4w &#x3D; 2x &#x3D; 1</p><p>例如，当权限为<code>-rwxrwx---</code>时，分数规则就是：</p><p>owner &#x3D; 4 + 2 + 1 &#x3D; 7</p><p>group &#x3D; 4 + 2 + 1 &#x3D; 7</p><p>others &#x3D; 0 + 0 + 0 &#x3D; 0</p><p>故该文件的权限数字就是<code>770</code> &#x3D;&#x3D; <code>xyz</code></p><p>变更权限的命令：<code>chmod [-R] xyz 文件或目录</code></p></li></ul><p>更改完成后不妨再用<code>ls -l</code>再查看一遍文件属性，以确保更改生效。</p><h3 id="符号更改法："><a href="#符号更改法：" class="headerlink" title="符号更改法："></a>符号更改法：</h3><p>我们可以使用 <strong>u, g, o</strong> 来代表三种身份的权限，<strong>a</strong>代表all，也就是对于所有的身份。</p><p>**+**代表加入**-**代表除去**&#x3D;**代表设定<code>chmod u=rwx,g=rx,o=r 文件名</code></p><p>​<em>PS: 部分参考自runoob</em></p><hr><h1 id="2-Linux文件与目录管理："><a href="#2-Linux文件与目录管理：" class="headerlink" title="2. Linux文件与目录管理："></a><strong>2. Linux文件与目录管理：</strong></h1><ul><li>绝对路径：从根目录<code>/</code>写起；</li><li>相对路径：例如由 <code>/usr/share/doc</code> 要到 <code>/usr/share/man</code> 底下时，可以写成： <code>cd ../man</code> ；</li></ul><h2 id="处理目录的常用命令："><a href="#处理目录的常用命令：" class="headerlink" title="处理目录的常用命令："></a>处理目录的常用命令：</h2><ul><li>ls（list files）: 列出目录及文件名</li><li>cd（change directory）：切换目录</li><li>pwd（print work directory）：显示目前的目录</li><li>mkdir（make directory）：创建一个新的目录</li><li>rmdir（remove directory）：删除一个空的目录</li><li>cp（copy file）: 复制文件或目录</li><li>rm（remove）: 删除文件或目录</li><li>mv（move file）: 移动文件与目录，或修改文件与目录的名称</li></ul><p>当你忘记某个命令应该如何使用的时候，你可以使用man [命令]来查看使用文档，例如man ls；(manner)</p><p>由于我比较懒，我就不列出每个命令的用法了，我也是在使用的时候再查找参考文档的（逃）。</p><h2 id="Linux文件内容查看："><a href="#Linux文件内容查看：" class="headerlink" title="Linux文件内容查看："></a>Linux文件内容查看：</h2><ul><li>cat 由第一行开始显示文件内容</li><li>tac 从最后一行开始显示（tac 是 cat 的倒过来）</li><li>nl  显示的时候，顺道输出行号</li><li>more 一页一页的显示文件内容</li><li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页</li><li>head 只看头几行</li><li>tail 只看尾巴几行</li></ul><p>同样地，当你忘记某个命令应该如何使用的时候，你可以使用man [命令]来查看使用文档，例如man cat；(manner)</p><hr><h1 id="3-Linux用户和用户组管理："><a href="#3-Linux用户和用户组管理：" class="headerlink" title="3. Linux用户和用户组管理："></a><strong>3. Linux用户和用户组管理：</strong></h1><h2 id="Linux系统用户账号的管理："><a href="#Linux系统用户账号的管理：" class="headerlink" title="Linux系统用户账号的管理："></a>Linux系统用户账号的管理：</h2><ol><li>添加新的用户账号命令：<code>useradd 选项 用户名</code></li></ol><ul><li><p>选项:</p><ul><li><p>-c comment 指定一段注释性描述</p></li><li><p>-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录</p></li><li><p>-g 用户组 指定用户所属的用户组</p></li><li><p>-G 用户组，用户组 指定用户所属的附加组</p></li><li><p>-s Shell文件 指定用户的登录Shell</p></li><li><p>-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号</p></li></ul></li></ul><ol start="2"><li>删除账号命令：<code>userdel 选项 用户名</code></li></ol><p>​常用的选项是<code>-r</code>，作用是把用户的主目录一起删除；</p><ol start="3"><li><p>修改账号命令：<code>usermod 选项 用户名</code></p><p>常用的选项与<code>useradd</code>一致，不同的是，有些系统可以使用选项<code>-l 新用户名</code></p><p>（虽然不太清楚这个的区别在哪里但是还是记录上为好）</p></li><li><p>用户口令的管理命令：<code>passwd 选项 用户名</code></p><p>用户账号刚创建时没有口令，被系统锁定无法使用，必须为其指定了口令之后才可以使用，即使是空的口令。</p><p>可使用的选项：</p><ul><li>-l 锁定口令，即禁用账号</li><li>-u 口令解锁。</li><li>-d 使账号无口令。</li><li>-f 强迫用户下次登录时修改口令</li></ul><p>特别地，如果是默认用户名，则修改当前用户的口令。</p></li></ol><h2 id="Linux系统用户组的管理："><a href="#Linux系统用户组的管理：" class="headerlink" title="Linux系统用户组的管理："></a>Linux系统用户组的管理：</h2><ol><li><p>增加一个新的用户组命令：<code>groupadd 选项 用户组</code></p><p>可用选项：</p><ul><li>-g GID 指定新用户组的组标识号（GID）。</li><li>-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。</li></ul><p>如果不写GID，则默认是在当前已有的最大组标识号的基础上+1；</p><p><code>groupadd group1</code></p><p><code>groupadd -g 114514 group2</code></p></li><li><p>删除一个已有的用户组命令：<code>groupdel 用户组</code></p></li><li><p>修改用户组的属性指令：<code>groupmod 选项 用户组</code></p><p>可用选项：</p><ul><li>-g GID 为用户组指定新的组标识号。</li><li>-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。</li><li>-n新用户组 将用户组的名字改为新名字</li></ul><p>例如：</p><p><code># groupmod –g 10000 -n group3 group2</code></p><p>此命令将组group2的标识号改为10000，组名修改为group3。</p></li><li><p>如果一个用户同时属于多个用户组，那么用户可以在用户组之间且耳环，以便具有其他用户组的权限。</p><p>命令：<code>$ newgrp root</code></p></li></ol><h2 id="与用户账号有关的系统文件："><a href="#与用户账号有关的系统文件：" class="headerlink" title="与用户账号有关的系统文件："></a>与用户账号有关的系统文件：</h2><p>与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括&#x2F;etc&#x2F;passwd, &#x2F;etc&#x2F;shadow, &#x2F;etc&#x2F;group等。</p><ol><li><p>&#x2F;etc&#x2F;passwd文件是用户管理工作涉及的最重要的一个文件，每个用户都在该文件中有一个对应的记录行，记录了该用户的一些基本属性，并且该文件对于所有用户都是可读的，每行的格式如下：</p><p><code>用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell</code></p><p>例如：<code>adm:x:4:4:System accounting:/usr/adm:</code> （冒号为分隔符，在名称的命名中不能随便使用）</p><p>其中有一些含义与注意事项，这里直接引用runoob上的内容：</p><blockquote><p><strong>1）”用户名”是代表用户账号的字符串。</strong></p><p>通常长度不超过8个字符，并且由大小写字母和&#x2F;或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。</p><p>为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。</p><p><strong>2）“口令”一些系统中，存放着加密后的用户口令字。</strong></p><p>虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于&#x2F;etc&#x2F;passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到&#x2F;etc&#x2F;shadow文件中，而在&#x2F;etc&#x2F;passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。</p><p><strong>3）“用户标识号”是一个整数，系统内部用它来标识用户。</strong></p><p>一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。</p><p>通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。</p><p><strong>4）“组标识号”字段记录的是用户所属的用户组。</strong></p><p>它对应着&#x2F;etc&#x2F;group文件中的一条记录。</p><p><strong>5)“注释性描述”字段记录着用户的一些个人情况。</strong></p><p>例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用做finger命令的输出。</p><p><strong>6)“主目录”，也就是用户的起始工作目录。</strong></p><p>它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。</p><p><strong>7)用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。</strong></p><p>Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX&#x2F;TOPS-20 type C Shell), bash(Bourne Again Shell)等。</p><p>系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为&#x2F;bin&#x2F;sh。</p><p>用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。</p><p>利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。</p><p><strong>8)系统中有一类用户称为伪用户（pseudo users）。</strong></p><p>这些用户在&#x2F;etc&#x2F;passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。</p><p>常见的伪用户如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">伪 用 户 含 义 </span><br><span class="line">bin 拥有可执行的用户命令文件 </span><br><span class="line">sys 拥有系统文件 </span><br><span class="line">adm 拥有帐户文件 </span><br><span class="line">uucp UUCP使用 </span><br><span class="line">lp lp或lpd子系统使用 </span><br><span class="line">nobody NFS使用</span><br></pre></td></tr></table></figure></blockquote></li><li><p>拥有账户文件</p><p>&#x2F;etc&#x2F;shadow文件只有超级用户才拥有这个文件的读权限，可以保证用户密码的安全性；</p><p>并且其中的记录行与&#x2F;etc&#x2F;passwd中一一对应，由pwconv自动产生：</p><p><code>登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</code></p><blockquote><ol><li>“登录名”是与&#x2F;etc&#x2F;passwd文件中的登录名相一致的用户账号</li><li>“口令”字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { .&#x2F;0-9A-Za-z }中的字符，则对应的用户不能登录。</li><li>“最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。</li><li>“最小时间间隔”指的是两次修改口令之间所需的最小天数。</li><li>“最大时间间隔”指的是口令保持有效的最大天数。</li><li>“警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。</li><li>“不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。</li><li>“失效时间”字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。</li></ol></blockquote></li><li><p>用户组的所有信息都存放在&#x2F;etc&#x2F;group文件中</p><p><code>组名:口令:组标识号:组内用户列表</code></p><blockquote><ol><li>“组名”是用户组的名称，由字母或数字构成。与&#x2F;etc&#x2F;passwd中的登录名一样，组名不应重复。</li><li>“口令”字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。</li><li>“组标识号”与用户标识号类似，也是一个整数，被系统内部用来标识组。</li><li>“组内用户列表”是属于这个组的所有用户的列表，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。</li></ol></blockquote></li><li><p>批量添加用户</p><p>步骤如下：</p><p>（1）先编辑一个文本用户文件。</p><p>（2）以root身份执行命令 <code>/usr/sbin/newusers</code>，从刚创建的用户文件<code>user.txt</code>中导入数据，创建用户：</p><p>（3）执行命令&#x2F;usr&#x2F;sbin&#x2F;pwunconv。</p><p>（4）编辑每个用户的密码对照文件。</p><p>（5）以 root 身份执行命令 <code>/usr/sbin/chpasswd</code>。</p><p>（6）确定密码经编码写入&#x2F;etc&#x2F;passwd的密码栏后。</p></li></ol><hr><h1 id="4-Linux磁盘管理："><a href="#4-Linux磁盘管理：" class="headerlink" title="4. Linux磁盘管理："></a><strong>4. Linux磁盘管理：</strong></h1><p>磁盘管理与系统性能有着直接关系；</p><h2 id="磁盘管理常用命令："><a href="#磁盘管理常用命令：" class="headerlink" title="磁盘管理常用命令："></a>磁盘管理常用命令：</h2><p>Linux 磁盘管理常用三个命令为 <strong>df</strong>、<strong>du</strong> 和 <strong>fdisk</strong>。</p><ul><li><strong>df</strong>（英文全称：disk free）：列出文件系统的整体磁盘使用量</li><li><strong>du</strong>（英文全称：disk used）：检查磁盘空间使用量</li><li><strong>fdisk</strong>：用于磁盘分区</li></ul><h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><p>df命令参数功能：检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。</p><p>语法：<code>df [-ahikHTm] [目录或文件名]</code></p><p>选项与参数：</p><ul><li>-a ：列出所有的文件系统，包括系统特有的 &#x2F;proc 等文件系统；</li><li>-k ：以 KBytes 的容量显示各文件系统；</li><li>-m ：以 MBytes 的容量显示各文件系统；</li><li>-h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；</li><li>-H ：以 M&#x3D;1000K 取代 M&#x3D;1024K 的进位方式；</li><li>-T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；</li><li>-i ：不用硬盘容量，而以 inode 的数量来显示</li></ul><h3 id="du"><a href="#du" class="headerlink" title="du"></a>du</h3><p>Linux du 命令也是查看使用空间的，但是与 df 命令不同的是 Linux du 命令是对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的，这里介绍 Linux du 命令。</p><p>语法：<code>du [-ahskm] 文件或目录名称</code></p><p>选项与参数：</p><ul><li>-a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。</li><li>-h ：以人们较易读的容量格式 (G&#x2F;M) 显示；</li><li>-s ：列出总量而已，而不列出每个各别的目录占用容量；</li><li>-S ：不包括子目录下的总计，与 -s 有点差别。</li><li>-k ：以 KBytes 列出容量显示；</li><li>-m ：以 MBytes 列出容量显示；</li></ul><h3 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h3><p>fdisk 是 Linux 的磁盘分区表操作工具。</p><p>语法：<code>fdisk [-l] 装置名称</code></p><p>选项与参数：</p><p>​-l ：输出后面接的装置所有的分区内容。若仅有 fdisk -l 时， 则系统将会把整个系统内能够搜寻到的装置的分区均列出来。</p><h2 id="磁盘格式化："><a href="#磁盘格式化：" class="headerlink" title="磁盘格式化："></a>磁盘格式化：</h2><p>磁盘分割完毕后自然就是要进行文件系统的格式化，格式化的命令非常的简单，使用 <code>mkfs</code>（make filesystem） 命令。</p><p>语法：<code>mkfs [-t 文件系统格式] 装置文件名</code></p><p>选项与参数：</p><p>​-t ：可以接文件系统格式，例如 ext3, ext2, vfat 等(系统有支持才会生效)</p><h2 id="磁盘检验："><a href="#磁盘检验：" class="headerlink" title="磁盘检验："></a>磁盘检验：</h2><p>fsck（file system check）用来检查和维护不一致的文件系统。</p><p>若系统掉电或磁盘发生问题，可利用fsck命令对文件系统进行检查。</p><p>语法：<code>fsck [-t 文件系统] [-ACay] 装置名称</code></p><p>选项与参数：</p><ul><li>-t : 给定档案系统的型式，若在 &#x2F;etc&#x2F;fstab 中已有定义或 kernel 本身已支援的则不需加上此参数</li><li>-s : 依序一个一个地执行 fsck 的指令来检查</li><li>-A : 对&#x2F;etc&#x2F;fstab 中所有列出来的 分区（partition）做检查</li><li>-C : 显示完整的检查进度</li><li>-d : 打印出 e2fsck 的 debug 结果</li><li>-p : 同时有 -A 条件时，同时有多个 fsck 的检查一起执行</li><li>-R : 同时有 -A 条件时，省略 &#x2F; 不检查</li><li>-V : 详细显示模式</li><li>-a : 如果检查有错则自动修复</li><li>-r : 如果检查有错则由使用者回答是否修复</li><li>-y : 选项指定检测每个文件是自动输入yes，在不确定那些是不正常的时候，可以执行 # fsck -y 全部检查修复。</li></ul><h2 id="磁盘挂载与卸除："><a href="#磁盘挂载与卸除：" class="headerlink" title="磁盘挂载与卸除："></a>磁盘挂载与卸除：</h2><p>Linux 的磁盘挂载使用 <code>mount</code> 命令，卸载使用 <code>umount</code> 命令。</p><p>语法：<code>xxxxxxxxxx mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n]  装置文件名  挂载点</code></p><hr><h1 id="5-Linux-vi-x2F-vim："><a href="#5-Linux-vi-x2F-vim：" class="headerlink" title="5. Linux vi &#x2F; vim："></a><strong>5. Linux vi &#x2F; vim：</strong></h1><p><img src="https://s2.loli.net/2022/07/22/n3jbDOhtvfrgSeT.gif" alt="avatar"></p><p>（此部分因为本人还没有熟悉Vim的操作，故暂以一图略之）</p><hr><h1 id="6-Linux-yum命令："><a href="#6-Linux-yum命令：" class="headerlink" title="6. Linux yum命令："></a><strong>6. Linux yum命令：</strong></h1><p>Yellow dog Updater, Modified 是一个在 Fedora 和 RedHat 以及 SUSE 中的 Shell 前端软件包管理器。</p><p>基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。</p><h3 id="yum-语法："><a href="#yum-语法：" class="headerlink" title="yum 语法："></a>yum 语法：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum [options] [command] [package ...]</span><br></pre></td></tr></table></figure><ul><li><strong>options：</strong>可选，选项包括-h（帮助），-y（当安装过程提示选择全部为 “yes”），-q（不显示安装的过程）等等。</li><li><strong>command：</strong>要进行的操作。</li><li><strong>package：</strong>安装的包名。</li></ul><h2 id="yum常用命令"><a href="#yum常用命令" class="headerlink" title="yum常用命令"></a>yum常用命令</h2><ul><li>列出所有可更新的软件清单命令：<strong>yum check-update</strong></li><li>更新所有软件命令：<strong>yum update</strong></li><li>仅安装指定的软件命令：<strong>yum install <package_name></strong></li><li>仅更新指定的软件命令：<strong>yum update <package_name></strong></li><li>列出所有可安裝的软件清单命令：<strong>yum list</strong></li><li>删除软件包命令：<strong>yum remove <package_name></strong></li><li>查找软件包命令：<strong>yum search <keyword></strong></li><li>清除缓存命令:</li><li><strong>yum clean packages</strong>: 清除缓存目录下的软件包</li><li><strong>yum clean headers</strong>: 清除缓存目录下的 headers</li><li><strong>yum clean oldheaders</strong>: 清除缓存目录下旧的 headers</li><li><strong>yum clean, yum clean all (&#x3D; yum clean packages; yum clean oldheaders)</strong> :清除缓存目录下的软件包及旧的 headers</li></ul><h2 id="国内-yum-源"><a href="#国内-yum-源" class="headerlink" title="国内 yum 源"></a>国内 yum 源</h2><p>网易（163）yum源是国内最好的yum源之一 ，无论是速度还是软件版本，都非常的不错。</p><p>将yum源设置为163 yum，可以提升软件包安装和更新的速度，同时避免一些常见软件版本无法找到。</p><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p>首先备份&#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br></pre></td></tr></table></figure><p>下载对应版本 repo 文件, 放入 &#x2F;etc&#x2F;yum.repos.d&#x2F; (操作前请做好相应备份)</p><ul><li><a href="http://mirrors.163.com/.help/CentOS5-Base-163.repo">CentOS5</a> ：<a href="http://mirrors.163.com/.help/CentOS5-Base-163.repo">http://mirrors.163.com/.help/CentOS5-Base-163.repo</a></li><li><a href="http://mirrors.163.com/.help/CentOS6-Base-163.repo">CentOS6</a> ：<a href="http://mirrors.163.com/.help/CentOS6-Base-163.repo">http://mirrors.163.com/.help/CentOS6-Base-163.repo</a></li><li><a href="http://mirrors.163.com/.help/CentOS7-Base-163.repo">CentOS7</a> ：<a href="http://mirrors.163.com/.help/CentOS7-Base-163.repo">http://mirrors.163.com/.help/CentOS7-Base-163.repo</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http://mirrors.163.com/.help/CentOS6-Base-163.repo</span><br><span class="line">mv CentOS6-Base-163.repo CentOS-Base.repo</span><br></pre></td></tr></table></figure><p>运行以下命令生成缓存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br></pre></td></tr></table></figure><hr><h1 id="7-Linux-apt命令："><a href="#7-Linux-apt命令：" class="headerlink" title="7. Linux apt命令："></a><strong>7. Linux apt命令：</strong></h1><p>Advanced Packaging Tool  是一个在 Debian 和 Ubuntu 中的 Shell 前端软件包管理器。</p><p>apt 命令提供了查找、安装、升级、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p><p>apt 命令执行需要超级管理员权限(root)。</p><h3 id="apt-语法"><a href="#apt-语法" class="headerlink" title="apt 语法"></a>apt 语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt [options] [command] [package ...]</span><br></pre></td></tr></table></figure><ul><li><strong>options：</strong>可选，选项包括 -h（帮助），-y（当安装过程提示选择全部为”yes”），-q（不显示安装的过程）等等。</li><li><strong>command：</strong>要进行的操作。</li><li><strong>package</strong>：安装的包名。</li></ul><h2 id="apt-常用命令"><a href="#apt-常用命令" class="headerlink" title="apt 常用命令"></a>apt 常用命令</h2><ul><li><p>列出所有可更新的软件清单命令：<strong>sudo apt update</strong></p></li><li><p>升级软件包：<strong>sudo apt upgrade</strong></p><p>列出可更新的软件包及版本信息：<strong>apt list –upgradeable</strong></p><p>升级软件包，升级前先删除需要更新软件包：<strong>sudo apt full-upgrade</strong></p></li><li><p>安装指定的软件命令：<strong>sudo apt install <package_name></strong></p><p>安装多个软件包：<strong>sudo apt install <package_1> <package_2> <package_3></strong></p></li><li><p>更新指定的软件命令：<strong>sudo apt update <package_name></strong></p></li><li><p>显示软件包具体信息,例如：版本号，安装大小，依赖关系等等：<strong>sudo apt show <package_name></strong></p></li><li><p>删除软件包命令：<strong>sudo apt remove <package_name></strong></p></li><li><p>清理不再使用的依赖和库文件: <strong>sudo apt autoremove</strong></p></li><li><p>移除软件包及配置文件: <strong>sudo apt purge <package_name></strong></p></li><li><p>查找软件包命令： <strong>sudo apt search <keyword></strong></p></li><li><p>列出所有已安装的包：<strong>apt list –installed</strong></p></li><li><p>列出所有已安装的包的版本信息：<strong>apt list –all-versions</strong></p></li></ul><hr><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="Shell简介："><a href="#Shell简介：" class="headerlink" title="Shell简介："></a><strong>Shell简介：</strong></h1><p>Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。</p><p>Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。</p><p>Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。</p><h2 id="Shell脚本："><a href="#Shell脚本：" class="headerlink" title="Shell脚本："></a>Shell脚本：</h2><p>Shell Script与Shell概念不同，但是业界一般直接用Shell来代指Shell脚本。</p><h2 id="Shell环境："><a href="#Shell环境：" class="headerlink" title="Shell环境："></a>Shell环境：</h2><p>Linux常见的Shell种类众多：</p><ul><li>Bourne Shell（&#x2F;usr&#x2F;bin&#x2F;sh或&#x2F;bin&#x2F;sh）</li><li><strong>Bourne Again Shell（&#x2F;bin&#x2F;bash）</strong></li><li>C Shell（&#x2F;usr&#x2F;bin&#x2F;csh）</li><li>K Shell（&#x2F;usr&#x2F;bin&#x2F;ksh）</li><li>Shell for Root（&#x2F;sbin&#x2F;sh）</li></ul><p>我本人学习的是<strong>Bash</strong>，这也是许多Linux系统的默认Shell</p><p><code>#!</code>是告诉系统 其后路径所指定的程序即是解释此脚本文件的Shell程序（说人话就是这个脚本需要什么解释器来执行）。</p><p>这里给出<em>runoob</em>的一个在线编辑器：<a href="https://www.runoob.com/try/showbash.php?filename=helloworld"><strong>Shell 在线工具</strong></a></p><p>Shell脚本的扩展名为.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &quot;Hello World!&quot;</span><br></pre></td></tr></table></figure><p>运行Shell脚本的两种方法：</p><ol><li>作为可执行程序cd到对应的.sh目录下之后</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ./test.sh#使脚本具有执行权限，参考之前的Linux命令部分</span><br><span class="line">./test.sh#执行脚本</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果写成test.sh 则Linux会去PATH寻找有没有这个路径 所以会出现找不到的情况</span></span><br></pre></td></tr></table></figure><pre><code>2. 作为解释器参数 就是直接运行解释器 参数直接写Shell脚本的文件名（个人感觉比较方便）</code></pre><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh test.sh#这里就不用写成./的形式了</span><br></pre></td></tr></table></figure><hr><h1 id="Shell变量："><a href="#Shell变量：" class="headerlink" title="Shell变量："></a><strong>Shell变量：</strong></h1><h2 id="定义变量："><a href="#定义变量：" class="headerlink" title="定义变量："></a>定义变量：</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">YourName = &quot;LiHua&quot;#没有$</span><br></pre></td></tr></table></figure><p>注意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：</p><ul><li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li><li>中间不能有空格，可以使用下划线_。</li><li>不能使用标点符号。</li><li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li></ul><h2 id="使用变量："><a href="#使用变量：" class="headerlink" title="使用变量："></a>使用变量：</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo $YourName#需要加$</span><br><span class="line">echo $&#123;YourName&#125;#大括号是可选的 目的是为了帮助解释器识别变量的边界</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">变量也可以被重定义 会覆盖掉</span></span><br></pre></td></tr></table></figure><h2 id="只读变量："><a href="#只读变量：" class="headerlink" title="只读变量："></a>只读变量：</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">LiHua_Math_Score = &quot;59&quot;</span><br><span class="line">readonly LiHua_Math_Score</span><br></pre></td></tr></table></figure><h2 id="删除变量："><a href="#删除变量：" class="headerlink" title="删除变量："></a>删除变量：</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LiHua_Math_Score = &quot;59&quot;</span><br><span class="line">unset Lihua_Math_Score</span><br><span class="line">echo $Lihua_Math_Score#实际上并没有任何东西被输出</span><br></pre></td></tr></table></figure><h2 id="变量类型："><a href="#变量类型：" class="headerlink" title="变量类型："></a>变量类型：</h2><ul><li><strong>局部变量</strong> 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。</li><li><strong>环境变量</strong> 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</li><li><strong>shell变量</strong> shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</li></ul><h2 id="Shell字符串："><a href="#Shell字符串：" class="headerlink" title="Shell字符串："></a>Shell字符串：</h2><p>Shell的字符串可以用单引号 双引号 甚至无引号不过功能不太一样；</p><p>单引号字符串的限制：</p><ul><li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；</li><li>单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</li></ul><p>双引号的优点：</p><ul><li>双引号里可以有变量</li><li>双引号里可以出现转义字符</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">获取字符串长度</span></span><br><span class="line">str=&quot;BoyNextDoor&quot;</span><br><span class="line">echo $&#123;#str&#125;#输出11</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">提取子字符串</span></span><br><span class="line">str=&quot;BoyNextDoor&quot;</span><br><span class="line">echo $&#123;str:1:4&#125;#输出oyNe</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查找子字符串</span></span><br><span class="line">str=&quot;BoyNextDoor&quot;</span><br><span class="line">echo `expr index &quot;$str&quot; ND`#输出4（这里是1_base）</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">特别地，最后一个参数若输入多个字符，则哪个字符先出现就先计算哪个</span></span><br></pre></td></tr></table></figure><h2 id="Shell数组："><a href="#Shell数组：" class="headerlink" title="Shell数组："></a>Shell数组：</h2><p>bash不支持多维数组 并且不限制数组的大小 0_base</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">定义数组</span></span><br><span class="line">Student_Score=(99 66 67 85)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">单独定义或修改</span></span><br><span class="line">Student_Score[0]=59#可以不使用连续的下标 并且下标的范围没有限制</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">读取数组</span></span><br><span class="line">tmp_value=$&#123;Student_Score[2]&#125;</span><br><span class="line">echo $&#123;array_name[@]&#125;# @符号可以获取数组中的所有元素</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">获取数组长度（与字符串相同）</span></span><br><span class="line">length=$&#123;#Student_Score[@]&#125;# 取得数组元素的个数</span><br><span class="line">length=$&#123;#Student_Score[*]&#125;# 或者</span><br><span class="line">lengthn=$&#123;#Student_Score[n]&#125;# 取得数组单个元素的长度</span><br></pre></td></tr></table></figure><h2 id="Shell注释："><a href="#Shell注释：" class="headerlink" title="Shell注释："></a>Shell注释：</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--------------------------------------------</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这是一个注释</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">author：Conqueror712</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">site：https://conqueror712.gitee.io/conqueror712.gitee.io/</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--------------------------------------------</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">也可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">多行注释</span></span><br><span class="line">:&lt;&lt;EOF</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这其中 EOF也可以用别的符号替换 例如 ?</span></span><br></pre></td></tr></table></figure><hr><h1 id="Shell传递参数："><a href="#Shell传递参数：" class="headerlink" title="Shell传递参数："></a><strong>Shell传递参数：</strong></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言：&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;目前主流的Linux环境搭建，除了暴力方法（使用钞能力购买一台Linux系统的PC），我们大致有&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数论丨基础</title>
    <link href="https://conqueror712.github.io/post/Number-Theory.html"/>
    <id>https://conqueror712.github.io/post/Number-Theory.html</id>
    <published>2022-07-18T05:33:57.000Z</published>
    <updated>2023-02-18T14:48:39.835Z</updated>
    
    <content type="html"><![CDATA[<h1 id="整除、gcd与lcm："><a href="#整除、gcd与lcm：" class="headerlink" title="整除、gcd与lcm："></a><strong>整除、gcd与lcm：</strong></h1><h2 id="算术基本定理："><a href="#算术基本定理：" class="headerlink" title="算术基本定理："></a>算术基本定理：</h2><h2 id="n的质因数分解唯一；"><a href="#n的质因数分解唯一；" class="headerlink" title="n的质因数分解唯一；"></a>n的质因数分解唯一；</h2><p>即<code>n = p1e1 · p2e2 · p3e3 ··· pkek</code> （pi默认升序 &amp;&amp; pi默认为素数）；</p><p>记π(n)为小于等于n的素数个数，则有<code>lim n→∞</code>时，<code>π(n) / n·ln n = 1</code>；</p><p>从2开始，第n个素数是<code>nlog n</code>级别的；</p><p><code>∑ 1 / i = O(log n)</code>；</p><p><code>∑ 1 / p = O(log log n)</code>（更小的复杂度）（在***埃氏筛***中用到）；</p><hr><h2 id="整除的性质："><a href="#整除的性质：" class="headerlink" title="整除的性质："></a><strong>整除的性质：</strong></h2><p>若 a | c &amp;&amp; b | c &amp;&amp; (a, b) &#x3D; 1（即a, b互质）—— 则 ab | c；</p><p>若 a | c &amp;&amp; b | c &amp;&amp; (a, b) &#x3D; 1 —— 则 [a, b] | c；（注：[a, b] &#x3D; ab &#x2F; (a, b)，分别代表lcm和gcd）</p><p>若 a | bc &amp;&amp; (a, b) &#x3D; 1 —— 则 a | c（a的因子不在b，那么一定在c）；</p><p>若 p | ab —— 则 p | a 或 p | b；</p><hr><h2 id="gcd-amp-lcm："><a href="#gcd-amp-lcm：" class="headerlink" title="gcd &amp; lcm："></a><strong>gcd &amp; lcm：</strong></h2><h3 id="欧几里得算法（辗转相除）："><a href="#欧几里得算法（辗转相除）：" class="headerlink" title="*欧几里得算法（辗转相除）：*"></a>*<strong>欧几里得算法（辗转相除）：*</strong></h3><p>(a, b) &#x3D; (a - b, b) &#x3D; (a % b, b)；</p><p>每次一定有一个数减半；</p><p>一般对于n个数字一起做gcd，欧几里得的时间复杂度大约是O(n + log (max ai))的；</p><p>(a, b) &#x3D; π pimin(ai, bi)</p><p>[a, b] &#x3D; π pimax(ai, bi)</p><p>(a, b) [a, b] &#x3D; a · b</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a / <span class="built_in">gcd</span>(a, b)) * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高精度欧几里得："><a href="#高精度欧几里得：" class="headerlink" title="高精度欧几里得："></a><em><strong>高精度欧几里得：</strong></em></h3><p>a奇b奇：(a, b) &#x3D; (a - b, b)；</p><p>a偶b奇：(a, b) &#x3D; (a &#x2F; 2, b)；</p><p>a偶b偶：(a, b) &#x3D; 2 · (a &#x2F; 2, b &#x2F; 2)；</p><p>[a, b] &#x3D; ( a &#x2F; (a, b) ) * b（防止爆int）；</p><h3 id="扩展欧几里得："><a href="#扩展欧几里得：" class="headerlink" title="扩展欧几里得："></a><em><strong>扩展欧几里得：</strong></em></h3><p><code>a % b = a - ceil(a / b) · b</code>；</p><p>由归纳法知，假设存在<code>u&#39;, v&#39; s.t. u&#39;b + v&#39;(a % b) = d</code>，</p><p>即<code>u&#39;b + v&#39;(a - ceil(a / b) · b) = d  v&#39;a + (u&#39; - ceil(a / b)) · b = d</code>；</p><p>可知<code>(a, b)</code>的解；</p><p>板子写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)&#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= (a / b) * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="裴蜀定理："><a href="#裴蜀定理：" class="headerlink" title="裴蜀定理："></a><em><strong>裴蜀定理：</strong></em></h3><p>对于任意整数<code>a, b, d, (a, b) | d</code></p><p>存在整数<code>u, v s.t. ua + vb = d</code>；</p><hr><h1 id="质数筛与线性筛："><a href="#质数筛与线性筛：" class="headerlink" title="质数筛与线性筛："></a><strong>质数筛与线性筛：</strong></h1><h2 id="试除法判定质数："><a href="#试除法判定质数：" class="headerlink" title="试除法判定质数："></a>试除法判定质数：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="试除法分解质因数："><a href="#试除法分解质因数：" class="headerlink" title="试除法分解质因数："></a>试除法分解质因数：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i, s ++ ;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="试除法求所有约数："><a href="#试除法求所有约数：" class="headerlink" title="试除法求所有约数："></a>试除法求所有约数：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">get_divisors</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (i != x / i) res.<span class="built_in">push_back</span>(x / i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果 N = p1^c1 * p2^c2 * ... *pk^ck</span></span><br><span class="line"><span class="comment">约数个数： (c1 + 1) * (c2 + 1) * ... * (ck + 1)</span></span><br><span class="line"><span class="comment">约数之和： (p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="质数筛："><a href="#质数筛：" class="headerlink" title="质数筛："></a>质数筛：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n;i++ )&#123;</span><br><span class="line">        <span class="keyword">if</span> (st[i]) <span class="keyword">continue</span>;</span><br><span class="line">        primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + i; j &lt;= n; j += i)&#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//埃拉托斯特尼筛</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1000000</span>；  </span><br><span class="line"><span class="type">void</span> <span class="built_in">Prime</span>()  &#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;MAXN; i++) prime[i]=<span class="number">1</span>;  <span class="comment">//先把每个数都定义为合数</span></span><br><span class="line">    prime[<span class="number">0</span>]=prime[<span class="number">1</span>]=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>;i &lt; MAXN;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!prime[i]) <span class="keyword">continue</span>;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i * <span class="number">2</span>; j &lt; MAXN;j += i) prime[j] = <span class="number">0</span>;  <span class="comment">//将i的倍数标记为合数</span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线性筛："><a href="#线性筛：" class="headerlink" title="线性筛："></a>线性筛：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++ )&#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++ )&#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一种特殊的判断质数的办法："><a href="#一种特殊的判断质数的办法：" class="headerlink" title="一种特殊的判断质数的办法："></a>一种特殊的判断质数的办法：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> n)</span></span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> stop = n / <span class="number">6</span> + <span class="number">1</span>, Tstop = <span class="built_in">sqrt</span>(n) + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">2</span> || n == <span class="number">3</span> || n == <span class="number">5</span> || n == <span class="number">7</span> || n == <span class="number">11</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span> || n % <span class="number">3</span> == <span class="number">0</span> || n % <span class="number">5</span> == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> i = <span class="number">1</span>; i &lt;= stop; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i * <span class="number">6</span> &gt;= Tstop) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line"><span class="keyword">if</span> ((n % (i * <span class="number">6</span> + <span class="number">1</span>) == <span class="number">0</span>) || (n % (i * <span class="number">6</span> + <span class="number">5</span>) == <span class="number">0</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="同余、欧拉函数、逆元"><a href="#同余、欧拉函数、逆元" class="headerlink" title="同余、欧拉函数、逆元"></a><strong>同余、欧拉函数、逆元</strong></h1><h2 id="同余："><a href="#同余：" class="headerlink" title="同余："></a>同余：</h2><p><em>定义与性质：</em></p><p><img src="https://s2.loli.net/2022/08/01/jUXVR18kWfrd4hQ.png" alt="avatar"></p><h2 id="逆元："><a href="#逆元：" class="headerlink" title="逆元："></a>逆元：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(a / b) % c, c为质数</span><br><span class="line">通过费马小定理，即b^(c - 1) % c = 1，等价于</span><br><span class="line">[a * b^(c - 2)] % c</span><br><span class="line">随后对其进行快速幂就可以了</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10100000</span>;</span><br><span class="line"></span><br><span class="line">ll inv[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, p, ans = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios;</span><br><span class="line">cin &gt;&gt; p &gt;&gt; n;</span><br><span class="line">inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">2</span>, n)&#123;</span><br><span class="line">inv[i] = (p - p / i) * inv[p % i] % p;</span><br><span class="line">ans ^= inv[i];</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求欧拉函数："><a href="#求欧拉函数：" class="headerlink" title="求欧拉函数："></a>求欧拉函数：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="type">int</span> phin = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">2</span>; d * d &lt;= n; d++)&#123;</span><br><span class="line"><span class="keyword">if</span> (n % d == <span class="number">0</span>)&#123;</span><br><span class="line">phin = phin / d * (d - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span> (n % d == <span class="number">0</span>)&#123;</span><br><span class="line">n /= d;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n != <span class="number">1</span>)&#123;</span><br><span class="line">phin = phin / n * (n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; phin &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">phi</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) res = res / x * (x - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>筛法求欧拉函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">int</span> euler[N];           <span class="comment">// 存储每个数的欧拉函数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_eulers</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    euler[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            primes[cnt ++ ] = i;</span><br><span class="line">            euler[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = primes[j] * i;</span><br><span class="line">            st[t] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                euler[t] = euler[i] * primes[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            euler[t] = euler[i] * (primes[j] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求 a^k % mod，时间复杂度 O(logk)。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    a %= mod;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k)&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            res = res * a % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="约数之和"><a href="#约数之和" class="headerlink" title="约数之和"></a>约数之和</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(false);cin.tie(0),cout.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,n,a) for (int i=n;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fir first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sec second</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="function">mt19937 <span class="title">mrand</span><span class="params">(random_device&#123;&#125;())</span></span>; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rnd</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">mrand</span>() % x;&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">9901</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    a %= mod;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k)&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            res = res * a % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归去算</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> (p % mod * <span class="built_in">sum</span>(p, k - <span class="number">1</span>) + <span class="number">1</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> + <span class="built_in">qmi</span>(p, k / <span class="number">2</span> + <span class="number">1</span>)) * <span class="built_in">sum</span>(p, k / <span class="number">2</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    <span class="type">int</span> a, b, res = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举a的所有质因子</span></span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">2</span>, a)&#123;</span><br><span class="line">        <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (a % i == <span class="number">0</span>)&#123;</span><br><span class="line">            s++;</span><br><span class="line">            a /= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等比数列求和公式</span></span><br><span class="line">        <span class="keyword">if</span> (s)&#123;</span><br><span class="line">            res = res * <span class="built_in">sum</span>(i, s * b) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!a)&#123;</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a[N][N]是增广矩阵</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gauss</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c, r;</span><br><span class="line">    <span class="keyword">for</span> (c = <span class="number">0</span>, r = <span class="number">0</span>; c &lt; n; c ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i ++ )   <span class="comment">// 找到绝对值最大的行</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; <span class="built_in">fabs</span>(a[t][c]))</span><br><span class="line">                t = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[t][c]) &lt; eps) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = c; i &lt;= n; i ++ ) <span class="built_in">swap</span>(a[t][i], a[r][i]);      <span class="comment">// 将绝对值最大的行换到最顶端</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= c; i -- ) a[r][i] /= a[r][c];      <span class="comment">// 将当前行的首位变成1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r + <span class="number">1</span>; i &lt; n; i ++ )       <span class="comment">// 用当前行将下面所有的列消成0</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; eps)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= c; j -- )</span><br><span class="line">                    a[i][j] -= a[r][j] * a[i][c];</span><br><span class="line"></span><br><span class="line">        r ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][n]) &gt; eps)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// 无解</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 有无穷多组解</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j ++ )</span><br><span class="line">            a[i][n] -= a[i][j] * a[j][n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 有唯一解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="组合数："><a href="#组合数：" class="headerlink" title="组合数："></a>组合数：</h1><h2 id="递推法求组合数："><a href="#递推法求组合数：" class="headerlink" title="递推法求组合数："></a>递推法求组合数：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c[a][b] 表示从a个苹果中选b个的方案数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j ++ )</span><br><span class="line">        <span class="keyword">if</span> (!j) c[i][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> c[i][j] = (c[i - <span class="number">1</span>][j] + c[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br></pre></td></tr></table></figure><h2 id="通过预处理逆元的方式求组合数："><a href="#通过预处理逆元的方式求组合数：" class="headerlink" title="通过预处理逆元的方式求组合数："></a>通过预处理逆元的方式求组合数：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N]</span></span><br><span class="line"><span class="comment">// 如果取模的数是质数，可以用费马小定理求逆元</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k, <span class="type">int</span> p)</span>    <span class="comment">// 快速幂模板</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预处理阶乘的余数和阶乘逆元的余数</span></span><br><span class="line">fact[<span class="number">0</span>] = infact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    fact[i] = (LL)fact[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    infact[i] = (LL)infact[i - <span class="number">1</span>] * <span class="built_in">qmi</span>(i, mod - <span class="number">2</span>, mod) % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lucas定理："><a href="#Lucas定理：" class="headerlink" title="Lucas定理："></a>Lucas定理：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">若p是质数，则对于任意整数 <span class="number">1</span> &lt;= m &lt;= n，有：</span><br><span class="line">    <span class="built_in">C</span>(n, m) = <span class="built_in">C</span>(n % p, m % p) * <span class="built_in">C</span>(n / p, m / p) (mod p)</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">qmi</span>(<span class="type">int</span> a, <span class="type">int</span> k, <span class="type">int</span> p)  <span class="comment">// 快速幂模板</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span>  <span class="comment">// 通过定理求组合数C(a, b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    LL x = <span class="number">1</span>, y = <span class="number">1</span>;  <span class="comment">// x是分子，y是分母</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a, j = <span class="number">1</span>; j &lt;= b; i --, j ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        x = (LL)x * i % p;</span><br><span class="line">        y = (LL) y * j % p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x * (LL)<span class="built_in">qmi</span>(y, p - <span class="number">2</span>, p) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lucas</span><span class="params">(LL a, LL b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; p &amp;&amp; b &lt; p) <span class="keyword">return</span> <span class="built_in">C</span>(a, b, p);</span><br><span class="line">    <span class="keyword">return</span> (LL)<span class="built_in">C</span>(a % p, b % p, p) * <span class="built_in">lucas</span>(a / p, b / p, p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分解质因数法求组合数："><a href="#分解质因数法求组合数：" class="headerlink" title="分解质因数法求组合数："></a>分解质因数法求组合数：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用：</span><br><span class="line">    <span class="number">1.</span> 筛法求出范围内的所有质数</span><br><span class="line">    <span class="number">2.</span> 通过 <span class="built_in">C</span>(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n! 中p的次数是 n / p + n / p^<span class="number">2</span> + n / p^<span class="number">3</span> + ...</span><br><span class="line">    <span class="number">3.</span> 用高精度乘法将所有质因子相乘</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> primes[N], cnt;     <span class="comment">// 存储所有质数</span></span><br><span class="line"><span class="type">int</span> sum[N];     <span class="comment">// 存储每个质数的次数</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个数是否已被筛掉</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span>      <span class="comment">// 线性筛法求素数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> p)</span>       <span class="comment">// 求n！中的次数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        res += n / p;</span><br><span class="line">        n /= p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a, <span class="type">int</span> b)</span>       <span class="comment">// 高精度乘低精度模板</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; c;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += a[i] * b;</span><br><span class="line">        c.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t)</span><br><span class="line">    &#123;</span><br><span class="line">        c.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">get_primes</span>(a);  <span class="comment">// 预处理范围内的所有质数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i ++ )     <span class="comment">// 求每个质因数的次数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> p = primes[i];</span><br><span class="line">    sum[i] = <span class="built_in">get</span>(a, p) - <span class="built_in">get</span>(b, p) - <span class="built_in">get</span>(a - b, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">res.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i ++ )     <span class="comment">// 用高精度乘法将所有质因子相乘</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; sum[i]; j ++ )</span><br><span class="line">        res = <span class="built_in">mul</span>(res, primes[i]);</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="未分类杂项"><a href="#未分类杂项" class="headerlink" title="未分类杂项"></a><strong>未分类杂项</strong></h1><h2 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h2><p>给定n个0和n个1，它们按照某种顺序排成长度为2n的序列，</p><p>满足任意前缀中0的个数都不少于1的个数的序列的数量为： Cat(n) &#x3D; C(2n, n) &#x2F; (n + 1)</p><h2 id="Mex运算"><a href="#Mex运算" class="headerlink" title="Mex运算"></a>Mex运算</h2><p>设S表示一个非负整数集合。定义mex(S)为求出不属于集合S的最小非负整数的运算，即：<br>mex(S) &#x3D; min{x}, x属于自然数，且x不属于S</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;整除、gcd与lcm：&quot;&gt;&lt;a href=&quot;#整除、gcd与lcm：&quot; class=&quot;headerlink&quot; title=&quot;整除、gcd与lcm：&quot;&gt;&lt;/a&gt;&lt;strong&gt;整除、gcd与lcm：&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;算术基本定理：&quot;&gt;&lt;a </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数据结构丨基础</title>
    <link href="https://conqueror712.github.io/post/Data-Structure.html"/>
    <id>https://conqueror712.github.io/post/Data-Structure.html</id>
    <published>2022-07-18T05:31:14.000Z</published>
    <updated>2023-02-15T14:29:18.290Z</updated>
    
    <content type="html"><![CDATA[<p><strong>简介：</strong></p><p>数据结构是在计算机中存储、组织数据的方式。小到变量、数组，大到线段树、平衡树，都是数据结构。</p><p>程序运行离不开数据结构，不同的数据结构又各有优劣，能够处理的问题各不相同，而根据具体问题选取合适的数据结构，可以大大提升程序的效率。所以，学习各种各样的数据结构是很有必要的。</p><hr><h1 id="链表："><a href="#链表：" class="headerlink" title="链表："></a><strong>链表：</strong></h1><h2 id="单链表："><a href="#单链表：" class="headerlink" title="单链表："></a>单链表：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点</span></span><br><span class="line"><span class="type">int</span> head, e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表头插入一个数a</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = a, ne[idx] = head, head = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将头结点删除，需要保证头结点存在</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = ne[head];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双链表："><a href="#双链表：" class="headerlink" title="双链表："></a>双链表：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点</span></span><br><span class="line"><span class="type">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//0是左端点，1是右端点</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>, l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在节点a的右边插入一个数x</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    l[idx] = a, r[idx] = r[a];</span><br><span class="line">    l[r[a]] = idx, r[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点a</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l[r[a]] = l[a];</span><br><span class="line">    r[l[a]] = r[a];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="队列："><a href="#队列：" class="headerlink" title="队列："></a><strong>队列：</strong></h1><p>类似地，鉴于STL的队列有<strong>或多</strong>或少的功能缺失，于是我们就来手写一个队列。</p><p>以下是代码，功能有待完善。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组实现队列的简单操作</span></span><br><span class="line"><span class="type">int</span> q[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> front = <span class="number">1</span>,rear = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    q[++rear] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ++front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;            <span class="comment">//询问第k个元素</span></span><br><span class="line">    <span class="comment">//如何判断队列里有几个元素？ rear - front + 1即可</span></span><br><span class="line">    <span class="keyword">return</span> q[front+k<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Top</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q[front];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不仅如此，我们经常还会用到<strong>循环队列</strong>，这边一并给出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组实现循环队列</span></span><br><span class="line"><span class="comment">//有些时候 入队出队次数远远大于队伍的元素个数，那么开很大的数组就浪费空间了</span></span><br><span class="line"><span class="comment">//于是我们就让 当队尾指针移动到数组末端时，再将其移动到数组头即可，反之亦然</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> size = <span class="number">1001</span>;            <span class="comment">//size要严格大于队列最长的时候的长度</span></span><br><span class="line"><span class="type">int</span> q[size+<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> front = <span class="number">1</span>,rear = size;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    rear = rear % size + <span class="number">1</span>;</span><br><span class="line">    q[rear] = x;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    front = front % size + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rear % size + <span class="number">1</span> == front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (front + x - <span class="number">1</span> &lt;= size)&#123;</span><br><span class="line">        <span class="keyword">return</span> q[front + x - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q[front + x - <span class="number">1</span> - size];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>STL的常用方法也给出（STL队列真真不常用）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//先进先出FIFO</span><br><span class="line">//只允许在后端rear插入，在前端front删除</span><br><span class="line">//queue普通队列 o(1)</span><br><span class="line">queue&lt;int&gt; que;</span><br><span class="line">que.push(1); //入队</span><br><span class="line">que.pop();   //出队</span><br><span class="line">que.empty();</span><br><span class="line">que.size();</span><br><span class="line">que.front(); //返回队头元素</span><br><span class="line">que.back();  //返回队尾元素</span><br><span class="line">//队列没办法像list一样用迭代器遍历，只能出队实现</span><br></pre></td></tr></table></figure><hr><h1 id="栈："><a href="#栈：" class="headerlink" title="栈："></a><strong>栈：</strong></h1><p>鉴于STL的栈有或多或少的功能缺失，于是我们就来手写一个栈。</p><p>以下是代码，功能有待完善。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//栈的简单操作  数组实现</span></span><br><span class="line"><span class="type">int</span> s[<span class="number">100001</span>];                <span class="comment">//创建栈</span></span><br><span class="line"><span class="type">int</span> top = <span class="number">0</span>;            <span class="comment">//创建头指针，一开始在底部</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    s[++top] = x;        <span class="comment">//先移动top 再赋值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        --top;            <span class="comment">//移动top就好啦，虽然原来的数还存在 但是没关系</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Top</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="number">0</span>)&#123;        <span class="comment">//如果一个元素都没有，怎么查询嘛</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s[top];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;        <span class="comment">//查询从栈顶往下数第k个元素是多少</span></span><br><span class="line">    <span class="keyword">return</span> s[top+<span class="number">1</span>-k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>附带一些STL的常用方法：（买一送一）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后进先出</span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; sta;</span><br><span class="line">sta.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">sta.<span class="built_in">top</span>(); <span class="comment">//获取栈顶元素</span></span><br><span class="line">sta.<span class="built_in">pop</span>();</span><br><span class="line">sta.<span class="built_in">empty</span>();</span><br><span class="line">sta.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">//出入都是栈顶元素，且都是o(1);</span></span><br><span class="line">sta.<span class="built_in">top</span>();</span><br></pre></td></tr></table></figure><p>更多详情可以看：[ - C++ Reference (cplusplus.com)](</p><hr><h1 id="二叉树："><a href="#二叉树：" class="headerlink" title="二叉树："></a><strong>二叉树：</strong></h1><p>给出一些<strong>二叉树</strong>的入门级（确信）使用方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用递归的方式建立一个完全二叉树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bulid</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">UpdateData</span>(t);  <span class="comment">//添加数据</span></span><br><span class="line">    <span class="built_in">Build</span>(t + t);   <span class="comment">//如果子节点存在</span></span><br><span class="line">    <span class="built_in">Build</span>(t + t + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//用这种方法建立非完全二叉树 会存在空间浪费的问题</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以用数组下标模拟节点编号，用多个数组来记录节点信息</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode1</span>&#123;    <span class="comment">//可以存储一般二叉树</span></span><br><span class="line">    <span class="type">int</span> value;      <span class="comment">//但是也会产生浪费的空间，具体用哪个就看情况了</span></span><br><span class="line">    <span class="type">int</span> l,r,fa;</span><br><span class="line">&#125; a[<span class="number">100001</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以与链表类似，用指针存储二叉树的父节点&amp;子节点 同时要记录根节点指针</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode2</span>&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    TreeNode2 *l,*r,*fa;</span><br><span class="line">&#125;;</span><br><span class="line">TreeNode2 *root;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下就以指针操作来简介二叉树的基本操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//新建节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    TreeNode *l, *r, *fa; <span class="comment">//初始为NULL</span></span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x)&#123; value = x;&#125;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode *p = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">//根节点初始化</span></span><br><span class="line">TreeNode *root;</span><br><span class="line">root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(v);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除节点（暂空）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入子节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(TreeNode *fa, TreeNode *p,<span class="type">int</span> flag)</span></span>&#123;</span><br><span class="line">    <span class="comment">//flag = 0 插入到左边</span></span><br><span class="line">    <span class="comment">//flag = 1 插入到右边</span></span><br><span class="line">    <span class="keyword">if</span> (!flag)&#123;</span><br><span class="line">        fa-&gt;l = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        fa-&gt;r = p;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;fa = fa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode *p = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(v);</span><br><span class="line"><span class="built_in">Insert</span>(fa,p,flag);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的遍历顺序（先序遍历、中序遍历、后序遍历）&lt;-以根节点的访问时间作为区分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历(DLR)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(TreeNode *p)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; p-&gt;value &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;l) <span class="built_in">PreOrder</span>(p-&gt;l);</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;r) <span class="built_in">PreOrder</span>(p-&gt;r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Pre <span class="title">Order</span><span class="params">(root)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历(LDR)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(TreeNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;l) <span class="built_in">InOrder</span>(p-&gt;l);</span><br><span class="line">    cout &lt;&lt; p-&gt;value &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;r) <span class="built_in">InOrder</span>(p-&gt;r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">InOrder</span>(root);</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历(LRD)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(TreeNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;l) <span class="built_in">PostOrder</span>(p-&gt;l);</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;r) <span class="built_in">PostOrder</span>(p-&gt;r);</span><br><span class="line">    cout &lt;&lt; p-&gt;value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">PostOrder</span>(root);</span><br><span class="line"></span><br><span class="line"><span class="comment">//层级遍历(BFS序列)(基于队列)</span></span><br><span class="line">TreeNode *q[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> front = <span class="number">1</span>, rear = <span class="number">1</span>;</span><br><span class="line">    q[<span class="number">1</span>] = root;</span><br><span class="line">    <span class="keyword">while</span> (front &lt;= rear)&#123;</span><br><span class="line">        TreeNode *p = q[front];</span><br><span class="line">        front++;</span><br><span class="line">        cout &lt;&lt; p-&gt;value &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;l) q[++rear] = p-&gt;l;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;r) q[++rear] = p-&gt;r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">BFS</span>(root);</span><br><span class="line"></span><br><span class="line"><span class="comment">//要实现计算每个节点的深度也不难</span></span><br><span class="line"><span class="comment">//root-&gt;d = 1; 每次++时p-&gt;l/r-&gt;d=p-&gt;d+1;</span></span><br></pre></td></tr></table></figure><hr><h1 id="堆："><a href="#堆：" class="headerlink" title="堆："></a><strong>堆：</strong></h1><p>众所周知，<strong>堆</strong>是一种很好用的数据结构，是基于<strong>完全二叉树</strong>的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//堆的数组实现</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxsize = <span class="number">10000</span>;</span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>;    <span class="comment">//记录当前size</span></span><br><span class="line"><span class="type">int</span> heap[Maxsize+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//当然也可以用vector实现</span></span><br><span class="line">vector &lt;<span class="type">int</span>&gt; Heap;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每一次插入新的数据，都要和它的父节点比一比（判别依据是根据本来是大根堆||小根堆）</span></span><br><span class="line"><span class="comment">//以小根堆举例，插入的复杂度为O(logn)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Up</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(k &gt; <span class="number">1</span> &amp;&amp; heap[k] &lt; heap[k/<span class="number">2</span>])&#123;</span><br><span class="line">        <span class="built_in">swap</span>(heap[k], heap[k/<span class="number">2</span>]);</span><br><span class="line">        k /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    heap[++len] = x;</span><br><span class="line">    <span class="built_in">Up</span>(len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆最常用的功能就是维护min||max</span></span><br><span class="line"><span class="comment">//以小根堆为例，我们常常会求得最小的数字，然后让它出堆；</span></span><br><span class="line"><span class="comment">//这时候我们就要从堆中删除堆顶元素。</span></span><br><span class="line"><span class="comment">//由于这时除了堆顶为空，它的左右子树堆仍然满足堆结构。</span></span><br><span class="line"><span class="comment">//为了操作简单，我们将堆尾元素放到堆顶，然后再将其&quot;逐 步 下 移&quot;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Down</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(k + k &lt;= len)&#123;</span><br><span class="line">        <span class="type">int</span> j = k + k;</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= len &amp;&amp; heap[j + <span class="number">1</span>] &lt; heap[j])&#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (heap[k] &lt;= heap[j])&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(heap[k],heap[j]);</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(heap[<span class="number">1</span>],heap[len]);</span><br><span class="line">    len--;</span><br><span class="line">    <span class="built_in">Down</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除堆中任意一个元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == len)&#123;</span><br><span class="line">        heap[len] = <span class="number">0</span>;  <span class="comment">//这句其实可以不写</span></span><br><span class="line">        len--;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x = heap[p];</span><br><span class="line">    <span class="type">int</span> y = heap[len];</span><br><span class="line">    <span class="built_in">swap</span>(heap[p],heap[len]);</span><br><span class="line">    len--;</span><br><span class="line">    <span class="keyword">if</span> (y &lt; x)&#123;</span><br><span class="line">        <span class="built_in">Up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">Down</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，对于我这种Blue_Dog(bushi)，可以采用方便的STL</p><p>STL里的堆的缺点就是没办法clear，也不知道为什么。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//STL</span></span><br><span class="line"><span class="comment">//大根堆：</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q1;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt;&gt; q2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//小根堆：</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt; q3;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基本操作：empty size top push pop...(没有clear)</span></span><br></pre></td></tr></table></figure><hr><h1 id="哈希："><a href="#哈希：" class="headerlink" title="哈希："></a><strong>哈希</strong>：</h1><h2 id="整数哈希："><a href="#整数哈希：" class="headerlink" title="整数哈希："></a>整数哈希：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//哈希操作</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> modnum = <span class="number">11</span>;</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; HashTable[modnum];</span><br><span class="line"></span><br><span class="line"><span class="comment">//哈希函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Hash</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x % modnum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入新值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> addr = <span class="built_in">Hash</span>(x);</span><br><span class="line">    HashTable[addr] = x;</span><br><span class="line">    HashTable[addr].<span class="built_in">push_back</span>(x);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsExist</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> addr = <span class="built_in">Hash</span>(x);</span><br><span class="line">    <span class="type">int</span> len = HashTable[addr].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt;= len<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (HashTable[addr][i] == x)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//值冲突解决方法一：往后找第一个空着的位置（非最优）</span></span><br><span class="line"><span class="comment">//分别在Insert和IsExist函数中插入或修改为以下语句</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">while (HashTable[addr] NOT NULL)</span></span><br><span class="line"><span class="comment">    addr = (addr + 1) % modnum;</span></span><br><span class="line"><span class="comment">——————————————————————————————————</span></span><br><span class="line"><span class="comment">while (HashTable[addr] NOT NULL)&#123;</span></span><br><span class="line"><span class="comment">    if (HashTable[addr] == x)&#123;</span></span><br><span class="line"><span class="comment">        return true;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    addr = (addr + 1) % modnum;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">return false;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//值冲突解决方法二：在每一个存放哈希值的地方都开一张链表来存放对应数值</span></span><br><span class="line"><span class="comment">//每次查找元素的时候就先找到对应的链表头，然后遍历这整张链表就行</span></span><br><span class="line"><span class="comment">//推荐用vector，就如上所示</span></span><br></pre></td></tr></table></figure><h2 id="字符串哈希："><a href="#字符串哈希：" class="headerlink" title="字符串哈希："></a>字符串哈希：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串哈希</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Hash</span><span class="params">(<span class="type">char</span> s[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        res = (res * base + (s[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>)) % p;</span><br><span class="line">        a[i] = res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CalcSubstringHash</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = a[l<span class="number">-1</span>] * <span class="built_in">pow</span>(base,r-l+<span class="number">1</span>) % p;  <span class="comment">//但是pow很慢！</span></span><br><span class="line">    <span class="keyword">return</span> (a[r] - t + p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="unordered-map："><a href="#unordered-map：" class="headerlink" title="unordered_map："></a><strong>unordered_map：</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(false);cin.tie(0),cout.tie(0)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="comment">//const ll mod = 1e9+7;</span></span><br><span class="line"><span class="comment">//const ll mod = 1000003;</span></span><br><span class="line"><span class="comment">//const ll mod = 9999971;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;string,<span class="type">int</span>&gt; hash_table;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Query</span><span class="params">(string name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hash_table.<span class="built_in">find</span>(name) == hash_table.<span class="built_in">end</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">404</span>; <span class="comment">//查无此人</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash_table[name];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    hash_table[<span class="string">&quot;ZhangSan&quot;</span>] = <span class="number">21</span>;</span><br><span class="line">    hash_table[<span class="string">&quot;LiSi&quot;</span>] = <span class="number">22</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">Query</span>(<span class="string">&quot;ZhangSan&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="单调栈与单调队列："><a href="#单调栈与单调队列：" class="headerlink" title="单调栈与单调队列："></a>单调栈与单调队列：</h1><h2 id="单调栈："><a href="#单调栈：" class="headerlink" title="单调栈："></a>单调栈：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单调栈，就是满足栈中元素是单调递增或递减的线性数据结构；</span></span><br><span class="line"><span class="comment">// 利用栈LIFO的特点和其中元素的单调性可以解决许多问题。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常见模型：找出每个数左边离它最近的比它大/小的数</span></span><br><span class="line"><span class="type">int</span> tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (tt &amp;&amp; <span class="built_in">check</span>(stk[tt], i)) tt -- ;</span><br><span class="line">    stk[ ++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单调队列："><a href="#单调队列：" class="headerlink" title="单调队列："></a>单调队列：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单调队列，就是满足队列中元素是单调递增或递减的先行数据结构；</span></span><br><span class="line"><span class="comment">// 利用队列FIFO的特点和其中元素的单调性也可以解决许多问题。</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 单调队列是可以用双端队列来实现的，下面是一个求动态区间最大数的例题：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常见模型：找出滑动窗口中的最大值/最小值</span></span><br><span class="line">deque &lt;<span class="type">int</span>&gt; q;</span><br><span class="line">VI ans;</span><br><span class="line"><span class="type">int</span> n, a[<span class="number">200010</span>], m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, n)&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, n)&#123;</span><br><span class="line">        <span class="keyword">if</span> (q.<span class="built_in">empty</span>() || a[i] &lt;= a[q.<span class="built_in">back</span>()])&#123;</span><br><span class="line">            q.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; a[i] &gt; a[q.<span class="built_in">back</span>()])&#123;</span><br><span class="line">                q.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i - q.<span class="built_in">front</span>() + <span class="number">1</span> &gt; m)&#123;</span><br><span class="line">            q.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= m)&#123;</span><br><span class="line">            ans.<span class="built_in">pb</span>(a[q.<span class="built_in">front</span>()]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : ans)&#123;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="树："><a href="#树：" class="headerlink" title="树："></a><strong>树：</strong></h1><p>下面我们来介绍一般意义上的树，</p><p>包括<strong>有根树</strong> 和 <strong>无根树</strong>；</p><p>有根树基本操作：</p><p><strong>vector实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100001</span>;</span><br><span class="line"></span><br><span class="line">VI edges[N + <span class="number">1</span>];</span><br><span class="line"><span class="comment">//数组里面的每一个元素都是一个vector，就是用vector来存树，当然也可以用链表来存</span></span><br><span class="line"><span class="comment">//edges[i]（这是个vector）就代表第i个点的所有子节点的下标</span></span><br><span class="line"><span class="type">int</span> n, father[N + <span class="number">1</span>];<span class="comment">//n代表树里面有多少个节点，father[]代表节点的父节点编号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    edges[x].<span class="built_in">pb</span>(y);<span class="comment">//给x节点添加一个儿子y</span></span><br><span class="line">    father[y] = x;<span class="comment">//更新y的父节点信息（对于有根树而言）</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintSon1</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//遍历x的所有儿子</span></span><br><span class="line">    <span class="type">int</span> cntson = edges[x].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; cntson;i++)&#123;</span><br><span class="line">        cout &lt;&lt; edges[x][i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintSon2</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//更简洁的写法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : edges[x])&#123;</span><br><span class="line">        cout &lt;&lt; edges[x][i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VI dfn;<span class="comment">//有根树的DFS序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    dfn.<span class="built_in">pb</span>(x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="comment">/*x的所有儿子y*/</span>)&#123;</span><br><span class="line">        <span class="built_in">DFS</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//DFS(root);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//有根树的BFS序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="comment">//将root加入队列q</span></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="comment">//x = q队首元素;</span></span><br><span class="line">        <span class="comment">//x出队;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="comment">/*x的所有儿子y*/</span>)&#123;</span><br><span class="line">            <span class="comment">//y入队;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BFS(root);</span></span><br><span class="line"><span class="comment">//q中出现的元素顺序即BFS序</span></span><br></pre></td></tr></table></figure><hr><p><strong>链表实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100001</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">100001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> where;<span class="comment">//记录Node的下标</span></span><br><span class="line">    Node *next;</span><br><span class="line">&#125; *head[N + <span class="number">1</span>], a[M];<span class="comment">//a[M]与a[N]在有根树内等价，a[]用来存Node</span></span><br><span class="line"><span class="comment">//head[i] -&gt; son -&gt; sonson -&gt; sonsonson...</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, father[N + <span class="number">1</span>], l = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    a[++l].where = y;<span class="comment">//先++</span></span><br><span class="line">    a[l].next = head[x];</span><br><span class="line">    head[x] = &amp;a[l];</span><br><span class="line">    father[y] = x;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintSon</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Node *p = head[x]; p; p = p-&gt;next)&#123;</span><br><span class="line">        cout &lt;&lt; p-&gt;where &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS2</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="comment">/*x的所有相邻节点y*/</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (y ！= from)&#123;</span><br><span class="line">            <span class="built_in">DFS2</span>(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//DFS(-1, x);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS2</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//将x加入队列q，x的来源节点为空</span></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        x = q队首元素</span></span><br><span class="line"><span class="comment">        from = x的来源节点</span></span><br><span class="line"><span class="comment">        x出队</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="comment">/*x的所有相邻节点y*/</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (y != from)&#123;</span><br><span class="line">                <span class="comment">//y入队</span></span><br><span class="line">                <span class="comment">//y的来源节点为x</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//BFS(x);</span></span><br></pre></td></tr></table></figure><hr><p><strong>无根树</strong>的求<strong>树上路径</strong>模板题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">rd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000001</span>;</span><br><span class="line">VI edges[N + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> pre[N + <span class="number">1</span>], l, c[N + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : edges[x])&#123;</span><br><span class="line">        <span class="keyword">if</span> (i != pre[x])&#123;</span><br><span class="line">            pre[i] = x;</span><br><span class="line">            <span class="built_in">DFS</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    <span class="type">int</span> n, x, y, u, v;</span><br><span class="line">    n = <span class="built_in">rd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n - <span class="number">1</span>;i++)&#123;</span><br><span class="line">        x = <span class="built_in">rd</span>();</span><br><span class="line">        y = <span class="built_in">rd</span>();</span><br><span class="line">        edges[x].<span class="built_in">pb</span>(y);</span><br><span class="line">        edges[y].<span class="built_in">pb</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    u = <span class="built_in">rd</span>();</span><br><span class="line">    v = <span class="built_in">rd</span>();</span><br><span class="line">    pre[u] = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">DFS</span>(u);</span><br><span class="line">    l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = v;i != u;i = pre[i])&#123;</span><br><span class="line">        c[++l] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    c[++l] = u;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l; i;--i)&#123;</span><br><span class="line">        cout &lt;&lt; c[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>接下来我们说一说<strong>树的直径</strong>：</p><p>树的直径是指树上任意两个节点之间最长（经过边的数量）的路径。</p><p>一棵树可以存在很多条直径，其长度相等。</p><p>树的直径的中间节点被称为<strong>树的中心</strong>，如果直径上的节点总数是偶数，则有两个中心。</p><p><em><strong>树的中心到其他点的最长路径最短。</strong></em></p><p>树的直径可以用<strong>两次搜索</strong>求得，第一次从<strong>任意节点</strong>开始搜索，找出距离最远的节点a；</p><p>第二次从节点a出发，找到距离节点a最远的节点b，则路径a-b即为树的直径。</p><p><em><strong>（反证法可证）</strong></em></p><hr><p>然后我们把时间交给<strong>树的重心</strong></p><p>对于一颗无根树而言，当一个节点被选为根节点时，</p><p>它底下每个子节点的子树的大小（子树包含的节点数目）的最大值最小的那个节点，</p><p>被称为树的重心。</p><p>一棵树有可能有一个或两个重心。</p><p>树的重心有以下<strong>性质</strong>：</p><p>　　当重心为根节点时，它底下的每个子树的大小不大于整棵树大小的一半；</p><p>　　重心到其他所有节点的距离之和（路径长度）最小；</p><p>树的重心可以通过枚举根节点，然后递归求出所有子节点的子树大小，最后进行比较得到。</p><hr><h1 id="字典树："><a href="#字典树：" class="headerlink" title="字典树："></a><strong>字典树：</strong></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//----------用数组实现a -&gt; z的字典树----------</span></span><br><span class="line"><span class="comment">//注：若next报错则用nxt等其他变量名</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> charsize = <span class="number">26</span>;    <span class="comment">//字符集大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//记录此节点的子节点编号（默认全是小写字母）</span></span><br><span class="line"><span class="type">int</span> next[maxn + <span class="number">1</span>][charsize];</span><br><span class="line"></span><br><span class="line"><span class="comment">//表示此编号节点是否为终止节点</span></span><br><span class="line"><span class="type">bool</span> isEnd[maxn + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> root = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;    <span class="comment">//表示当前的节点编号数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//----------字典树的插入----------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s为等待插入的字符串，1base，len为字符串长度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> s[], <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> now = <span class="number">0</span>;    <span class="comment">//当前在哪个节点上</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= len;i++)&#123;   <span class="comment">//遍历，没什么好说的</span></span><br><span class="line">        <span class="type">int</span> x = s[i] - <span class="string">&#x27;a&#x27;</span>;     <span class="comment">//转成数字</span></span><br><span class="line">        <span class="keyword">if</span> (!next[now][x])&#123;     <span class="comment">//如果当前节点没有子节点x，则创建之，并且给予编号</span></span><br><span class="line">            next[now][x] = ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        now = next[now][x];     <span class="comment">//无论创建了新节点与否，都更新当前节点的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    isEnd[now] = <span class="literal">true</span>;          <span class="comment">//最后的最后，把该字符串的最后一个字符的isEnd标记为true</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------字典树的查找----------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实际上查找和插入的本质是相似的</span></span><br><span class="line"><span class="comment">//s为等待插入的字符串，1base，len为字符串长度</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(<span class="type">char</span> s[], <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> now = <span class="number">0</span>;    <span class="comment">//和上面一样，记录当前在看的节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len;i++)&#123;  <span class="comment">//遍历之</span></span><br><span class="line">        <span class="type">int</span> x = s[i] - <span class="string">&#x27;a&#x27;</span>;     <span class="comment">//转成数字</span></span><br><span class="line">        <span class="keyword">if</span> (!next[now][x])&#123;     <span class="comment">//如果当前节点没有子节点x，则直接返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        now = next[now][x];     <span class="comment">//如果没有return则更新当前节点位置，继续循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isEnd[now];          <span class="comment">//最后进行判断最后一个字符是否是结束位置，返回即可</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------字典树的删除----------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//其实Trie树需要删除数据的情况比较罕见</span></span><br><span class="line"><span class="comment">//这个时候我们需要记录每个树节点的&quot;子树大小&quot;，这里的子树大小不同于一般的概念（一般的就是说子树有多少个节点）</span></span><br><span class="line"><span class="comment">//这里的子树大小指的是该节点的子树上有多少个真实存在的字符串（真实存在的意思就是必须结尾字符的isEnd是true）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于要删除的字符串，先用查找字符串的方式找到末尾，删除标记（isEnd）后回溯整条路径</span></span><br><span class="line"><span class="comment">//值得一提的是，如果路径上节点的子树大小为0，就可以直接删除这个节点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//----------用Struct存储字典树----------</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> charsize = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----简单写法-----</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> next[charsize];</span><br><span class="line">    <span class="type">bool</span> isEnd;</span><br><span class="line">&#125; tree[maxn + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----当字符集较大时-----</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    unordered_map &lt;<span class="type">char</span>, <span class="type">int</span>&gt; next_map;</span><br><span class="line">    <span class="type">bool</span> isEnd;</span><br><span class="line">&#125; tree[maxn + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----指针-----</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    TreeNode *next[charsize];</span><br><span class="line">    <span class="type">bool</span> isEnd;</span><br><span class="line">&#125; *root;</span><br></pre></td></tr></table></figure><p>另一种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="comment">// 0号点既是根节点，又是空节点</span></span><br><span class="line"><span class="comment">// son[][]存储树中每个节点的子节点</span></span><br><span class="line"><span class="comment">// cnt[]存储以每个节点结尾的单词数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一个字符串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) son[p][u] = ++ idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询字符串出现的次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="并查集："><a href="#并查集：" class="headerlink" title="并查集："></a><strong>并查集：</strong></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-----并查集的初始化-----</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一开始有n个元素，互相独立，则构成了n个集合，每个集合的代表元素就是它本身</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[maxn + <span class="number">1</span>];   <span class="comment">//fa数组记录每个元素由谁代表</span></span><br><span class="line"><span class="type">int</span> sz[maxn + <span class="number">1</span>];   <span class="comment">//sz数组记录每个集合的元素个数</span></span><br><span class="line"><span class="type">int</span> dep[maxn + <span class="number">1</span>];  <span class="comment">//dep数组记录每个集合的树深度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Initialize</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123; <span class="comment">//一共有n个点</span></span><br><span class="line">        fa[i] = i;              <span class="comment">//把代表元素设置为自己</span></span><br><span class="line">        sz[i] = dep[i] = <span class="number">1</span>;     <span class="comment">//一开始的深度就是1，子树大小也是1，因为只有自己孤零零的一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----集合合并-----</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Findset</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;     <span class="comment">//这个是用来找代表元素的函数，递归找</span></span><br><span class="line">    <span class="keyword">if</span> (fa[x] == x)&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Findset</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> fx = <span class="built_in">Findset</span>(x);</span><br><span class="line">    <span class="type">int</span> fy = <span class="built_in">Findset</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (fx == fy)&#123;      <span class="comment">//如果发现是一家子的，那得了直接完事儿了</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fa[fx] = fy;        <span class="comment">//否则我们就搞个强扭的瓜，扭到一起去  反过来写也是可以</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----路径压缩-----</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//大致思路就是在查询的操作过程中，把沿途经过的每一个节点的fa都设置为集合的代表元</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QuicklyFindset</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == fa[x])&#123;    <span class="comment">//如果就是代表元素就直接返回咯</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    fa[x] = <span class="built_in">QuicklyFindset</span>(fa[x]);      <span class="comment">//在不是的情况下每一次都设置一遍</span></span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">上述代码简写版：</span></span><br><span class="line"><span class="comment">int QuicklyFindset(int x)&#123;</span></span><br><span class="line"><span class="comment">    return x == fa[x] ? x : (fa[x] == QuicklyFindset(fa[x]));</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-----启发式合并-----</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//log的复杂度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//大体思路：在合并集合的过程中，我们尽量选择包含元素个数少的集合，将它合并到另一个集合之中去，使要改变代表元的元素尽可能的少</span></span><br><span class="line"><span class="comment">//这种将较小的集合合并到较大的集合之中的方法被称为 启发式合并，在其他的数据结构中也很常见</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeuristicUnion</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> fx = <span class="built_in">Findset</span>(x);</span><br><span class="line">    <span class="type">int</span> fy = <span class="built_in">Findset</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (fx == fy)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sz[fx] &gt; sz[fy])&#123;</span><br><span class="line">        <span class="built_in">swap</span>(fx, fy);   <span class="comment">//确定谁是骡子谁是马</span></span><br><span class="line">    &#125;</span><br><span class="line">    fa[fx] = fy;</span><br><span class="line">    sz[fy] += sz[fx];   <span class="comment">//子树的大小也要加起来</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----按深度合并-----</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//log的复杂度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//大体思路：每一次合并的过程中，将深度较小的集合合并到深度较大的一方去，并更新一下新集合的深度</span></span><br><span class="line"><span class="comment">//值得一提的是，在路径压缩的时候，可能会破坏维护的深度值，但其实整体算法的复杂度不会变差</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeepUnion</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> fx = <span class="built_in">Findset</span>(x);</span><br><span class="line">    <span class="type">int</span> fy = <span class="built_in">Findset</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (fx == fy)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dep[fx] &gt; dep[fy])&#123;</span><br><span class="line">        <span class="built_in">swap</span>(fx, fy);</span><br><span class="line">    &#125;</span><br><span class="line">    fa[fx] = fy;</span><br><span class="line">    <span class="keyword">if</span> (dep[fx] == dep[fy])&#123;    <span class="comment">//只有两棵树深度相等的时候才会更新</span></span><br><span class="line">        dep[fy]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a><strong>线段树</strong></h1><p>线段树就是解决线段问题的一种树形结构，是一种数据结构。</p><p><img src="C:\Users\22562\AppData\Roaming\Typora\typora-user-images\image-20221103141204075.png" alt="image-20221103141204075"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, ope_cnt, f[<span class="number">2000001</span>], a[<span class="number">500001</span>]; <span class="comment">//f[i]记录的是编号为i的节点记录的区间和</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">BuildTree</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">//k是编号 l r是左端点和右端点</span></span><br><span class="line"><span class="keyword">if</span> (l == r)&#123;</span><br><span class="line"><span class="comment">//走到叶子节点了，走不动了</span></span><br><span class="line">f[k] = a[l];<span class="comment">//f[k] = a[r]当然也可以，无所谓</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = (l + r) / <span class="number">2</span>;<span class="comment">//这里可以用(l + r) &gt;&gt; 1，也是除以2的意思</span></span><br><span class="line"><span class="comment">//获得了当前区间的中点，开始分割递归</span></span><br><span class="line"><span class="built_in">BuildTree</span>(k + k, l, mid);</span><br><span class="line"><span class="built_in">BuildTree</span>(k + k + <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">f[k] = f[k + k] + f[k + k + <span class="number">1</span>];</span><br><span class="line"><span class="comment">//这里是用到了完全二叉树的节点编号的性质，父节点为k，则两个子节点分别为k + k和k + k + 1</span></span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//整棵树就建好了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="comment">//k是编号</span></span><br><span class="line"><span class="comment">//递归的去从根节点开始加val，一直加到点x上</span></span><br><span class="line">f[k] += val;</span><br><span class="line"><span class="keyword">if</span> (l == r)&#123;</span><br><span class="line"><span class="comment">//再怎么想都进不去了吧</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = (l + r) / <span class="number">2</span>;<span class="comment">//又是找中点的一步</span></span><br><span class="line"><span class="keyword">if</span> (x &lt;= mid)&#123;</span><br><span class="line"><span class="comment">//如果x在mid的左边，也就是说要往左子树递归</span></span><br><span class="line"><span class="built_in">Add</span>(k + k, l, mid, x, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//如果x在mid的右边，也就是说要往右子树递归</span></span><br><span class="line"><span class="built_in">Add</span>(k + k + <span class="number">1</span>, mid + <span class="number">1</span>, r, x, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line"><span class="comment">//编号为k的点对应的区间是l~r，s~t是其子区间</span></span><br><span class="line"><span class="keyword">if</span> (l == s &amp;&amp; r == t)&#123;</span><br><span class="line"><span class="keyword">return</span> f[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (t &lt;= mid)&#123;</span><br><span class="line"><span class="comment">//如果s~t完全位于左区间</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">calc</span>(k + k, l, mid, s, t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s &gt; mid)&#123;</span><br><span class="line"><span class="comment">//如果s~t完全位于右区间</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">calc</span>(k + k + <span class="number">1</span>, mid + <span class="number">1</span>, r, s, t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//如果s~t横跨两边，加起来即可</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">calc</span>(k + k, l, mid, s, mid) + <span class="built_in">calc</span>(k + k + <span class="number">1</span>, mid + <span class="number">1</span>, r, mid + <span class="number">1</span>, t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; ope_cnt;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归建树</span></span><br><span class="line"><span class="built_in">BuildTree</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= ope_cnt; i++)&#123;</span><br><span class="line"><span class="type">int</span> ope, x, val;</span><br><span class="line">cin &gt;&gt; ope &gt;&gt; x &gt;&gt; val;</span><br><span class="line"><span class="keyword">if</span> (ope == <span class="number">1</span>)&#123;<span class="comment">//操作1：第x个数加上k</span></span><br><span class="line"><span class="built_in">Add</span>(<span class="number">1</span>, <span class="number">1</span>, n, x, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="comment">//操作2：查询区间x~y的区间和</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">calc</span>(<span class="number">1</span>, <span class="number">1</span>, n, x, val) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;简介：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据结构是在计算机中存储、组织数据的方式。小到变量、数组，大到线段树、平衡树，都是数据结构。&lt;/p&gt;
&lt;p&gt;程序运行离不开数据结构，不同的数据结构又各有优劣，能够处理的问题各不相同，而根据具体问题选取合适的数据结构，可</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>算法丨动态规划</title>
    <link href="https://conqueror712.github.io/post/DP.html"/>
    <id>https://conqueror712.github.io/post/DP.html</id>
    <published>2022-07-17T05:33:24.000Z</published>
    <updated>2023-02-15T14:29:47.292Z</updated>
    
    <content type="html"><![CDATA[<p><strong>简介：</strong></p><p>动态规划是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。</p><p>由于动态规划并不是某种具体的算法，而是一种解决特定问题的方法，因此它会出现在各式各样的数据结构中，与之相关的题目种类也更为繁杂。</p><hr><h1 id="背包问题："><a href="#背包问题：" class="headerlink" title="背包问题："></a><strong>背包问题：</strong></h1><p>首先当然是我们最熟悉的<strong>01背包</strong>啦！</p><p>最简单的想法是，<strong>二维dp数组</strong>，不考虑其他的优化。</p><p><strong>状态</strong>：</p><p><code>dp[i][j]</code> 表示取第 <code>i</code> 个物品，总体积为 <code>j</code> 时候的情况。</p><p>那么我们就会获得两种转移情况，对于下一个物品。一种是取了，一种是没取。</p><p>于是我们获得了<strong>状态转移方程</strong>：</p><p><code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i]);</code></p><p>这里要说明的是，01背包大多数都是对j<strong>倒序枚举</strong>，而完全背包则是<strong>正序枚举</strong>。</p><p>至于为什么是这种顺序或者那种顺序，只需要看<strong>状态转移</strong>是怎么转移的就好啦。</p><p>实在不行可以画个图帮忙理解。</p><p>代码展示如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(false);cin.tie(0),cout.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,n,a) for (int i=n;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fir first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sec second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="function">mt19937 <span class="title">mrand</span><span class="params">(random_device&#123;&#125;())</span></span>; </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ORZ cout &lt;&lt; <span class="string">&quot;Orz&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rnd</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">mrand</span>() % x;&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, v[N], w[N], dp[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// dp[j]表示总体积为j时候的情况</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, n)&#123;</span><br><span class="line">cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, n)&#123;</span><br><span class="line"><span class="built_in">per</span>(j, m, v[i])&#123;</span><br><span class="line">dp[j] = <span class="built_in">max</span>(dp[j], dp[j - v[i]] + w[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dp[m] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>有了01背包，怎么能少了<strong>完全背包</strong>呢！</p><p>基于上题，这里就不多做赘述，直接上关键部分（<strong>一维dp数组</strong>优化）。</p><p><strong>状态</strong>：</p><p><code>dp[j]</code> 表示总体积为 <code>j</code> 时候的情况。</p><p><strong>状态转移方程</strong>：</p><p><code>dp[j] = max(dp[j],dp[j-v[i]] + w[i]);</code></p><p>代码展示如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(false);cin.tie(0),cout.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,n,a) for (int i=n;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fir first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sec second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="function">mt19937 <span class="title">mrand</span><span class="params">(random_device&#123;&#125;())</span></span>; </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ORZ cout &lt;&lt; <span class="string">&quot;Orz&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rnd</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">mrand</span>() % x;&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1001</span>;</span><br><span class="line"><span class="type">int</span> n, m, v[N], w[N], dp[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 考虑前i种物品 总体积为j时分两种情况：</span></span><br><span class="line"><span class="comment">// 1. 第i种物品没取，问题变成了考虑前i - 1种物品 总体积为j时的情况</span></span><br><span class="line"><span class="comment">// 2. 第i种物品去了，问题变成了考虑前i种物品 总体积为j - v[i]时的情况</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, n)&#123;</span><br><span class="line">cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, n)&#123;</span><br><span class="line"><span class="built_in">rep</span>(j, v[i], m)&#123;</span><br><span class="line">dp[j] = <span class="built_in">max</span>(dp[j], dp[j - v[i]] + w[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dp[m] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>接下来要登场的是大名鼎鼎的<strong>多重背包</strong>！</p><p>顾名思义，每种物品可以取多个（有限）。</p><p><strong>状态</strong>：</p><p><code>dp[j]</code> 表示总体积为 <code>j</code> 时候的情况。</p><p><strong>状态转移方程</strong>：</p><p><code>dp[j] = max(dp[j],dp[j-v[i]] + w[i]);</code></p><p>什么嘛，这跟前几个的状态转移方程有什么区别嘛！这不是唬人呢嘛！</p><p>其实，多重背包的重点在于<code>for循环</code>的不同。</p><p>对于数据量<strong>比较小</strong>的情况，我们直接<strong>暴力</strong>三重<code>for</code>就行了，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(false);cin.tie(0),cout.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,n,a) for (int i=n;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fir first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sec second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="function">mt19937 <span class="title">mrand</span><span class="params">(random_device&#123;&#125;())</span></span>; </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ORZ cout &lt;&lt; <span class="string">&quot;Orz&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rnd</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">mrand</span>() % x;&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">101</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第i种物品可以使用l[i]次，只需要把它拆成l[i]个物品，每个物品只能用一次，就转化成了01背包问题</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios;</span><br><span class="line"><span class="type">int</span> n, m, v[N], w[N], l[N], dp[N];</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, n)&#123;</span><br><span class="line">cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; l[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, n)&#123;</span><br><span class="line"><span class="built_in">rep</span>(j, <span class="number">1</span>, l[i])&#123;</span><br><span class="line"><span class="built_in">per</span>(k, m, v[i])&#123;</span><br><span class="line">dp[k] = <span class="built_in">max</span>(dp[k], dp[k - v[i]] + w[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dp[m] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释一下：</p><p>第一重 <code>i</code> 的含义不变，枚举第 <code>i</code> 种物品的情况；</p><p>第二重 <code>k</code> 的含义是 我这一种（第 <code>i</code> 种）物品一共有<code>l[i]</code>个，那么我当然可以取从<code>1</code>到<code>l[i]</code>个该种物品啦！</p><p>第三重 <code>j</code> 的含义就很简单啦，首先我们看到这是逆序遍历的，是因为这其实相当于一个01背包，只不过把<code>l[i]</code>次展开了而已，又因为我们用的是一维dp数组，故采用逆序遍历的方法。这里的下界的意思是，如果这个物品的体积比<code>j</code>还大，那么显然不用考虑了，直接continue就可以了。</p><p>当然，对于数据量较大（真的很大）的多重背包我们就不能这么写了（除非你有量子计算机之类的bushi）。</p><p>那么应该如何写呢，我们来看。</p><p>话不多说，先上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(false);cin.tie(0),cout.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,n,a) for (int i=n;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fir first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sec second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="function">mt19937 <span class="title">mrand</span><span class="params">(random_device&#123;&#125;())</span></span>; </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ORZ cout &lt;&lt; <span class="string">&quot;Orz&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rnd</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">mrand</span>() % x;&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当数据量更大的时候就需要换一种拆解方法，不能线性的拆了</span></span><br><span class="line"><span class="comment">// 第i种物品可以使用l[i]次，我们可以拆成logn个物品，每个物品只能使用一次</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2001</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios;</span><br><span class="line"><span class="type">int</span> n, m, v[N], w[N], l[N], dp[N];</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, n)&#123;</span><br><span class="line">cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; l[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">   <span class="type">int</span> res = l[i];</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= res; res -= k, k *= <span class="number">2</span>)&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= v[i] * k; j--)&#123;</span><br><span class="line">   dp[j] = <span class="built_in">max</span>(dp[j], dp[j - v[i] * k] + w[i] * k);</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= v[i] * res; j--)&#123;</span><br><span class="line">   dp[j] = <span class="built_in">max</span>(dp[j], dp[j - v[i] * res] + w[i] * res);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dp[m] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们在每次枚举<code>i</code>的时候，都用一个<code>res</code>把该种物品的个数记下来。</p><p>对于每一次枚举<code>k</code>，我们让<code>res -= k &amp;&amp; k *= 2</code></p><p>也就是说，这里<code>res</code>就记录的是剩余的数量（因为把<code>k</code>个都拿走了）。</p><p>至于这里为什么让<code>k *= 2</code>，牵扯到一个<strong>数学小知识</strong>：</p><p>1,2,…,2^m中选一些数字相加，可以得出任意的∈[ 0 , 2^(m+1) )的值，且每个数字只能用一次。</p><p>用<strong>数学归纳法</strong>不难证明。</p><p>这样一来，我们的第二重循环的复杂度就由<code>n</code>化到了<code>logn</code>，与此同时，<code>j</code>也随之变化。</p><p>此外，还有一种基于<strong>单调队列</strong>的多重背包实现方法，这里暂时挖个坑，以后可能会添加进来（）。</p><hr><p>下面是<strong>分组背包</strong>。懒了，直接上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">1000</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = m;j &gt;= <span class="number">0</span>;j--)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> k: c[i])&#123;<span class="comment">//vector &lt;int&gt; c;</span></span><br><span class="line"> <span class="keyword">if</span> (v[k] &lt;= j)</span><br><span class="line">dp[j] = <span class="built_in">max</span>(dp[j],dp[j-v[k]]+w[k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及<strong>二维背包</strong>。偷懒++：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = m;j &gt;= v[i];j--)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = k;x &gt;= t[i];x--)&#123;</span><br><span class="line">dp[j][x] = <span class="built_in">max</span>(dp[j][x],dp[j-v[i]][x-t[i]] + w[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后续的多维背包也是一样的思路。</p><hr><h1 id="数位DP："><a href="#数位DP：" class="headerlink" title="数位DP："></a><strong>数位DP：</strong></h1><p><strong>数位DP的引入（数位和）：</strong></p><p>考虑这样一个问题，对于区间<code>[l, r]</code>，询问在此之间的整数，总共出现0 ~ 9的次数。</p><p>举例：</p><p>对于区间<code>[1, 100]</code>情况如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cnt_0 = 11</span><br><span class="line">cnt_1 = 21</span><br><span class="line">cnt_2 = cnt_3 = cnt_4 = cnt_5 = cnt_6 = cnt_7 = cnt_8 = cnt_9 = 20</span><br></pre></td></tr></table></figure><p>如此，我们就搞明白了这个问题在问什么。</p><p>显然的是，区间<code>[l, r] = [1, r] - [1, l - 1]</code>。</p><p><strong>一般的结论：</strong></p><p>我们考虑<code>[1, n]</code>的情况，不妨把n逐位拆分成<code>a1 a2 a3 ...am </code>，总共m位。</p><p>如果让前面<code>i - 1</code>位的数字与n一致，也就是说前<code>i - 1</code>是固定的，则这写固定的位置对于答案的贡献不难得出：</p><p>​对于<code>j &lt; i</code>，有<code>a i  * 10^(m - i)</code>个数字第<code>j</code>位是<code>a j </code></p><p>举个例子：对于n &#x3D; 12345来说，如果我们选取<code>i</code>为第三位，即数字3，则前面的1与2都是固定的，后面的数字（ i 之后）可以随意排列组合，所以说有上述那么多个数字（排列方式）的第<code>j</code>位是<code>aj </code>，这里<code>aj </code>就是之前说的固定的值，在本例中是1与2。</p><p>那么，对于第<code>i</code>位本身来说，可以进行枚举不超过 ai 的所有数值，即：</p><p>​<code>第i位可以是0, 1, ..., ai - 1, 分别出现了10^(m - i)次</code></p><p>之所以能出现这么多次是因为它后面的数可以随机排列组合，和前面的思路类似，同样地，对于n &#x3D; 12345，i &#x3D; 3的话，那么这里就可以取1和2了。</p><p>最后，我们来看后面的满足<code>j &gt; i</code>的位置<code>j</code>，可以是0 ~ 9的任何数字，因为再怎么取也不会大过n了。</p><p>​<code>对于x ∈ [0, 9] 有a i  * 10^(m - i - 1)个数字第j位是x</code></p><p>​<code>一共有m - i个位置，所以x的出现次数要加上(m - i) * [a i  * 10^(m - i - 1)]</code></p><p><strong>但是</strong>，存在一个问题是，对于<code>m - 1</code>位的情况来说，这样做会把前导0也算进去；</p><p>对于这种情况，我们可以枚举第一个非零位置<code>pos</code>在哪里：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pos == <span class="number">1</span>)&#123;</span><br><span class="line">满足j &gt; i的位置j是<span class="number">0</span>的数字有(a <span class="number">1</span>  - <span class="number">1</span>) * <span class="number">10</span>^(m - <span class="number">2</span>)个</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">满足j &gt; i的位置j是<span class="number">0</span>的数字有<span class="number">9</span> * <span class="number">10</span>^(m - i - <span class="number">1</span>)个</span><br><span class="line">&#125;</span><br><span class="line">由于一共有m - i个位置，所以<span class="number">0</span>的出现次数要加上<span class="number">9</span> * <span class="number">10</span>^(m - i - <span class="number">1</span>) * (m - i)</span><br></pre></td></tr></table></figure><p>最后的最后，我们再把n &#x3D; n的情况考虑一下就好啦！</p><p>下面是稍微  有点问题  的代码（待修改）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(false);cin.tie(0),cout.tie(0)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for (int i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,n,a) for (int i=n;i&gt;=a;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pf push_front</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(x) (x).begin(),(x).end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fir first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sec second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ(x) ((int)(x).size())</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="function">mt19937 <span class="title">mrand</span><span class="params">(random_device&#123;&#125;())</span></span>; </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ORZ cout &lt;&lt; <span class="string">&quot;Orz&quot;</span> &lt;&lt; endl;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rnd</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">mrand</span>() % x;&#125;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span> </span>&#123; <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> c[<span class="number">21</span>];</span><br><span class="line">ll l, r, ans[<span class="number">10</span>], f[<span class="number">17</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">calc</span><span class="params">(ll n, <span class="type">int</span> xs)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 把 n 的每个数位处理出来</span></span><br><span class="line"><span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; n; n /= <span class="number">10</span>)&#123;</span><br><span class="line">c[++m] = n % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = m; i &lt; j; i++, j--)&#123;</span><br><span class="line"><span class="built_in">swap</span>(c[i], c[j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//枚举第 i 类</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line"><span class="comment">// 处理 &lt; i 的位置 j 的贡献</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++)&#123;</span><br><span class="line">ans[c[j]] += xs * c[i] * f[m - i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//考虑第 i 位的贡献</span></span><br><span class="line"><span class="comment">//非零的那些数字</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; c[i]; j++)&#123;</span><br><span class="line">ans[j] += xs * f[m - i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当前不是第一类并且当前这一位可以放 0，考虑 0 出现的次数</span></span><br><span class="line"><span class="keyword">if</span> (i != <span class="number">1</span> &amp;&amp; c[i])&#123;</span><br><span class="line">ans[<span class="number">0</span>] += xs * f[m - i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//考虑 &gt; i 的那些位置的贡献</span></span><br><span class="line"><span class="keyword">if</span> (m != i) &#123;</span><br><span class="line"><span class="comment">//非零的那些数字</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; <span class="number">10</span>; j++)&#123;</span><br><span class="line">ans[j] += xs * f[m - i - <span class="number">1</span>] * (m - i) * c[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当前不是第一类，考虑 0 出现的次数</span></span><br><span class="line"><span class="keyword">if</span> (i != <span class="number">1</span>)&#123;</span><br><span class="line">ans[<span class="number">0</span>] += xs * f[m - i - <span class="number">1</span>] * (m - i) * c[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计第一类中 0 出现的次数</span></span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 考虑首位非零</span></span><br><span class="line"><span class="keyword">if</span> (m &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">ans[<span class="number">0</span>] += xs * (c[<span class="number">1</span>] - <span class="number">1</span>) * (m - <span class="number">1</span>) * f[m - <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 考虑后面那些位置非 0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt; m; j++)&#123;</span><br><span class="line">ans[<span class="number">0</span>] += xs * <span class="number">9</span> * (m - j) * f[m - j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 再把 n 的贡献统计进去</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">ans[c[i]] += xs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios;</span><br><span class="line"><span class="comment">//先处理 10 的 x 次方等于几</span></span><br><span class="line">f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">16</span>; i++)&#123;</span><br><span class="line">f[i] = f[i - <span class="number">1</span>] * <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line"><span class="comment">//calc 的第二个参数 = 1 表示加，-1 表示减</span></span><br><span class="line"><span class="built_in">calc</span>(r, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">calc</span>(l - <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="comment">//按要求输出结果</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="状压DP："><a href="#状压DP：" class="headerlink" title="状压DP："></a><strong>状压DP：</strong></h1><p>状态压缩的基本思想就是，用一个<strong>数字</strong>（大多数是十进制数字）来<strong>枚举每一种状态</strong>，有可能是十进制对应的二进制的<code>01</code>串所蕴含的信息，也有可能是别的形式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;简介：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;动态规划是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。&lt;/p&gt;
&lt;p&gt;由于动态规划并不是某种具体的算法，而是一种解决特定问题的方法，因此它会出现在各式各样的数据结构中，与之相关的题目种类也更为繁杂。</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Pytorch + Openmmlab丨学习记录</title>
    <link href="https://conqueror712.github.io/post/openmmlab.html"/>
    <id>https://conqueror712.github.io/post/openmmlab.html</id>
    <published>2022-07-16T11:20:19.000Z</published>
    <updated>2023-02-15T14:30:08.704Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h3><p>本篇内容目前用于记录自己的学习过程，方便自己查阅，或许正在看本文的你对其中的一些内容有所疑惑，这大概是本人为了方便自己阅读和理解所以写的不够清楚的原因所致，如果你有任何想询问的问题，欢迎访问B站同名账号私信联系，或者在我的Github公开仓库中提问（目前尚未开放其他联系功能）。</p><hr><h3 id="更新日志："><a href="#更新日志：" class="headerlink" title="更新日志："></a>更新日志：</h3><p>2022.07.12 本文初稿，简要说明了一些环境配置上的问题和重要步骤。</p><p>2022.07.13 修改了一些版本上的错误。</p><p>2022.07.18 合并了Pytorch的学习记录。</p><p>2022.08.30 更新了一些有关镜像的内容。</p><hr><h1 id="零-Pytorch入门"><a href="#零-Pytorch入门" class="headerlink" title="零.  Pytorch入门"></a><strong>零.  Pytorch入门</strong></h1><p>Anaconda Prompt的一些操作：</p><h2 id="创建环境："><a href="#创建环境：" class="headerlink" title="创建环境："></a><strong>创建环境：</strong></h2><p><code>conda create -n name1 python=3.9</code></p><p>这里 -n 后面的内容是你创建的环境的名字，</p><p>随后如果出现 <code>The following NEW packages will be INSTALLED:</code>，yes即可。</p><p><strong>激活and取消激活这些包的指令：</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda activate &lt;环境名&gt;</span><br><span class="line">conda deactivate</span><br></pre></td></tr></table></figure><p><code>pip list</code>可以知道这个环境中有哪些工具包</p><hr><h2 id="加载数据："><a href="#加载数据：" class="headerlink" title="加载数据："></a><strong>加载数据：</strong></h2><p>Dataset 提供一种方式去获取数据及其label</p><p>Dataloader 为后面的网络提供不同的数据形式</p><p><code>nvidia-smi</code>可以知道自己的英伟达显卡的具体信息，CUDA9.2版本需要396.26版本</p><p>复制安装指令，安装即可。</p><p>安装过程中出现如下信息同上操作：</p><p><code>The following NEW packages will be INSTALLED:</code></p><p>随后再次使用pip list查看是否有Pytorch即可（过程太慢请使用镜像）。</p><p>另一种检查方法是键入<code>python</code>进入python，然后<code>import torch</code></p><p>随后再输入<code>torch.cuda.is_available()</code>，如果返回True则成功。</p><p>在Pytorch中安装Jupyter</p><p><code>conda install nb_conda</code></p><p>随后键入jupyter notebook即可</p><hr><p> 下面是一些调用数据的实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyData</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="comment"># 初始化，根据这个类来创建特定的实例时需要</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root_dir, label_dir</span>):</span><br><span class="line">        self.root_dir = root_dir</span><br><span class="line">        self.label_dir = label_dir</span><br><span class="line">        self.path = os.path.join(self.root_dir, self.label_dir)</span><br><span class="line">        self.img_path = os.listdir(self.path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">        img_name = self.img_path[idx]</span><br><span class="line">        img_item_path = os.path.join(self.root_dir, self.label_dir, img_name)</span><br><span class="line">        img = Image.<span class="built_in">open</span>(img_item_path)</span><br><span class="line">        label = self.label_dir</span><br><span class="line">        <span class="keyword">return</span> img, label</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.img_path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root_dir = <span class="string">&quot;dataset/train&quot;</span></span><br><span class="line">ants_label_dir = <span class="string">&quot;ants&quot;</span></span><br><span class="line">bees_label_dir = <span class="string">&quot;bees&quot;</span></span><br><span class="line">ants_dataset = MyData(root_dir, ants_label_dir)</span><br><span class="line">bees_dataset = MyData(root_dir, bees_label_dir)</span><br><span class="line"></span><br><span class="line">train_dataset = ants_dataset + bees_dataset</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然，也可以通过修改文件夹名字来进行如上操作，这里就不给出了。</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/07/20/Qyeo9GJg4FjxEc8.png" alt="avatar"></p><p><img src="https://s2.loli.net/2022/07/20/jzoCbfUGEZOQsJq.png" alt="avatar"></p><hr><h1 id="一-配置环境"><a href="#一-配置环境" class="headerlink" title="一.  配置环境"></a><strong>一.  配置环境</strong></h1><ul><li>Linux &#x2F; Windows</li><li>Python</li><li>Pytorch</li><li>CUDA</li><li>gcc &amp;&amp; g++ (5.4+)</li><li>mmcv-full</li></ul><hr><h2 id="Windows环境-or-Linux环境："><a href="#Windows环境-or-Linux环境：" class="headerlink" title="Windows环境 or Linux环境："></a>Windows环境 or Linux环境：</h2><p>我们先来看mmcv，安装mmcv的前提是环境中需要有Pytorch。</p><p>Pytorch我选择在conda中进行安装，并且采用了国内的镜像。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">conda config <span class="literal">--add</span> channels https://mirrors.ustc.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config <span class="literal">--add</span> channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config <span class="literal">--add</span> channels https://mirrors.ustc.edu.cn/anaconda/cloud/conda<span class="literal">-forge</span>/</span><br><span class="line">conda config <span class="literal">--add</span> channels https://mirrors.ustc.edu.cn/anaconda/cloud/msys2/</span><br><span class="line">conda config <span class="literal">--add</span> channels https://mirrors.ustc.edu.cn/anaconda/cloud/bioconda/</span><br><span class="line">conda config <span class="literal">--add</span> channels https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/</span><br><span class="line">conda config <span class="literal">--add</span> channels https://mirrors.ustc.edu.cn/anaconda/cloud/pytorch/</span><br><span class="line">conda config <span class="literal">--set</span> show_channel_urls yes</span><br><span class="line">上述镜像疑似失效 目前采用清华源</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">conda config <span class="literal">--add</span> channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/ </span><br><span class="line">conda config <span class="literal">--add</span> channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda<span class="literal">-forge</span>/ </span><br><span class="line">conda config <span class="literal">--add</span> channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config <span class="literal">--add</span> channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ </span><br><span class="line">conda config <span class="literal">--add</span> channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/peterjc123/</span><br><span class="line">conda config <span class="literal">--add</span> channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/</span><br><span class="line">conda config <span class="literal">--set</span> show_channel_urls yes</span><br></pre></td></tr></table></figure><ol><li><h3 id="创建并激活conda虚拟环境："><a href="#创建并激活conda虚拟环境：" class="headerlink" title="创建并激活conda虚拟环境："></a>创建并激活conda虚拟环境：</h3></li></ol><p><code>conda create -n mmcv python=3.8 -y</code></p><p><code>conda activate mmcv</code></p><ol start="2"><li><h3 id="安装Pytorch和Torchvision："><a href="#安装Pytorch和Torchvision：" class="headerlink" title="安装Pytorch和Torchvision："></a>安装Pytorch和Torchvision：</h3></li></ol><p><code>conda install pytorch==1.10.0 torchvision cudatoolkit=11.3 -c pytorch</code></p><p>注意，这里版本号之间不仅需要更改成自己需要的版本，还需要注意对应关系。</p><p>值得一提的是，如果采用国内的镜像，则需要去掉<code>-c</code>，否则还是会很慢。</p><ol start="3"><li><h3 id="安装最新版mmcv-full（注意，这是使用预编译包，如果要从源码编译，则直接跳转至下文！）："><a href="#安装最新版mmcv-full（注意，这是使用预编译包，如果要从源码编译，则直接跳转至下文！）：" class="headerlink" title="安装最新版mmcv-full（注意，这是使用预编译包，如果要从源码编译，则直接跳转至下文！）："></a>安装最新版mmcv-full（注意，这是使用预编译包，如果要从源码编译，则直接跳转至下文！）：</h3></li></ol><p><code>pip install mmcv-full -f https://download.openmmlab.com/mmcv/dist/&#123;cu_version&#125;/&#123;torch_version&#125;/index.html</code></p><p>注意，链接中的 <code>&#123;cu_version&#125;</code> 和 <code>&#123;torch_version&#125;</code> 根据自身需求替换成实际的版本号。</p><p>本人在安装的时候使用的指令是：</p><p><code>pip install mmcv-full -f https://download.openmmlab.com/mmcv/dist/cu113/torch1.10.0/index.html</code></p><p>值得一提的是，貌似还有一种安装方法是用MIM，但本人在Linux下试了一次没有成功。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip3 install openmim</span><br><span class="line">mim install mmcv<span class="literal">-full</span>==<span class="number">1.5</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure><hr><h2 id="查看环境版本指令："><a href="#查看环境版本指令：" class="headerlink" title="查看环境版本指令："></a>查看环境版本指令：</h2><p><code>python --version</code>Python</p><p><code>print(torch.__version__)</code>Pytorch（python环境下，并且导入torch）</p><p><code>nvcc -V</code>CUDA</p><p><code>gcc -v</code>gcc</p><p><code>print(mmedit.__version__)</code> mmedit（python环境下，并且导入mmedit）</p><hr><p>直到这里，都属于安装MMCV的阶段，以上步骤在Windows和Linux下几乎都一样，接下来到了从源码上编译MMCV，Windows就要复杂一些了，具体如下：</p><h2 id="Windows环境编译MMCV："><a href="#Windows环境编译MMCV：" class="headerlink" title="Windows环境编译MMCV："></a>Windows环境编译MMCV：</h2><p>依赖：</p><ul><li>Git</li><li>Visual Studio</li><li>Anaconda（推荐） | Miniconda</li><li>CUDA</li></ul><p>注意需要启用的是Anaconda命令行而非一般的命令行。</p><p>这里防止出错，直接部分<em>引用官方文档</em>：</p><h3 id="创建一个新的-Conda-环境"><a href="#创建一个新的-Conda-环境" class="headerlink" title="创建一个新的 Conda 环境"></a>创建一个新的 Conda 环境</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create <span class="literal">--name</span> mmcv python=<span class="number">3.8</span>  <span class="comment"># 经测试，3.6, 3.7, 3.8 也能通过</span></span><br><span class="line">conda activate mmcv  <span class="comment"># 确保做任何操作前先激活环境</span></span><br></pre></td></tr></table></figure><p>安装 PyTorch 时，可以根据需要安装支持 CUDA 或不支持 CUDA 的版本</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CUDA version</span></span><br><span class="line">conda install pytorch==<span class="number">1.10</span>.<span class="number">0</span> torchvision cudatoolkit=<span class="number">11.3</span> <span class="literal">-c</span> pytorch</span><br><span class="line"><span class="comment"># 注意，这里的版本一定要对应，否则会报错！</span></span><br></pre></td></tr></table></figure><h3 id="准备-MMCV-源代码"><a href="#准备-MMCV-源代码" class="headerlink" title="准备 MMCV 源代码"></a>准备 MMCV 源代码</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/<span class="built_in">open-mmlab</span>/mmcv.git</span><br><span class="line"><span class="built_in">cd</span> mmcv</span><br></pre></td></tr></table></figure><h3 id="安装所需-Python-依赖包"><a href="#安装所需-Python-依赖包" class="headerlink" title="安装所需 Python 依赖包"></a>安装所需 Python 依赖包</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install <span class="literal">-r</span> requirements/runtime.txt</span><br></pre></td></tr></table></figure><p><strong>建议安装 <code>ninja</code> 以加快编译速度</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install <span class="literal">-r</span> requirements/optional.txt</span><br></pre></td></tr></table></figure><h4 id="接下来就要开始编译过程了："><a href="#接下来就要开始编译过程了：" class="headerlink" title="接下来就要开始编译过程了："></a>接下来就要开始编译过程了：</h4><h3 id="设置-MSVC-编译器"><a href="#设置-MSVC-编译器" class="headerlink" title="设置 MSVC 编译器"></a>设置 MSVC 编译器</h3><p>设置环境变量。添加 <code>C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\bin\Hostx86\x64</code> 到 <code>PATH</code>，则 <code>cl.exe</code> 可以在命令行中运行，如下所示，以下是测试部分：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(base) <span class="built_in">PS</span> C:\Users\xxx&gt; cl</span><br><span class="line">Microsoft (<span class="built_in">R</span>) C/C++ Optimizing  Compiler Version <span class="number">19.27</span>.<span class="number">29111</span> <span class="keyword">for</span> x64</span><br><span class="line">Copyright (C) Microsoft Corporation.   All rights reserved.</span><br><span class="line"></span><br><span class="line">usage: cl [ <span class="type">option...</span> ] filename... [ / <span class="type">link</span> <span class="type">linkoption...</span> ]</span><br></pre></td></tr></table></figure><p>为了兼容性，我们使用 x86-hosted 以及 x64-targeted 版本，即路径中的 <code>Hostx86\x64</code> （注意先后顺序）。</p><p>因为 PyTorch 将解析 <code>cl.exe</code> 的输出以检查其版本，只有 utf-8 将会被识别，你可能需要将系统语言更改为英语。</p><p>控制面板 -&gt; 地区-&gt; 管理-&gt; 非 Unicode 来进行语言转换。</p><h3 id="设置环境变量（注意这里是PS终端）："><a href="#设置环境变量（注意这里是PS终端）：" class="headerlink" title="设置环境变量（注意这里是PS终端）："></a>设置环境变量（注意这里是PS终端）：</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$env:MMCV_WITH_OPS</span> = <span class="number">1</span></span><br><span class="line"><span class="variable">$env:MAX_JOBS</span> = <span class="number">8</span>  <span class="comment"># 根据你可用CPU以及内存量进行设置</span></span><br></pre></td></tr></table></figure><p>检查 <code>CUDA_PATH</code> 或者 <code>CUDA_HOME</code> 环境变量已经存在在 <code>envs</code> 之中</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(base) <span class="built_in">PS</span> C:\Users\WRH&gt; <span class="built_in">ls</span> env:</span><br><span class="line"></span><br><span class="line">Name                           Value</span><br><span class="line"><span class="literal">----</span>                           <span class="literal">-----</span></span><br><span class="line">CUDA_PATH                      C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.<span class="number">3</span></span><br><span class="line">CUDA_PATH_V11_3                C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.<span class="number">3</span></span><br><span class="line">CUDA_PATH_V11_7                C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.<span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>如 果 没 有</strong>，你可以按照下面的步骤设置</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$env:CUDA_HOME</span> = <span class="string">&quot;C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.3&quot;</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="variable">$env:CUDA_HOME</span> = <span class="variable">$env:CUDA_PATH_V11_3</span>  <span class="comment"># CUDA_PATH_V11_3 已经在环境变量中</span></span><br></pre></td></tr></table></figure><h3 id="设置-CUDA-的目标架构"><a href="#设置-CUDA-的目标架构" class="headerlink" title="设置 CUDA 的目标架构"></a>设置 CUDA 的目标架构</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$env:TORCH_CUDA_ARCH_LIST</span>=<span class="string">&quot;6.1&quot;</span> <span class="comment"># 支持 GTX 1080（本人是1050qwq）</span></span><br><span class="line"><span class="comment"># 或者用所有支持的版本，但可能会变得很慢</span></span><br><span class="line"><span class="variable">$env:TORCH_CUDA_ARCH_LIST</span>=<span class="string">&quot;3.5 3.7 5.0 5.2 6.0 6.1 7.0 7.5&quot;</span></span><br></pre></td></tr></table></figure><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$env:MMCV_WITH_OPS</span> = <span class="number">1</span></span><br><span class="line"><span class="variable">$env:MAX_JOBS</span> = <span class="number">8</span> <span class="comment"># 根据你可用CPU以及内存量进行设置（保守点可以输4）</span></span><br><span class="line">conda activate mmcv <span class="comment"># 激活环境</span></span><br><span class="line"><span class="built_in">cd</span> mmcv  <span class="comment"># 改变路径</span></span><br><span class="line">python setup.py build_ext  <span class="comment"># 如果成功, cl 将被启动用于编译算子</span></span><br><span class="line">python setup.py develop <span class="comment"># 安装</span></span><br><span class="line">pip list <span class="comment"># 检查是否安装成功</span></span><br></pre></td></tr></table></figure><p>与此同时，我们可以进行MMEditing的安装：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/<span class="built_in">open-mmlab</span>/mmediting.git</span><br><span class="line"><span class="built_in">cd</span> mmediting</span><br><span class="line">pip3 install <span class="literal">-e</span> .</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">python <span class="literal">-c</span> <span class="string">&quot;import mmedit; print(mmedit.__version__)&quot;</span></span><br><span class="line"><span class="comment"># Example output: 0.14.0</span></span><br></pre></td></tr></table></figure><hr><p>接下来要装MMSegmentation，这里暂时先不展开。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;写在前面：&quot;&gt;&lt;a href=&quot;#写在前面：&quot; class=&quot;headerlink&quot; title=&quot;写在前面：&quot;&gt;&lt;/a&gt;写在前面：&lt;/h3&gt;&lt;p&gt;本篇内容目前用于记录自己的学习过程，方便自己查阅，或许正在看本文的你对其中的一些内容有所疑惑，这大概是本人为了方便自</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>图论丨基础</title>
    <link href="https://conqueror712.github.io/post/Graph-Theory.html"/>
    <id>https://conqueror712.github.io/post/Graph-Theory.html</id>
    <published>2022-07-15T05:34:21.000Z</published>
    <updated>2023-02-24T03:18:15.084Z</updated>
    
    <content type="html"><![CDATA[<p><strong>简介：</strong></p><p><strong>图论 (Graph theory)</strong> 是数学的一个分支，图是图论的主要研究对象。<strong>图 (Graph)</strong> 是由若干给定的顶点及连接两顶点的边所构成的图形，这种图形通常用来描述某些事物之间的某种特定关系。顶点用于代表事物，连接两顶点的边则用于表示两个事物间具有这种关系。</p><hr><h1 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h1><h2 id="直接存边"><a href="#直接存边" class="headerlink" title="直接存边"></a>直接存边</h2><p>不可取</p><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, m)&#123;</span><br><span class="line"><span class="type">int</span> u, v;</span><br><span class="line">cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">edge1[u][v] = <span class="number">1</span>;</span><br><span class="line">edge1[v][u] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有边则1，无边则0</span></span><br></pre></td></tr></table></figure><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// edge[i]记录的是 当前i号点通过一条边能走到哪些点 也是一个数组</span></span><br><span class="line">vector &lt;<span class="type">int</span>&gt; edge[N];</span><br></pre></td></tr></table></figure><h2 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1005</span>;<span class="comment">//点数最大值</span></span><br><span class="line"><span class="type">int</span> n, m, cnt;<span class="comment">//n个点，m条边</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to, w, next;<span class="comment">//终点，边权，同起点的上一条边的编号</span></span><br><span class="line">&#125;edge[maxn];<span class="comment">//边集</span></span><br><span class="line"><span class="type">int</span> head[maxn];<span class="comment">//head[i],表示以i为起点的第一条边在边集数组的位置（编号）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span><span class="comment">//初始化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) head[i] = <span class="number">-1</span>;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span><span class="comment">//加边，u起点，v终点，w边权</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].to = v; <span class="comment">//终点</span></span><br><span class="line">    edge[cnt].w = w; <span class="comment">//权值</span></span><br><span class="line">    edge[cnt].next = head[u];<span class="comment">//以u为起点上一条边的编号，也就是与这个边起点相同的上一条边的编号</span></span><br><span class="line">    head[u] = cnt++;<span class="comment">//更新以u为起点上一条边的编号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> u, v, w;</span><br><span class="line">    <span class="built_in">init</span>();<span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)<span class="comment">//输入m条边</span></span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="built_in">add_edge</span>(u, v, w);<span class="comment">//加边</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        加双向边</span></span><br><span class="line"><span class="comment">        add_edge(u, v, w);</span></span><br><span class="line"><span class="comment">        add_edge(v, u, w);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="comment">//n个起点</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = head[i]; j != <span class="number">-1</span>; j = edge[j].next)<span class="comment">//遍历以i为起点的边</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; edge[j].to &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; edge[j].w &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5 7</span></span><br><span class="line"><span class="comment">1 2 1</span></span><br><span class="line"><span class="comment">2 3 2</span></span><br><span class="line"><span class="comment">3 4 3</span></span><br><span class="line"><span class="comment">1 3 4</span></span><br><span class="line"><span class="comment">4 1 5</span></span><br><span class="line"><span class="comment">1 5 6</span></span><br><span class="line"><span class="comment">4 5 7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><p><code>O(n + m)</code></p><h2 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">// st[u] 表示点u已经被遍历过</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j]) <span class="built_in">dfs</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">st[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 表示1号点已经被遍历过</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>; <span class="comment">// 表示点j已经被遍历过</span></span><br><span class="line">            q.<span class="built_in">push</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="最短路算法："><a href="#最短路算法：" class="headerlink" title="最短路算法："></a><strong>最短路算法：</strong></h1><h2 id="Bellman-Ford："><a href="#Bellman-Ford：" class="headerlink" title="Bellman-Ford："></a>Bellman-Ford：</h2><p><strong>前置：</strong></p><p>对于无向图中的一条边(u↔v)，可以看作有向图中两条边(u→v)and(v→u)的结合。</p><p>我们可以通过这种方式把无向图转化为有向图，</p><p>从而使用有向图的最短路算法。</p><p><strong>图的一些记号：</strong></p><p>G &#x3D; &lt;V,E&gt;代表一个简单有向图（简单图：没有重边和自环）</p><p>n &#x3D; |V|代表顶点数</p><p>m &#x3D; |E|代表边数</p><p>l(u,v)代表u到v的边权</p><p>S代表起点，T代表终点</p><p>dist(u)代表当前求出的S到u的最短路径长度</p><p><strong>特别地：</strong></p><p>对于所有边权都大于等于0的图，</p><p>任意两个顶点之间的最短路，</p><p>显然不会经过重复的顶点或者边。</p><p>也就是说任意一条最短路经过的顶点数不会超过n个，边不会超过n-1条。</p><p>而对于有边权为负的图，有可能图中会存在负环，<strong>此时</strong>途径负环的最短路没有意义。</p><p><strong>Bellman-Ford算法</strong></p><p><strong>核心思想：</strong></p><p>松弛操作(Relieve)，即对于边(u,v)，用dist(u)和l(u,v)的和 尝试更新dist(v)：</p><p><code>dist[v] = min(dist[v], dist[u]+ l(u,v))</code></p><p>如此，不断尝试对图上的每一条边进行松弛操作。</p><p>每次迭代就对所有的边进行该操作，直到某一次迭代没有发生任何改变时停止。</p><p>在最短路存在的情况下，由于一次迭代会使得最短路的边数至少+1</p><p>而S到每个顶点的最短路经过的边数最多为n-1</p><p>因此整个算法最多会进行n-1轮迭代，每一轮复杂度为O(m)</p><p>则总复杂度为O(nm)</p><p>基于此我们得出，当从S出发能到达一个负环时，就会进行n轮以上的迭代</p><p>我们可以外加一个超级初节点，使得其到任意一个点的边权为0，</p><p>从而在O(nm)的复杂度里检测图上是否存在负环。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y, v;</span><br><span class="line">&#125; edge[M];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, dist[N], pre[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shortestpath</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">127</span>, <span class="built_in">sizeof</span>(dist));        <span class="comment">//Initialization</span></span><br><span class="line">    dist[s] = <span class="number">0</span>;                            <span class="comment">//Initialization</span></span><br><span class="line">    <span class="keyword">for</span> (;;)&#123;       </span><br><span class="line">    <span class="comment">// 在每次迭代中，遍历所有边，尝试用Relieve_Operation更新距离数组</span></span><br><span class="line">        <span class="type">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">            <span class="type">int</span> x = edge[i].x;</span><br><span class="line">            <span class="type">int</span> y = edge[i].y;</span><br><span class="line">            <span class="type">int</span> v = edge[i].v;</span><br><span class="line">            <span class="keyword">if</span> (dist[x] + <span class="number">1</span> &lt;&lt; <span class="number">30</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (dist[x] + v &lt; dist[y])&#123;</span><br><span class="line">                    dist[y] = dist[x] + v;</span><br><span class="line">                    pre[y] = x;</span><br><span class="line">                    ok = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!ok)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//pre数组是为了打印路径</span></span><br><span class="line"><span class="comment">//此代码保证了题目的数据不会出现负环</span></span><br></pre></td></tr></table></figure><p>大名鼎鼎的SPFA就是Bellman-Ford的队列优化方法，但是不要写就对了，这里也直接略过。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vector邻接表写法（GOOD!）</span></span><br><span class="line">vector &lt;PII&gt; edge[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shortestpath</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">127</span>, <span class="built_in">sizeof</span>(dist));</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">// 在每次迭代中，遍历所有边，尝试用Relieve_Operation更新距离数组</span></span><br><span class="line">        <span class="type">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it : edge[i])&#123;</span><br><span class="line">            <span class="type">int</span> x = i;</span><br><span class="line">            <span class="type">int</span> y = it.fir;</span><br><span class="line">            <span class="type">int</span> v = it.sec;</span><br><span class="line">            <span class="keyword">if</span> (dist[x] &lt; (<span class="number">1</span> &lt;&lt; <span class="number">30</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span> (dist[x] + v &lt; dist[y])&#123;</span><br><span class="line">                    dist[y] = dist[x] + v;</span><br><span class="line">                    ok = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!ok)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[t];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Dijkstra："><a href="#Dijkstra：" class="headerlink" title="Dijkstra："></a>Dijkstra：</h2><p>Dijkstra算法常用于求<strong>无负权</strong>边中的最短路，</p><p>在优化后有比Bellman-Ford算法优秀很多的时间复杂度。</p><p><strong>同样的，我们引入记号：</strong></p><p>G &#x3D; &lt;V,E&gt;代表一个简单有向图（简单图：没有重边和自环）</p><p>n &#x3D; |V|代表顶点数</p><p>m &#x3D; |E|代表边数</p><p>l(u,v)代表u到v的边权</p><p>S代表起点，T代表终点</p><p>dist(u)代表当前求出的S到u的最短路径长度</p><hr><p><strong>Dijkstra算法简介：</strong></p><p>我们要维护一个<strong>顶点集合C</strong>，</p><p>满足对于所有集合C中的<strong>顶点x</strong>，我们都已经找到了<strong>起点S到x的最短路</strong>，</p><p>此时，<strong>dist(x)<strong>记录的就是</strong>最终最短路的长度</strong>。</p><hr><p><strong>Dijkstra算法流程：</strong></p><ol><li>初始化：</li></ol><p>将C设置为空，将S的距离设置为0，其余顶点的距离设置为正无穷。</p><ol start="2"><li>更新：</li></ol><p>每一轮中，将<strong>离起点最近的（dist最小，不能是无穷大）还不在C中</strong>的顶点加入C， </p><p>并且用这个点连出去的边，通过<strong>松弛操作</strong>尝试更新其他点的dist。</p><ol start="3"><li>判断：</li></ol><p>当T（如果T存在）或者没有新的点加入C时，算法结束。</p><p>由于图上并不存在负权边，可以证明每次加入C的点，</p><p>都已经找到了从起点到它的最短路。</p><hr><p> 代码实现：O(n2 + m)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">vector &lt;PII&gt; edge[N];</span><br><span class="line"><span class="type">int</span> n, m, dist[N];</span><br><span class="line"><span class="type">bool</span> b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(b, <span class="literal">false</span>, <span class="built_in">sizeof</span>(b));</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">127</span>, <span class="built_in">sizeof</span>(dist));</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!b[i] &amp;&amp; dist[i] &lt; <span class="number">1</span> &lt;&lt; <span class="number">30</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (x == <span class="number">-1</span> || dist[i] &lt; dist[x])&#123;</span><br><span class="line">                    x = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x == t || x == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        b[x] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : edge[x])&#123;</span><br><span class="line">            dist[p.fir] = <span class="built_in">min</span>(dist[p.fir], dist[x] + p.sec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[t];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆优化Dijkstra：O((n + m)log n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用一个堆来维护dist数组，可以使用set，也可以使用priority_queue</span></span><br><span class="line">vector &lt;PII&gt; edge[N];</span><br><span class="line"></span><br><span class="line">set &lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">vector &lt;PII&gt; edge[N];</span><br><span class="line"><span class="type">int</span> n, m, dist[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">127</span>, <span class="built_in">sizeof</span>(dist));</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        q.<span class="built_in">insert</span>(&#123;dist[i], i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x = q.<span class="built_in">begin</span>()-&gt;second;</span><br><span class="line">        q.<span class="built_in">erase</span>(q.<span class="built_in">begin</span>());</span><br><span class="line">        <span class="keyword">if</span> (x == t || dist[x] &gt; <span class="number">1</span> &lt;&lt; <span class="number">30</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : edge[x])&#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[x] + p.sec &lt; dist[p.fir])&#123;</span><br><span class="line">                q.<span class="built_in">erase</span>(&#123;dist[p.fir], p.fir&#125;);</span><br><span class="line">                dist[p.fir] = dist[x] + p.sec;</span><br><span class="line">                q.<span class="built_in">insert</span>(&#123;dist[p.fir], p.fir&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[t];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Floyd："><a href="#Floyd：" class="headerlink" title="Floyd："></a>Floyd：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Floyd算法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空间优化核心代码 时间复杂度O(n^3) 空间复杂度O(n^2) </span></span><br><span class="line"><span class="comment">// 邻接矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Floyd_Memory_Optimized</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line">    <span class="type">int</span> v[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line">    <span class="built_in">memset</span>(v, <span class="number">127</span>, <span class="built_in">sizeof</span>(v));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            v[i][j] = a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (v[i][k] &lt; (<span class="number">1</span> &lt;&lt; <span class="number">30</span>) &amp;&amp; v[k][j] &lt; (<span class="number">1</span> &lt;&lt; <span class="number">30</span>))&#123;</span><br><span class="line">                    v[i][j] = <span class="built_in">min</span>(v[i][j], v[i][k] + v[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="最小生成树："><a href="#最小生成树：" class="headerlink" title="最小生成树："></a><strong>最小生成树：</strong></h1><h2 id="Prim："><a href="#Prim：" class="headerlink" title="Prim："></a>Prim：</h2><p><strong>最小生成树：</strong></p><p>一张<strong>有权无向连通图</strong>中，<strong>边权和最小</strong>的生成树叫做<strong>最小生成树</strong>。</p><p>如果原图不连通，则没有最小生成树。</p><p><strong>Prim算法</strong>是一种常用的最小生成树算法，做法与Dijkstra相似，</p><p>也需要维护一个<strong>顶点集合C</strong>，每次通过一条边连接一个<strong>不在C中的点</strong>，</p><p>直到最后形成一个树形结构。</p><p>定义dist(u)表示 <strong>连接C中任意点和u的边的边权的最小值</strong>，</p><p>具体流程如下：</p><p>将任意点x加入C，此时C中只有一个点x；</p><p>对于其他点y，如果x, y之间有边，则dist(y) &#x3D; min(这些边的边权)，否则dist(y) &#x3D; INF；</p><p>在每一轮中，将<strong>dist最小</strong><em>（不能是INF）</em>的<strong>还不在C中的顶点z</strong>加入C，</p><p>同时，将<strong>连接C和z的边权最小的边</strong>加入最小生成树的边集合之中，</p><p>并且用z连出去的边尝试更新其他点的dist；</p><p>当没有新的点能加入C时，该算法结束。</p><p>此时，若所有的点都加入了C，则找到了最小生成树，否则说明该图不连通。</p><hr><p><strong>朴素Prim代码实现：O(n2+m)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">vector &lt;PII&gt; edge[N];  <span class="comment">//边集</span></span><br><span class="line"><span class="type">int</span> n, m, dist[N];      <span class="comment">//dist集</span></span><br><span class="line"><span class="type">bool</span> b[N];              <span class="comment">//存在性集</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(b, <span class="literal">false</span>, <span class="built_in">sizeof</span>(b));</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">127</span>, <span class="built_in">sizeof</span>(dist));</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!b[i] &amp;&amp; dist[i] &lt; <span class="number">1</span> &lt;&lt; <span class="number">30</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (x == <span class="number">-1</span> || dist[i] &lt; dist[x])&#123;</span><br><span class="line">                    x = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++tot;</span><br><span class="line">        ans += dist[x];</span><br><span class="line">        b[x] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : edge[x])&#123;</span><br><span class="line">            dist[i.fir] = <span class="built_in">min</span>(dist[i.fir], i.sec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tot != n)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>堆优化Prim算法：O((n+m)log n)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">set &lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line">vector &lt;PII&gt; edge[N];  <span class="comment">//边集</span></span><br><span class="line"><span class="type">int</span> n, m, dist[N];      <span class="comment">//dist集</span></span><br><span class="line"><span class="type">bool</span> b[N];              <span class="comment">//存在性集</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(b, <span class="literal">false</span>, <span class="built_in">sizeof</span>(b));</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">127</span>, <span class="built_in">sizeof</span>(dist));</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        q.<span class="built_in">insert</span>(&#123;dist[i], i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x = q.<span class="built_in">begin</span>()-&gt;second;</span><br><span class="line">        q.<span class="built_in">erase</span>(q.<span class="built_in">begin</span>());</span><br><span class="line">        <span class="keyword">if</span> (dist[x] &gt; <span class="number">1</span> &lt;&lt; <span class="number">30</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++tot;</span><br><span class="line">        ans += dist[x];</span><br><span class="line">        b[x] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : edge[x])&#123;</span><br><span class="line">            <span class="keyword">if</span> (!b[i.fir] &amp;&amp; i.sec &lt; dist[i.fir])&#123;</span><br><span class="line">                q.<span class="built_in">erase</span>(&#123;dist[i.fir], i.fir&#125;);</span><br><span class="line">                dist[i.fir] = i.sec;</span><br><span class="line">                q.<span class="built_in">insert</span>(&#123;dist[i.fir], i.fir&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tot != n)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal:"></a>Kruskal:</h2><p>大致流程：</p><ul><li>初始化<strong>并查集</strong>，每个点的代表元都是它自己，本身构成一个独立的集合；</li><li>将所有的边按照边权的从小到大排序；</li><li>按边权从小到大依次枚举所有的边，如果当前这条边连接的两个顶点位于同一个集合（即，它们的代表元素是一样的），则什么都不做，否则<ul><li>将这条边添加到最小生成树的边集之中</li><li>将这条边连接的两个点所在的集合合并（利用并查集的合并操作）；</li></ul></li><li>如此循环，直至剩下一个集合，算法结束。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m, fa[N];    <span class="comment">//fa是代表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y, v;    <span class="comment">//x, y代表这条边连接的两个点，v代表这条边的边权</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Node &amp;A) <span class="type">const</span>&#123;  <span class="comment">//重构&lt;运算符</span></span><br><span class="line">        <span class="keyword">return</span> v &lt; A.v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; a[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FindSet</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == fa[i])&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[i] = <span class="built_in">FindSet</span>(fa[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Kruskal</span><span class="params">()</span></span>&#123;  <span class="comment">//O(m log n) 也可以写成O(m log m)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        fa[i] = i;  <span class="comment">//并查集初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + m + <span class="number">1</span>); <span class="comment">//按边权排序</span></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cnt = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">FindSet</span>(a[i].x);</span><br><span class="line">        <span class="type">int</span> y = <span class="built_in">FindSet</span>(a[i].y);</span><br><span class="line">        <span class="keyword">if</span> (x != y)&#123;</span><br><span class="line">            fa[x] = y;</span><br><span class="line">            ans += a[i].v;</span><br><span class="line">            --cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt != <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//多于一个连通块</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a><strong>拓扑排序</strong></h1><p>拓扑排序 (Topological Sorting)是对<strong>有向无环图</strong> (DAG, Direct Acycilc Grapgh)的顶点进行的一种线性排序，排序序列中每个顶点都会且仅会出现一次，且对所有有向边<code>u -&gt; v</code>，排序后<code>u</code>都在<code>v</code>的前面。</p><p>如果图中存在环，那么就不能拓扑排序。</p><p>一个DAG可能存在<strong>多种</strong>不同的拓扑排序结果。</p><p>对于一个n个顶点的DAG来说，最多存在<code>n!</code>种合法的拓扑序列（无边），最少<code>1</code>种（单链）。</p><p><code>O(n + m)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; edge[N];</span><br><span class="line"><span class="type">int</span> n, m, q[N], d[N];   <span class="comment">//d记录了每个点一开始的入度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">TopoSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> Front = <span class="number">1</span>, Rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!d[i])&#123;</span><br><span class="line">            q[++Rear] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (Front &lt;= Rear)&#123;</span><br><span class="line">        <span class="type">int</span> x = q[Front];</span><br><span class="line">        ++Front;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> y : edge[x])&#123;</span><br><span class="line">            <span class="keyword">if</span> (--d[y] == <span class="number">0</span>)&#123;</span><br><span class="line">                q[++Rear] = y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Rear == n)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;  <span class="comment">//q中记录了一个合法的拓扑序列</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">topsort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// d[i] 存储点i的入度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!d[i])</span><br><span class="line">            q[ ++ tt] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)&#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++ ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (--d[j] == <span class="number">0</span>)</span><br><span class="line">                q[++tt] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。</span></span><br><span class="line">    <span class="keyword">return</span> tt == n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="欧拉路与欧拉回路"><a href="#欧拉路与欧拉回路" class="headerlink" title="欧拉路与欧拉回路"></a><strong>欧拉路与欧拉回路</strong></h1><h2 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h2><ul><li><strong>欧拉路</strong>亦称<strong>欧拉通路</strong>，是经过图中所有边恰好一次的<strong>通路</strong>；</li><li><strong>欧拉回路</strong>是经过图中所有边恰好一次的<strong>回路</strong>；特别地，欧拉回路是一种欧拉路（因为回路是通路）；</li></ul><h2 id="欧拉路的判别方法"><a href="#欧拉路的判别方法" class="headerlink" title="欧拉路的判别方法"></a>欧拉路的判别方法</h2><ul><li>对于无向图G，G中存在<strong>欧拉回路</strong>当且仅当G中<em>所有度非零的点是连通的</em>且<em>没有奇数度的点</em>；</li><li>对于无向图G，G中存在<strong>欧拉路</strong>当且仅当G中<em>所有度非零的点是连通的</em>且<em>G中恰有0或2个奇数度的点</em>（0个表示存在欧拉回路）；</li><li>对于有向图G，G中存在<strong>欧拉回路</strong>当且仅当G中<em>所有度非零的点是强连通的</em>且<em>每个点的入度和出度相同</em>；</li><li>对于有向图G，G中存在<strong>欧拉路</strong>当且仅当：<ul><li>将G中所有有向边改为无向边后，G中<em>所有度非零的点是连通的</em>；</li><li>最多只有一个点的<code>出度 - 入度 = 1</code></li><li>最多只有一个点的<code>入度 - 出度 = 1</code></li><li>其他所有点的<code>入度 = 出度</code></li></ul></li></ul><h3 id="图的度"><a href="#图的度" class="headerlink" title="图的度"></a>图的度</h3><p>在图论中，一个点的度（degree）指图中与该点相连的边数（又叫做价）；</p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一些还没整理的结论：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 给定度数列，构造一棵树，每次选择度数最小的点作为叶子，挂到最大度数的点上，每次更新点的度数</span><br><span class="line"></span><br><span class="line">2. 给定度数列，构造简单图，每次选择度数最大的点连上du个剩下的比较大的点连边，每次更新点的度数，也是贪心的思想</span><br></pre></td></tr></table></figure><hr><h1 id="二分图："><a href="#二分图：" class="headerlink" title="二分图："></a>二分图：</h1><h2 id="染色法判别二分图："><a href="#染色法判别二分图：" class="headerlink" title="染色法判别二分图："></a>染色法判别二分图：</h2><p><code>O(n + m)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;      <span class="comment">// n表示点数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;     <span class="comment">// 邻接表存储图</span></span><br><span class="line"><span class="type">int</span> color[N];       <span class="comment">// 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数：u表示当前节点，c表示当前点的颜色</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u] = c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (color[j] == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(j, !c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (color[j] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(color, <span class="number">-1</span>, <span class="keyword">sizeof</span> color);</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (color[i] == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(i, <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匈牙利算法："><a href="#匈牙利算法：" class="headerlink" title="匈牙利算法："></a>匈牙利算法：</h2><p><code>O(nm)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n1, n2;     <span class="comment">// n1表示第一个集合中的点数，n2表示第二个集合中的点数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;     <span class="comment">// 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边</span></span><br><span class="line"><span class="type">int</span> match[N];       <span class="comment">// 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 表示第二个集合中的每个点是否已经被遍历过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (match[j] == <span class="number">0</span> || <span class="built_in">find</span>(match[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                match[j] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点</span></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(i)) res ++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;简介：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图论 (Graph theory)&lt;/strong&gt; 是数学的一个分支，图是图论的主要研究对象。&lt;strong&gt;图 (Graph)&lt;/strong&gt; 是由若干给定的顶点及连接两顶点的边所构成的图形，这种</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>算法丨杂项</title>
    <link href="https://conqueror712.github.io/post/Other-Algorithm.html"/>
    <id>https://conqueror712.github.io/post/Other-Algorithm.html</id>
    <published>2022-07-14T06:14:25.000Z</published>
    <updated>2023-02-16T06:46:22.948Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">简介：</span><br><span class="line"></span><br><span class="line">这里是一些包括但不限于字符串、编程技巧、搜索等杂乱算法。</span><br></pre></td></tr></table></figure><hr><h1 id="字符串："><a href="#字符串：" class="headerlink" title="字符串："></a><strong>字符串：</strong></h1><h2 id="KMP："><a href="#KMP：" class="headerlink" title="KMP："></a>KMP：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度</span></span><br><span class="line">求模式串的Next数组：</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">    ne[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">    <span class="keyword">if</span> (j == m)</span><br><span class="line">    &#123;</span><br><span class="line">        j = ne[j];</span><br><span class="line">        <span class="comment">// 匹配成功后的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">string a1, a2;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> kmp[<span class="number">2000000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; a1 &gt;&gt; a2;</span><br><span class="line">    <span class="type">int</span> len1 = a1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> len2 = a2.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; len2; i++)&#123;</span><br><span class="line">    <span class="comment">//自己匹配自己</span></span><br><span class="line">        <span class="keyword">while</span>(k &amp;&amp; a2[i] != a2[k])&#123;</span><br><span class="line">            <span class="comment">//找到最长的前后缀重叠长度</span></span><br><span class="line">            k = kmp[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不相等的情况，即无前缀能与后缀重叠，直接赋值位0（注意是给下一位，因为匹配的是下一位适失配的情况）</span></span><br><span class="line">        kmp[i + <span class="number">1</span>] = a2[i] == a2[k] ? ++k : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len1; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(k &amp;&amp; a1[i] != a2[k])&#123;</span><br><span class="line">            <span class="comment">//如果不匹配，则将利用kmp数组往回跳</span></span><br><span class="line">            k = kmp[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果相等了，则匹配下一位</span></span><br><span class="line">        k += a1[i] == a2[k] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(k == len2)&#123;</span><br><span class="line">            <span class="comment">//如果已经全部匹配完毕，则输出初始位置</span></span><br><span class="line">            cout &lt;&lt; i - len2 + <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len2; i++)&#123;</span><br><span class="line">        <span class="comment">//输出f数组</span></span><br><span class="line">        cout &lt;&lt; kmp[i] &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == len2];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="浅谈KMP与双指针的联系："><a href="#浅谈KMP与双指针的联系：" class="headerlink" title="浅谈KMP与双指针的联系："></a>浅谈KMP与双指针的联系：</h3><blockquote><p>KMP算法和双指针算法都是字符串匹配算法，它们都可以用于解决字符串匹配问题，但是它们的实现方式和应用场景有所不同。</p><p>KMP算法是一种基于动态规划思想的字符串匹配算法，它的核心思想是利用已经匹配成功的信息来避免不必要的字符比较，从而提高匹配效率。KMP算法的实现需要用到一个next数组，通过该数组来记录模式串中每个位置前缀的最长可匹配前缀长度。在匹配过程中，当模式串与文本串中的某个字符不匹配时，KMP算法通过查找next数组来确定模式串中应该与文本串中的哪个字符进行匹配，从而跳过不必要的比较，提高了匹配的效率。</p><p>双指针算法则是一种较为简单的字符串匹配算法，它的核心思想是使用两个指针分别指向文本串和模式串，通过比较两个指针所指向的字符是否相等来判断匹配情况。在匹配过程中，当模式串与文本串中的某个字符不匹配时，可以通过移动模式串指针或文本串指针来进行下一轮的匹配，直到模式串全部匹配完毕或者匹配失败。</p><p>虽然KMP算法和双指针算法有不同的实现方式和思路，但是它们也有一些联系。例如，在使用双指针算法进行字符串匹配时，如果发现当前字符不匹配，可以通过计算前缀数组或者next数组来判断模式串指针应该移动到哪个位置，从而避免不必要的比较。此外，双指针算法和KMP算法在处理字符串匹配问题时都需要注意边界情况的处理，例如模式串为空、文本串为空、模式串长度大于文本串长度等情况。</p><p>KMP算法和双指针算法在字符串匹配问题上的时间复杂度略有不同。</p><p>对于KMP算法，构建next数组的时间复杂度为O(m)，其中m为模式串的长度。在匹配过程中，最坏情况下需要进行n次比较，其中n为文本串的长度，因此匹配过程的时间复杂度为O(n)，因此KMP算法的总时间复杂度为O(m+n)。</p><p>对于双指针算法，匹配过程需要在文本串和模式串上分别移动指针进行比较，时间复杂度为O(mn)，其中m为模式串长度，n为文本串长度。但是，在实际应用中，双指针算法通常用于解决一些简单的字符串匹配问题，例如判断一个字符串是否为回文字符串，此时时间复杂度可以降低到O(n)。</p><p>综上所述，KMP算法的时间复杂度优于双指针算法，因此在需要高效解决字符串匹配问题的场合，KMP算法更为适用。但是在一些简单的字符串匹配问题上，双指针算法也可以提供一定的效率。</p></blockquote><h2 id="substr："><a href="#substr：" class="headerlink" title="substr："></a>substr：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// substr test</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    string str = <span class="string">&quot;HelloWorld&quot;</span>;</span><br><span class="line">    <span class="comment">// substr(l, len) = [l, len)</span></span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, <span class="number">9</span>)&#123;</span><br><span class="line">        cout &lt;&lt; str.<span class="built_in">substr</span>(<span class="number">0</span>, i) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, <span class="number">9</span>)&#123;</span><br><span class="line">    cout &lt;&lt; str.<span class="built_in">substr</span>(<span class="number">9</span> - i, i) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// substr(l) = [l, end]</span></span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, <span class="number">9</span>)&#123;</span><br><span class="line">        cout &lt;&lt; str.<span class="built_in">substr</span>(i) &lt;&lt; endl;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="搜索："><a href="#搜索：" class="headerlink" title="搜索："></a><strong>搜索：</strong></h1><h2 id="BFS："><a href="#BFS：" class="headerlink" title="BFS："></a>BFS：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//板子1</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">st[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 表示1号点已经被遍历过</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])&#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>; <span class="comment">// 表示点j已经被遍历过</span></span><br><span class="line">            q.<span class="built_in">push</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//板子2HDU</span></span><br><span class="line"><span class="type">int</span> vis[<span class="number">100001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> source, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">    queue &lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(source);</span><br><span class="line">    vis[source] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> a = Q.<span class="built_in">front</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (a == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (;;<span class="comment">/*对于a所有的后继节点b*/</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[b])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Q.<span class="built_in">push</span>(b);</span><br><span class="line">            vis[b] = <span class="number">1</span>; <span class="comment">//剪枝</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DFS："><a href="#DFS：" class="headerlink" title="DFS："></a>DFS：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">// st[u] 表示点u已经被遍历过</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j]) &#123;</span><br><span class="line">            <span class="built_in">DFS</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="二分："><a href="#二分：" class="headerlink" title="二分："></a><strong>二分：</strong></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">二分的本质是条件和边界，并不是单调性；</span><br><span class="line"></span><br><span class="line">关于要不要加1，就看是l=mid还是r=mid；</span><br></pre></td></tr></table></figure><h2 id="整数二分："><a href="#整数二分：" class="headerlink" title="整数二分："></a>整数二分：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;    <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="浮点数二分："><a href="#浮点数二分：" class="headerlink" title="浮点数二分："></a>浮点数二分：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">bsearch_3</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;   <span class="comment">// eps 表示精度，取决于题目对精度的要求</span></span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分查找模板："><a href="#二分查找模板：" class="headerlink" title="二分查找模板："></a>二分查找模板：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m, a[<span class="number">200010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Binary_Search</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l + <span class="number">1</span> &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; a[mid])&#123;<span class="comment">//这里自行决定加不加等号</span></span><br><span class="line">            l = mid;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            r = mid;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;<span class="comment">//返回了左指针的下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="离散化、前缀和与差分："><a href="#离散化、前缀和与差分：" class="headerlink" title="离散化、前缀和与差分："></a><strong>离散化、前缀和与差分：</strong></h1><h2 id="前缀和："><a href="#前缀和：" class="headerlink" title="前缀和："></a>前缀和：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">S[i] = S[i - <span class="number">1</span>] + a[i];<span class="comment">//同理有后缀和</span></span><br></pre></td></tr></table></figure><h2 id="二维前缀和："><a href="#二维前缀和：" class="headerlink" title="二维前缀和："></a>二维前缀和：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不要用容斥原理，不好用</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="comment">//先求数组a关于第一个维度的前缀和&#123;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">        a[i][j]=a[i][j]+a[i][j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">    <span class="comment">//在已经求完一个维度前缀和的基础上求数组a关于第二个维度的前缀和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">        a[i][j]=a[i][j]+a[i<span class="number">-1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这种方式可以理解成二维前缀和是数组在求完关于第一个维度的前缀和，</span></span><br><span class="line"><span class="comment">然后再for一遍求它关于第二个维度的前缀和。</span></span><br><span class="line"><span class="comment">然后它在求三维以上前缀和的时候，就体现出这种写法在高维前缀和上的优越性了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=p;++k)&#123;</span><br><span class="line">            a[i][j][k]+=a[i<span class="number">-1</span>][j][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=p;++k)&#123;</span><br><span class="line">            a[i][j][k]+=a[i][j<span class="number">-1</span>][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=p;++k)&#123;</span><br><span class="line">            a[i][j][k]+=a[i][j][k<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无需借助容斥原理，求高维前缀和的复杂度变为O(|高维空间容量|*k)，可以处理k稍大一些的情况。</span></span><br></pre></td></tr></table></figure><hr><h2 id="差分："><a href="#差分：" class="headerlink" title="差分："></a><strong>差分</strong>：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">差分数组和前缀和数组互相对应，</span><br><span class="line"></span><br><span class="line">S[i]是a[i]的前缀和，a[i]就是S[i]的差分；</span><br><span class="line"></span><br><span class="line">差分就一个思想 插入</span><br><span class="line"></span><br><span class="line">给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    b[l] += c;</span><br><span class="line">    b[r+<span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这个表能很好的帮助理解，假设我们要修改2146这个区间（+1），则：</p><table><thead><tr><th>a[i]</th><th>3</th><th>5</th><th><em>2</em></th><th><em>1</em></th><th><em>4</em></th><th><em>6</em></th><th>7</th></tr></thead><tbody><tr><td><strong>d[i]</strong></td><td><strong>3</strong></td><td><strong>2</strong></td><td><strong>-3</strong></td><td><strong>-1</strong></td><td><strong>3</strong></td><td><strong>2</strong></td><td><strong>1</strong></td></tr><tr><td><strong>d’[i]</strong></td><td><strong>3</strong></td><td><strong>2</strong></td><td><strong>-2</strong></td><td><strong>-1</strong></td><td><strong>3</strong></td><td><strong>2</strong></td><td><strong>0</strong></td></tr><tr><td><strong>pre[i]</strong></td><td><strong>3</strong></td><td><strong>5</strong></td><td><strong>3</strong></td><td><strong>2</strong></td><td><strong>5</strong></td><td><strong>7</strong></td><td><strong>7</strong></td></tr></tbody></table><h2 id="二维差分："><a href="#二维差分：" class="headerlink" title="二维差分："></a>二维差分：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i][j] = s[i][j] - s[i - <span class="number">1</span>][j] - s[i][j - <span class="number">1</span>] + s[i - <span class="number">1</span>][j - <span class="number">1</span>];<span class="comment">//子矩形加</span></span><br></pre></td></tr></table></figure><hr><h1 id="双指针："><a href="#双指针：" class="headerlink" title="双指针："></a>双指针：</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; i &amp;&amp; <span class="built_in">check</span>(i, j)) j ++ ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体问题的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">常见问题分类：</span><br><span class="line">    (<span class="number">1</span>) 对于一个序列，用两个指针维护一段区间</span><br><span class="line">    (<span class="number">2</span>) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</span><br></pre></td></tr></table></figure><hr><h1 id="高精度："><a href="#高精度：" class="headerlink" title="高精度："></a><strong>高精度：</strong></h1><h2 id="高精度加法："><a href="#高精度加法：" class="headerlink" title="高精度加法："></a>高精度加法：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">add</span>(B, A);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度减法："><a href="#高精度减法：" class="headerlink" title="高精度减法："></a>高精度减法：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度整体："><a href="#高精度整体：" class="headerlink" title="高精度整体："></a>高精度整体：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BigInteger</span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE(x) ((int)x.size())</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; x;</span><br><span class="line">    <span class="type">bool</span> sign;</span><br><span class="line">    <span class="built_in">BigInteger</span>(std::vector&lt;<span class="type">int</span>&gt; y) &#123; <span class="keyword">this</span>-&gt;x = y; &#125;</span><br><span class="line">    <span class="built_in">BigInteger</span>(<span class="type">const</span> BigInteger&amp; y) &#123; *<span class="keyword">this</span> = y; &#125;</span><br><span class="line">    <span class="built_in">BigInteger</span>(<span class="type">const</span> BigInteger* y) &#123; *<span class="keyword">this</span> = *y; &#125;</span><br><span class="line">    <span class="built_in">BigInteger</span>(<span class="type">const</span> std::string&amp; y) &#123; *<span class="keyword">this</span> = y; &#125;</span><br><span class="line">    <span class="built_in">BigInteger</span>(<span class="type">long</span> <span class="type">long</span> y = <span class="number">0</span>) &#123; *<span class="keyword">this</span> = y; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">squeeze</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">SIZE</span>(x) &amp;&amp; x[<span class="built_in">SIZE</span>(x) - <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            x.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">SIZE</span>(x) == <span class="number">0</span>) sign = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BigInteger <span class="title">abs</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="function">BigInteger <span class="title">ret</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        ret.sign = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BigInteger&amp; <span class="keyword">operator</span> = (<span class="type">const</span> BigInteger&amp; y)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = y.x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;sign = y.sign;</span><br><span class="line">        <span class="built_in">squeeze</span>();</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BigInteger&amp; <span class="keyword">operator</span> = (<span class="type">const</span> std::string&amp; y)&#123;</span><br><span class="line">        x.<span class="built_in">clear</span>();</span><br><span class="line">        sign = (y[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">SIZE</span>(y) - <span class="number">1</span>; i &gt;= sign; i--) &#123;</span><br><span class="line">            x.<span class="built_in">push_back</span>(y[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">squeeze</span>();</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BigInteger&amp; <span class="keyword">operator</span> = (<span class="type">long</span> <span class="type">long</span> y)</span><br><span class="line">    &#123;</span><br><span class="line">        x.<span class="built_in">clear</span>();</span><br><span class="line">        sign = y &lt; <span class="number">0</span>;</span><br><span class="line">        y = std::<span class="built_in">abs</span>(y);</span><br><span class="line">        <span class="keyword">while</span> (y)&#123;</span><br><span class="line">            x.<span class="built_in">push_back</span>(y % <span class="number">10</span>);</span><br><span class="line">            y /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">squeeze</span>();</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BigInteger <span class="keyword">operator</span> - () <span class="type">const</span>&#123;</span><br><span class="line">        <span class="function">BigInteger <span class="title">ret</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        ret.sign = sign ^ <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BigInteger <span class="keyword">operator</span> + (<span class="type">const</span> BigInteger&amp; y) <span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (y.sign == <span class="number">1</span>) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> - (-y); &#125;</span><br><span class="line">        <span class="keyword">if</span> (sign == <span class="number">1</span>) &#123; <span class="keyword">return</span> y - (-*<span class="keyword">this</span>); &#125;</span><br><span class="line">        BigInteger ret;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="built_in">SIZE</span>(x) &amp;&amp; j &lt; <span class="built_in">SIZE</span>(y.x)) ret.x.<span class="built_in">push_back</span>(x[i++] + y.x[j++]);</span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="built_in">SIZE</span>(x)) ret.x.<span class="built_in">push_back</span>(x[i++]);</span><br><span class="line">        <span class="keyword">while</span> (j &lt; <span class="built_in">SIZE</span>(y.x)) ret.x.<span class="built_in">push_back</span>(y.x[j++]);</span><br><span class="line">        ret.x.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i + <span class="number">1</span> &lt; <span class="built_in">SIZE</span>(ret.x); i++) &#123;</span><br><span class="line">            ret.x[i + <span class="number">1</span>] += ret.x[i] / <span class="number">10</span>, ret.x[i] %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ret.<span class="built_in">squeeze</span>();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    BigInteger <span class="keyword">operator</span> - (<span class="type">const</span> BigInteger&amp; y) <span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (y.sign == <span class="number">1</span>) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> + (-y); &#125;</span><br><span class="line">        <span class="keyword">if</span> (sign == <span class="number">1</span>) &#123; <span class="keyword">return</span> -((-*<span class="keyword">this</span>) + y); &#125;</span><br><span class="line">        <span class="keyword">if</span> (*<span class="keyword">this</span> &lt; y) &#123; <span class="keyword">return</span> -(y - *<span class="keyword">this</span>); &#125;</span><br><span class="line">        BigInteger ret;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; <span class="built_in">SIZE</span>(y.x)) &#123;</span><br><span class="line">            ret.x.<span class="built_in">push_back</span>(x[i++] - y.x[j++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="built_in">SIZE</span>(x)) &#123;</span><br><span class="line">            ret.x.<span class="built_in">push_back</span>(x[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; <span class="built_in">SIZE</span>(ret.x); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ret.x[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                ret.x[i] += <span class="number">10</span>, ret.x[i + <span class="number">1</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ret.<span class="built_in">squeeze</span>();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    BigInteger <span class="keyword">operator</span> * (<span class="type">const</span> BigInteger&amp; y) <span class="type">const</span> &#123;</span><br><span class="line">        BigInteger ret;</span><br><span class="line">        ret.sign = sign ^ y.sign;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="built_in">SIZE</span>(x) + <span class="built_in">SIZE</span>(y.x)) * <span class="number">2</span>; i++) &#123;</span><br><span class="line">            ret.x.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">SIZE</span>(x); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">SIZE</span>(y.x); j++) &#123;</span><br><span class="line">                ret.x[i + j] += x[i] * y.x[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">SIZE</span>(ret.x) &amp;&amp; (ret.x[i] &gt; <span class="number">9</span> || ret.x[i + <span class="number">1</span>] &gt; <span class="number">0</span>); i++) &#123;</span><br><span class="line">            ret.x[i + <span class="number">1</span>] += ret.x[i] / <span class="number">10</span>, ret.x[i] %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ret.<span class="built_in">squeeze</span>();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    BigInteger <span class="keyword">operator</span> / (<span class="type">const</span> BigInteger&amp; y) <span class="type">const</span>&#123;</span><br><span class="line">        std::stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="function">BigInteger <span class="title">tmp</span><span class="params">(<span class="number">0ll</span>)</span>, <span class="title">ten</span><span class="params">(<span class="number">10ll</span>)</span></span>;</span><br><span class="line">        <span class="built_in">assert</span>(y != tmp);</span><br><span class="line">        BigInteger t1 = <span class="keyword">this</span>-&gt;<span class="built_in">abs</span>(), t2 = y.<span class="built_in">abs</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">SIZE</span>(t1.x) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            tmp = tmp * ten + t1.x[i];</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (tmp &gt;= t2)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = tmp - t2;</span><br><span class="line">                s++;</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.x.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            tmp.x.<span class="built_in">push_back</span>(st.<span class="built_in">top</span>()), st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>&amp; st; <span class="keyword">delete</span>&amp; t1; <span class="keyword">delete</span>&amp; t2;</span><br><span class="line">        tmp.sign = sign ^ y.sign;</span><br><span class="line">        tmp.<span class="built_in">squeeze</span>();</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    BigInteger <span class="keyword">operator</span> % (<span class="type">const</span> BigInteger&amp; y) <span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> - *<span class="keyword">this</span> / y * y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BigInteger <span class="keyword">operator</span> += (<span class="type">const</span> BigInteger&amp; y) &#123; *<span class="keyword">this</span> = *<span class="keyword">this</span> + y; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    BigInteger <span class="keyword">operator</span> -= (<span class="type">const</span> BigInteger&amp; y) &#123; *<span class="keyword">this</span> = *<span class="keyword">this</span> - y; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    BigInteger <span class="keyword">operator</span> *= (<span class="type">const</span> BigInteger&amp; y) &#123; *<span class="keyword">this</span> = *<span class="keyword">this</span> * y; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    BigInteger <span class="keyword">operator</span> /= (<span class="type">const</span> BigInteger&amp; y) &#123; *<span class="keyword">this</span> = *<span class="keyword">this</span> / y; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    BigInteger <span class="keyword">operator</span> %= (<span class="type">const</span> BigInteger&amp; y) &#123; *<span class="keyword">this</span> = *<span class="keyword">this</span> % y; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    BigInteger <span class="keyword">operator</span> ++ () &#123; *<span class="keyword">this</span> = *<span class="keyword">this</span> + <span class="number">1</span>; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    BigInteger <span class="keyword">operator</span> -- () &#123; *<span class="keyword">this</span> = *<span class="keyword">this</span> - <span class="number">1</span>; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line"></span><br><span class="line">    BigInteger <span class="keyword">operator</span> ^ (<span class="type">const</span> BigInteger&amp; y) <span class="type">const</span>&#123;</span><br><span class="line">        <span class="function">BigInteger <span class="title">ret</span><span class="params">(<span class="number">1ll</span>)</span>, <span class="title">k</span><span class="params">(y)</span>, <span class="title">a</span><span class="params">(<span class="keyword">this</span>)</span>, <span class="title">zero</span><span class="params">(<span class="number">0ll</span>)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; zero)&#123;</span><br><span class="line">            <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">1</span>) ret *= a;</span><br><span class="line">            a *= a;</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> BigInteger&amp; y) <span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sign == <span class="number">0</span> &amp;&amp; y.sign == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (sign == <span class="number">1</span> &amp;&amp; y.sign == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (sign == <span class="number">1</span> &amp;&amp; y.sign == <span class="number">1</span>) &#123; <span class="keyword">return</span> (-y) &lt; (-*<span class="keyword">this</span>); &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">SIZE</span>(x) &lt; <span class="built_in">SIZE</span>(y.x)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">SIZE</span>(x) &gt; <span class="built_in">SIZE</span>(y.x)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">SIZE</span>(x) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (x[i] &lt; y.x[i]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (x[i] &gt; y.x[i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &gt; (<span class="type">const</span> BigInteger&amp; y) <span class="type">const</span> &#123; <span class="keyword">return</span> y &lt; *<span class="keyword">this</span>; &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt;= (<span class="type">const</span> BigInteger&amp; y) <span class="type">const</span> &#123; <span class="keyword">return</span> !(y &lt; *<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &gt;= (<span class="type">const</span> BigInteger&amp; y) <span class="type">const</span> &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span> &lt; y); &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> BigInteger&amp; y) <span class="type">const</span> &#123; <span class="keyword">return</span> *<span class="keyword">this</span> &lt;= y &amp;&amp; *<span class="keyword">this</span> &gt;= y; &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> != (<span class="type">const</span> BigInteger&amp; y) <span class="type">const</span> &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span> == y); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span> &lt;&lt; (std::ostream&amp; out, <span class="type">const</span> BigInteger&amp; y)&#123;</span><br><span class="line">        <span class="keyword">if</span> (y.sign) out &lt;&lt; <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">SIZE</span>(y.x) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            out &lt;&lt; y.x[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">SIZE</span>(y.x) == <span class="number">0</span>) out &lt;&lt; <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> std::istream&amp; <span class="keyword">operator</span> &gt;&gt; (std::istream&amp; in, BigInteger&amp; y)&#123;</span><br><span class="line">        std::string s;</span><br><span class="line">        in &gt;&gt; s;</span><br><span class="line">        y = s;</span><br><span class="line">        <span class="keyword">return</span> in;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This is a test.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    BigInteger a,b,c;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入a = &quot;</span>;</span><br><span class="line">    cin &gt;&gt; a;               <span class="comment">//输入测试</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入b = &quot;</span>;</span><br><span class="line">    cin &gt;&gt; b;</span><br><span class="line">    c = a - b;              <span class="comment">//赋值测试</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a + b = &quot;</span> &lt;&lt; a + b &lt;&lt; endl;    <span class="comment">//输出测试 &amp;&amp; 加法测试</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a - b = &quot;</span> &lt;&lt; c &lt;&lt; endl;        <span class="comment">//减法测试</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a * b = &quot;</span> &lt;&lt; a * b &lt;&lt; endl;    <span class="comment">//乘法测试</span></span><br><span class="line">    <span class="comment">//除此之外 还有除法运算 比较运算 幂运算 不过在这里没有给出测试</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a><strong>位运算</strong></h1><h3 id="二元运算符："><a href="#二元运算符：" class="headerlink" title="二元运算符："></a>二元运算符：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;按位与    |按位或    ^按位异或</span><br><span class="line"></span><br><span class="line">对于非01的整数 会首先转化成二进制，然后逐位运算，最后在转换回十进制。</span><br></pre></td></tr></table></figure><h3 id="一元运算符："><a href="#一元运算符：" class="headerlink" title="一元运算符："></a>一元运算符：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">!逻辑非    ~按位非（逻辑运算符还有&amp;&amp;    ||）</span><br><span class="line"></span><br><span class="line">让我们来复习一下原码 反码和补码的知识：</span><br><span class="line"></span><br><span class="line">原码：一个数字直接转换为二进制后得到的01序列</span><br><span class="line"></span><br><span class="line">反码：原码的每一位取反</span><br><span class="line"></span><br><span class="line">补码：正数的补码就是原码负数的补码是在符号位不变的情况下 把原码的每一位取反（反码）再加一</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">对于一个带仿佛好的整型变量进行`~`运算，实际上就是把它的补码中的每一位按位非之后，再转换为原码（减一后符号位不变再取反）</span><br><span class="line"></span><br><span class="line">对于unsigned int无符号整型，道理是一样的，按位非就比较简单，就直接按位取反</span><br></pre></td></tr></table></figure><h3 id="左移右移："><a href="#左移右移：" class="headerlink" title="左移右移："></a>左移右移：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">（都是二元运算符）&lt;&lt; &gt;&gt;，不建议对负数进行左移右移；</span><br><span class="line"></span><br><span class="line">x &lt;&lt; k表示将x转化为二进制后，向左移动k位，并在末尾补k个0之后得到的值；</span><br><span class="line"></span><br><span class="line">x &gt;&gt; k表示将x转化为二进制后，向右移动k位，并在前面补k个0之后得到的值；</span><br><span class="line"></span><br><span class="line">在不越界的情况下，x &lt;&lt; k等价于(x * 2^k)x &gt;&gt; k等价于x / 2^k</span><br></pre></td></tr></table></figure><h3 id="位运算优先级：（建议使用括号）"><a href="#位运算优先级：（建议使用括号）" class="headerlink" title="位运算优先级：（建议使用括号）"></a>位运算优先级：（建议使用括号）</h3><p><img src="https://s2.loli.net/2022/08/05/nG7EHDvwCST1rNj.png" alt="avatar"></p><h3 id="位运算常用技巧：（请注意取值范围）"><a href="#位运算常用技巧：（请注意取值范围）" class="headerlink" title="位运算常用技巧：（请注意取值范围）"></a>位运算常用技巧：（请注意取值范围）</h3><p><img src="https://s2.loli.net/2022/08/05/bylQVihozXMsW4p.png" alt="avatar"></p><p><img src="https://s2.loli.net/2022/08/05/XHGFjm5Nuf63v4g.png" alt="avatar"></p><hr><h1 id="排序："><a href="#排序：" class="headerlink" title="排序："></a><strong>排序：</strong></h1><h2 id="快速排序："><a href="#快速排序：" class="headerlink" title="快速排序："></a>快速排序：</h2><p>模板1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Quicksort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(a[l], a[l + <span class="built_in">rand</span>() % (r - l + <span class="number">1</span>)]);</span><br><span class="line">    <span class="type">int</span> x = a[l];</span><br><span class="line">    <span class="type">int</span> i = l, j = r;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; a[j] &gt; x)&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j)&#123;</span><br><span class="line">            a[i++] = a[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; a[i] &lt; x)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j)&#123;</span><br><span class="line">            a[j--] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[i] = x;</span><br><span class="line">    <span class="built_in">Quicksort</span>(l, i - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">Quicksort</span>(i + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板2：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j), <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序："><a href="#归并排序：" class="headerlink" title="归并排序："></a>归并排序：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="快速幂、快速乘和矩阵乘法："><a href="#快速幂、快速乘和矩阵乘法：" class="headerlink" title="快速幂、快速乘和矩阵乘法："></a><strong>快速幂、快速乘和矩阵乘法：</strong></h1><h2 id="快速幂："><a href="#快速幂：" class="headerlink" title="快速幂："></a>快速幂：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">将n的二进制中为`1`的位置对应的`a`的`2^k`次幂相乘*</span><br><span class="line"></span><br><span class="line">举个例子：计算`5^11`，则`a = 5  n = 11`，11的二进制是`1011`，则`5^11 = 5^8 * 5^2 * 5^1`</span><br><span class="line"></span><br><span class="line">于是我们可以用`O(log n)`的时间复杂度来计算`a`的所有**会被用到**的`2^k`次幂（因为n的二进制最多有log位）；</span><br><span class="line"></span><br><span class="line">从1次开始，每一个就会用到前面一个的平方（1, 2, 4, 8...）</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quickpow</span><span class="params">(ll a, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; n; n &gt;&gt;= <span class="number">1</span>)&#123;<span class="comment">//n /= 2;</span></span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            ans *= a;</span><br><span class="line">            ans %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        a *= a;</span><br><span class="line">        a %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速乘："><a href="#快速乘：" class="headerlink" title="快速乘："></a><strong>快速乘：</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">快速是相对于高精度来说；</span><br><span class="line"></span><br><span class="line">将b的二进制中为1的位置对应的2^k * a</span><br><span class="line"></span><br><span class="line">举个例子：计算7 * 11 % P，考虑11的二进制1011，则有7 * 11 = 7 * 8 + 7 * 2 + 7 * 1</span><br><span class="line"></span><br><span class="line">于是我们可以用O(log b)的时间复杂度来计算所有会被用到的2^k * a的值。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">quickmul</span><span class="params">(ll a, ll b, ll mod)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    a %= mod;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            ans += a;</span><br><span class="line">            ans %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        a += a;</span><br><span class="line">        a %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="矩阵乘法："><a href="#矩阵乘法：" class="headerlink" title="矩阵乘法："></a>矩阵乘法：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//未优化O(n^3 log k)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">201</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> P = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll a[N][N], f[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">aa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll w[N][N];</span><br><span class="line">    <span class="built_in">memset</span>(w, <span class="number">0</span>, <span class="built_in">sizeof</span>(w));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">                w[i][j] += a[i][k] * a[k][j];</span><br><span class="line">                w[i][j] %= P;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(a, w, <span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll w[N];</span><br><span class="line">    <span class="built_in">memset</span>(w, <span class="number">0</span>, <span class="built_in">sizeof</span>(w));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            w[i] += f[j] * a[j][i];</span><br><span class="line">            w[i] %= P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(f, w, <span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">matrixpow</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; k; k /= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">fa</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">aa</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优化的aa O(n^3 log k)但是常数小了很多</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">aa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll w[N][N];</span><br><span class="line">    <span class="built_in">memset</span>(w, <span class="number">0</span>, <span class="built_in">sizeof</span>(w));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i][k])&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (a[k][j])&#123;</span><br><span class="line">                        w[i][j] += a[i][k] * a[k][j];</span><br><span class="line">                        w[i][j] %= P;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(a, w, <span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="读入优化："><a href="#读入优化：" class="headerlink" title="读入优化："></a><strong>读入优化：</strong></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">rd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="博弈论："><a href="#博弈论：" class="headerlink" title="博弈论："></a><strong>博弈论：</strong></h1><h2 id="概念介绍："><a href="#概念介绍：" class="headerlink" title="概念介绍："></a>概念介绍：</h2><h3 id="平等博弈-amp-不平等博弈"><a href="#平等博弈-amp-不平等博弈" class="headerlink" title="平等博弈 &amp; 不平等博弈"></a>平等博弈 &amp; 不平等博弈</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（操作空间是否一致）</span><br></pre></td></tr></table></figure><h3 id="必胜态-amp-必败态"><a href="#必胜态-amp-必败态" class="headerlink" title="必胜态 &amp; 必败态"></a>必胜态 &amp; 必败态</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">（更多是在平等博弈下讨论的）</span><br><span class="line"></span><br><span class="line">假设我们的游戏是**无环的**，即*不会存在能回到原来的状态从而无限进行下去的可能*；</span><br><span class="line"></span><br><span class="line">则该游戏存在的所有状态构成一个**有向无环图**；</span><br><span class="line"></span><br><span class="line">*注：以下都是基于Alice和Bob轮流进行游戏的情况下*</span><br><span class="line"></span><br><span class="line">**先手必胜态**和**先手必败态**都是指的当前局面下，下一步谁来走，而不是整局游戏的先手。</span><br><span class="line"></span><br><span class="line">必胜态触发的两种情况：（对必败态同理）</span><br><span class="line"></span><br><span class="line">1. 达到终止条件（胜利条件）</span><br><span class="line">2. 存在一个后继为必败态（随着后续的步骤会转变到必败态）</span><br><span class="line"></span><br><span class="line">如果存在平局的情况，那么我们可以采用：胜1平0负-1的状态表示方式，此时我们的dp方程就是min(后继)；</span><br><span class="line"></span><br><span class="line">不难想到，无论是平等博弈还是不平等博弈，我们都可以从**终点开始枚举**所有的状态，利用**动态规划**的思想。</span><br><span class="line"></span><br><span class="line">那么，什么情况下不能dp呢？</span><br><span class="line"></span><br><span class="line">就是当游戏局面很多的时候，没有办法把所有的状态都记下来的时候，就需要用到博弈论的手法了。</span><br><span class="line"></span><br><span class="line">下面介绍一些经典的博弈模型：</span><br></pre></td></tr></table></figure><h3 id="巴什博弈"><a href="#巴什博弈" class="headerlink" title="巴什博弈"></a>巴什博弈</h3><p>…</p><h3 id="威佐夫博弈-useless"><a href="#威佐夫博弈-useless" class="headerlink" title="威佐夫博弈(useless)"></a>威佐夫博弈(useless)</h3><p>…</p><hr><h1 id="计算几何"><a href="#计算几何" class="headerlink" title="计算几何"></a>计算几何</h1><h2 id="判断两线段是否相交"><a href="#判断两线段是否相交" class="headerlink" title="判断两线段是否相交"></a>判断两线段是否相交</h2><p>注意：如果有<code>#include &lt;math.h&gt;</code>则需要注意<code>y1, y2</code>等变量需要放进局部变量而非全局变量，因为<code>math.h</code>中有同名函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span> &#123;</span><br><span class="line">    <span class="type">double</span> x1;</span><br><span class="line">    <span class="type">double</span> y1;</span><br><span class="line">    <span class="type">double</span> x2;</span><br><span class="line">    <span class="type">double</span> y2;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">intersection</span><span class="params">(<span class="type">const</span> Line &amp;l1, <span class="type">const</span> Line &amp;l2)</span></span>&#123;</span><br><span class="line">    <span class="comment">//快速排斥实验</span></span><br><span class="line">    <span class="keyword">if</span> ((l1.x1 &gt; l1.x2 ? l1.x1 : l1.x2) &lt; (l2.x1 &lt; l2.x2 ? l2.x1 : l2.x2) ||</span><br><span class="line">        (l1.y1 &gt; l1.y2 ? l1.y1 : l1.y2) &lt; (l2.y1 &lt; l2.y2 ? l2.y1 : l2.y2) ||</span><br><span class="line">        (l2.x1 &gt; l2.x2 ? l2.x1 : l2.x2) &lt; (l1.x1 &lt; l1.x2 ? l1.x1 : l1.x2) ||</span><br><span class="line">        (l2.y1 &gt; l2.y2 ? l2.y1 : l2.y2) &lt; (l1.y1 &lt; l1.y2 ? l1.y1 : l1.y2))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//跨立实验</span></span><br><span class="line">    <span class="keyword">if</span> ((((l1.x1 - l2.x1)*(l2.y2 - l2.y1) - (l1.y1 - l2.y1)*(l2.x2 - l2.x1))*</span><br><span class="line">        ((l1.x2 - l2.x1)*(l2.y2 - l2.y1) - (l1.y2 - l2.y1)*(l2.x2 - l2.x1))) &gt; <span class="number">0</span> ||</span><br><span class="line">        (((l2.x1 - l1.x1)*(l1.y2 - l1.y1) - (l2.y1 - l1.y1)*(l1.x2 - l1.x1))*</span><br><span class="line">        ((l2.x2 - l1.x1)*(l1.y2 - l1.y1) - (l2.y2 - l1.y1)*(l1.x2 - l1.x1))) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="离线算法："><a href="#离线算法：" class="headerlink" title="离线算法："></a>离线算法：</h1><h2 id="离线与在线简介："><a href="#离线与在线简介：" class="headerlink" title="离线与在线简介："></a>离线与在线简介：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">在线和离线可以简单的理解为对于所有的操作是否需要读入完毕。</span><br><span class="line"></span><br><span class="line">在线的要求是可以不用先知道所有的操作（类似询问、修改），边读入边执行，类似**&quot;走一步，做一步&quot;**的思想。</span><br><span class="line"></span><br><span class="line">离线则与在线相反，要求必须知道所有的操作，类似**&quot;记录所有步，回头再做&quot;**的思想，一般用Query[]记录所有操作。</span><br><span class="line"></span><br><span class="line">常见的在线算法：带有**“可持久化”**字样的（主席树（可持久化线段树）、可持久化字典树、etc）</span><br><span class="line"></span><br><span class="line">常见的离线算法：整体二分、陈丹琦（CDQ）分治、莫队算法；</span><br><span class="line"></span><br><span class="line">在线算法的思路相对简单，而代码量大，容易爆栈，赛场上及其考验心态；</span><br><span class="line"></span><br><span class="line">离线算法的思路相对复杂，而代码量小，建议选手多采用；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">参考作者：hymscott</span><br></pre></td></tr></table></figure><hr><h2 id="莫队："><a href="#莫队：" class="headerlink" title="莫队："></a>莫队：</h2><h3 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">假设n = m，那么对于序列上的区间询问问题，如果从[l, r]的答案，</span><br><span class="line"></span><br><span class="line">能够O(1)的扩展到[l - 1, r][l - 1, r][l, r - 1][l, r + 1]的答案，</span><br><span class="line"></span><br><span class="line">那么可以在O(n√n)的复杂度内求出所有询问的答案。</span><br></pre></td></tr></table></figure><h3 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">离线后排序，顺序处理每个询问，暴力从上一个区间的答案转移到下一个区间答案。</span><br></pre></td></tr></table></figure><h3 id="排序方法："><a href="#排序方法：" class="headerlink" title="排序方法："></a>排序方法：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于区间[l, r]，以l所在块的编号为第一关键字，r为第二关键字，从小到大排序。</span><br></pre></td></tr></table></figure><h3 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> sign)</span> </span>&#123;</span><br><span class="line"><span class="comment">// update nowAns</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">BLOCK_SIZE = <span class="built_in">int</span>(<span class="built_in">ceil</span>(<span class="built_in">pow</span>(n, <span class="number">0.5</span>)));</span><br><span class="line"><span class="built_in">sort</span>(querys, querys + m);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">    <span class="type">const</span> query &amp;q = querys[i];</span><br><span class="line">    <span class="keyword">while</span> (l &gt; q.l) <span class="built_in">move</span>(--l, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (r &lt; q.r) <span class="built_in">move</span>(r++, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (l &lt; q.l) <span class="built_in">move</span>(l++, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">while</span> (r &gt; q.r) <span class="built_in">move</span>(--r, <span class="number">-1</span>);</span><br><span class="line">    ans[q.id] = nowAns;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析暂略；</p><hr><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">简介：滑动窗口（双指针）是优化某些区间问题的常用技巧；</span><br><span class="line">之前学习的单调队列使用的实际上就是这一类技巧；</span><br></pre></td></tr></table></figure><hr><h1 id="杂项（未归类）："><a href="#杂项（未归类）：" class="headerlink" title="杂项（未归类）："></a><strong>杂项（未归类）：</strong></h1><h2 id="消解算法："><a href="#消解算法：" class="headerlink" title="消解算法："></a>消解算法：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （其实应该是离散数学的内容）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ios ios::sync_with_stdio(false);cin.tie(0),cout.tie(0)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="comment">//const ll mod = 1e9+7;</span></span><br><span class="line"><span class="comment">//const ll mod = 1000003;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> s[N][<span class="number">30</span>];<span class="comment">//用于存储简单析取式</span></span><br><span class="line"><span class="type">int</span> num0, num1, num2;<span class="comment">//控制s0,s1,s2三个集合之间的转换，仍然利用s数组存储</span></span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"><span class="type">int</span> c[<span class="number">30</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cunchu</span><span class="params">(<span class="type">char</span> str[])</span><span class="comment">//存储简单析取式，利用字母进行存储&#123;</span></span></span><br><span class="line"><span class="function">    <span class="title">memset</span><span class="params">(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s))</span></span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    num0 = num1 = <span class="number">-1</span>; num2 = <span class="number">0</span>;<span class="comment">//num2控制总共简单析取式的数量</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len)&#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] &gt;= <span class="string">&#x27;a&#x27;</span>&amp;&amp;str[i] &lt;= <span class="string">&#x27;z&#x27;</span>)&#123;</span><br><span class="line">            s[num2][str[i] - <span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span>;<span class="comment">//正值记为1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">&#x27;&amp;&#x27;</span>)num2++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">&#x27;!&#x27;</span>)&#123;</span><br><span class="line">            s[num2][str[++i] - <span class="string">&#x27;a&#x27;</span>] = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(<span class="type">int</span> s[],<span class="type">int</span> c[])</span><span class="comment">//判断是否相同，不相同则放入集合s2中&#123;</span></span></span><br><span class="line"><span class="function">    <span class="title">for</span> <span class="params">(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] != c[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">(<span class="type">int</span> c[])</span><span class="comment">//循环进行检验是否有重复，无重复返回正值&#123;</span></span></span><br><span class="line"><span class="function">    <span class="title">for</span> <span class="params">(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num2; i++)</span><span class="comment">//与原有的s1比较，是否有重复&#123;</span></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(same(s[i], c))</span></span></span><br><span class="line"><span class="function">            <span class="keyword">return</span> <span class="literal">false</span></span>;<span class="comment">//如有相同则不将其加入s2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//无相同加入s2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">RES</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> b[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> record1 = <span class="number">0</span>;<span class="comment">//记录消解的变元个数</span></span><br><span class="line">    <span class="type">int</span> record2 = <span class="number">0</span>;<span class="comment">//记录为消解的变元个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)<span class="comment">//利用字母代表变元，记录每个真值情况&#123;</span></span><br><span class="line">        <span class="keyword">if</span> (!a[i] &amp;&amp; !b[i])<span class="comment">//变元不存在</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> ((a[i] == <span class="number">1</span> &amp;&amp; b[i] == <span class="number">2</span>) || (a[i] == <span class="number">2</span> &amp;&amp; b[i] == <span class="number">1</span>))<span class="comment">//可消解的情况</span></span><br><span class="line">            record1++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            record2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(record1!=<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//无可以消解的情况，或者有多对可以消解的情况 </span></span><br><span class="line">    <span class="keyword">if</span> (!record2)<span class="comment">//全部都可以消解，得到空句子，直接返回不满足式</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="built_in">sizeof</span>(c));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] + b[i] == <span class="number">3</span> || a[i] + b[i] == <span class="number">0</span>)<span class="comment">//变元不存在或者变元可消解</span></span><br><span class="line">            c[i] = <span class="number">0</span>;<span class="comment">//可消解</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[i]==<span class="number">1</span>||b[i]==<span class="number">1</span>)<span class="comment">//有两种情况，两边只有一边有相应变元，两边都有变元，且变元相同 </span></span><br><span class="line">            c[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//变元存在且真值为负</span></span><br><span class="line">            c[i] = <span class="number">2</span>;</span><br><span class="line">    &#125;<span class="comment">//记录消解的结果</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">judge</span>(c))&#123;</span><br><span class="line">        num2++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        s[num2][i]=c[i];<span class="comment">//将消解的结果存入s数组中，赋值给s2 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">    <span class="built_in">cunchu</span>(str);</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        num0 = num1; num1 = num2;<span class="comment">//将s1赋给s0,将s2赋给s1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= num0; i++)<span class="comment">//至少经过一次消解的情况&#123;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = num0+<span class="number">1</span>; j &lt;= num1; j++)<span class="comment">//将所有情况存储在一个数组中，利用下标控制集合的个数&#123;</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">RES</span>(s[i], s[j]))<span class="comment">//消解利用循环一次进行消解&#123;</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">                    <span class="built_in">getchar</span>();</span><br><span class="line">                    <span class="built_in">getchar</span>();</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = num0 + <span class="number">1</span>; i &lt;= num1; i++)<span class="comment">//第一次进行消解的情况,s1内部进行消解&#123;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= num1; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">RES</span>(s[i], s[j]))&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">                    <span class="built_in">getchar</span>();</span><br><span class="line">                    <span class="built_in">getchar</span>();</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (num2 &gt; num1);<span class="comment">//将新加的简单析取式仍然利用num2计数，若无新出现的简单析取式，s2为0，则跳出循环</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="批量标准化修改文件名："><a href="#批量标准化修改文件名：" class="headerlink" title="批量标准化修改文件名："></a>批量标准化修改文件名：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;io.h&gt;</span>  <span class="comment">//对系统文件进行操作的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">8</span>;   <span class="comment">//整型格式化输出为字符串后的长度，例如，N=6，则整型转为长度为6的字符串，12转为为000012</span></span><br><span class="line"><span class="type">const</span> string FileType = <span class="string">&quot;.jpg&quot;</span>;    <span class="comment">// 需要查找的文件类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数说明 整型转固定格式的字符串</span></span><br><span class="line"><span class="comment">输入：</span></span><br><span class="line"><span class="comment">n 需要输出的字符串长度</span></span><br><span class="line"><span class="comment">i 需要结构化的整型</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">返回转化后的字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">string <span class="title">int2string</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> s[BUFSIZ];</span><br><span class="line">    <span class="built_in">sprintf</span>(s, <span class="string">&quot;%d&quot;</span>, i);</span><br><span class="line">    <span class="type">int</span> l = <span class="built_in">strlen</span>(s);  <span class="comment">// 整型的位数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l &gt; n)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;整型的长度大于需要格式化的字符串长度！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        stringstream M_num;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; n - l;i++)</span><br><span class="line">            M_num &lt;&lt; <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        M_num &lt;&lt; i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> M_num.<span class="built_in">str</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">_finddata_t</span> c_file;   <span class="comment">// 查找文件的类</span></span><br><span class="line"></span><br><span class="line">    string File_Directory =<span class="string">&quot;C:\\Users\\22562\\mmediting\\data\\Vid4\\BIx4\\Watermelon&quot;</span>;   <span class="comment">//文件夹目录</span></span><br><span class="line"></span><br><span class="line">    string buffer = File_Directory + <span class="string">&quot;\\*&quot;</span> + FileType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//long hFile;  //win7系统，_findnext()返回类型可以是long型</span></span><br><span class="line">    <span class="type">intptr_t</span> hFile;   <span class="comment">//win10系统 ，_findnext()返回类型为intptr_t ，不能是long型</span></span><br><span class="line"></span><br><span class="line">    hFile = _findfirst(buffer.<span class="built_in">c_str</span>(), &amp;c_file);   <span class="comment">//找第一个文件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hFile == <span class="number">-1L</span>)   <span class="comment">// 检查文件夹目录下存在需要查找的文件</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No %s files in current directory!\n&quot;</span>, FileType);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Listing of files:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        string newfullFilePath;</span><br><span class="line">        string oldfullFilePath;</span><br><span class="line">        string str_name;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            oldfullFilePath.<span class="built_in">clear</span>();</span><br><span class="line">            newfullFilePath.<span class="built_in">clear</span>();</span><br><span class="line">            str_name.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//旧名字</span></span><br><span class="line">            oldfullFilePath = File_Directory + <span class="string">&quot;\\&quot;</span> + c_file.name;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//新名字</span></span><br><span class="line">            ++i;</span><br><span class="line">            str_name = <span class="built_in">int2string</span>(N, i);    <span class="comment">//整型转字符串</span></span><br><span class="line">            newfullFilePath = File_Directory + <span class="string">&quot;\\&quot;</span>+ str_name + FileType;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*重命名函数rename（const char* _OldFileName,const char* _NewFileName）</span></span><br><span class="line"><span class="comment">              第一个参数为旧文件路径，第二个参数为新文件路径*/</span></span><br><span class="line">            <span class="type">int</span> c = <span class="built_in">rename</span>(oldfullFilePath.<span class="built_in">c_str</span>(), newfullFilePath.<span class="built_in">c_str</span>());  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;File successfully renamed&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;Error renaming file&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">while</span> (_findnext(hFile, &amp;c_file) == <span class="number">0</span>);  <span class="comment">//如果找到下个文件的名字成功的话就返回0,否则返回-1  </span></span><br><span class="line">        _findclose(hFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span c</summary>
      
    
    
    
    
  </entry>
  
</feed>
