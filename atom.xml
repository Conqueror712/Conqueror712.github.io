<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>落雨乄天珀夜</title>
  
  
  <link href="https://conqueror712.github.io/atom.xml" rel="self"/>
  
  <link href="https://conqueror712.github.io/"/>
  <updated>2023-05-14T02:58:48.618Z</updated>
  <id>https://conqueror712.github.io/</id>
  
  <author>
    <name>落雨乄天珀夜</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计网 - 网络层的功能丨学习记录</title>
    <link href="https://conqueror712.github.io/post/Computer-Network-4-1.html"/>
    <id>https://conqueror712.github.io/post/Computer-Network-4-1.html</id>
    <published>2023-05-14T02:57:03.000Z</published>
    <updated>2023-05-14T02:58:48.618Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>个人博客：<a href="https://conqueror712.github.io/">https://conqueror712.github.io/</a></p><p>知乎：<a href="https://www.zhihu.com/people/soeur712/posts">https://www.zhihu.com/people/soeur712/posts</a></p><p>Bilibili：<a href="https://space.bilibili.com/57089326">https://space.bilibili.com/57089326</a></p><p>掘金：<a href="https://juejin.cn/user/1297878069809725/posts">https://juejin.cn/user/1297878069809725/posts</a></p></blockquote><p>注：本文图片的水印均是笔者自己的。</p><p>参考资料：《自顶向下的计算机网络》《王道计算机网络考研复习指导》</p><blockquote><p>本节概述：</p></blockquote><p>网络层：<strong>向上只提供简单灵活的、无连接的、尽力而为的数据报服务</strong>。</p><p>特点：传送的分组可能会出错、丢失、重复、乱序以及超时。</p><p>原因：降低网络构建的成本，灵活其运行方式以适用于多种应用，在今天看来，这是正确的。</p><hr><h1 id="异构网络互联："><a href="#异构网络互联：" class="headerlink" title="异构网络互联："></a>异构网络互联：</h1><h2 id="网络互连的概念："><a href="#网络互连的概念：" class="headerlink" title="网络互连的概念："></a>网络互连的概念：</h2><p>将两个以上的计算机网络，通过一定的方法，用一些<strong>中继系统</strong>相互连接起来，以构成更大的网络系统。</p><p>更准确地说，是指用<strong>路由器进行网络互连和路由选择</strong>。</p><p>（路由器是一台专用的计算机，用于在互联网中进行路由选择）</p><p>那中继系统又是什么呢？</p><h2 id="中继系统："><a href="#中继系统：" class="headerlink" title="中继系统："></a>中继系统：</h2><p>中继系统分类（按所在层次）：</p><ul><li>物理层：转发器、集线器</li><li>数据链路层：网桥、交换机</li><li><strong>网络层：路由器</strong></li><li>网络层以上：网关</li></ul><p>就这样，许多计算机网络就可以通过一些路由器进行互连；</p><h2 id="IP网："><a href="#IP网：" class="headerlink" title="IP网："></a>IP网：</h2><p>又因为参加互连的计算机网络都使用相同的<strong>IP协议</strong>，所以可以整体视为一个<strong>虚拟IP网络</strong>（逻辑互连网络）。</p><p>更进一步地说，就是说，互连起来的各种物理网络的<strong>异构性</strong>本来是客观存在的，但是通过<strong>IP协议</strong>，就可以使这些性能各异的网络在网络层上看起来好像是一个统一的网络，我们可以理解为<strong>封装</strong>。</p><p>使用IP网的<strong>好处</strong>：</p><p>当IP网上的主机进行通信的时候，其内部复杂的路由转发过程被掩盖，就像<strong>黑盒</strong>一样，简单明确。</p><hr><h1 id="路由与转发："><a href="#路由与转发：" class="headerlink" title="路由与转发："></a>路由与转发：</h1><p>路由器主要有两个功能：路由选择、分组转发。</p><h2 id="路由选择："><a href="#路由选择：" class="headerlink" title="路由选择："></a>路由选择：</h2><p>根据特定的<strong>路由选择协议</strong>，构造出<strong>路由表</strong>，同时经常或定期地和相邻路由器<strong>交换路由信息</strong>，从而不断地<strong>更新和维护路由表</strong>。</p><p>更进一步地说，是按照复杂的<strong>分布式算法</strong>，根据从各相邻路由器得到的关于整个<strong>网络拓扑的变化情况</strong>，<strong>动态</strong>地改变所选择的路由。</p><h2 id="分组转发："><a href="#分组转发：" class="headerlink" title="分组转发："></a>分组转发：</h2><p>处理<strong>通过路由器的数据流</strong>。关键操作是<strong>转发表查询、转发和相关的队列管理和任务调度</strong>等。</p><p>更进一步地说，是路由器<strong>根据转发表</strong>，将用户的<strong>IP数据报</strong>从合适的端口<strong>转发</strong>出去。</p><p>（在讨论路由选择原理的时候，往往不去区分转发表和路由表，都统称为路由表）</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d52ded8e99aa492597ff6e65322eceea~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><hr><h1 id="SDN的基本概念："><a href="#SDN的基本概念：" class="headerlink" title="SDN的基本概念："></a>SDN的基本概念：</h1><p>因为网络层的主要任务就是<strong>转发</strong>和<strong>路由选择</strong>，所以可以将网络层抽象地划分为：</p><ul><li>数据平面（转发）</li><li>控制平面（选择）</li></ul><p>SDN——软件定义网络，是近年流行的一种创新网络架构，采用<strong>集中式的控制平面</strong>和<strong>分布式的数据平面</strong>（互相分离）。</p><p>其中，其控制平面利用<strong>控制-数据接口</strong>，对数据平面上的路由器进行<strong>集中式的控制</strong>，从而方便软件来控制网络。</p><p>这使得路由器<strong>变得简单</strong>，砍掉了相互交换路由信息这一功能，集成在远程控制器中；</p><p>路由器只需要进行<strong>收到分组、查找转发表、转发分组</strong>这三项工作。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08280287cdde4863a663beb21474cd1d~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h2 id="SDN的应用："><a href="#SDN的应用：" class="headerlink" title="SDN的应用："></a>SDN的应用：</h2><p>在某些具体条件下，例如一些<strong>大型的数据中心之间的广域网</strong>，使用SDN模式进行改造，就可以让网络的<strong>运行效率变高</strong>。</p><h2 id="SDN的可编程性："><a href="#SDN的可编程性：" class="headerlink" title="SDN的可编程性："></a>SDN的可编程性：</h2><p>SDN具有可编程性，为开发者们提供强大的编程接口（<strong>北向接口</strong>），使得网络具有很好的编程性。</p><p>SDN控制器和转发设备建立双向会话的接口称为<strong>南向接口</strong>；</p><p>通过不同的南向接口协议（如Openflow），SDN控制器就可以<strong>兼容不同的硬件设备</strong>，同时可以在设备中实现上层应用的逻辑。</p><p>SDN控制器集群内部控制器之间的通信接口称为<strong>东西向接口</strong>，用于增强整个控制平面的<strong>可靠性</strong>和<strong>可拓展性</strong>。</p><h2 id="SDN的优缺点："><a href="#SDN的优缺点：" class="headerlink" title="SDN的优缺点："></a>SDN的优缺点：</h2><p>优点：</p><ul><li>集中式与分布式的并行——既利于<strong>控制平面的全局优化</strong>，又利于<strong>高性能的网络转发</strong>；</li><li>两大功能分离——灵活可编程与性能的<strong>平衡</strong>；</li><li>两大功能分离——<strong>降低成本</strong>。</li></ul><p>缺点：</p><ul><li>集中管理——<strong>安全风险</strong>（更易攻击）</li><li>集中化的控制器——<strong>瓶颈问题</strong>（性能）</li></ul><hr><h1 id="拥塞控制："><a href="#拥塞控制：" class="headerlink" title="拥塞控制："></a>拥塞控制：</h1><p>概念：在通信子网中，因出现<strong>过量的分组</strong>而引起网络<strong>性能的下降</strong>的现象——拥塞。</p><h2 id="判断网络是否进入拥塞状态的方法："><a href="#判断网络是否进入拥塞状态的方法：" class="headerlink" title="判断网络是否进入拥塞状态的方法："></a>判断网络是否进入拥塞状态的方法：</h2><p>观察网络的<strong>吞吐量</strong>与<strong>网络负载</strong>的关系。</p><p>随着<strong>网络负载的增加</strong>：</p><ul><li>网络的吞吐量<strong>明显小于</strong>正常的吞吐量——<strong>轻度拥塞状态</strong>；</li><li>网络的吞吐量快速下降——<strong>拥塞状态</strong>；</li><li>网络的吞吐量降为零——<strong>死锁状态</strong>。</li></ul><p>这时，拥塞控制就来解决这一问题。</p><h2 id="流量控制与拥塞控制的区别："><a href="#流量控制与拥塞控制的区别：" class="headerlink" title="流量控制与拥塞控制的区别："></a>流量控制与拥塞控制的区别：</h2><p>流量控制：发送端与接收端的<strong>点对点</strong>的通信量控制，抑制发送速率，以便接收。</p><p>拥塞控制：必须确保通信子网能够传送待传送的数据，<strong>全局性</strong>问题。</p><h2 id="拥塞控制的两种方法："><a href="#拥塞控制的两种方法：" class="headerlink" title="拥塞控制的两种方法："></a>拥塞控制的两种方法：</h2><ul><li>开环控制：在设计时实现考虑到——<strong>静态方法</strong>。</li><li>闭环控制：采用监测网络系统，及时检测哪里发生了拥塞——<strong>动态方法</strong>。</li></ul><hr><h1 id="附加-本节易错知识点习题："><a href="#附加-本节易错知识点习题：" class="headerlink" title="[附加] 本节易错知识点习题："></a>[附加] 本节易错知识点习题：</h1><blockquote><p>路由器连接的异构网络是指：数据链路层和物理层均不同。</p></blockquote><p>网络的异构性指的是传输介质、数据编码方式、链路控制协议、不同的数据单元格式、不同的转发机制。</p><p>而这些特点分别在物理层和数据链路层中定义。</p><hr><blockquote><p>在路由器互联的多个局域网的结构中，要求每个局域网的物理层、数据链路层、网络层的协议可以不同，但是网络层以上的高层协议必须相同。</p></blockquote><p>路由器只能隐藏网络层及以下的具体细节，但是以上不可以。</p><hr><blockquote><p>可以分隔广播域的是路由器。</p></blockquote><p>路由器工作在网络层，不转发广播包，因此可以分隔广播域，抑制网络风暴。</p><p>交换机工作在数据链路层，能够分隔冲突域，但不能分隔广播域。</p><p>集线器和中继器是物理层设备，都不能分隔。</p><hr><blockquote><p>一个路由器的路由表通常包含：目的网络和到达该目的网络路径上的下一个路由器的IP地址。</p></blockquote><hr><blockquote><p>路由器在能够开始向输出链路传输分组的第一位之前，必须先接收到整个分组——存储转发机制。</p></blockquote><hr><blockquote><p>在因特网中，IP分组的传输需要经过源主机和中间路由器到达目的主机；</p><p>通常来说，源主机和中间路由器都不知道IP分组到达目的主机需要经过的完整路径。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;个人博客：&lt;a href=&quot;https://conqueror712.github.io/&quot;&gt;https://conqueror712.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;知乎：&lt;a href=&quot;https://www.zhihu.com/</summary>
      
    
    
    
    <category term="408" scheme="https://conqueror712.github.io/categories/408/"/>
    
    
  </entry>
  
  <entry>
    <title>MLC-LLM教程丨无需科技，浏览器就能用的大模型</title>
    <link href="https://conqueror712.github.io/post/MLC-LLM.html"/>
    <id>https://conqueror712.github.io/post/MLC-LLM.html</id>
    <published>2023-05-01T12:14:34.000Z</published>
    <updated>2023-05-01T13:00:31.339Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><blockquote><p>本文预计阅读时长：10分钟</p></blockquote><p>你是否还在为ChatGPT的注册、网络、封号等问题头疼？</p><p>别担心，人人都能<strong>本地使用</strong>的语言模型来了！</p><p>本文就来介绍<strong>MLC-LLM</strong>的浏览器使用方法。</p><p>特别说明：<strong>进行对话无需科技</strong>！</p><p>当然，它不仅可以通过浏览器来使用，还可以通过手机或电脑（不同于浏览器）来使用，</p><p>笔者认为，<strong>浏览器方法是最简单的一种</strong>，故撰写此文。</p><blockquote><p>个人博客：<a href="https://conqueror712.github.io/">https://conqueror712.github.io/</a></p><p>知乎：<a href="https://www.zhihu.com/people/soeur712/posts">https://www.zhihu.com/people/soeur712/posts</a></p><p>Bilibili：<a href="https://space.bilibili.com/57089326">https://space.bilibili.com/57089326</a></p><p>掘金：<a href="https://juejin.cn/user/1297878069809725/posts">https://juejin.cn/user/1297878069809725/posts</a></p></blockquote><hr><h1 id="教程："><a href="#教程：" class="headerlink" title="教程："></a>教程：</h1><h2 id="官方文档："><a href="#官方文档：" class="headerlink" title="官方文档："></a>官方文档：</h2><p>首先，给出官方文档，英文阅读能力较强的读者可以自行前往进行参考，当然，笔者就是根据官方文档来学习的使用方法，只看官方文档显然也可以，不过可能会有一些解释不清的地方，不妨继续阅读本文以明确。</p><p>文档主页：<a href="https://mlc.ai/mlc-llm/">https://mlc.ai/mlc-llm/</a></p><p>浏览器方法页面：<a href="https://mlc.ai/web-llm/">https://mlc.ai/web-llm/</a></p><blockquote><p>心急的读者可能会直接在自己的浏览器上进行对话了，但是很遗憾，这大概并不能成功。</p></blockquote><hr><h2 id="环境配置："><a href="#环境配置：" class="headerlink" title="环境配置："></a>环境配置：</h2><p>读者不要看到环境配置就大惊失色，事实上，这并没有多么困难，甚至可以说是傻瓜式，一键式操作。</p><p>我们只需要下载一个<strong>开发者专用的Chrome浏览器</strong>，俗称金丝雀版Chrome。</p><p>下载地址：<a href="https://www.google.com/chrome/canary/%EF%BC%88%E9%9C%80%E8%A6%81%E7%A7%91%E6%8A%80%EF%BC%89">https://www.google.com/chrome/canary/（需要科技）</a></p><blockquote><p>笔者也为不方便使用科技的读者准备了下载链接：</p><p>链接：<code>https://pan.baidu.com/s/1X9RuHQkRYA07tCjimYIU4Q?pwd=8guf </code></p><p>提取码：<code>8guf</code></p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70ceebe112e44907bcbf47cd5d145332~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>傻瓜式安装后，我们就可以通过金丝雀版Chrome打开上面的浏览器方法页面<a href="https://mlc.ai/web-llm/%E3%80%82">https://mlc.ai/web-llm/。</a></p><blockquote><p>此时，我们才可以真正的进行对话，不过在此之前，我们需要等待浏览器初始化，这大概需要两分钟。</p></blockquote><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c72d1e8619a4b078f092d6771570168~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><blockquote><p>PS：如果没有进行初始化，那就输入一段话然后按一下<code>Send</code>试一试。</p></blockquote><hr><h2 id="效果演示："><a href="#效果演示：" class="headerlink" title="效果演示："></a>效果演示：</h2><p>初始化结束后，我们就可以愉快地对话了！</p><blockquote><p>值得一提的是，中文可能会出现乱码的情况，不过他会自己修复一些。</p></blockquote><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8852074afe154433854685e060a207f4~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><blockquote><p>需要注意的是，响应速度可能并不尽如人意，这大概与本机的配置有关，但这也不失为一种本地化使用AI的办法，当你的其他AI崩溃的时候，不妨来试一试MLC-LLM！</p></blockquote><p>这张任务管理器界面截图证明了这个确实是跑在本地上了，笔者的渣机内存和GPU占用率很高：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff639722a1ec459abf24b188dbba3784~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><hr><p>THE END.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文预计阅读时长：10分钟&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你是否还在为ChatGPT的注册、网</summary>
      
    
    
    
    <category term="Experience" scheme="https://conqueror712.github.io/categories/Experience/"/>
    
    
  </entry>
  
  <entry>
    <title>面经丨BUPT第三届模拟面试大赛</title>
    <link href="https://conqueror712.github.io/post/Interview-BUPT.html"/>
    <id>https://conqueror712.github.io/post/Interview-BUPT.html</id>
    <published>2023-04-26T15:32:52.000Z</published>
    <updated>2023-04-26T16:08:19.349Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e849f5a76724b0f8dad347fe57d8aff~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>笔者这次是作为决赛的选手参加的此次面试，人生中的第一次面试经历，收获颇丰，特此记录与分享。</p><p>本次活动是从面向整个人工智能学院的海选中选出的9位同学进行决赛，有数位领导参会，个人认为规格还是很高的。</p><hr><h1 id="无领导面试："><a href="#无领导面试：" class="headerlink" title="无领导面试："></a>无领导面试：</h1><p>以下是我在此次面试前做的一些准备资料：</p><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>无领导小组讨论，俗称群面Group Interview.</p><p>小组成员以讨论的方式，共同应对一个需要解决的问题，经过各种观点和思想的碰撞和提炼，共同找出一个最合适的答案或结果。</p><p>面试官则在一旁对应聘者在讨论中的发言内容及左右局势的能力进行评估。</p><h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><ul><li>节约时间</li><li>让应聘者较为放松</li></ul><h2 id="评分标准："><a href="#评分标准：" class="headerlink" title="评分标准："></a>评分标准：</h2><ul><li><strong>语言方面的考核</strong>，通常包括应聘者的语言表达能力、辩论说服能力、组织协调能力、发言主动性、论点的正确性等。</li><li><strong>非语言方面的考核</strong>，包括应聘者的面部表情、身体姿势、语调、语速和手势等等。</li><li><strong>应聘者个性特点的考核</strong>，通常包括自信心、进取心、责任心、情绪稳定性、反应灵活性等等。在小组面试中，应聘者的所有举动都在面试官的视线里，所有的细节都有可能决定应聘者在小组面试中的成败。</li></ul><h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><ul><li>仔细听规则，适当记录</li><li>成败源于细节，态度决定一切</li><li>自我介绍不要紧张，声音要洪亮，语言清晰流畅，避免机械式的背书，多肢体语言，表情控制，自信</li><li>听一听别人的自我介绍，对对方有一个第一印象，方便后续的小组讨论与合作</li><li>拿到题目之后仔细审题，要有广度有深度</li><li>观点陈述要有条理，语言简洁凝练</li><li>小组讨论要有礼貌，注意发言顺序，要面向小组成员而不是面试官</li></ul><h2 id="角色划分："><a href="#角色划分：" class="headerlink" title="角色划分："></a>角色划分：</h2><ul><li>破冰者</li><li>领导者</li><li>时间控制者</li><li>总结汇报者</li><li>组织协调者</li><li>其他参与者</li></ul><hr><h1 id="面经分享："><a href="#面经分享：" class="headerlink" title="面经分享："></a>面经分享：</h1><h2 id="自我介绍环节："><a href="#自我介绍环节：" class="headerlink" title="自我介绍环节："></a>自我介绍环节：</h2><p>面试官提出的一些共性的问题：</p><ul><li>时间把握，给出的要求是90s，那么显然不能超过90s，也不能低于70s</li><li>讲述要有逻辑</li><li>注意语速，上台前可以先做深呼吸</li><li>注意一定要脱稿完成</li><li>第一印象很重要，一定要自信</li><li>归纳总结性的自我介绍为上，而不是流水账</li><li>项目经历和专业能力是很重要的，要多说</li></ul><h2 id="小组面试环节："><a href="#小组面试环节：" class="headerlink" title="小组面试环节："></a>小组面试环节：</h2><p><em>这部分记的内容不多，因为当时在台上没有可以记录的东西</em></p><ul><li>一定要做好自己是哪个角色的准备</li><li>尽可能展现自我的个性，展示自己的优势之处，让HR记住你</li><li>无领导小组面试很展现个性，一定要注意表现出来</li></ul><h2 id="随机应变环节："><a href="#随机应变环节：" class="headerlink" title="随机应变环节："></a>随机应变环节：</h2><ul><li><p>如果是作为领导的话，考虑员工的能力比性格更重要</p></li><li><p>避免口语化，注意逻辑性（上面也提到了这一点）</p></li><li><p>如果有一些棘手的背景设计，记得要为自己想办法争取时间</p></li><li><p>如果有多方案，要考虑能不能并行的做，两手或者多手抓</p></li><li><p>要灵活的面对问题，而不是被局限在问题里面，比如跳出二择的问题（因为两个可能都不是好的解决方法）</p></li><li><p>回答的时候要面向HR，而不是面向屏幕或者其他的什么东西</p></li><li><p>语速要适中，注意语音语调的变化</p></li><li><p>注意听问题的弦外之音，不懂就问（如果遇到领导的指示不明白的情况）</p></li><li><p>对于问题的情况，大概率背景是不那么明确的，注意要情况分类，类比二叉树</p></li><li><p>要注意更加侧重于解决方案而不是在背景分析里面打转</p></li><li><p>对于非常狗血的问题或者追问，一定要在适当的时候说拒绝回答，这样才是一个鲜活的人</p></li><li><p>面对问题，要想办法在侧面体现出自己的优势</p></li><li><p>注意每个问题是偏向于深度回答还是广度回答，一般来说，二者兼得会很不错，一个重要的指标是要合逻辑、通情理，这样才能够说服面试官</p></li><li><p>准备和经验要充分，多参加这种面试，多锻炼，各种场合的，不要害怕</p></li><li><p>可以自己录制自己的演讲视频，会发现很多问题</p></li></ul><hr><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63f8287b88984234897487b2bc029f00~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>THE END</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5</summary>
      
    
    
    
    <category term="Interview" scheme="https://conqueror712.github.io/categories/Interview/"/>
    
    
  </entry>
  
  <entry>
    <title>计网 - Ep3 - 传输层「万字长文」丨学习记录</title>
    <link href="https://conqueror712.github.io/post/Computer-Network-3.html"/>
    <id>https://conqueror712.github.io/post/Computer-Network-3.html</id>
    <published>2023-04-20T06:39:28.000Z</published>
    <updated>2023-04-27T16:52:46.036Z</updated>
    
    <content type="html"><![CDATA[<p><em>Computer Networking A Top-Down Approach Learning Note Part 3</em></p><p><strong>前言</strong>：</p><p>本文是笔者初学计算机网络的笔记和一些心得，难免会有部分疏漏和错误，还请各位读者积极指出，不吝赐教。</p><p>有一些内容是笔者认为对自己暂时没那么重要的部分，就没有放上去，具体的内容可以查看相关的书籍。</p><p>观前提醒：本文篇幅较长，若您只是想看其中的某一小节的知识，直接点击目录进行跳转即可！</p><p>事不宜迟，我们开始吧！</p><blockquote><p>个人博客：<a href="https://conqueror712.github.io/">https://conqueror712.github.io/</a></p><p>知乎：<a href="https://www.zhihu.com/people/soeur712/posts">https://www.zhihu.com/people/soeur712/posts</a></p><p>Bilibili：<a href="https://space.bilibili.com/57089326">https://space.bilibili.com/57089326</a></p><p>掘金：<a href="https://juejin.cn/user/1297878069809725/posts">https://juejin.cn/user/1297878069809725/posts</a></p></blockquote><p>注：本文图片的水印均是笔者自己的。</p><p>参考资料：《自顶向下的计算机网络》《王道计算机网络考研复习指导》</p><hr><h1 id="传输层概述"><a href="#传输层概述" class="headerlink" title="传输层概述"></a>传输层概述</h1><p>传输层，为<strong>运行在不同主机上的应用进程</strong>，提供<strong>直接的通信服务</strong>，起着至关重要的作用。</p><blockquote><p>Learning Target:</p></blockquote><p>传输层的工作原理：</p><ul><li>多路复用 &#x2F; 多路分解</li><li>可靠数据传输</li><li>流量控制</li><li>拥塞控制</li></ul><p>Internet的传输层协议：</p><ul><li>UDP：无连接传输</li><li>TCP：面向连接的可靠传输</li><li>TCP的拥塞控制</li></ul><hr><h2 id="概述和传输层服务："><a href="#概述和传输层服务：" class="headerlink" title="概述和传输层服务："></a>概述和传输层服务：</h2><blockquote><p>传输服务与协议</p></blockquote><p><strong>传输服务和协议</strong>目的：为运行在不同主机上的应用进程提供<strong>逻辑通信</strong>。</p><p>传输协议运行位置：端系统。</p><ul><li>发送方：将应用层来的报文分成<strong>报文段</strong>，然后继续传递给网络层。</li><li>接收方：将报文段重组成报文，然后继续传递给应用层。（相反的过程）</li></ul><p>还需注意的是，有很多传输层协议可以使用，对于Internet来说，就是TCP和UDP。</p><blockquote><p>我们来对比一下传输层和网络层的区别</p></blockquote><p>网络层服务：主机之间的逻辑通信。</p><p>传输层服务：进程之间的逻辑通信（更细）。</p><ul><li>传输层服务<strong>依赖于</strong>网络层的服务（延时和带宽，这两个不可以被加强）</li><li>传输层服务对网络层的服务进行<strong>增强</strong>（数据丢失、数据混乱、加密）</li></ul><p>笔者的理解：网络层建立起主机之间的逻辑通信之后，传输层才能在之上进行颗粒度更细的进程上的逻辑通信。</p><blockquote><p>Internet传输层协议</p></blockquote><p>TCP：</p><ul><li>多路复用、多路分解</li><li>建立连接</li><li>拥塞控制</li><li>流量控制</li></ul><p>UDP：</p><ul><li>多路复用、多路分解</li><li>没有为尽力而为的IP服务添加更多的额外服务</li></ul><hr><h2 id="传输层的寻址与端口："><a href="#传输层的寻址与端口：" class="headerlink" title="传输层的寻址与端口："></a>传输层的寻址与端口：</h2><h3 id="端口："><a href="#端口：" class="headerlink" title="端口："></a>端口：</h3><p>端口能够让应用层的各种应用进程将其数据通过端口<strong>向下交付</strong>给传输层，</p><p>以及让传输层知道应当将其报文段中的数据通过端口<strong>向上交付</strong>给应用层的相应进程。</p><p>端口是传输层服务访问点（T-SAP）；</p><p>（类比）端口在传输层的作用类似于IP地址在网络层的作用或MAC地址在数据链路层的作用；</p><p>不同的是，IP和MAC地址标识的是主机，而端口表示的是应用进程。</p><h3 id="端口号："><a href="#端口号：" class="headerlink" title="端口号："></a>端口号：</h3><p>应用进程通过端口号进行标识，端口号长度为16bits，能表示65536个不同的端口号。</p><p>应当注意的是，端口号只具有<strong>本地意义</strong>。</p><p><strong>端口号分类</strong>：</p><p>$[0, 1023]$的端口号称之为<strong>周知端口号</strong>，保留给HTTP(80)等周知应用层协议，由IANA指派。</p><p>$[1024, 49151]$的端口号称之为<strong>登记端口号</strong>，供没有周知端口号的应用程序使用，也需要在IANA上登记。</p><p>$[49152, 65535]$的端口号称之为<strong>临时端口</strong>，通信结束后，这些就会释放掉。</p><blockquote><p>IANA，互联网地址指派机构</p></blockquote><h3 id="套接字："><a href="#套接字：" class="headerlink" title="套接字："></a>套接字：</h3><p>套接字$Socket&#x3D;(IP地址:端口号)$</p><p>在网络中，采用发送方和接收方的套接字来识别端点，<strong>唯一地标识网络中的一台主机和其上的一个应用进程</strong>。</p><hr><h2 id="多路复用与多路分解："><a href="#多路复用与多路分解：" class="headerlink" title="多路复用与多路分解："></a>多路复用与多路分解：</h2><p>人话解释：就是将，由网络层提供的主机到主机的交付服务，延伸到，为运行在主机上的应用程序提供进程到进程的交付服务。</p><p>这是所有的计算机网络都需要的服务，而不仅仅是Internet独有的。</p><p>复习<strong>套接字</strong>：相当于网络和进程之间传递数据的门户。</p><blockquote><p>发送方主机——多路复用：</p></blockquote><p>含义：从多个套接字，接收来自多个进程的报文，根据套接字对应的<strong>IP地址和端口号</strong>等信息，对报文段<strong>用头部</strong>加以封装（该头部信息用于以后的解复用）。</p><blockquote><p>接收方主机——多路分解：</p></blockquote><p>含义：根据报文段的头部信息中的<strong>IP地址和端口号</strong>，将接收到的报文段发给正确的套接字（和对应的应用进程）。</p><ul><li>Port是端口号，用于区分进程</li><li>PID是进程的唯一标识</li></ul><p>如果还没有明白，可以仔细阅读这个例子 ：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a52712255f34457cb2037b601864c844~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>传输层多路复用的要求：</p><ol start="0"><li>套接字有唯一标识符；</li><li>每个报文段有特殊字段来指示该报文段所要交付到的套接字；</li></ol><hr><h3 id="无连接的多路复用与多路分解："><a href="#无连接的多路复用与多路分解：" class="headerlink" title="无连接的多路复用与多路分解："></a>无连接的多路复用与多路分解：</h3><p>一个UDP套接字是由一个<strong>二元组</strong>来全面标识的：</p><p>该二元组包含一个<strong>目的IP地址</strong>和一个<strong>目的端口号</strong>。</p><p>那么，源端口号还有存在的必要吗？答案是有的，源端口号作为<strong>返回地址</strong>的一部分。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c493d6e7fb34784b7b5960e1ce8a57f~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><hr><h3 id="面向连接的多路复用与多路分解："><a href="#面向连接的多路复用与多路分解：" class="headerlink" title="面向连接的多路复用与多路分解："></a>面向连接的多路复用与多路分解：</h3><p>TCP套接字和UDP套接字的区别是，TCP套接字是由一个四元组来全面标识的：</p><p>四元组：源IP地址，源端口号，目的IP地址，目的端口号。</p><p>与UDP不同的是：</p><p>两个具有不同源IP地址或源端口号的到达TCP报文段将被定向到两个不同的套接字，除非TCP报文段携带了初始创建连接的请求。</p><blockquote><p>具体的细节并没有在此展开，笔者认为，一方面是因为写在一起过于纷繁复杂，不便于读者观看；另一方面是笔者自己也一时间看不下去那么多细节，所以就先Overview，之后在做题的过程中遇到问题再返回来查漏补缺。</p></blockquote><hr><p>Web服务器与TCP，先以一图以示之：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3025661947be4a31a363b4102e0507b2~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><hr><h1 id="无连接传输-UDP："><a href="#无连接传输-UDP：" class="headerlink" title="无连接传输 - UDP："></a>无连接传输 - UDP：</h1><h2 id="UDP数据报："><a href="#UDP数据报：" class="headerlink" title="UDP数据报："></a>UDP数据报：</h2><p>UDP的全称到底是什么？事实上是：User Datagram Protocol，即用户数据报协议。</p><p>UDP传的是数据报。</p><p>与IP一样，也是<strong>尽力而为</strong>的，除了相比IP，更加细分了进程到进程以外（IP是主机到主机），几乎没有额外的内容了，仅仅增加了两个最基本的服务：<strong>复用和分用以及差错检测</strong>。</p><blockquote><p>UDP的首部格式以及UDP的优点：（其中，左图上面四个部分都是16bits的）</p></blockquote><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03e2dc0c61a044ae93e73259f6689eb6~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>除此之外，UDP还支持一对一，一对多，多对一和多对多的交互通信。</p><p>UDP常用于一次性传输较少数据的网络应用，如DNS，SNMP等；</p><p>UDP也常用于多媒体应用，这对于实时性是有要求的；</p><p>UDP不保证可靠交付，但这不意味着应用对数据的要求是不可靠的，所有维护可靠性的工作可以由用户在应用层完成。</p><p>UDP是面向报文的，一次交付一个完整的报文，<strong>因此报文是UDP数据包处理的最小单位</strong>。</p><p>UDP的数据报包含两部分：UDP首部和用户数据。UDP的首部有8B，由四个字段组成，如上图所示↑，意义如下：</p><ul><li>源端口号：在需要对方回信时选用，不需要是全置零；</li><li>目的端口：这在终点交付报文时必须使用到；</li><li>长度：UDP数据报的长度，最小值是8（仅有首部）；</li><li>校验和：检测UDP数据报在传输中是否有错，有错就丢弃，该字段是可选的，当源主机不想计算校验和时置零。</li></ul><h3 id="UDP基于端口的分用："><a href="#UDP基于端口的分用：" class="headerlink" title="UDP基于端口的分用："></a>UDP基于端口的分用：</h3><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c307f8342f24f63ae382ab726389bab~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><hr><h2 id="UDP校验："><a href="#UDP校验：" class="headerlink" title="UDP校验："></a>UDP校验：</h2><p>在计算校验和时，要在UDP数据报之前增加12B的<strong>伪首部</strong>，</p><p><strong>只是</strong>用于在计算校验和时，临时添加在UDP数据报的前面，得到一个临时的UDP数据报。</p><p>校验和需要用这个临时的UDP数据报来计算。</p><p>UDP数据报的首部和伪首部示意图：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b50b49c1d4d45f6961f0dcc61dbb079~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h3 id="校验和的计算方法："><a href="#校验和的计算方法：" class="headerlink" title="校验和的计算方法："></a>校验和的计算方法：</h3><p>UDP校验和的计算方法与IP数据报首部校验和的计算方法类似，</p><p>但不同的是，IP数据报的校验和只检验IP数据报的首部，但是UDP的校验和则检查首部和数据部分。</p><blockquote><p>这部分的题目不多（也有可能是笔者见的比较少），具体的计算方法这里暂略。</p></blockquote><p>以下给出一个计算UDP校验和的例子：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da6f0e9bc34a4a6da50d5cf95ca872ed~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h3 id="校验和的目的："><a href="#校验和的目的：" class="headerlink" title="校验和的目的："></a>校验和的目的：</h3><p>快速检测在被传输报文段中的差错（如比特反转）。</p><p>虽然这种方法的校错能力不强，但是有点是简单快捷。</p><hr><h1 id="面向连接的传输-TCP："><a href="#面向连接的传输-TCP：" class="headerlink" title="面向连接的传输 - TCP："></a>面向连接的传输 - TCP：</h1><blockquote><p>TCP是在不可靠的IP层之上实现的可靠的数据传输协议，主要解决传输的可靠、有序、不丢失和不重复的问题。</p></blockquote><h2 id="TCP报文段："><a href="#TCP报文段：" class="headerlink" title="TCP报文段："></a>TCP报文段：</h2><p>报文段是什么：TCP传送的数据单元称为<strong>报文段</strong>。</p><p>TCP报文段用处：</p><ul><li>运载数据</li><li>建立连接、释放连接和应答</li></ul><blockquote><p>组成概述</p></blockquote><p>一个TCP报文段分为首部和数据两部分，整个TCP报文段作为IP数据报的数据部分封装在IP数据报中。</p><p>首部的前20B是固定的，TCP首部最短就为20B，后面有4N字节是根据需要而增加的选项，长度是4B的整数倍。</p><p>如图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/896c531313c448e2a3cb3a297a1a876d~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><blockquote><p>各个字段的意义：（这部分有点多，但是大概是很重要的部分）</p></blockquote><h3 id="源端口和目的端口："><a href="#源端口和目的端口：" class="headerlink" title="源端口和目的端口："></a>源端口和目的端口：</h3><p>各占2B的大小。</p><p>端口是传输层与应用层的服务接口，传输层的<strong>复用</strong>和<strong>分用</strong>功能都要通过端口实现。</p><h3 id="序号："><a href="#序号：" class="headerlink" title="序号："></a>序号：</h3><p>占4B的大小，范围是$[0, 2^{32}-1]$，共$2^{32}$个序号。</p><p>（有的地方也称之为序列号，反正都是Sequence Number）</p><p>TCP为每个报文段分配一个序列号，<strong>用于报文段的重组和丢失检测</strong>。</p><p>∵TCP是面向字节流的（即TCP传送时时逐个字节传送的）</p><p>∴TCP连接传送的字节流中的<strong>每个字节都按顺序编号</strong>，</p><p>序号字段的值指的是本报文段所发送的数据的第一个字节的序号（类似于首地址）。</p><h3 id="确认号："><a href="#确认号：" class="headerlink" title="确认号："></a>确认号：</h3><p>占4B的大小，是<strong>期望</strong>收到对方<strong>下一个</strong>报文段的<strong>第一个</strong>数据字节的序号。</p><p>若确认号为N则说明序号到N-1为止的所有数据都已正确收到。</p><h3 id="数据偏移（首部长度）："><a href="#数据偏移（首部长度）：" class="headerlink" title="数据偏移（首部长度）："></a>数据偏移（首部长度）：</h3><p>占4bits， 首部长度指出TCP报文段的<strong>数据起始处</strong>距离TCP报文段的<strong>起始处</strong>有多远。</p><p>∵数据偏移的<strong>单位</strong>是32bits，即4B；</p><p>又∵4位二进制数能表示的最大值为15；</p><p>∴TCP首部的最大长度为60B。</p><blockquote><p>这里如果没理解的话可以看如下解释：</p><p>首部长度字段占4比特,最大值为15。但是这个15不是直接表示15个字节,而是表示15 * 4 &#x3D; 60个字节。 这是因为TCP报文段采用32位定界长度的格式,所以所有的字段都必须是4字节对齐的。所以当首部长度字段的值是1时,代表首部4字节;当值为2时,代表首部8字节;以此类推,最大值为15时,代表首部15 * 4 &#x3D; 60字节。</p></blockquote><h3 id="保留："><a href="#保留：" class="headerlink" title="保留："></a>保留：</h3><p>占6bits，目前置零。</p><h3 id="紧急位URG："><a href="#紧急位URG：" class="headerlink" title="紧急位URG："></a>紧急位URG：</h3><p>当<code>URG == 1</code>时，表明<strong>紧急指针字段</strong>有效，它告诉系统此报文段中有紧急数据，应当<strong>尽快传送</strong>。</p><p>不过，需要注意的是，URG需要配合首部中紧急指针字段（后续会介绍）使用，</p><p>即，数据<strong>从第一个字节到紧急指针所指的字节就是紧急数据</strong>。</p><h3 id="确认位ACK："><a href="#确认位ACK：" class="headerlink" title="确认位ACK："></a>确认位ACK：</h3><p>当<code>ACK == 1</code>时，<strong>确认号字段</strong>才有效。</p><p>TCP规定，在连接建立之后，所有传送的报文段都必须把ACK置1。</p><h3 id="推送位PSH："><a href="#推送位PSH：" class="headerlink" title="推送位PSH："></a>推送位PSH：</h3><p>当接收方TCP收到<code>PSH == 1</code>的报文段，就会<strong>尽快地交付</strong>给接收应用进程，而不是等到整个缓存都填满了再向上交付。</p><h3 id="复位位RST："><a href="#复位位RST：" class="headerlink" title="复位位RST："></a>复位位RST：</h3><p>当<code>RST == 1</code>时，表明TCP连接中出现严重差错，必须<strong>释放连接</strong>，然后再重新建立连接。</p><h3 id="同步位SYN："><a href="#同步位SYN：" class="headerlink" title="同步位SYN："></a>同步位SYN：</h3><p>当<code>SYN == 1</code>时，表示这是一个<strong>连接请求</strong> or <strong>连接接受</strong>的报文。</p><p>当<code>SYN == 1 &amp;&amp; ACK == 0</code>时，说明这是一个连接请求报文（还没建立连接），</p><p>若对方同意建立连接，则在响应报文中为<code>SYN == 1 &amp;&amp; ACK == 1</code>。</p><h3 id="终止位FIN："><a href="#终止位FIN：" class="headerlink" title="终止位FIN："></a>终止位FIN：</h3><p>用来<strong>释放一个连接</strong>，当<code>FIN == 1</code>时，说明此报文段的发送方的数据已经发送完毕，并要求释放连接。</p><h3 id="窗口："><a href="#窗口：" class="headerlink" title="窗口："></a>窗口：</h3><p>占2B，范围为$[0, 2^{16}-1]$。</p><p>它指的是，现在允许对方发送的数据量，这是因为接收方的数据缓存空间是有限的，</p><p>这个窗口值可以作为接收方让发送方设置其发送窗口大小的依据。</p><h3 id="校验和："><a href="#校验和：" class="headerlink" title="校验和："></a>校验和：</h3><p>占2B，校验和字段检验的范围包括首部和数据两部分。</p><p>与UDP一样，在计算校验和时，要在TCP报文段的前面加上12B的伪首部，具体来说：</p><ul><li>将UDP伪首部的协议字段的17改成6</li><li>UDP长度字段改成TCP长度</li></ul><p>其他的都和UDP一样。</p><h3 id="紧急指针："><a href="#紧急指针：" class="headerlink" title="紧急指针："></a>紧急指针：</h3><p>占2B，如上文，指出本报文段中紧急数据共多少字节。</p><h3 id="选项："><a href="#选项：" class="headerlink" title="选项："></a>选项：</h3><p>长度可变。</p><p>TCP最初只规定了一种选项，即<strong>最大报文段长度Maximum Segment Size(MSS)</strong> ，</p><p>MSS是TCP报文段中的<strong>数据字段</strong>的最大长度。</p><h3 id="填充："><a href="#填充：" class="headerlink" title="填充："></a>填充：</h3><p>这是为了是整个首部长度是4B的整数倍而设置的。</p><hr><h2 id="TCP连接管理："><a href="#TCP连接管理：" class="headerlink" title="TCP连接管理："></a>TCP连接管理：</h2><h3 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h3><p>因为TCP是面向连接的协议，所以每个TCP连接都要经历三个阶段：</p><ol start="0"><li>建立连接</li><li>传输数据</li><li>释放连接</li></ol><p>在TCP连接的建立过程中，需要解决以下三个问题：</p><ol start="0"><li>要让每一方都能够确知对方的存在</li><li>要允许双方协商一些参数</li><li>能够对运输尸体资源进行分配</li></ol><p>TCP把连接作为最基本的抽象，每条TCP连接有两个端点，但这端点不是主机，不是IP地址，也不是应用进程，而是套接字。</p><p>TCP采用C-S模式。</p><h3 id="TCP三次握手："><a href="#TCP三次握手：" class="headerlink" title="TCP三次握手："></a>TCP三次握手：</h3><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35a2cf403af8456da067a5b4ce5d4b73~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>连接建立前，服务器进程处于LISTEN状态。</p><h4 id="第一步："><a href="#第一步：" class="headerlink" title="第一步："></a>第一步：</h4><p>如图所示，图上展示出的内容不再赘述，需要指出的是，SYN报文段不能携带数据，但要消耗掉一个序号；</p><p>此时，客户端进程进入SYN-SENT（同步已发送）状态。</p><h4 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h4><p>同意建立连接后，发回确认，并为该TCP连接分配缓存和变量；</p><p>确认报文段也不能携带数据，但是也要消耗掉一个序号；</p><p>此时，TCP服务器进程进入SYN-RCVD（同步收到）状态。</p><p>（与此同时，由于服务器端的资源是在第二次握手时分配的，而客户端则在第三次握手时才分配，这个空档期就可以用来对服务器进行SYN泛洪攻击）</p><h4 id="第三步："><a href="#第三步：" class="headerlink" title="第三步："></a>第三步：</h4><p>当客户端收到确认时，还要向服务器给出确认，并为该TCP连接分配缓存和变量；</p><p>该报文段<strong>可以携带数据</strong>，若不携带数据则不消耗序号；</p><p>此时，TCP客户端进程进入ESTABLISHED（已建立连接）状态。</p><h3 id="TCP四次挥手："><a href="#TCP四次挥手：" class="headerlink" title="TCP四次挥手："></a>TCP四次挥手：</h3><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/466c9c7df52544b6aab275f15faf709b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>与三次握手一样，如图所示，图上展示出的内容不再赘述；</p><p>需要指出的一点是，参与TCP连接的两个进程中的任意一方都可以主动终止该连接。</p><h4 id="第一步：-1"><a href="#第一步：-1" class="headerlink" title="第一步："></a>第一步：</h4><p>FIN报文段即使不携带任何数据，也会消耗一个序号；</p><p>此时，TCP客户进程进入FIN-WAIT-1（终止等待1）状态；</p><h4 id="第二步：-1"><a href="#第二步：-1" class="headerlink" title="第二步："></a>第二步：</h4><p>服务器收到连接释放报文段后，发出确认，进入CLOSE-WAIT（关闭等待）状态。</p><p>但我们要注意的是，TCP连接可以视为一个双有向边，即L-&gt;R关闭不影响R-&gt;L的数据传输。</p><h4 id="第三步：-1"><a href="#第三步：-1" class="headerlink" title="第三步："></a>第三步：</h4><p>如果服务器已经没有要向客户端发送的数据，就通知TCP释放连接，这时进入LAST-ACK（最后确认）状态。</p><blockquote><p>你真的要离开我了吗？</p></blockquote><h4 id="第四步："><a href="#第四步：" class="headerlink" title="第四步："></a>第四步：</h4><p>客户端收到连接释放报文段时，类似第二步地，也必须发出确认；</p><p>值得一提的是，这里有一个计时器，必须等待2MSL（最长报文段寿命）之后，客户端才能进入CLOSED（连接关闭）状态。</p><blockquote><p>选择题喜欢考察关于连接和释放的题目，ACK、SYN、FIN一定切记等于1。</p></blockquote><hr><h2 id="TCP流量控制："><a href="#TCP流量控制：" class="headerlink" title="TCP流量控制："></a>TCP流量控制：</h2><blockquote><p>下面以<strong>数据链路层</strong>的流量控制与可靠传输机制进行说明，在传输层也类似，亦会从中介绍。</p></blockquote><p>流量控制涉及对链路上的帧的<strong>发送速率的控制</strong>，以便接收方有足够的缓冲空间来接收每个帧。</p><p>流量控制的基本方法是<strong>由接收方控制发送方发送数据的速率</strong>。</p><p>流量控制的两种常见方式：</p><ul><li>停止-等待协议</li><li>滑动窗口协议</li></ul><h3 id="停止-等待-SW-流量控制基本原理："><a href="#停止-等待-SW-流量控制基本原理：" class="headerlink" title="停止-等待(SW)流量控制基本原理："></a>停止-等待(SW)流量控制基本原理：</h3><blockquote><p>一句话描述Stop-and-Wait：</p></blockquote><p>发送方每发送一帧，都要等待接收方的应答信号，之后<strong>才能</strong>发送下一帧；</p><p>接收方每接收一帧，都要反馈一个应答信号，表示可接收下一帧，若接收方不反馈应答信号，则发送方必须一直等待。</p><p>这样每次只发送一帧，然后陷入等待的这种过程，传输效率很低。</p><p><em>借用我初中年级主任的一句话：人生就是在这样你等我，我等他的过程中被浪费掉了。</em></p><h3 id="滑动窗口流量控制基本原理："><a href="#滑动窗口流量控制基本原理：" class="headerlink" title="滑动窗口流量控制基本原理："></a>滑动窗口流量控制基本原理：</h3><p>滑动窗口分为两个窗口：</p><ul><li>发送窗口：在任意时刻，发送方维持一组连续的，允许发送的帧的序号。</li><li>接收窗口：在任意时刻，接收方维持一组连续的，允许接收的帧的序号。</li></ul><p>$W_T$表示在还未收到对方确认信息的情况下，发送方最多还可以发送多少个数据帧，$W_R$的道理类似。</p><p>有如下例：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77f1eb94736a4430a726bd1d4380a846~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><blockquote><p>那么，窗口具体是如何滑动的呢？</p></blockquote><p>发送端每收到一个确认帧，发送窗口就向前滑动一个帧的位置；当发送窗口内没有可以发送的帧（即窗口内的帧全是已发送但未收到确认的帧）时，发送方就会停止发送，直到收到接收方发送的确认帧，使得窗口移动，移动之后，窗口内有了新的可以发送的帧，才开始继续发送。</p><p>接收端收到数据帧后，将窗口向前移动一个位置，并发回确认帧，若收到的数据帧落在接收窗口之外，则一律丢弃。</p><blockquote><p>好，那么滑动窗口有什么重要的特性吗？</p></blockquote><ol start="0"><li><p>只有接收窗口向前滑动，且接收方发送了确认帧时，发送窗口才有可能向前滑动（得收到确认帧）。</p></li><li><p>停止-等待协议、GBN协议和SR协议只在发送窗口与接收窗口的<strong>大小</strong>上有所差别：</p><ul><li>SW：发送窗口大小 &#x3D; 接收窗口大小 &#x3D; 1</li><li>GBN：发送窗口大小 &gt; 1，接收窗口大小 &#x3D; 1</li><li>SR：发送窗口大小 &gt; 1，接收窗口大小 &gt; 1</li></ul></li><li><p>只有接收窗口大小为1时，才能保证帧的<strong>有序接收</strong>。</p></li><li><p>数据链路层的滑动窗口大小在传输过程中时固定的，而传输层的则不是。</p></li></ol><h3 id="TCP如何使用窗口机制实现流量控制："><a href="#TCP如何使用窗口机制实现流量控制：" class="headerlink" title="TCP如何使用窗口机制实现流量控制："></a>TCP如何使用窗口机制实现流量控制：</h3><h4 id="接收窗口rwnd："><a href="#接收窗口rwnd：" class="headerlink" title="接收窗口rwnd："></a>接收窗口rwnd：</h4><p>在通信过程中，<strong>接收方根据自己接收缓存的大小，动态地调整发送方的窗口大小</strong>，</p><p>即调整TCP报文段首部中的<strong>窗口</strong>字段值来限制发送方向网络注入报文的速率。</p><h4 id="拥塞窗口cwnd："><a href="#拥塞窗口cwnd：" class="headerlink" title="拥塞窗口cwnd："></a>拥塞窗口cwnd：</h4><p>发送方根据其<strong>对当前网络的拥塞程度的估计而确定的窗口值</strong>，其大小与网络的带宽和时延密切相关。</p><blockquote><p>我们假设了接收方总是有足够大的缓存空间，故发送窗口的大小由网络的拥塞程度决定，故而等效为拥塞窗口。</p></blockquote><h3 id="传输层和数据链路层的流量控制的区别："><a href="#传输层和数据链路层的流量控制的区别：" class="headerlink" title="传输层和数据链路层的流量控制的区别："></a>传输层和数据链路层的流量控制的区别：</h3><p>传输层定义<strong>端到端</strong>用户之间的流量控制；</p><p>数据链路层定义<strong>两个中间的相邻节点</strong>的流量控制；</p><p>另外，数据链路层的滑动窗口协议和窗口大小不能动态变化，<strong>传输层的则可以动态变化</strong>。</p><hr><h2 id="TCP可靠传输："><a href="#TCP可靠传输：" class="headerlink" title="TCP可靠传输："></a>TCP可靠传输：</h2><h3 id="数据链路层的可靠传输："><a href="#数据链路层的可靠传输：" class="headerlink" title="数据链路层的可靠传输："></a>数据链路层的可靠传输：</h3><p>数据链路层的可靠传输使用<strong>确认</strong>和<strong>超时重传</strong>两种机制来完成。</p><ul><li><p>确认：</p><p>是一种无数据的控制帧，使得接收方可以让发送方知道哪些内容被正确接收；</p><p>有时为了图方便，会将确认捎带在一个回复帧中，称为<strong>捎带确认</strong>。</p></li><li><p>超时重传：</p><p>指发送方在发送某个数据帧后就开启一个计时器⏲，在一定的时间内，如果没有得到发送的数据帧的确认帧，那就重新发送该数据帧，直到发送成功为止。</p></li></ul><blockquote><p>那么问题来了，当数据帧传输到了以后出错了怎么办呢？答案是ARQ。</p></blockquote><p>自动重传请求（Automatic Repeat reQuest, ARQ）：</p><p>通过接收方请求发送方重传出错的数据帧，来恢复出错的帧。</p><p>传统自动重传请求分为三种：</p><ul><li>SW-ARQ</li><li>GBN-ARQ</li><li>SR-ARQ</li></ul><p>后两者是滑动窗口技术与请求重传技术的结合。</p><h3 id="传输层的可靠传输："><a href="#传输层的可靠传输：" class="headerlink" title="传输层的可靠传输："></a>传输层的可靠传输：</h3><p>TCP在IP层的不可靠的、尽力而为的服务的基础上建立了一种可靠数据传输服务。</p><p>TCP通过校验、序号、确认和重传等机制来达到目的，我们分别展开。</p><h4 id="校验："><a href="#校验：" class="headerlink" title="校验："></a>校验：</h4><p>与UDP一样，不再赘述。</p><h4 id="序号：-1"><a href="#序号：-1" class="headerlink" title="序号："></a>序号：</h4><blockquote><p>概括：</p></blockquote><p>TCP首部的<strong>序号</strong>字段，用来保证数据能够<strong>有序</strong>提交给应用层；</p><p>TCP把数据视为一个<strong>无结构但有序的字节流</strong>，序号建立在传送的字节流上，而非报文段。</p><blockquote><p>关于字节流的更多细节：</p></blockquote><p>TCP连接传送的数据流，把每个字节都编上序号，序号字段的值是指本报文段所发送的数据的第一个字节的序号。</p><p>有例图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d330bc54b0e4ffdbec326e0c6fffdb1~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>第一个报文段的序号是0，第二个报文段的序号是3，第三个是6，第四个是8。</p><h4 id="确认："><a href="#确认：" class="headerlink" title="确认："></a>确认：</h4><p>TCP首部的确认号是期望收到对方的下一个报文段的数据的第一个字节的序号，这想必不难理解。</p><p>此外，发送方的缓存区会缓存<strong>已经发送但是还没收到确认的报文段</strong>，以便在需要时重传。</p><p>很重要的一点是，TCP默认使用<strong>累计确认</strong>，即TCP只确认字节流中<strong>至第一个丢失字节为止的字节</strong>。</p><blockquote><p>有点不好理解？我们以一个例子说明：</p></blockquote><p>在上图中，例如，接收方B收到了发送方A发送的，包含字节<code>0~2</code>及字节6<del>7的报文段，但是，由于种种原因，接收方B并没有收到字节&#96;3</del>5&#96;的报文段，此时B仍在等待字节3及其后面的字节，因此<strong>B到A的下一个报文段将会把确认号字段置为3</strong>，以保证顺序。</p><h4 id="重传："><a href="#重传：" class="headerlink" title="重传："></a>重传：</h4><p>有两种情况会导致TCP对报文段进行重传：超时和冗余ACK。（这部分在后续的拥塞控制里面也有提及，故简要叙述）</p><blockquote><p>超时：</p></blockquote><p>TCP每发送一个报文段，就对这个报文段设置一次计时器。</p><p>当计时器设置的<strong>重传时间到期但还未收到确认时</strong>，就会重传这一报文段。</p><p>这其中有一种自适应的算法来确认加权平均往返时间$RTT_S$，由于这方面的考题不多，故算法不做介绍。</p><blockquote><p>冗余ACK</p></blockquote><p>TCP规定当发送方收到对同一个报文段的<strong>3个冗余ACK</strong>时，就可以认为跟在这个被确认报文段之后的报文段已经丢失。</p><p>简单举个例子：当A收到对于1号报文段的3个冗余ACK时，就可以认为2号报文段已经丢失，这时候，A就可以对2号报文段执行重传，这部分在后续的拥塞控制里的快重传有介绍，这里点到为止。</p><hr><h2 id="TCP拥塞控制："><a href="#TCP拥塞控制：" class="headerlink" title="TCP拥塞控制："></a>TCP拥塞控制：</h2><p>拥塞控制的意义：</p><p>防止过多的数据注入网络，保证网络中的路由器或链路<strong>不至于过载</strong>。</p><h3 id="关于拥塞："><a href="#关于拥塞：" class="headerlink" title="关于拥塞："></a>关于拥塞：</h3><p>当拥塞出现的时候，端点实际上并不了解拥塞发生的细节，对于通信连接的端点来说，只能”观察”到其现象，即通信时延的增加。</p><p>我们考虑以下这个例子：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/292ee130595e4c68ae1c46a0b17cf64e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><hr><h3 id="控制与流量控制的区别："><a href="#控制与流量控制的区别：" class="headerlink" title="控制与流量控制的区别："></a>控制与流量控制的区别：</h3><p>拥塞控制：<strong>全局性</strong>的过程，让网络能够承受现有的网络负荷，涉及所有的主机、路由器以及与降低网络传输性能有关的所有因素。</p><p>流量控制：<strong>局部性</strong>的过程，是端到端的问题，与拥塞控制一样，是<strong>通过控制发送方发送数据的速率来达到控制效果</strong>。</p><hr><h3 id="两个窗口："><a href="#两个窗口：" class="headerlink" title="两个窗口："></a>两个窗口：</h3><p>TCP为什么要有两个窗口呢？</p><p>事实上，这是因为发送方在确定发送报文段的速率的时候，既要考虑接收方的接收能力，又要从全局考虑不要使网络发生拥塞。</p><ol start="0"><li><p>接收窗口rwnd：</p><p><strong>接收方</strong>根据<strong>目前接收缓存大小</strong>所许诺的最新窗口值，反映<strong>接收方的容量</strong>。</p><p>由接收方根据其放在TCP报文的首部的窗口字段，通知对方。</p></li><li><p>拥塞窗口cwnd：</p><p><strong>发送方</strong>根据自己估算的<strong>网络拥塞程度</strong>而设置的窗口值，反映<strong>网络的当前容量</strong>。</p><p>只要网络未出现拥塞，拥塞窗口就可以再大一些，以便把更多的分组发送出去，反之，一旦出现网络拥塞，拥塞窗口就会减小一些，以限制注入网络的分组数。</p></li></ol><p>这两者有一个上限：</p><p>发送窗口的上限值 &#x3D; $min[rwnd, cwnd]$</p><p>然而，接收窗口的大小是根据TCP报文首部的窗口字段通知发送方的，但是发送方该如何维护拥塞窗口呢？这时候就需要慢开始和拥塞避免算法了，请看下文。</p><blockquote><p>当然，我们上文中提到，上述条件成立的前提是，我们假设了接收方总是有足够大的缓存空间；</p><p>基于此，发送窗口的大小由网络的拥塞程度决定，故而等效为拥塞窗口。</p></blockquote><hr><h3 id="四种拥塞控制的算法："><a href="#四种拥塞控制的算法：" class="headerlink" title="四种拥塞控制的算法："></a>四种拥塞控制的算法：</h3><p>慢开始、拥塞避免、快重传、快恢复。</p><p>这四种算法是同时运用的。</p><blockquote><p>一句话概括：</p></blockquote><p>在TCP连接建立和网络出现超时的时候，采用慢开始和拥塞避免算法；</p><p>当发送方接收到冗余ACK时，采用快重传和快恢复算法。</p><h4 id="慢开始算法："><a href="#慢开始算法：" class="headerlink" title="慢开始算法："></a>慢开始算法：</h4><blockquote><p>一句话解释算法：</p></blockquote><p>在TCP刚刚连接好并开始发送TCP报文段时，先令拥塞窗口cwnd &#x3D; 1，即一个最大报文段长度MSS；</p><p>每当接收到一个对新报文段的确认后，cwnd++，即增大一个MSS；</p><p>这样逐步增大发送方的cwnd，可以使分组注入网络的速率更加合理。</p><blockquote><p>慢开始的慢到底是什么意思</p></blockquote><p>其实，这个慢的意思是一开始先不着急用很大的窗口来发送报文段，初始时，cwnd &#x3D; 1的效果类似于”试探”。</p><p>这就是慢的含义——花费一点时间来慢慢的进入正题。</p><p>使用慢开始算法后，每经过一个传输轮次RTT，cwnd就会加倍，也就是说是指数规律增长，这样一来，慢开始就会一直把cwnd增大到一个规定的<strong>慢开始门限ssthresh（阈值）</strong> ，然后改用拥塞避免算法。</p><blockquote><p>所谓RTT，就是往返时延Round-Trip Time</p><p>是指网络通信中一个数据包从发送端发送到接收端，再从接收端返回到发送端所需的时间。</p><p>在计算机网络中，往返时延是一个重要的网络性能指标，可以反映出网络的响应速度和稳定性。当我们在浏览网页、发送邮件、进行在线游戏等网络操作时，RTT 往返时延会直接影响我们的体验。较低的 RTT 往返时延可以提高网络响应速度和传输效率，较高的 RTT 往返时延则会导致网络传输变慢、卡顿、延迟等问题。</p></blockquote><h4 id="拥塞避免算法："><a href="#拥塞避免算法：" class="headerlink" title="拥塞避免算法："></a>拥塞避免算法：</h4><blockquote><p>一句话解释算法：</p></blockquote><p>每经过一个RTT，就让cwnd++，而不是加倍，使得cwnd线性缓慢增长。</p><p>据此，我们可以知道：</p><ul><li>if (cwnd &lt; ssthresh): use 慢开始算法</li><li>if (cwnd &gt; ssthresh): use 拥塞避免算法</li><li>if (cwnd &#x3D;&#x3D; ssthresh): use 慢开始算法 or 拥塞避免算法（一般来说是用拥塞避免算法）</li></ul><h4 id="网络拥塞的处理过程："><a href="#网络拥塞的处理过程：" class="headerlink" title="网络拥塞的处理过程："></a>网络拥塞的处理过程：</h4><p>无论是哪个阶段，只要发送方判断网络出现拥塞（未按时收到确认ACK），</p><p>就要把慢开始门限ssthresh设置为<strong>出现拥塞时的发送方的cwnd值的一半</strong>（但不能小于2），</p><p>然后，把cwnd重新设置为1，继续执行慢开始算法。</p><blockquote><p>特别地，在慢开始阶段，若2cwnd&gt;ssthresh，则令下一个RTT后的cwnd&#x3D;ssthresh而不是2cwnd。</p></blockquote><p>如例图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0a5472f16c14e7eb4891778a84daeab~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>然而，需要注意的是，这两种算法都不能完全避免拥塞，只是可以缓解拥塞。</p><blockquote><p>所谓ACK，是指确认（Acknowledgment）的缩写，它是一种用于确认收到数据的信号。在TCP&#x2F;IP协议中，当一个计算机接收到另一个计算机发送的数据包时，会向发送方发送一个ACK信号，表示已经成功接收到数据。这个ACK信号是由接收方发送给发送方的，以告诉发送方数据已经被正确接收。在TCP协议中，发送方会等待一个ACK信号来确认数据已经被成功接收，如果在一定时间内没有收到ACK信号，就会认为数据包丢失或损坏，然后重新发送数据。因此，ACK在计算机网络中非常重要，它能够确保数据的可靠传输。</p></blockquote><hr><p>快重传和快恢复算法是对慢开始和拥塞避免算法的改进。</p><h4 id="快重传："><a href="#快重传：" class="headerlink" title="快重传："></a>快重传：</h4><blockquote><p>一句话解释算法：</p></blockquote><p>我们已经知道的是，TCP可靠传输机制中，利用了快重传技术，通过冗余ACK来检测丢包的发生。</p><p>在这里，我们利用冗余ACK来检测网络的拥塞，其实是同一套道理（因为丢了包不就意味着网络可能出现了拥塞嘛）。</p><p>快重传并不是取消了重传计时器，而是在某些情况下更早地重传丢失的报文段。</p><p>当发送方<strong>连续收到三个重复的ACK</strong>时，<strong>直接重传</strong>对方尚未接收到的报文段，而<strong>不必等待</strong>那个报文段设置的重传计时器超时。</p><h4 id="快恢复："><a href="#快恢复：" class="headerlink" title="快恢复："></a>快恢复：</h4><blockquote><p>一句话解释算法：</p></blockquote><p>当发送方连续收到三个冗余ACK时，把慢开始门限ssthresh设置为此时cwnd的一半，这是为了预防网络发生拥塞。</p><p>这一过程与慢开始有点类似，但是不同的是，快恢复会把cwnd值设置为慢开始门限ssthresh改变后的数值，而不是1，然后直接开始进行拥塞避免算法。如下图例子所示：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db292a83e0ce429083e80b39bc2a520d~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><hr><blockquote><p>后续，笔者会给出章节相关的重难点和做题经验，敬请期待。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;em&gt;Computer Networking A Top-Down Approach Learning Note Part 3&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;本文是笔者初学计算机网络的笔记和一些心得，难免会有部分疏漏和错误</summary>
      
    
    
    
    <category term="408" scheme="https://conqueror712.github.io/categories/408/"/>
    
    
  </entry>
  
  <entry>
    <title>Neo4j - Ep3丨学习记录</title>
    <link href="https://conqueror712.github.io/post/Neo4j-3.html"/>
    <id>https://conqueror712.github.io/post/Neo4j-3.html</id>
    <published>2023-04-09T05:21:28.000Z</published>
    <updated>2023-04-16T13:56:16.186Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><blockquote><p>Abstract：本文的主要内容是<strong>图形数据建模、领域知识对建模的重要性以及图数据模型和实例模型之间的区别</strong>。</p></blockquote><p>笔者近日在学习有关知识图谱Knowledge Graph的相关内容。</p><p>Neo4j是项目所需的一款功能强大的应用，特此来学习之，并记录于本文。</p><p>笔者是AI领域的小白，作为初学者，文章中难免会有出错或者不恰当的部分，烦请读者朋友们指出（在以下任意平台）。</p><blockquote><p>个人博客：<a href="https://conqueror712.github.io/">https://conqueror712.github.io/</a></p><p>知乎：<a href="https://www.zhihu.com/people/soeur712/posts">https://www.zhihu.com/people/soeur712/posts</a></p><p>Bilibili：<a href="https://space.bilibili.com/57089326">https://space.bilibili.com/57089326</a></p><p>掘金：<a href="https://juejin.cn/user/1297878069809725/posts">https://juejin.cn/user/1297878069809725/posts</a></p></blockquote><p><strong>注意：本文不是教程，只是个人学习的记录和心得，可能会对你有帮助，建议配合官方文档一起学习！</strong></p><p>官方文档链接：<a href="https://graphacademy.neo4j.com/courses/modeling-fundamentals/1-getting-started/">https://graphacademy.neo4j.com/courses/modeling-fundamentals/1-getting-started/</a></p><p>再注：原文是英文，若有较好的英文阅读能力可以直接读，本文是对原文中重要的内容进行了翻译，以及加上了笔者自己的理解。</p><hr><h1 id="初窥门径："><a href="#初窥门径：" class="headerlink" title="初窥门径："></a>初窥门径：</h1><h2 id="什么是图形数据建模："><a href="#什么是图形数据建模：" class="headerlink" title="什么是图形数据建模："></a>什么是图形数据建模：</h2><p>首先我们要知道的是Neo4j中，<strong>图的组成部分</strong>有哪些，具体来说有四个组件，分别是：</p><ul><li>节点</li><li>标签</li><li>关系</li><li>属性</li></ul><p>而<strong>创建图形数据模型</strong>的步骤又如下所示：</p><ol><li>了解领域并为应用程序定义特定用例（问题）。</li><li>开发初始图形数据模型：<ul><li>对节点（实体）建模。</li><li>对节点之间的关系建模。</li></ul></li><li>针对初始数据模型测试用例。</li><li>使用 Cypher 使用测试数据创建图形（实例模型）。</li><li>测试用例，包括针对图表的性能。</li><li>由于关键用例的变化或性能原因，重构（改进）图形数据模型。</li><li>在图上实施重构并使用 Cypher 重新测试。</li></ol><p>由此可见，图形数据建模事实上是一个迭代的过程，有些读者可能会觉得那么频繁的重构是很麻烦的，不过事实上，与RDBMS相比，利用Cypher语言构建的Neo4j图形修改起来是十分灵活和方便的。</p><hr><h2 id="模型的目的："><a href="#模型的目的：" class="headerlink" title="模型的目的："></a>模型的目的：</h2><p>在为应用程序执行图形数据建模过程时，至少需要两种类型的模型：</p><ul><li>数据模型</li><li>实例模型</li></ul><blockquote><p>听起来名字差不多？那么，这两种模型分别都是什么呢？</p></blockquote><p>事实上：</p><ul><li>数据模型描述的是图形的<strong>标签、关系和属性</strong>。</li><li>实例模型是用来测试模型用例的，这是图形数据建模的重要一环。</li></ul><p>这是一个数据模型的例子：</p><p><img src="https://cdnjson.com/images/2023/04/09/image.png" alt="avatar"></p><p>而这是一个实例模型的例子：</p><img src="https://cdnjson.com/images/2023/04/09/image77db515ea60ba928.png" alt="avatar" style="zoom:50%;" /><hr><h1 id="建模节点："><a href="#建模节点：" class="headerlink" title="建模节点："></a>建模节点：</h1><p>这一部分主要学习的是：</p><ul><li>从您的用例中识别实体。</li><li>在图中创建节点以支持数据模型。</li></ul><hr><h2 id="定义标签："><a href="#定义标签：" class="headerlink" title="定义标签："></a>定义标签：</h2><p>实体是应用程序用例中的主导名词，比如：<strong>食谱</strong>中主要使用了哪些<strong>成分</strong>？</p><p>加粗的<strong>名词</strong>就是所谓的实体。</p><p>而这些实体就是在图中的节点，我们定义标签也是用名词来定义，也就是节点的”名字”。</p><h2 id="定义属性："><a href="#定义属性：" class="headerlink" title="定义属性："></a>定义属性：</h2><p>节点不仅有名字（标签），还要有属性，属性是用来唯一标识一个节点的，还可以回答应用程序用例的具体细节和返回数据。</p><p>具体问题需要具体分析。</p><hr><h1 id="建模关系："><a href="#建模关系：" class="headerlink" title="建模关系："></a>建模关系：</h1><p>这一部分主要学习的是：</p><ul><li>从用例中识别关系。</li><li>在图中创建关系以支持数据模型。</li></ul><p>首先我们要知道的是，关系是实体之间的联系，一般来说是<strong>动词</strong>。</p><p>比如：食谱中主要<strong>使用了</strong>哪些成分？</p><p>虽然这看上去不是一件很难的事情，但是它们的微观和宏观设计可以说是<strong>图形性能</strong>中最关键的因素。</p><h2 id="命名关系："><a href="#命名关系：" class="headerlink" title="命名关系："></a>命名关系：</h2><p>如上例，”使用了”就是一种命名，不能随便命名，以防混淆。</p><h2 id="关系方向："><a href="#关系方向：" class="headerlink" title="关系方向："></a>关系方向：</h2><p>在Neo4j中创建关系的时候，一定是一条有向的边，倘若真的需要无向边，那就正反都创建就好了。</p><p>值得一提的是，关系可以是两个节点之间的，也可以是一个节点的自环。</p><h2 id="Fanout："><a href="#Fanout：" class="headerlink" title="Fanout："></a>Fanout：</h2><p>直接翻译成扇出不知道合不合适，我们就暂时先用Fanout了。</p><p>在这里，我们的实体（Person、Residence）不是表示为单个节点，而是表示为网络或链接节点。</p><img src="https://cdnjson.com/images/2023/04/14/image067c2e266ab99c52.png" alt="avatar" style="zoom:50%;" /><h2 id="关系属性："><a href="#关系属性：" class="headerlink" title="关系属性："></a>关系属性：</h2><p>在这里我们看到我们在MARRIED关系上有一个日期属性来进一步描述 Michael 和 Sarah 之间的关系。</p><p>此外，我们在WORKS_AT关系上有一个角色属性来描述迈克尔在 Graph Inc. 工作时拥有或拥有的角色。</p><img src="https://cdnjson.com/images/2023/04/14/image0a34e05dcbb509f4.png" alt="avatar" style="zoom: 50%;" /><hr><h1 id="测试模型："><a href="#测试模型：" class="headerlink" title="测试模型："></a>测试模型：</h1><p>在本模块中，我们将测试图是否可以用于测试模型的用例。</p><p>简单来说，在测试用例期间，我们需要做的是：</p><ul><li>向图中添加更多数据以测试可扩展性。</li><li>测试和修改用于测试用例的任何 Cypher 代码。</li><li>如果无法回答用例，则重构数据模型。</li></ul><hr><h1 id="重构图："><a href="#重构图：" class="headerlink" title="重构图："></a>重构图：</h1><p>在本模块中，我们将学习：</p><ul><li>为什么我们重构一个图数据模型和图。</li><li>向数据模型添加标签。</li></ul><h2 id="为什么重构："><a href="#为什么重构：" class="headerlink" title="为什么重构："></a>为什么重构：</h2><p>重构是<strong>更改数据模型和图形</strong>的过程。</p><p>重构的三个原因：</p><ul><li>建模的图表并没有回答所有的用例。</li><li>出现了一个新的用例，您必须在数据模型中考虑该用例。</li><li>用例的 Cypher 表现不佳，尤其是当图形缩放时。</li></ul><h2 id="重构步骤："><a href="#重构步骤：" class="headerlink" title="重构步骤："></a>重构步骤：</h2><p>要重构图形数据模型和图形，您必须：</p><ol><li>设计新的数据模型。</li><li>编写 Cypher 代码来转换现有图形以实现新的数据模型。</li><li>重新测试所有用例，可能使用更新的 Cypher 代码。</li></ol><blockquote><p>具体内容待补充</p></blockquote><hr><h1 id="消除重复数据："><a href="#消除重复数据：" class="headerlink" title="消除重复数据："></a>消除重复数据：</h1><h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h2><p>我们应该注意避免在图表中重复数据。</p><p>有些数据库需要一种<strong>非规范化形式</strong>来提高一组查询的速度，而图形数据库并不总是这样。</p><p>去重数据给你带来了额外的好处，允许你通过一个节点进行查询。</p><p>例如，找到购买了特定产品的其他客户，或者根据其他用户的评分找到类似的电影。</p><p>此外，在图中复制数据会增加图的大小以及查询可能需要检索的数据量。</p><blockquote><p>具体内容待补充</p></blockquote><hr><h1 id="特殊化关系："><a href="#特殊化关系：" class="headerlink" title="特殊化关系："></a>特殊化关系：</h1><h2 id="为什么要重构图表以特殊化关系："><a href="#为什么要重构图表以特殊化关系：" class="headerlink" title="为什么要重构图表以特殊化关系："></a>为什么要重构图表以特殊化关系：</h2><ul><li>减少需要检索的节点数。</li><li>提高查询性能。</li></ul><p>特殊关系允许您遵循特定的关系类型并避免在单个查询中遍历图的大部分。</p><h2 id="如何建立动态关系："><a href="#如何建立动态关系：" class="headerlink" title="如何建立动态关系："></a>如何建立动态关系：</h2><p>使用Cypher中的APOC库，这是图形引擎在运行时可用的库中的专用过程。</p><blockquote><p>具体内容待补充</p></blockquote><hr><h1 id="中间节点："><a href="#中间节点：" class="headerlink" title="中间节点："></a>中间节点：</h1><p>有时，我们会发现需要将更多数据连接到关系的情况，而不是可以在属性中完全捕获的数据。</p><p>换句话说，您需要连接两个以上节点的关系。</p><p>数学通过<strong>超边</strong>的概念允许这样做。这在 Neo4j 中是不可能的，但我们也有办法，解决方案是创建中间节点。</p><h2 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h2><ul><li>在单个上下文中连接两个以上的节点。<ul><li>超边（n 元关系）</li></ul></li><li>将某事与一段关系联系起来。</li><li>在实体之间共享图中的数据。</li></ul><blockquote><p>具体内容待补充</p></blockquote><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Abstract：本文的主要内容是&lt;strong&gt;图形数据建模、领域知识对建模的重要性以及图数据模型和实例</summary>
      
    
    
    
    <category term="AI" scheme="https://conqueror712.github.io/categories/AI/"/>
    
    
  </entry>
  
  <entry>
    <title>深度学习 - Ep4 - 卷积神经网络丨学习记录</title>
    <link href="https://conqueror712.github.io/post/DL-CNN.html"/>
    <id>https://conqueror712.github.io/post/DL-CNN.html</id>
    <published>2023-04-08T11:48:55.000Z</published>
    <updated>2023-04-23T03:07:54.906Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>本篇内容记录笔者学习深度学习的学习过程，如果你有任何想询问的问题，欢迎在以下任何平台提问！</p><p>参考书：《动手学深度学习》</p><blockquote><p>个人博客：<a href="https://conqueror712.github.io/">https://conqueror712.github.io/</a></p><p>知乎：<a href="https://www.zhihu.com/people/soeur712/posts">https://www.zhihu.com/people/soeur712/posts</a></p><p>Bilibili：<a href="https://space.bilibili.com/57089326">https://space.bilibili.com/57089326</a></p><p>掘金：<a href="https://juejin.cn/user/1297878069809725/posts">https://juejin.cn/user/1297878069809725/posts</a></p></blockquote><hr><h1 id="从全连接层到卷积："><a href="#从全连接层到卷积：" class="headerlink" title="从全连接层到卷积："></a>从全连接层到卷积：</h1><p><img src="https://cdnjson.com/images/2023/04/08/image713e2a24b5495899.png" alt="avatar"></p><ul><li>图像的平移不变性使我们以相同的方式处理局部图像，而不在乎它的位置。</li><li>局部性意味着计算相应的隐藏表示只需一小部分局部图像像素。</li><li>在图像处理中，卷积层通常比全连接层需要更少的参数，但依旧获得高效用的模型。</li><li>卷积神经网络（CNN）是一类特殊的神经网络，它可以包含多个卷积层。</li><li>多个输入和输出通道使模型在每个空间位置可以获取图像的多方面特征。</li></ul><hr><h1 id="图像卷积："><a href="#图像卷积：" class="headerlink" title="图像卷积："></a>图像卷积：</h1><h2 id="互相关运算："><a href="#互相关运算：" class="headerlink" title="互相关运算："></a>互相关运算：</h2><p>卷积神经网络的设计更多的用于图像数据，</p><p>而严格来说，”卷积”这个词用的有点问题，事实上，它所做的运算是<strong>互相关运算</strong>而非卷积运算。</p><p>在卷积层中，<strong>输入张量和核张量通过互相关运算产生输出张量</strong>。</p><p>我们以一个例子来说明，话不多说，上图：</p><p><img src="https://cdnjson.com/images/2023/04/19/image.png" alt="avatar"></p><hr><h2 id="卷积层和卷积核的区别："><a href="#卷积层和卷积核的区别：" class="headerlink" title="卷积层和卷积核的区别："></a>卷积层和卷积核的区别：</h2><ul><li>卷积层是深度神经网络中的一种基本层级结构，其目的是从输入数据中提取有用的特征。</li><li><strong>卷积层由多个卷积核组成</strong>，每个卷积核用于对输入数据进行卷积操作，从而生成输出特征图。</li></ul><p>卷积核是卷积层中的一个重要参数，它定义了卷积操作的形式和卷积层的特征提取能力。</p><p>卷积核通常是一个小的、固定大小的矩阵，可以视为卷积运算中的滤波器。</p><p>卷积核中的每个元素都具有一定的权重，用于控制对输入数据中不同位置的响应。</p><p>在具体操作中，卷积层对输入和卷积核权重进行互相关运算，并在添加标量偏置之后产生输出。</p><hr><h2 id="图像中目标的边缘检测："><a href="#图像中目标的边缘检测：" class="headerlink" title="图像中目标的边缘检测："></a>图像中目标的边缘检测：</h2><p>通过找到像素变化的位置，来检测图像中不同颜色的边缘。</p><p>举个例子（例子来源于《动手学深度学习》）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X = torch.ones((<span class="number">6</span>, <span class="number">8</span>))</span><br><span class="line">X[:, <span class="number">2</span>:<span class="number">6</span>] = <span class="number">0</span></span><br><span class="line">X</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tensor([[<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>]])</span><br></pre></td></tr></table></figure><p>我们构造一个高度为1、宽度为2的卷积核<code>K</code>。</p><p>当进行互相关运算时，<strong>如果水平相邻的两元素相同，则输出为零，否则输出为非零。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">K = torch.tensor([[<span class="number">1.0</span>, -<span class="number">1.0</span>]])</span><br></pre></td></tr></table></figure><p>现在，我们对参数<code>X</code>（输入）和<code>K</code>（卷积核）执行互相关运算。 如下所示，输出<code>Y</code>中的1代表从白色到黑色的边缘，-1代表从黑色到白色的边缘，其他情况的输出为0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Y = corr2d(X, K)</span><br><span class="line">Y</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tensor([[ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>, -<span class="number">1.</span>,  <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>, -<span class="number">1.</span>,  <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>, -<span class="number">1.</span>,  <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>, -<span class="number">1.</span>,  <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>, -<span class="number">1.</span>,  <span class="number">0.</span>],</span><br><span class="line">        [ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>, -<span class="number">1.</span>,  <span class="number">0.</span>]])</span><br></pre></td></tr></table></figure><p>现在我们将输入的二维图像转置，再进行如上的互相关运算。</p><p>其输出如下，之前检测到的垂直边缘消失了。 不出所料，这个卷积核<code>K</code><strong>只可以检测垂直边缘，无法检测水平边缘</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">corr2d(X.t(), K)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tensor([[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">        [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">        [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">        [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">        [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">        [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">        [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">        [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>]])</span><br></pre></td></tr></table></figure><hr><h1 id="学习卷积核："><a href="#学习卷积核：" class="headerlink" title="学习卷积核："></a>学习卷积核：</h1><p>对于更复杂数值的卷积核或者连续的卷积层来说，我们就不太可能去手动设计滤波器了；</p><p>这时候就需要通过”学习”来构造适合的卷积核了。</p><p>先构造一个卷积层，并将其卷积核初始化为随机张量。</p><p>接下来，在每次迭代中，我们比较<code>Y</code>与卷积层输出的平方误差，然后计算梯度来更新卷积核。</p><p>一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构造一个二维卷积层，它具有1个输出通道和形状为（1，2）的卷积核</span></span><br><span class="line">conv2d = nn.Conv2d(<span class="number">1</span>,<span class="number">1</span>, kernel_size=(<span class="number">1</span>, <span class="number">2</span>), bias=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个二维卷积层使用四维输入和输出格式（批量大小、通道、高度、宽度），</span></span><br><span class="line"><span class="comment"># 其中批量大小和通道数都为1</span></span><br><span class="line">X = X.reshape((<span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">8</span>))</span><br><span class="line">Y = Y.reshape((<span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">7</span>))</span><br><span class="line">lr = <span class="number">3e-2</span>  <span class="comment"># 学习率</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    Y_hat = conv2d(X)</span><br><span class="line">    l = (Y_hat - Y) ** <span class="number">2</span></span><br><span class="line">    conv2d.zero_grad()</span><br><span class="line">    l.<span class="built_in">sum</span>().backward()</span><br><span class="line">    <span class="comment"># 迭代卷积核</span></span><br><span class="line">    conv2d.weight.data[:] -= lr * conv2d.weight.grad</span><br><span class="line">    <span class="keyword">if</span> (i + <span class="number">1</span>) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;epoch <span class="subst">&#123;i+<span class="number">1</span>&#125;</span>, loss <span class="subst">&#123;l.<span class="built_in">sum</span>():<span class="number">.3</span>f&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><hr><ul><li>二维卷积层的核心计算是二维互相关运算。最简单的形式是，对二维输入数据和卷积核执行互相关操作，然后添加一个偏置。</li><li>我们可以设计一个卷积核来检测图像的边缘。</li><li>我们可以从数据中学习卷积核的参数。</li><li>学习卷积核时，无论用严格卷积运算或互相关运算，卷积层的输出不会受太大影响。</li><li>当需要检测输入特征中更广区域时，我们可以构建一个更深的卷积网络。</li></ul><hr><h1 id="填充和步幅："><a href="#填充和步幅：" class="headerlink" title="填充和步幅："></a>填充和步幅：</h1><h2 id="填充："><a href="#填充：" class="headerlink" title="填充："></a>填充：</h2><p>在应用多层卷积时，我们常常丢失边缘像素。</p><p>由于我们通常使用小卷积核，因此对于任何单个卷积，我们可能只会丢失几个像素。</p><p>但随着我们应用许多连续卷积层，累积丢失的像素数就多了。</p><p>解决这个问题的简单方法即为<strong>填充（padding）</strong>：在输入图像的边界填充元素（通常填充元素是0）。</p><p>如下例，我们将3×3输入填充到5×5，那么它的输出就增加为4×4：</p><p><img src="https://cdnjson.com/images/2023/04/19/imagecd0d3843ecbae19a.png" alt="avatar"></p><hr><h2 id="步幅："><a href="#步幅：" class="headerlink" title="步幅："></a>步幅：</h2><p>在计算互相关时，卷积窗口从输入张量的左上角开始，向下、向右滑动。</p><p>在前面的例子中，我们默认每次滑动一个元素。</p><p>但是，有时候为了高效计算或是缩减采样次数，卷积窗口可以跳过中间位置，每次滑动多个元素。</p><p>我们将每次滑动元素的数量称为<strong>步幅（stride）</strong>。</p><p><img src="https://cdnjson.com/images/2023/04/19/image698e0910fe9a35f9.png" alt="avatar"></p><hr><ul><li>填充可以增加输出的高度和宽度。这常用来使输出与输入具有相同的高和宽。</li><li>步幅可以减小输出的高和宽，例如输出的高和宽仅为输入的高和宽的$1&#x2F;n$（n是一个大于1的整数）。</li><li>填充和步幅可用于有效地调整数据的维度。</li></ul><hr><h1 id="多输入多输出通道："><a href="#多输入多输出通道：" class="headerlink" title="多输入多输出通道："></a>多输入多输出通道：</h1><h2 id="多输入通道："><a href="#多输入通道：" class="headerlink" title="多输入通道："></a>多输入通道：</h2><p>当输入包含多个通道时，需要构造一个与输入数据具有相同输入通道数的卷积核，以便与输入数据进行互相关运算。</p><p><img src="https://cdnjson.com/images/2023/04/19/image2d706cc4ae16c640.png" alt="avatar"></p><hr><h2 id="多输出通道："><a href="#多输出通道：" class="headerlink" title="多输出通道："></a>多输出通道：</h2><p>在最流行的神经网络架构中，随着神经网络层数的加深，我们常会增加输出通道的维数，通过减少空间分辨率以获得更大的通道深度。</p><p>直观地说，我们可以将每个通道看作对不同特征的响应。</p><p>而现实可能更为复杂一些，因为每个通道不是独立学习的，而是为了共同使用而优化的。</p><p>因此，多输出通道并不仅是学习多个单通道的检测器。</p><hr><ul><li>多输入多输出通道可以用来扩展卷积层的模型。</li><li>当以每像素为基础应用时，1×1卷积层相当于<strong>全连接层</strong>。</li><li>1×1卷积层通常用于<strong>调整网络层的通道数量</strong>和<strong>控制模型复杂性</strong>。</li></ul><hr><h1 id="池化层："><a href="#池化层：" class="headerlink" title="池化层："></a>池化层：</h1><h2 id="最大池化层与平均池化层："><a href="#最大池化层与平均池化层：" class="headerlink" title="最大池化层与平均池化层："></a>最大池化层与平均池化层：</h2><p>池化层，也称汇聚层。</p><p>池化层的两个目的：</p><ul><li>降低卷积层对位置的敏感性；</li><li>降低对空间降采样表示的敏感性。</li></ul><p>与卷积层类似，池化层运算符由一个固定形状的窗口组成，该窗口根据其步幅大小在输入的所有区域上滑动，为固定形状窗口遍历的每个位置计算一个输出。</p><p>然而，不同于卷积层中的输入与卷积核之间的互相关计算，池化层不包含参数。</p><p>相反，池运算是确定性的，我们通常计算池化窗口中所有元素的最大值或平均值。</p><p>这些操作分别称为<em>最大池化层</em>（maximum pooling）和<em>平均池化层</em>（average pooling）。</p><p><img src="https://img.picgo.net/2023/04/19/image01b296e555bb4e42.png" alt="avatar"></p><hr><h2 id="填充与步幅："><a href="#填充与步幅：" class="headerlink" title="填充与步幅："></a>填充与步幅：</h2><p>类似地，与卷积层一样，池化层也可以改变输出形状，通过改变填充和步幅。</p><hr><h2 id="多个通道："><a href="#多个通道：" class="headerlink" title="多个通道："></a>多个通道：</h2><p>在处理多通道输入数据时，汇聚层在每个输入通道上单独运算，而不是像卷积层一样在通道上对输入进行汇总。 这意味着汇聚层的输出通道数与输入通道数相同。</p><hr><ul><li>对于给定输入元素，最大汇聚层会输出该窗口内的最大值，平均汇聚层会输出该窗口内的平均值。</li><li>汇聚层的主要优点之一是减轻卷积层对位置的过度敏感。</li><li>我们可以指定汇聚层的填充和步幅。</li><li>使用最大汇聚层以及大于1的步幅，可减少空间维度（如高度和宽度）。</li><li>汇聚层的输出通道数与输入通道数相同。</li></ul><hr><h1 id="卷积神经网络之——LeNet："><a href="#卷积神经网络之——LeNet：" class="headerlink" title="卷积神经网络之——LeNet："></a>卷积神经网络之——LeNet：</h1><p>LeNet是一种卷积神经网络，由Yann LeCun等人在1990年代提出，是卷积神经网络的开山鼻祖之一。</p><p>LeNet在当时被广泛应用于手写数字识别等任务，并为后来更复杂的卷积神经网络的设计奠定了基础。</p><p>虽然LeNet已经相对简单，但其基本的卷积神经网络结构已经被广泛应用于现代深度学习模型中。</p><p>因此，<strong>LeNet通常也被用作卷积神经网络的统称</strong>。</p><h2 id="LeNet："><a href="#LeNet：" class="headerlink" title="LeNet："></a>LeNet：</h2><p>总体来看，LeNet（LeNet-5）由两个部分组成：</p><ul><li>卷积编码器：由两个卷积层组成；</li><li>全连接层密集块：由三个全连接层组成。</li></ul><p><img src="https://img.picgo.net/2023/04/19/image7fe28db16e3136e3.png" alt="avatar"></p><p>简化版如下：</p><img src="https://img.picgo.net/2023/04/19/image92cfb05af2c1888f.png" alt="avatar" style="zoom: 67%;" /><ul><li>卷积神经网络（CNN）是一类使用卷积层的网络。</li><li>在卷积神经网络中，我们组合使用卷积层、非线性激活函数和汇聚层。</li><li>为了构造高性能的卷积神经网络，我们通常对卷积层进行排列，逐渐降低其表示的空间分辨率，同时增加通道数。</li><li>在传统的卷积神经网络中，卷积块编码得到的表征在输出之前需由一个或多个全连接层进行处理。</li><li>LeNet是最早发布的卷积神经网络之一。</li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h1&gt;&lt;p&gt;本篇内容记录笔者学习深度学习的学习过程，如果你有任何想询问的问题，欢迎在以下任何平台提问！&lt;/p&gt;
&lt;p&gt;参考书：《动手学深度学习》</summary>
      
    
    
    
    <category term="AI" scheme="https://conqueror712.github.io/categories/AI/"/>
    
    
  </entry>
  
  <entry>
    <title>Neo4j - Ep2丨学习记录</title>
    <link href="https://conqueror712.github.io/post/Neo4j-2.html"/>
    <id>https://conqueror712.github.io/post/Neo4j-2.html</id>
    <published>2023-04-02T01:46:08.000Z</published>
    <updated>2023-04-03T03:29:18.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><blockquote><p>Abstract：本文的主要内容是<strong>图数据库的入门</strong>以及<strong>Cypher语言的基础知识</strong>。</p></blockquote><p>笔者近日在学习有关知识图谱Knowledge Graph的相关内容。</p><p>Neo4j是项目所需的一款功能强大的应用，特此来学习之，并记录于本文。</p><p>笔者是AI领域的小白，作为初学者，文章中难免会有出错或者不恰当的部分，烦请读者朋友们指出（在以下任意平台）。</p><blockquote><p>个人博客：<a href="https://conqueror712.github.io/">https://conqueror712.github.io/</a></p><p>知乎：<a href="https://www.zhihu.com/people/soeur712/posts">https://www.zhihu.com/people/soeur712/posts</a></p><p>Bilibili：<a href="https://space.bilibili.com/57089326">https://space.bilibili.com/57089326</a></p><p>掘金：<a href="https://juejin.cn/user/1297878069809725/posts">https://juejin.cn/user/1297878069809725/posts</a></p></blockquote><p><strong>注意：本文不是教程，只是个人学习的记录和心得，可能会对你有帮助，建议配合官方文档一起学习！</strong></p><p>官方文档链接：<a href="https://graphacademy.neo4j.com/courses/cypher-fundamentals/1-reading/">https://graphacademy.neo4j.com/courses/cypher-fundamentals/1-reading/</a></p><p>再注：原文是英文，若有较好的英文阅读能力可以直接读，本文是对原文中重要的内容进行了翻译，以及加上了笔者自己的理解。</p><hr><h1 id="从Neo4j读取数据："><a href="#从Neo4j读取数据：" class="headerlink" title="从Neo4j读取数据："></a>从Neo4j读取数据：</h1><blockquote><p>Cypher语言可以帮助在图中检索数据，包括节点，关系（也就是边），还可以过滤查询Filter queries。</p></blockquote><h2 id="Cypher简介："><a href="#Cypher简介：" class="headerlink" title="Cypher简介："></a>Cypher简介：</h2><p>Cypher是一种为图而设计的<strong>查询语言</strong>。</p><p>一个很重要的概念是：Cypher的模式pattern：</p><ul><li><strong>节点</strong>由圆括号表示 <code>()</code>.</li><li>使用冒号来表示<strong>标签</strong> <code>(:Person)</code>.</li><li>节点之间的<strong>关系</strong>用两个破折号表示， <code>(:Person)--(:Movie)</code>.</li><li>使用大于或小于符号<code>&lt;</code>或<code>&gt;</code>表示<strong>关系的方向</strong>，<code>(:Person)-&gt;(:Movie)</code>.</li><li><strong>关系的类型</strong>是用两个破折号之间的方括号写的<code>[</code> and <code>]</code>，<code>[:ACTED_IN]</code></li><li>在<em>语音气泡</em>中绘制的<strong>属性</strong>类似<code>JSON</code>的语法指定；<ul><li>Neo4j中的属性是<code>key-value对</code>， <code>&#123;name: &#39;Tom Hanks&#39;&#125;</code>.</li></ul></li></ul><p>Example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(m:Movie &#123;title: &#x27;Cloud Atlas&#x27;&#125;)&lt;-[:ACTED_IN]-(p:Person)</span><br></pre></td></tr></table></figure><blockquote><p>此模式中的两个节点类型是Movie和Person。</p><p>Person节点与Movie节点有直接的ACTED_IN关系。</p><p>这个模式中的特定Movie节点由值为Cloud Atlas的title属性过滤。</p><p>这个图形代表了所有在电影 Cloud Atlas 中扮演角色的人。</p></blockquote><h3 id="检索-MATCH："><a href="#检索-MATCH：" class="headerlink" title="检索 - MATCH："></a>检索 - MATCH：</h3><p>那么，Cypher是<strong>怎么工作</strong>的呢？</p><p>Cypher的工作原理是匹配数据中的模式；</p><p>我们使用<code>MATCH</code>关键字从图中检索数据；</p><p>可以认为<code>MATCH</code>类似于<code>SQL</code>语句中的<code>FROM</code>。</p><p>例如，如果我们想要在图中找到<strong>一个Person</strong>，我们将<code>MATCH</code>一个带有标签的单个节点的模式<code>:Person</code> -前缀为冒号。</p><p>假设我们想从图中检索<strong>所有Person</strong>节点；</p><p>我们可以通过在冒号前放置一个值来赋值一个变量； </p><p>使用变量<code>p</code>表示从图中检索到的<strong>所有Person</strong>节点，并使用<code>RETURN</code>返回它们。</p><p>就像这样：</p><p>（注意，<code>SHIFT + ENTER</code>可以换行输入，这个界面在右下角可以点开）</p><img src="https://cdnjson.com/images/2023/04/02/image6f9925aec568421d.png" alt="avatar" style="zoom:67%;" /><p>这太酷了，简直符合我对<del>Cyber</del>cCypher的想象！</p><p>我们还可以看到返回的Text，具体来说，该查询返回图中带有Person标签的所有节点。可以使用图视图或表视图查看返回的结果。在选择表视图时，还可以看到返回的节点的属性。</p><img src="https://cdnjson.com/images/2023/04/02/imageb1130e8fe1625bf9.png" alt="avatar" style="zoom: 67%;" /><p>如果我们要具体指定地查询某一个人，应该如何操作呢？</p><p>事实上，就像这样：</p><img src="https://cdnjson.com/images/2023/04/02/imagee952588b70d20236.png" alt="avatar" style="zoom:67%;" /><p>更进一步地，如果我只想知道他的出生年份，如何查询呢？</p><p>很简单，只需要<code>RETURN p.born</code>就可以了，这里就不再演示了。</p><hr><h3 id="检索-WHERE："><a href="#检索-WHERE：" class="headerlink" title="检索 - WHERE："></a>检索 - WHERE：</h3><p>筛选查询的另一种方法是使用<code>WHERE</code>子句，而不是用大括号内联指定属性值。</p><p>Example:</p><img src="https://cdnjson.com/images/2023/04/02/imageaa5fee26e225cfd0.png" alt="avatar" style="zoom:67%;" /><p>一般来说，<code>WHERE</code>在今后会更常用，因为其功能更强大。</p><p>Example:</p><img src="https://cdnjson.com/images/2023/04/02/image18621067e7323998.png" alt="avatar" style="zoom:67%;" /><hr><h3 id="使用与编写习惯："><a href="#使用与编写习惯：" class="headerlink" title="使用与编写习惯："></a>使用与编写习惯：</h3><p>在Cypher中，<strong>标签、属性键和变量</strong>是区分大小写的。Cypher<strong>关键字</strong>不区分大小写。</p><p>一言以蔽之，就是<strong>自定义的东西区分大小写</strong>。</p><p>推荐方式：</p><ul><li>标签：<code>CamelCase</code></li><li>属性键和变量：<code>camelCase</code></li><li>关键字：<code>UPPERCASE</code></li></ul><blockquote><p>随后，你可以在网站中的课后习题中进行练习，那都是一些比较简单和基础但是不可谓不重要的题目。</p></blockquote><hr><h2 id="寻找关系："><a href="#寻找关系：" class="headerlink" title="寻找关系："></a>寻找关系：</h2><p>扩展<code>MATCH</code>子句中的模式，以遍历具有<code>ACTED_IN</code>类型的所有关系到任何节点。</p><p>Domain Model显示<code>ACTED_IN</code>关系从<code>Person</code>节点向外延伸，因此我们可以在模式中添加方向，通常将此称为<strong>遍历traversal</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p:Person &#123;name: &#x27;Tom Hanks&#x27;&#125;)-[:ACTED_IN]-&gt;(m)</span><br><span class="line">RETURN m.title</span><br></pre></td></tr></table></figure><p>当然，我们也可以进行一些指定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p:Person &#123;name: &#x27;Tom Hanks&#x27;&#125;)-[:ACTED_IN]-&gt;(m:Movie)</span><br><span class="line">RETURN m.title</span><br></pre></td></tr></table></figure><hr><h2 id="过滤查询："><a href="#过滤查询：" class="headerlink" title="过滤查询："></a>过滤查询：</h2><p>Example:</p><p>此查询检索Person节点和Movie节点，该人员在2008或2009年发布的电影中扮演角色。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p:Person)-[:ACTED_IN]-&gt;(m:Movie)</span><br><span class="line">WHERE m.released = 2008 OR m.released = 2009</span><br><span class="line">RETURN p, m</span><br></pre></td></tr></table></figure><img src="https://cdnjson.com/images/2023/04/02/imagefba0d2efeca010cc.png" alt="avatar" style="zoom:67%;" /><h3 id="按节点标签进行过滤："><a href="#按节点标签进行过滤：" class="headerlink" title="按节点标签进行过滤："></a>按节点标签进行过滤：</h3><p>Solution1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p:Person)-[:ACTED_IN]-&gt;(m:Movie)</span><br><span class="line">WHERE m.title=&#x27;The Matrix&#x27;</span><br><span class="line">RETURN p.name</span><br></pre></td></tr></table></figure><p>Solution2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p)-[:ACTED_IN]-&gt;(m)</span><br><span class="line">WHERE p:Person AND m:Movie AND m.title=&#x27;The Matrix&#x27;</span><br><span class="line">RETURN p.name</span><br></pre></td></tr></table></figure><hr><h3 id="使用范围进行过滤："><a href="#使用范围进行过滤：" class="headerlink" title="使用范围进行过滤："></a>使用范围进行过滤：</h3><p><code>a &lt;= XX &lt;= b</code></p><p>Example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p:Person)-[:ACTED_IN]-&gt;(m:Movie)</span><br><span class="line">WHERE 2000 &lt;= m.released &lt;= 2003</span><br><span class="line">RETURN p.name, m.title, m.released</span><br></pre></td></tr></table></figure><hr><h3 id="根据属性的存在进行筛选："><a href="#根据属性的存在进行筛选：" class="headerlink" title="根据属性的存在进行筛选："></a>根据属性的存在进行筛选：</h3><p><code>IS NOT NULL</code></p><p>Example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p:Person)-[:ACTED_IN]-&gt;(m:Movie)</span><br><span class="line">WHERE p.name=&#x27;Jack Nicholson&#x27; AND m.tagline IS NOT NULL</span><br><span class="line">RETURN m.title, m.tagline</span><br></pre></td></tr></table></figure><hr><h3 id="按部分字符串筛选："><a href="#按部分字符串筛选：" class="headerlink" title="按部分字符串筛选："></a>按部分字符串筛选：</h3><p><code>START WITH</code>  <code>END WITH</code> <code>CONTAINS</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p:Person)-[:ACTED_IN]-&gt;()</span><br><span class="line">WHERE p.name STARTS WITH &#x27;Michael&#x27;</span><br><span class="line">RETURN p.name</span><br></pre></td></tr></table></figure><p>大小写转换：</p><p><code>toLower(p.name)</code> <code>toUpper(p.name)</code></p><hr><h3 id="根据图中的模式进行过滤："><a href="#根据图中的模式进行过滤：" class="headerlink" title="根据图中的模式进行过滤："></a>根据图中的模式进行过滤：</h3><p>假设你想找出所有的，写过一部电影但没有导演这部电影的人。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p:Person)-[:WROTE]-&gt;(m:Movie)</span><br><span class="line">WHERE NOT exists( (p)-[:DIRECTED]-&gt;(m) )</span><br><span class="line">RETURN p.name, m.title</span><br></pre></td></tr></table></figure><hr><h3 id="使用列表过滤："><a href="#使用列表过滤：" class="headerlink" title="使用列表过滤："></a>使用列表过滤：</h3><p>如果你有一组想要测试的值，你可以将它们放在列表中，或者可以使用图中的现有列表进行测试。</p><p>Cypher列表是<strong>方括号内以逗号分隔的值集</strong>。</p><p>可以在<code>WHERE</code>子句中定义列表。在查询期间，图形引擎将每个属性与列表中的值进行比较。您可以在列表中放置数字值或字符串值，但通常情况下，列表的元素是相同类型的数据。如果您正在测试字符串类型的属性，那么列表中的所有元素都将是字符串。</p><p>在这个例子中，我们只想检索出生在1965、1970或1975年的人的<code>Person</code>节点:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p:Person)</span><br><span class="line">WHERE p.born IN [1965, 1970, 1975]</span><br><span class="line">RETURN p.name, p.born</span><br></pre></td></tr></table></figure><p>同样的，我们也可以添加一些条件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p:Person)-[r:ACTED_IN]-&gt;(m:Movie)</span><br><span class="line">WHERE  &#x27;Neo&#x27; IN r.roles AND m.title=&#x27;The Matrix&#x27;</span><br><span class="line">RETURN p.name, r.roles</span><br></pre></td></tr></table></figure><hr><h3 id="节点或关系具有哪些属性："><a href="#节点或关系具有哪些属性：" class="headerlink" title="节点或关系具有哪些属性："></a>节点或关系具有哪些属性：</h3><p>使用<code>key()进行查询</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p:Person)</span><br><span class="line">RETURN p.name, keys(p)</span><br></pre></td></tr></table></figure><img src="https://cdnjson.com/images/2023/04/02/image0b54197fa6e66fca.png" alt="avatar" style="zoom:67%;" /><hr><h3 id="图中存在什么性质："><a href="#图中存在什么性质：" class="headerlink" title="图中存在什么性质："></a>图中存在什么性质：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALL db.propertyKeys()</span><br></pre></td></tr></table></figure><img src="https://cdnjson.com/images/2023/04/02/image3bcd488bbbe5a876.png" alt="avatar" style="zoom:67%;" /><blockquote><p>同样地，你可以在网站中的课后习题中进行练习，那都是一些比较简单和基础但是不可谓不重要的题目。</p></blockquote><hr><h1 id="向Neo4j写入数据："><a href="#向Neo4j写入数据：" class="headerlink" title="向Neo4j写入数据："></a>向Neo4j写入数据：</h1><p>因为这主要是语法的部分，并没有什么特别难理解的东西需要进一步的解释，所以，这一部分更推荐动手实践，</p><p>还是挑重点来说，主要内容包括：</p><blockquote><p>使用<code>MERGE</code>在图中创建节点；</p><p>使用<code>MERGE</code>在图中创建关系；</p><p>创建、更新和删除图中节点和关系的属性；</p><p>根据图中的内容执行有条件的<code>MERGE</code>处理；</p><p>从图中删除节点和关系。</p></blockquote><hr><h2 id="创建节点："><a href="#创建节点：" class="headerlink" title="创建节点："></a>创建节点：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MERGE (p:Person &#123;name: &#x27;Michael Caine&#x27;&#125;)</span><br></pre></td></tr></table></figure><p>另外，可以使用<code>CREATE</code>而不是<code>MERGE</code>创建节点。</p><p>使用<code>CREATE</code>的好处是，它在添加节点之前<strong>不会查找主键</strong>。</p><p>如果您确定数据是干净的，并且希望在导入过程中<strong>提高速度</strong>，则可以使用CREATE。</p><hr><h2 id="创建关系："><a href="#创建关系：" class="headerlink" title="创建关系："></a>创建关系：</h2><p>如果Person和Movie节点都已经存在，我们可以在创建它们之间的关系之前使用<code>MATCH</code>子句找到它们。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p:Person &#123;name: &#x27;Michael Caine&#x27;&#125;)</span><br><span class="line">MATCH (m:Movie &#123;title: &#x27;The Dark Knight&#x27;&#125;)</span><br><span class="line">MERGE (p)-[:ACTED_IN]-&gt;(m)</span><br></pre></td></tr></table></figure><p><code>MERGE</code>的作用是创建图中<strong>不存在的</strong>节点或关系。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MERGE (p:Person &#123;name: &#x27;Emily Blunt&#x27;&#125;)-[:ACTED_IN]-&gt;(m:Movie &#123;title: &#x27;A Quiet Place&#x27;&#125;)</span><br><span class="line">RETURN p, m</span><br></pre></td></tr></table></figure><img src="https://cdnjson.com/images/2023/04/03/image.png" alt="avatar" style="zoom:67%;" /><hr><h2 id="设置属性："><a href="#设置属性：" class="headerlink" title="设置属性："></a>设置属性：</h2><p>有两种办法可以进行属性的设置：</p><ol><li><p>作为<code>MERGE</code>子句的一部分；</p></li><li><p>使用<code>SET</code>关键字来引用节点或关系。</p></li></ol><p>具体来说，我们给出两个样例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MERGE (p:Person &#123;name: &#x27;Michael Caine&#x27;&#125;)</span><br><span class="line">MERGE (m:Movie &#123;title: &#x27;Batman Begins&#x27;&#125;)</span><br><span class="line">MERGE (p)-[:ACTED_IN &#123;roles: [&#x27;Alfred Penny&#x27;]&#125;]-&gt;(m)</span><br><span class="line">RETURN p,m</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p:Person)-[r:ACTED_IN]-&gt;(m:Movie)</span><br><span class="line">WHERE p.name = &#x27;Michael Caine&#x27; AND m.title = &#x27;The Dark Knight&#x27;</span><br><span class="line">SET r.roles = [&#x27;Alfred Penny&#x27;]</span><br><span class="line">RETURN p, r, m</span><br></pre></td></tr></table></figure><p>注意：<code>SET</code>中的<code>[]</code>有时不是必要的。</p><p>如果需要设置多个属性，请使用逗号分隔。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET r.roles = [&#x27;Alfred Penny&#x27;], r.year = 2008</span><br></pre></td></tr></table></figure><hr><h2 id="更新属性："><a href="#更新属性：" class="headerlink" title="更新属性："></a>更新属性：</h2><p>除此之外，<code>SET</code>还可以用于<strong>更新属性</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p:Person)-[r:ACTED_IN]-&gt;(m:Movie)</span><br><span class="line">WHERE p.name = &#x27;Michael Caine&#x27; AND m.title = &#x27;The Dark Knight&#x27;</span><br><span class="line">SET r.roles = [&#x27;Mr. Alfred Penny&#x27;]</span><br><span class="line">RETURN p, r, m</span><br></pre></td></tr></table></figure><blockquote><p>像这样直接覆盖就可以了</p></blockquote><hr><h2 id="删除属性："><a href="#删除属性：" class="headerlink" title="删除属性："></a>删除属性：</h2><p>至于删除属性，我们可以用<code>REMOVE</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p:Person)-[r:ACTED_IN]-&gt;(m:Movie)</span><br><span class="line">WHERE p.name = &#x27;Michael Caine&#x27; AND m.title = &#x27;The Dark Knight&#x27;</span><br><span class="line">REMOVE r.roles</span><br><span class="line">RETURN p, r, m</span><br></pre></td></tr></table></figure><p>还可以用<code>SET xxx = null</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p:Person)</span><br><span class="line">WHERE p.name = &#x27;Gene Hackman&#x27;</span><br><span class="line">SET p.born = null</span><br><span class="line">RETURN p</span><br></pre></td></tr></table></figure><hr><h2 id="神奇的自定义MERGE："><a href="#神奇的自定义MERGE：" class="headerlink" title="神奇的自定义MERGE："></a>神奇的自定义MERGE：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 查找或创建一个具有此名称的人</span><br><span class="line">MERGE (p:Person &#123;name: &#x27;McKenna Grace&#x27;&#125;)</span><br><span class="line"></span><br><span class="line">// 如果节点是在此查询期间创建的，则只设置&#x27;createdAt&#x27;属性</span><br><span class="line">ON CREATE SET p.createdAt = datetime()</span><br><span class="line"></span><br><span class="line">// 如果之前创建了节点，则只设置&#x27;updatedAt&#x27;属性</span><br><span class="line">ON MATCH SET p.updatedAt = datetime()</span><br><span class="line"></span><br><span class="line">// 设置&#x27;born&#x27;属性</span><br><span class="line">SET p.born = 2006</span><br><span class="line"></span><br><span class="line">RETURN p</span><br></pre></td></tr></table></figure><p>类似地，可以用逗号分割多个属性。</p><hr><h2 id="MERGE处理："><a href="#MERGE处理：" class="headerlink" title="MERGE处理："></a>MERGE处理：</h2><p>使用<code>MERGE</code>来创建节点或关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 查找或创建一个具有此名称的人</span><br><span class="line">MERGE (p:Person &#123;name: &#x27;Michael Caine&#x27;&#125;)</span><br><span class="line"></span><br><span class="line">// 用这个标题找到或创建一个电影</span><br><span class="line">MERGE (m:Movie &#123;title: &#x27;The Cider House Rules&#x27;&#125;)</span><br><span class="line"></span><br><span class="line">// 查找或创建两个节点之间的关系</span><br><span class="line">MERGE (p)-[:ACTED_IN]-&gt;(m)</span><br></pre></td></tr></table></figure><p>下面是在查询处理器中发生的事情:</p><blockquote><p>Neo4j将尝试查找名称为Michael Caine的Person节点。</p><p>如果不存在，则创建节点。</p><p>然后，它将尝试在图中展开该节点的ACTED_IN关系。</p><p>如果这个节点中有任何ACTED_IN关系，它将查找标题为“the Cider House Rules”的电影。</p><p>如果Movie没有节点，则创建该节点。</p><p>如果两个节点之间没有关系，则在它们之间创建ACTED_IN关系。</p></blockquote><hr><h2 id="删除数据："><a href="#删除数据：" class="headerlink" title="删除数据："></a>删除数据：</h2><p>前文提到的”删除属性”是删除数据的一个子集。</p><p>还可以包括：节点、关系、属性、标签。</p><p>要删除数据库中的任何数据，必须<strong>先检索</strong>它，<strong>再删除</strong>它。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p:Person)</span><br><span class="line">WHERE p.name = &#x27;Jane Doe&#x27;</span><br><span class="line">DETACH DELETE p</span><br></pre></td></tr></table></figure><p>这里仅给出一个例子，其他的类似。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Abstract：本文的主要内容是&lt;strong&gt;图数据库的入门&lt;/strong&gt;以及&lt;strong&gt;Cy</summary>
      
    
    
    
    <category term="AI" scheme="https://conqueror712.github.io/categories/AI/"/>
    
    
  </entry>
  
  <entry>
    <title>初识 - 文献综述丨学习记录</title>
    <link href="https://conqueror712.github.io/post/Literature-Review.html"/>
    <id>https://conqueror712.github.io/post/Literature-Review.html</id>
    <published>2023-03-29T13:25:35.000Z</published>
    <updated>2023-03-30T01:51:38.135Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>鉴于笔者差不多也要开始写文献综述了，而作为一个这方面的萌新，对此可以说是一窍不通。</p><p>下面就记录我自己的经验，关于学习如何写一个文献综述，以及如何写好一个文献综述。</p><p>话说这篇文章事实上就是对于网上的内容进行的一个”小综述”，大概算是吧（笑）。</p><p>再注：本文会随着笔者的不断学习而更新和改进。</p><blockquote><p>个人博客：<a href="https://conqueror712.github.io/">https://conqueror712.github.io/</a></p><p>知乎：<a href="https://www.zhihu.com/people/soeur712/posts">https://www.zhihu.com/people/soeur712/posts</a></p><p>Bilibili：<a href="https://space.bilibili.com/57089326">https://space.bilibili.com/57089326</a></p><p>掘金：<a href="https://juejin.cn/user/1297878069809725/posts">https://juejin.cn/user/1297878069809725/posts</a></p></blockquote><hr><p>文献综述还有一些别名：研究综述、国内外研究现状</p><p>定义：在全面掌握分析某一学术问题或者研究领域相关文献的基础上，对该学术问题或研究领域在一定时期内已有的研究成果、存在的问题进行<strong>分析、归纳、整理和评述</strong>而形成的一种不同于研究论文的文体。</p><p>文献综述反映当前某一领域中某分支学科或重要专题的历史现状、最新进展、学术见解和建议，它往往能反映出有关问题的新动态、新趋势、新水平、新原理和新技术等等。作者一般不在其中发表个人见解和建议，也不做任何评论，只是客观概括地反映事实。</p><hr><h1 id="文献综述有什么用："><a href="#文献综述有什么用：" class="headerlink" title="文献综述有什么用："></a>文献综述有什么用：</h1><ul><li>是科研新手非常好的入门方式</li><li>可以整理自己的<strong>思路</strong></li><li>避免与已有的研究<strong>重复</strong></li><li>明确现有研究和自己将要做的研究的<strong>必要性与价值</strong></li><li>体现研究者对于相关研究领域的<strong>熟悉程度</strong></li></ul><hr><h1 id="如何入门文献综述："><a href="#如何入门文献综述：" class="headerlink" title="如何入门文献综述："></a>如何入门文献综述：</h1><h2 id="选题："><a href="#选题：" class="headerlink" title="选题："></a>选题：</h2><blockquote><p>良好的开始是成功的一半</p></blockquote><ul><li>新颖性</li><li>可行性</li><li>选题的意义和价值</li></ul><p>具体来说：</p><p><strong>新颖性</strong>主要看是不是能在这个领域贡献新的知识，判断方法与思路：</p><ol><li>是否呈现新事实 or 发现新现象</li><li>是否有新的阐释</li><li>是否提出新问题</li><li>是否拓展新视角</li></ol><p><strong>可行性</strong>顾名思义，既要有一定的相关文献作为基础，又不能选择已经比较完善的领域。</p><p><strong>选题的意义和价值</strong>，这大致可以分为两个方面，理论意义和实践意义。理论意义就是指这个选题是否可以丰富和完善已有的理论研究内容，促进该领域的进一步发展；实践意义就是说是否对现实生活有用，考虑经济效益和社会效益。</p><hr><h2 id="检索："><a href="#检索：" class="headerlink" title="检索："></a>检索：</h2><p>盲目的检索只会徒增自己的时间成本，甚至会影响到之后的研究。</p><p>需要真正明确自己的研究方向，再进行检索。</p><hr><h2 id="看："><a href="#看：" class="headerlink" title="看："></a>看：</h2><p>高效阅读？带着以下的问题：</p><ol><li><p>这篇文章主要解决哪些问题？</p></li><li><p>针对这些问题，作者采用了哪些方法？</p></li><li><p>这些方法各具有哪些优点和不足？</p></li><li><p>目前该领域的最新研究进展如何？</p></li></ol><p>其次，有一些需要注意的点：</p><ul><li>看前言、摘要和绪论，根据关键词，找到适合的书来看。注意不要看的太仔细，不要拘泥于一两个知识点</li><li>找关键词：从师兄师姐或者课题组的其他同学的论文的关键词</li><li>尽可能多的看，看二三十篇开始动手整理</li></ul><hr><h2 id="写："><a href="#写：" class="headerlink" title="写："></a>写：</h2><ul><li>将绪论部分求同存异，然后按自己的逻辑编排，便于了解课题和打基础</li><li>找到一个方向从而缩小关注的范围，便于深入，这一步可以问一问老师</li></ul><hr><h2 id="再看："><a href="#再看：" class="headerlink" title="再看："></a>再看：</h2><ul><li>关注方法，关键性能指标，原理等</li><li>分类，比较</li></ul><hr><h2 id="深入细节："><a href="#深入细节：" class="headerlink" title="深入细节："></a>深入细节：</h2><ul><li>继续看文献，但是要统计和比较</li><li>对别人的图表要有自己的分析，当成未知结论的图，重新分析得出自己的结论，提出新的问题和方法</li><li>熟练应用数学特别是统计</li><li>耐心，文献不是一天看完的，一般这一周期都会持续三个月以上的时间</li></ul><hr><h2 id="关于参考文献："><a href="#关于参考文献：" class="headerlink" title="关于参考文献："></a>关于参考文献：</h2><p>参考文献是很重要的，一定要<strong>认真对待</strong>。</p><p>一个合格的参考文献需要有：</p><ul><li>全面性</li><li>新进性</li><li>权威性、代表性</li><li>相关性</li><li>实事求是性</li></ul><hr><h1 id="文献综述的常见问题："><a href="#文献综述的常见问题：" class="headerlink" title="文献综述的常见问题："></a>文献综述的常见问题：</h1><ul><li>内容不完整</li><li>逻辑混乱</li><li>避重就轻</li><li>只述不评</li><li>个人观点过多</li></ul><hr><h1 id="什么是一个优秀的文献综述："><a href="#什么是一个优秀的文献综述：" class="headerlink" title="什么是一个优秀的文献综述："></a>什么是一个优秀的文献综述：</h1><blockquote><ol><li><p>在将要研究的主题之下，我们<strong>已经知道了什么</strong>？</p></li><li><p>研究的主要概念或主要变量具有怎样的<strong>特征</strong>？</p></li><li><p>这些主要的概念或变量之间具有怎样的<strong>关系</strong>？</p></li><li><p>有关这个研究主题，<strong>已有的理论</strong>有哪些？</p></li><li><p>在已有的研究中，存在怎样的<strong>缺陷或不足</strong>？</p></li><li><p>还有哪些观点<strong>有待检验</strong>？</p></li><li><p>哪些证据是<strong>缺乏的、不全面的、互相矛盾或非常局限的</strong>？</p></li><li><p><strong>为什么</strong>要研究目前所确定的这个问题？</p></li><li><p>你希望当前的研究对这个主题有怎样的<strong>贡献</strong>（你的<strong>研究价值</strong>是什么）？</p></li><li><p>已有的研究设计或研究方法，存在哪些有<strong>待改进之处</strong></p></li></ol></blockquote><hr><h1 id="文献综述结构："><a href="#文献综述结构：" class="headerlink" title="文献综述结构："></a>文献综述结构：</h1><p>研究背景&#x2F;研究目的与意义，研究现状，评述，参考文献；</p><p>（大致如上，但是不仅限于此）</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h1&gt;&lt;p&gt;鉴于笔者差不多也要开始写文献综述了，而作为一个这方面的萌新，对此可以说是一窍不通。&lt;/p&gt;
&lt;p&gt;下面就记录我自己的经验，关于学习如</summary>
      
    
    
    
    <category term="Experience" scheme="https://conqueror712.github.io/categories/Experience/"/>
    
    
  </entry>
  
  <entry>
    <title>深度学习 - Ep3 - DL计算丨学习记录</title>
    <link href="https://conqueror712.github.io/post/DL-Calc.html"/>
    <id>https://conqueror712.github.io/post/DL-Calc.html</id>
    <published>2023-03-27T14:52:05.000Z</published>
    <updated>2023-04-05T14:52:29.029Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>本篇内容记录笔者学习深度学习的学习过程，如果你有任何想询问的问题，欢迎在以下任何平台提问！</p><blockquote><p>在本章中，我们将深入探索深度学习计算的<strong>关键组件， 即模型构建、参数访问与初始化、设计自定义层和块、将模型读写到磁盘， 以及利用GPU实现显著的加速</strong>。</p><p>这些知识将使读者从深度学习”基础用户”变为”高级用户”。 </p><p>虽然本章不介绍任何新的模型或数据集， 但后面的高级模型章节在很大程度上<strong>依赖于本章的知识</strong>。</p></blockquote><p>参考书：《动手学深度学习》</p><blockquote><p>个人博客：<a href="https://conqueror712.github.io/">https://conqueror712.github.io/</a></p><p>知乎：<a href="https://www.zhihu.com/people/soeur712/posts">https://www.zhihu.com/people/soeur712/posts</a></p><p>Bilibili：<a href="https://space.bilibili.com/57089326">https://space.bilibili.com/57089326</a></p><p>掘金：<a href="https://juejin.cn/user/1297878069809725/posts">https://juejin.cn/user/1297878069809725/posts</a></p></blockquote><p>注：本文将会随着笔者的学习过程随时补充。</p><hr><h1 id="层和块："><a href="#层和块：" class="headerlink" title="层和块："></a>层和块：</h1><img src="https://cdnjson.com/images/2023/04/05/imagea9c660f81077f9a8.png" alt="avatar" style="zoom: 80%;" /><p>从这里也可以看出，层和块的关系：<strong>块里面包含单个或多个层</strong>。</p><blockquote><p>我们简要说明一下每个块必须提供的基本功能。</p></blockquote><ol><li>将<strong>输入数据</strong>作为其<strong>前向传播函数的参数</strong>。</li><li>通过<strong>前向传播函数</strong>来<strong>生成输出</strong>。请注意，<strong>输出的形状可能与输入的形状不同</strong>。例如，我们上面模型中的第一个全连接的层接收一个20维的输入，但是返回一个维度为256的输出。</li><li>计算其输出关于输入的<strong>梯度</strong>，可通过其反向传播函数进行访问。</li><li><strong>存储和访问</strong>前向传播计算所需的<strong>参数</strong>。</li><li>根据需要<strong>初始化模型参数</strong>。</li></ol><p><img src="https://cdnjson.com/images/2023/04/05/imagef81de356cba3e122.png" alt="avatar"></p><p>如图：多个层被组合成块，形成更大的模型。</p><blockquote><p>简要总结。</p></blockquote><ul><li>一个块可以由许多层组成；一个块可以由许多块组成。</li><li>块可以包含代码。</li><li>块负责大量的内部处理，包括参数初始化和反向传播。</li><li>层和块的顺序连接由<code>Sequential</code>块处理。</li></ul><hr><h1 id="参数管理："><a href="#参数管理：" class="headerlink" title="参数管理："></a>参数管理：</h1><blockquote><p>在选择了架构并设置了超参数后，我们就进入了<strong>训练阶段</strong>。 </p><p>此时，我们的目标是找到<strong>使损失函数最小化的模型参数值</strong>。 </p><p>经过训练后，我们将需要使用这些参数来做出未来的预测。 </p><p>此外，有时我们希望提取参数，以便在其他环境中复用它们；</p><p>将模型保存下来，以便它可以在其他软件中执行， 或者为了获得科学的理解而进行检查。</p><p><del>这是成为调参工程师的第一步！</del></p></blockquote><p>首先，我们来明确一点，超参数和模型参数有什么区别？如何区分它们？</p><p>（已经了解的读者可以跳过）</p><h2 id="两种不同的参数："><a href="#两种不同的参数：" class="headerlink" title="两种不同的参数："></a>两种不同的参数：</h2><p>（该部分引用自<a href="https://zhuanlan.zhihu.com/p/37476536%EF%BC%8C%E5%B9%B6%E5%A2%9E%E5%8A%A0%E4%BA%86%E5%85%B6%E5%8F%AF%E8%AF%BB%E6%80%A7%EF%BC%89">https://zhuanlan.zhihu.com/p/37476536，并增加了其可读性）</a></p><blockquote><p><strong>模型参数</strong>是模型内部的配置变量，其值可以根据数据进行估计。</p></blockquote><ul><li>模型在进行<strong>预测</strong>时需要它们。</li><li>它们的<strong>值</strong>，定义了可使用的模型。</li><li>他们是<strong>从数据估计</strong>或获悉的。</li><li>它们通常<strong>不</strong>由编程者<strong>手动设置</strong>。</li><li>他们通常<strong>被保存</strong>为<strong>学习模型的一部分</strong>。</li></ul><blockquote><p><strong>模型超参数</strong>是模型外部的配置，其值无法从数据中估计。</p></blockquote><ul><li>它们通常用于<strong>帮助估计模型参数</strong>。</li><li>它们通常由<strong>人工指定</strong>。</li><li>他们通常可以使用<strong>启发式设置</strong>。</li><li>他们经常被调整为给定的<strong>预测建模</strong>问题。</li></ul><p>我们虽然无法知道给定问题的模型超参数的最佳值，但是我们可以使用<strong>经验法则</strong>，在其他问题上使用复制值，或通过反复试验来搜索最佳值。</p><blockquote><p>如何区分？</p></blockquote><p>如果必须手动指定模型参数，那么它<strong>可能</strong>是一个模型超参数。</p><p>接下来，我们进入正题。</p><hr><h2 id="访问参数："><a href="#访问参数：" class="headerlink" title="访问参数："></a>访问参数：</h2><p>我们可以通过一些方式来<strong>访问参数</strong>（也就是查看）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(net[<span class="number">2</span>].state_dict())</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># OrderedDict([(&#x27;weight&#x27;, tensor([[ 0.3016, -0.1901, -0.1991, -0.1220,  0.1121, -0.1424, -0.3060,  0.3400]])), (&#x27;bias&#x27;, tensor([-0.0291]))])</span></span><br></pre></td></tr></table></figure><p>注意，<code>state_dict()</code>并不是一定要这么写，具体要看情况。</p><p>不过我们也可以采用一种更加简便的方式<strong>访问所有的参数</strong>，而不用每一层都问一次：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(*[(name, param.shape) <span class="keyword">for</span> name, param <span class="keyword">in</span> net[<span class="number">0</span>].named_parameters()])</span><br><span class="line"><span class="built_in">print</span>(*[(name, param.shape) <span class="keyword">for</span> name, param <span class="keyword">in</span> net.named_parameters()])</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># (&#x27;weight&#x27;, torch.Size([8, 4])) (&#x27;bias&#x27;, torch.Size([8]))</span></span><br><span class="line"><span class="comment"># (&#x27;0.weight&#x27;, torch.Size([8, 4])) (&#x27;0.bias&#x27;, torch.Size([8])) (&#x27;2.weight&#x27;, torch.Size([1, 8])) (&#x27;2.bias&#x27;, torch.Size([1]))</span></span><br></pre></td></tr></table></figure><p>当然我们也可以从<strong>嵌套块</strong>收集参数，但因为我们的终点不是讲某一个细节，而是作为一个初学者，对于每一部分的知识形成一个整体的印象和框架，所以我们并不深入地去看这到底是怎么实现的。</p><blockquote><p>可能会有较真的严谨一些的读者对此表示嗤之以鼻，的确，如果能第一次学习就将所有的细节都掌握那自然是更好的，不过笔者并不能做到这一点，相信也有一部分读者赞同这个观点，总之大家可以各取所需就是了。</p></blockquote><hr><h2 id="参数初始化："><a href="#参数初始化：" class="headerlink" title="参数初始化："></a>参数初始化：</h2><p>良好的初始化是很有必要的，有两种参数初始化的办法：</p><ul><li>深度学习框架提供的默认随机初始化；</li><li>自定义初始化方法， 满足我们通过其他规则实现初始化权重。</li></ul><p>下面直接看两种办法在Pytorch里面的代码对比：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_normal</span>(<span class="params">m</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(m) == nn.Linear:</span><br><span class="line">        nn.init.normal_(m.weight, mean=<span class="number">0</span>, std=<span class="number">0.01</span>)</span><br><span class="line">        nn.init.zeros_(m.bias)</span><br><span class="line">net.apply(init_normal)</span><br><span class="line">net[<span class="number">0</span>].weight.data[<span class="number">0</span>], net[<span class="number">0</span>].bias.data[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_init</span>(<span class="params">m</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(m) == nn.Linear:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Init&quot;</span>, *[(name, param.shape)</span><br><span class="line">                        <span class="keyword">for</span> name, param <span class="keyword">in</span> m.named_parameters()][<span class="number">0</span>])</span><br><span class="line">        nn.init.uniform_(m.weight, -<span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">        m.weight.data *= m.weight.data.<span class="built_in">abs</span>() &gt;= <span class="number">5</span></span><br><span class="line"></span><br><span class="line">net.apply(my_init)</span><br><span class="line">net[<span class="number">0</span>].weight[:<span class="number">2</span>]</span><br></pre></td></tr></table></figure><hr><h2 id="参数绑定："><a href="#参数绑定：" class="headerlink" title="参数绑定："></a>参数绑定：</h2><blockquote><p>有时我们希望在多个层间共享参数： 我们可以定义一个稠密层，然后使用它的参数来设置另一个层的参数。</p></blockquote><p>特别地，当参数绑定时，梯度会发生什么情况？ </p><p>答案是由于模型参数包含梯度，因此<strong>在反向传播期间</strong>，绑定层的梯度会<strong>加在一起</strong>。</p><hr><h1 id="延后初始化与自定义层："><a href="#延后初始化与自定义层：" class="headerlink" title="延后初始化与自定义层："></a>延后初始化与自定义层：</h1><h2 id="延后初始化："><a href="#延后初始化：" class="headerlink" title="延后初始化："></a>延后初始化：</h2><p>深度学习框架无法判断网络的输入维度是什么，不过有<strong>延后初始化</strong>（defers initialization）：</p><ul><li>直到数据第一次通过模型传递时，框架才会动态地推断出每个层的大小。</li></ul><blockquote><p>延后初始化使框架能够自动推断参数形状，使修改模型架构变得容易，避免了一些常见的错误。</p><p>我们可以通过模型传递数据，使框架最终初始化参数。</p></blockquote><h2 id="自定义层："><a href="#自定义层：" class="headerlink" title="自定义层："></a>自定义层：</h2><p>深度学习成功背后的一个因素是<strong>神经网络的灵活性</strong>： </p><ul><li>我们可以用创造性的方式组合不同的层，从而设计出适用于各种任务的架构。</li></ul><hr><blockquote><p>关于文件读写和GPU的介绍就不在本文给出了，读者可以自行查找相关内容。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h1&gt;&lt;p&gt;本篇内容记录笔者学习深度学习的学习过程，如果你有任何想询问的问题，欢迎在以下任何平台提问！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="AI" scheme="https://conqueror712.github.io/categories/AI/"/>
    
    
  </entry>
  
  <entry>
    <title>深度学习 - Ep2 - 多层感知机丨学习记录</title>
    <link href="https://conqueror712.github.io/post/DL-MLP.html"/>
    <id>https://conqueror712.github.io/post/DL-MLP.html</id>
    <published>2023-03-27T14:52:05.000Z</published>
    <updated>2023-04-03T08:10:24.063Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>本篇内容记录笔者学习深度学习的学习过程，如果你有任何想询问的问题，欢迎在以下任何平台提问！</p><p>参考书：《动手学深度学习》</p><blockquote><p>个人博客：<a href="https://conqueror712.github.io/">https://conqueror712.github.io/</a></p><p>知乎：<a href="https://www.zhihu.com/people/soeur712/posts">https://www.zhihu.com/people/soeur712/posts</a></p><p>Bilibili：<a href="https://space.bilibili.com/57089326">https://space.bilibili.com/57089326</a></p><p>掘金：<a href="https://juejin.cn/user/1297878069809725/posts">https://juejin.cn/user/1297878069809725/posts</a></p></blockquote><p>注：本文将会随着笔者的学习过程随时补充。</p><hr><h1 id="多层感知机："><a href="#多层感知机：" class="headerlink" title="多层感知机："></a>多层感知机：</h1><p>从单层神经网络到多层神经网络。</p><h2 id="隐藏层："><a href="#隐藏层：" class="headerlink" title="隐藏层："></a>隐藏层：</h2><p><img src="https://img.picgo.net/2023/03/29/IJ2BQGEC9_LWUSKH3EZD7ae2acf350291795.png" alt="avatar"></p><hr><h2 id="激活函数："><a href="#激活函数：" class="headerlink" title="激活函数："></a>激活函数：</h2><p><img src="https://img.picgo.net/2023/03/29/image296b3f3f52baec2d.png" alt="avatar"></p><hr><h1 id="权重衰减："><a href="#权重衰减：" class="headerlink" title="权重衰减："></a>权重衰减：</h1><p>权重衰减可以帮助缓解过拟合问题。</p><p>在深度学习中，模型的过拟合问题通常是由于模型过于复杂或训练数据不足等原因造成的。</p><p>权重衰减是一种<strong>正则化技术</strong>，它通过在模型的损失函数中增加一个惩罚项来减少模型中的过度拟合。</p><ul><li><strong>正则化</strong>：是处理过拟合的常用方法：在训练集的损失函数中<strong>加入惩罚项</strong>，以<strong>降低学习到的模型的复杂度</strong>。</li><li>保持模型简单的一个特别的选择是使用$L_2$惩罚的权重衰减。这会导致学习算法更新步骤中的权重衰减。</li><li>权重衰减功能在深度学习框架的优化器中提供。</li><li>在同一训练代码实现中，不同的参数集可以有不同的更新行为。</li></ul><p><img src="https://cdnjson.com/images/2023/03/29/image.png" alt="avatar"></p><p>权重衰减通过在损失函数中<strong>添加L1或L2范数惩罚项</strong>来实现。</p><ul><li>L1惩罚项将模型中所有参数的绝对值之和作为惩罚项</li><li>L2惩罚项将模型中所有参数的平方和作为惩罚项。</li></ul><p>这些惩罚项的引入使得模型在训练过程中更加倾向于使用较小的参数值，从而减少了过拟合的风险。</p><hr><h1 id="Dropout-暂退法："><a href="#Dropout-暂退法：" class="headerlink" title="Dropout - 暂退法："></a>Dropout - 暂退法：</h1><p>我们希望模型能够<strong>深度挖掘特征</strong>，即<strong>将其权重分散到多个特征中</strong>，而不是<strong>过于依赖少数潜在的虚假关联</strong>。</p><h2 id="重新审视过拟合："><a href="#重新审视过拟合：" class="headerlink" title="重新审视过拟合："></a>重新审视过拟合：</h2><p><img src="https://cdnjson.com/images/2023/03/29/imagee9b5c48d72dac33f.png" alt="avatar"></p><h2 id="扰动的稳健性："><a href="#扰动的稳健性：" class="headerlink" title="扰动的稳健性："></a>扰动的稳健性：</h2><p><img src="https://cdnjson.com/images/2023/03/29/image78c95bd6be4ede4a.png" alt="avatar"></p><p>所以说，Dropout可以改进深层网络的泛化性。</p><p>Dropout是一种在神经网络中进行正则化的方法，</p><p>它通过在训练期间随机屏蔽一部分神经元来减少模型的复杂度，从而避免过拟合的问题。</p><blockquote><p>在每次训练迭代中，</p><p>dropout会随机选择一些神经元，</p><p>将其输出设置为0，</p><p>从而减少这些神经元的贡献，</p><p>同时也促使神经元之间的相互作用变得更加分散和平均。</p></blockquote><hr><h1 id="前向-x2F-反向传播和计算图："><a href="#前向-x2F-反向传播和计算图：" class="headerlink" title="前向 &#x2F; 反向传播和计算图："></a>前向 &#x2F; 反向传播和计算图：</h1><p>前向传播：<strong>按顺序（从输入层到输出层）计算和存储神经网络中每层的结果。</strong></p><p>反向传播：计算神经网络参数梯度的方法。 该方法根据微积分中的<strong>链式规则</strong>，按相反的顺序从输出层到输入层遍历网络。</p><p><img src="https://cdnjson.com/images/2023/03/29/imagea4b38c7f912cc1d2.png" alt="avatar"> </p><hr><p>计算图有助于我们可视化计算中操作符和变量的依赖关系。</p><h2 id="前向传播计算图："><a href="#前向传播计算图：" class="headerlink" title="前向传播计算图："></a>前向传播计算图：</h2><p><img src="https://zh-v2.d2l.ai/_images/forward.svg" alt="avatar"></p><ul><li>前向传播在神经网络定义的计算图中按顺序计算和存储中间变量，它的顺序是从输入层到输出层。</li><li>反向传播按相反的顺序（从输出层到输入层）计算和存储神经网络的中间变量和参数的梯度。</li><li>在训练深度学习模型时，前向传播和反向传播是相互依赖的。</li><li>训练比预测需要更多的内存。</li></ul><hr><h1 id="数值稳定性和模型初始化："><a href="#数值稳定性和模型初始化：" class="headerlink" title="数值稳定性和模型初始化："></a>数值稳定性和模型初始化：</h1><p>梯度爆炸指的是在深度神经网络训练过程中，梯度值变得异常巨大，导致网络中的某些权重值在更新时发生了非常大的变化。这会导致模型的参数更新过于剧烈，使得模型在训练过程中无法收敛到合适的解决方案，也可能导致数值计算溢出等问题。</p><p>相反，梯度消失是指在深度神经网络训练过程中，梯度值变得非常小，甚至接近于0，导致网络的某些权重值几乎不会被更新，从而使得模型无法学习到足够的特征和模式，导致模型欠拟合的问题。</p><p>梯度爆炸和梯度消失通常是由于神经网络结构太深，导致梯度在反向传播过程中指数级别地增加或减少，使得梯度难以传播到浅层网络，或者使得梯度不稳定而难以优化。为了缓解这些问题，可以采取一些技术，如权重初始化、使用梯度截断和层归一化等方法来稳定训练过程，并提高深度神经网络的性能和泛化能力。</p><h2 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h2><ul><li>梯度消失和梯度爆炸是深度网络中常见的问题。在参数初始化时需要非常小心，以确保梯度和参数可以得到很好的控制。</li><li>需要用启发式的初始化方法来确保初始梯度既不太大也不太小。</li><li>ReLU激活函数缓解了梯度消失问题，这样可以加速收敛。</li><li>随机初始化是保证在进行优化前打破对称性的关键。</li><li>Xavier初始化表明，对于每一层，输出的方差不受输入数量的影响，任何梯度的方差不受输出数量的影响。</li></ul><hr><p>附注：</p><p>关于环境和分布偏移，这里先以一言以蔽之：</p><p><strong>环境偏移指的是训练和测试数据之间的差异，而分布偏移指的是测试数据和目标分布之间的差异。</strong></p><p>有关内容纷繁复杂，后续单开一篇文章来记录。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h1&gt;&lt;p&gt;本篇内容记录笔者学习深度学习的学习过程，如果你有任何想询问的问题，欢迎在以下任何平台提问！&lt;/p&gt;
&lt;p&gt;参考书：《动手学深度学习》</summary>
      
    
    
    
    <category term="AI" scheme="https://conqueror712.github.io/categories/AI/"/>
    
    
  </entry>
  
  <entry>
    <title>深度学习 - Ep1 - 线性神经网络丨学习记录</title>
    <link href="https://conqueror712.github.io/post/DL-LinearNN.html"/>
    <id>https://conqueror712.github.io/post/DL-LinearNN.html</id>
    <published>2023-03-27T02:20:05.000Z</published>
    <updated>2023-03-27T10:33:36.780Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>本篇内容记录笔者学习深度学习的学习过程，如果你有任何想询问的问题，欢迎在以下任何平台提问！</p><blockquote><p>个人博客：<a href="https://conqueror712.github.io/">https://conqueror712.github.io/</a></p><p>知乎：<a href="https://www.zhihu.com/people/soeur712/posts">https://www.zhihu.com/people/soeur712/posts</a></p><p>Bilibili：<a href="https://space.bilibili.com/57089326">https://space.bilibili.com/57089326</a></p><p>掘金：<a href="https://juejin.cn/user/1297878069809725/posts">https://juejin.cn/user/1297878069809725/posts</a></p></blockquote><p>注：本文将会随着笔者的学习过程随时补充。</p><hr><h1 id="线性回归："><a href="#线性回归：" class="headerlink" title="线性回归："></a>线性回归：</h1><p><img src="https://cdnjson.com/images/2023/03/27/image00739de91ba022ad.png" alt="avatar"></p><h2 id="线性模型："><a href="#线性模型：" class="headerlink" title="线性模型："></a>线性模型：</h2><p>n维输入：$\vec{x}&#x3D;[x_1,x_2,…,x_n]^T$</p><p>有：</p><ul><li>n维权重：$\vec{w}&#x3D;[w_1, w_2, …, w_n]^T$</li><li>标量偏差$b$</li></ul><p>输出是输入的加权和：$y&#x3D;&lt;\vec{w},\vec{x}&gt;+b$</p><p>如此，线性模型（有显式解）可以看作单层的神经网络（带权的层为1）</p><hr><h2 id="损失函数："><a href="#损失函数：" class="headerlink" title="损失函数："></a>损失函数：</h2><p><img src="https://cdnjson.com/images/2023/03/27/image9853c9b4dd51251a.png" alt="avatar"></p><p>平方误差损失函数：$l^{(i)}(\vec{w},b)&#x3D;\frac{1}{2}(\hat{y}^{(i)}-y^{(i)})^2$</p><p>其中，$\hat{y}^{(i)}$是预测值，$y^{(i)}$是真实标签</p><hr><h2 id="随机梯度下降："><a href="#随机梯度下降：" class="headerlink" title="随机梯度下降："></a>随机梯度下降：</h2><p><img src="https://cdnjson.com/images/2023/03/27/imageaf856f6cb117078e.png" alt="avatar"></p><blockquote><p>最小化目标函数 &lt;&#x3D;&gt;  执行极大似然估计</p></blockquote><p>梯度下降中的参数更新公式：$\overrightarrow{w_t} &#x3D; \overrightarrow{w_{t-1}} - η\frac{\partial{l}}{\partial{\overrightarrow{w_{t-1}}}}$</p><p>其中：$η$是学习率（步长的超参数），$\frac{\partial{l}}{\partial{\overrightarrow{w_{t-1}}}}$是梯度</p><hr><h1 id="Softmax回归："><a href="#Softmax回归：" class="headerlink" title="Softmax回归："></a>Softmax回归：</h1><p>Softmax实际上是一个分类问题；</p><p>回归：估计一个连续值</p><ul><li>单连续值输出</li><li>自然区间R</li><li>与真实值的区别作为损失</li></ul><p>分类：预测一个离散类别</p><ul><li>通常多个输出</li><li>输出$i$是预测为第$i$类的置信度（对分类问题，只关心对于正确类的置信度是否足够大）</li></ul><h2 id="一些数据集："><a href="#一些数据集：" class="headerlink" title="一些数据集："></a>一些数据集：</h2><p>MNIST：手写数字识别（10类）</p><p>ImageNet：自然物品分类（1000类）</p><h2 id="回归→分类："><a href="#回归→分类：" class="headerlink" title="回归→分类："></a>回归→分类：</h2><p><img src="https://cdnjson.com/images/2023/03/27/image42108b108f54af64.png" alt="avatar"></p><h2 id="全连接层的开销："><a href="#全连接层的开销：" class="headerlink" title="全连接层的开销："></a>全连接层的开销：</h2><p><img src="https://zh-v2.d2l.ai/_images/softmaxreg.svg" alt="avatar"></p><p>像这样的二分图，对于$d$个输入和$q$个输出:</p><p>原本：参数开销$O(dq)$，这实在是太高了！</p><p>优化：$O(\frac{dq}{n})$，$n$为超参数，可以灵活指定，用以平衡<strong>参数节约</strong>和<strong>模型有效性</strong>。</p><h2 id="交叉熵损失："><a href="#交叉熵损失：" class="headerlink" title="交叉熵损失："></a>交叉熵损失：</h2><p>交叉熵，衡量2个概率的区别，原始公式如下：</p><p>$H(p, q) &#x3D; \Sigma_i-p_ilog(q_i)$</p><p>以此作为损失，有损失函数：</p><p>$l(y, \hat{y})&#x3D;-\Sigma_iy_ilog\hat{y_i}&#x3D;-log\hat{y_y}$</p><p>其梯度是<strong>真实概率和预测概率的区别</strong>：</p><p>$\sigma_{o_i}l(y, \hat{y})&#x3D;softmax(o)_i-y_i$（o是置信度）</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h1&gt;&lt;p&gt;本篇内容记录笔者学习深度学习的学习过程，如果你有任何想询问的问题，欢迎在以下任何平台提问！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="AI" scheme="https://conqueror712.github.io/categories/AI/"/>
    
    
  </entry>
  
  <entry>
    <title>Neo4j - Ep1丨学习记录</title>
    <link href="https://conqueror712.github.io/post/Neo4J.html"/>
    <id>https://conqueror712.github.io/post/Neo4J.html</id>
    <published>2023-03-25T06:47:09.000Z</published>
    <updated>2023-04-02T01:52:01.932Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><blockquote><p>Abstract：本文的主要内容是<strong>图数据库的入门</strong>以及<strong>Neo4j的基础知识</strong>。</p></blockquote><p>笔者近日在学习有关知识图谱Knowledge Graph的相关内容。</p><p>Neo4j是项目所需的一款功能强大的应用，特此来学习之，并记录于本文。</p><p>笔者是AI领域的小白，作为初学者，文章中难免会有出错或者不恰当的部分，烦请读者朋友们指出（在以下任意平台）。</p><blockquote><p>个人博客：<a href="https://conqueror712.github.io/">https://conqueror712.github.io/</a></p><p>知乎：<a href="https://www.zhihu.com/people/soeur712/posts">https://www.zhihu.com/people/soeur712/posts</a></p><p>Bilibili：<a href="https://space.bilibili.com/57089326">https://space.bilibili.com/57089326</a></p><p>掘金：<a href="https://juejin.cn/user/1297878069809725/posts">https://juejin.cn/user/1297878069809725/posts</a></p></blockquote><p>还有要说明的是，笔者此前的文章存在一个问题是，篇幅过长，</p><p>这不仅导致读者不愿意看，就连笔者自己再次翻阅的时候都只能利用<code>Ctrl+F</code>才能找到我要找的内容。</p><p>故拆分之，便于阅读和查看，每篇文章控制在<code>1.5k~3.5k</code>字之间。</p><p><strong>注意：本文不是教程，只是个人学习的记录和心得，可能会对你有帮助，建议配合官方文档一起学习！</strong></p><p>官方文档链接：<a href="https://graphacademy.neo4j.com/courses/neo4j-fundamentals/">https://graphacademy.neo4j.com/courses/neo4j-fundamentals/</a></p><hr><h1 id="Neo4j-AuraDB入门："><a href="#Neo4j-AuraDB入门：" class="headerlink" title="Neo4j - AuraDB入门："></a>Neo4j - AuraDB入门：</h1><blockquote><p>入门部分会有五个板块：</p><ol><li>Create a database</li><li>View online courses</li><li>Start console tour</li><li>Open Sample Guide</li><li>More resources</li></ol></blockquote><p>首先进入网址：<a href="https://console.neo4j.io/?product=aura-db#create-database/free">https://console.neo4j.io/?product=aura-db#create-database/free</a></p><p>我们就暂时用免费版来学习，点击Start Here，随后会生成一个随机的初始密码，就像这样：</p><img src="https://cdnjson.com/images/2023/03/25/image7ad4ea336942c883.png" alt="avatar" style="zoom:67%;" /><blockquote><p>随后我们会修改这个密码，这实在是太难记了！</p></blockquote><img src="https://cdnjson.com/images/2023/03/25/imagea399953d4c3854ba.png" alt="avatar" style="zoom: 67%;" /><blockquote><p>可以看到，我们已经创建成功了，它在欢迎我们呢！</p><p>到此为止，都非常顺利，不过我们马上就遇到了第一个难题：他居然推荐我们先学四个课程再来玩这个，</p></blockquote><img src="https://cdnjson.com/images/2023/03/25/image9a1551da7ded5ee0.png" alt="avatar" style="zoom: 67%;" /><blockquote><p>那好吧，作为优秀的新时代新青年，我们秉承磨刀不误砍柴工的精神，先去学一下这些课程。</p><p>官方告诉我们，这四门课程总共需要6个小时才能学完，</p><p>不要紧，俗话说的好，慢慢来才比较快，接下来我们就进入课程的学习吧。</p></blockquote><p>（已经学完了或者认为自己不需要学的读者可以直接跳到下一部分）</p><hr><h1 id="Neo4j-基础知识："><a href="#Neo4j-基础知识：" class="headerlink" title="Neo4j - 基础知识："></a>Neo4j - 基础知识：</h1><p>这些课程都有官方的中文版教程，有能力的读者可以自行前往阅读，</p><p>这里笔者给出自己的学习过程，以及一些在学习过程中的见解。</p><p>注意：与官方文档中重复的部分就不予记录了，查阅即可！</p><p>（文档链接还是最上面的链接，大家Start Here之后就有了）</p><h2 id="以图的方式去思考"><a href="#以图的方式去思考" class="headerlink" title="以图的方式去思考"></a>以图的方式去思考</h2><h3 id="关于概念："><a href="#关于概念：" class="headerlink" title="关于概念："></a>关于概念：</h3><p>七桥问题→图论的诞生：节点 + 边</p><p>现在看来，图是一种非常有用的工具，可以帮我们<strong>建模和分析数据</strong>，广泛应用于解决复杂问题上，包括<strong>路线查找、供应链分析和实时推荐</strong>。</p><blockquote><p>学到这里，你会发现这个网站的教程居然还有课堂小测！这真是太良心了，感动哭了</p></blockquote><p>在知识图谱中，我们经常听到”对象”，”实体”这样的名词，事实上，这都是”节点”的别名，它可以代表任何你想代表的<strong>事物</strong>。</p><p>而”关系”，也就是”边”，通常是<strong>动词</strong>。</p><p>关系是图数据库中最重要的元素。</p><hr><h3 id="关于图的遍历："><a href="#关于图的遍历：" class="headerlink" title="关于图的遍历："></a>关于图的遍历：</h3><p><code>Neo4j</code>的<code>Cypher</code>语言针对节点遍历进行了优化，因此<strong>边不会被多次遍历</strong>，这对应用程序来说是一个巨大的<strong>性能提升</strong>。</p><hr><h3 id="Graphs-are-Everywhere："><a href="#Graphs-are-Everywhere：" class="headerlink" title="Graphs are Everywhere："></a>Graphs are Everywhere：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MATCH (c:Category)-[:HAS_CHILD|HAS_PRODUCT*1..3]-&gt;(p:Product)</span><br><span class="line">RETURN p.id, p.title, collect(c.name) AS categories</span><br></pre></td></tr></table></figure><p>解释：</p><ol><li>查找距离类别节点最多三个关系远的产品节点</li><li>查询匹配到的产品节点的id和title属性，同时返回一个集合categories，其中包含了这些产品所属的所有类别的名称。</li></ol><p>为什么推荐算法中常用图数据库？</p><p>因为图数据库的优势在于，需要<strong>遍历更小比例的图就能生成推荐</strong>。 </p><p>你可以简单地从一个产品节点遍历购买该产品的用户，然后再遍历他们购买的后续产品。</p><p>不仅如此，图和图数据库还可以用到方方面面，Neo4j Graphgist站点有许多示例数据模型。</p><hr><h2 id="属性图"><a href="#属性图" class="headerlink" title="属性图"></a>属性图</h2><blockquote><p>哦！我们大概终于是遇到了一个新的概念——属性图。</p></blockquote><p>我们可以使用两个额外的元素来为数据提供一些<strong>附加的上下文</strong>。</p><h3 id="什么是属性图"><a href="#什么是属性图" class="headerlink" title="什么是属性图"></a>什么是属性图</h3><h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><p>只需要一张图就可以解释清楚，这也是官方文档中给出的图：</p><blockquote><p>看！那些黑框框里面的<strong>零个、一个或多个</strong>词就是标签。</p></blockquote><img src="https://cdnjson.com/images/2023/03/25/imageb82978e7e936b587.png" alt="avatar" style="zoom: 33%;" /><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><blockquote><p>同样给出一张图，不过这可能就得多说两句了，</p></blockquote><p>为节点添加属性，可以使其<strong>具体化</strong>。</p><p>属性是<strong>键值对</strong>的形式。</p><p>不需要为具有特定标签的每个节点都指定属性。 如果节点的属性不存在，则将其视为 <code>null</code>。</p><img src="https://cdnjson.com/images/2023/03/25/image3eafeaa374eb730c.png" alt="avatar" style="zoom: 33%;" /><h4 id="边的类型和属性以及方向"><a href="#边的类型和属性以及方向" class="headerlink" title="边的类型和属性以及方向"></a>边的类型和属性以及方向</h4><p>不仅是点，边（关系）也是有标签和属性的，只不过把”标签”换成了”类型”。</p><p>并且和点不同的是，Neo4j的<strong>每个关系必须有一个类型</strong>，</p><p>这不仅<strong>完善了图的含义</strong>，还便于我们对图进行<strong>部分遍历</strong>。</p><blockquote><p>什么是部分遍历呢？就比如说我们只关心谁在哪工作，不关心谁和谁结婚。</p></blockquote><p>当然，如果是这样的话我们可能需要进行多源遍历，这需要看情况。</p><p>对于关系的属性，这些可以指加权图中的<strong>权值</strong>，或者只是为关系<strong>提供额外的上下文</strong>。</p><img src="https://cdnjson.com/images/2023/03/25/image7b7b24b869445a4f.png" alt="avatar" style="zoom: 33%;" /><p>除此之外，在Neo4j中，图的每个关系<strong>必须</strong>有方向。</p><p>不过，尽管方向是必需的，但可以在任一方向查询关系，或在查询时完全忽略。</p><hr><h3 id="原生图的优势"><a href="#原生图的优势" class="headerlink" title="原生图的优势"></a>原生图的优势</h3><blockquote><p>接下来的内容可能有点陌生了，至少对于笔者这样的新手来说是这样的，</p><p>理解和学习可能会花费更多的时间，</p><p>不过没关系，让我们继续吧！</p></blockquote><p>Neo4j是一个原生图数据库，这意味着从数据存储到查询语言的所有内容都是<strong>专门为遍历而设计的</strong>。</p><p>Neo4j符合<strong>ACID</strong>标准——事务中的一组修改将全部提交或失败。</p><h4 id="无索引邻接IFA"><a href="#无索引邻接IFA" class="headerlink" title="无索引邻接IFA"></a>无索引邻接IFA</h4><p>提交数据库事务时，对<strong>关系的引用</strong>与<strong>关系开始和结束处的节点</strong>一起存储。 </p><p>由于每个节点都知道与其连接的每个传入和传出关系，底层图引擎将简单地<strong>查询内存中的指针</strong>——这是计算机非常擅长的。</p><p>查询过程：</p><ol><li>根据指定的锚点计划查询</li><li>使用索引来检索锚节点</li><li>按照指针检索所需的结果节点</li></ol><p>与关系数据库访问相比，IFA 的好处是：</p><ul><li>更少的<strong>索引查找</strong></li><li>没有<strong>表扫描</strong></li><li>减少<strong>数据重复</strong></li></ul><p>还是不好理解？没关系，以下这个例子会帮助到你！</p><blockquote><p>假设你要规划一次旅行，并且需要找到一个好的餐厅去享受美食。</p><p>你可能会在互联网上搜索各种餐厅的信息，并且想了解它们的菜单、位置、评价等信息。</p><p>如果这些信息存储在一个关系型数据库中，那么你可能需要<strong>进行多个查询</strong>来获取所有信息。</p><p>例如，你可能需要先查询餐厅表格，然后再查询菜单表格和评论表格，最后将这些信息整合起来以得出你需要的信息。这种查询方式需要多次查询和连接多个表格，因此查询速度可能会比较慢。</p><p>相比之下，如果这些信息存储在一个图数据库中，那么你只需要进行一个查询，就能够得到所有相关的信息。</p><p>图数据库使用图的方式来存储数据，其中节点表示实体，边表示实体之间的关系。</p><p>例如，在图数据库中，你可以使用<strong>一个节点表示餐厅，另一个节点表示菜单，使用一条边表示餐厅和菜单之间的关系。</strong>这种查询方式只需要一次查询和一次遍历，因此查询速度会比较快！</p></blockquote><h3 id="从其他数据库到图数据库"><a href="#从其他数据库到图数据库" class="headerlink" title="从其他数据库到图数据库"></a>从其他数据库到图数据库</h3><p>随着关系数据库中记录数的增加，查询变得<strong>越来越慢</strong>。 </p><p>图数据库中的查询时间将<strong>与查询期间实际触及的数据大小保持一致</strong>。</p><p>将关系视为<strong>一等公民</strong>也可以在开始时提供优势。 </p><p>在<strong>图中建模关系</strong>比创建<strong>数据透视表</strong>来表示<strong>多对多</strong>关系更<strong>自然</strong>。</p><p>也就是说，总结起来就是一句话：</p><blockquote><p>可以将关系模型实现为图模型，这样对于理解起来会更方便！</p></blockquote><p>除此之外，<strong>键值存储</strong>和<strong>文档存储</strong>也是可以实现用图来提高性能的存储方式。</p><hr><h2 id="你的第一个图"><a href="#你的第一个图" class="headerlink" title="你的第一个图"></a>你的第一个图</h2><h3 id="电影图数据"><a href="#电影图数据" class="headerlink" title="电影图数据"></a>电影图数据</h3><p>这部分内容是一个图数据库的例子，帮助理解上述知识，</p><p>这里放一张图，以示实际应用中的图数据库是什么样子的：</p><img src="https://cdnjson.com/images/2023/03/25/image310d0d810246e431.png" alt="avatar" style="zoom: 67%;" /><p>具体的内容就不展开了，大家可以自行前往查看。</p><blockquote><p>可能有的读者会大失所望，还以为是要开始创建第一个项目了呢！</p><p>先别着急，还记得一开始官方教程中告诉我们的吗？这刚刚是第一个基础，还有三个基础等着我们呢！</p><p>先让我们庆祝一下，我们已经完成了第一部分的学习！</p></blockquote><img src="https://cdnjson.com/images/2023/03/25/imageb3709901b8436875.png" alt="avatar" style="zoom: 67%;" /><blockquote><p>甚至给我颁发了一个证书 XD</p></blockquote><img src="https://cdnjson.com/images/2023/03/25/image48542dc349b9f728.png" alt="avatar" style="zoom:50%;" /><hr><p>Thanks for reading and see you next time!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Abstract：本文的主要内容是&lt;strong&gt;图数据库的入门&lt;/strong&gt;以及&lt;strong&gt;Ne</summary>
      
    
    
    
    <category term="AI" scheme="https://conqueror712.github.io/categories/AI/"/>
    
    
  </entry>
  
  <entry>
    <title>计网 - Ep2 - 应用层「万字长文」丨学习记录</title>
    <link href="https://conqueror712.github.io/post/Computer-Network-2.html"/>
    <id>https://conqueror712.github.io/post/Computer-Network-2.html</id>
    <published>2023-03-20T02:58:59.000Z</published>
    <updated>2023-04-23T03:09:54.791Z</updated>
    
    <content type="html"><![CDATA[<p><em>Computer Networking A Top-Down Approach Learning Note Part 2</em></p><p><strong>前言</strong>：</p><p>本文是笔者初学计算机网络的笔记和一些心得，难免会有部分疏漏和错误，还请各位读者积极指出，不吝赐教。</p><p>有一些内容是笔者认为对自己暂时没那么重要的部分，就没有放上去，具体的内容可以查看相关的书籍。</p><p>观前提醒：本文篇幅较长，若您只是想看其中的某一小节的知识，直接点击目录进行跳转即可！</p><p>事不宜迟，我们开始吧！</p><blockquote><p>个人博客：<a href="https://conqueror712.github.io/">https://conqueror712.github.io/</a></p><p>知乎：<a href="https://www.zhihu.com/people/soeur712/posts">https://www.zhihu.com/people/soeur712/posts</a></p><p>Bilibili：<a href="https://space.bilibili.com/57089326">https://space.bilibili.com/57089326</a></p><p>掘金：<a href="https://juejin.cn/user/1297878069809725/posts">https://juejin.cn/user/1297878069809725/posts</a></p></blockquote><hr><h1 id="Unit-2-应用层"><a href="#Unit-2-应用层" class="headerlink" title="Unit 2 应用层"></a>Unit 2 应用层</h1><h2 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h2><p>网络核心中没有应用层软件</p><p>想法 → 网络应用</p><p>研发网络应用程序的核心：写出能够运行在不同的端系统和通过网络彼此通信的程序。</p><h3 id="网络-x2F-应用程序体系结构"><a href="#网络-x2F-应用程序体系结构" class="headerlink" title="网络&#x2F;应用程序体系结构"></a>网络&#x2F;应用程序体系结构</h3><p>Network architecture and applicaiton architecture are both the “design and structure”.</p><h4 id="常见的网络体系结构："><a href="#常见的网络体系结构：" class="headerlink" title="常见的网络体系结构："></a>常见的网络体系结构：</h4><ul><li>客户 - 服务器模式 <code>C - S</code><ul><li>服务器：<ul><li>一直运行</li><li><strong>固定的IP地址</strong>和周知的端口号，不像DHCP获取的动态IP</li><li>扩展性：服务器农场</li></ul></li><li>客户端：<ul><li>主动与服务器通信</li><li>与互联网有间歇性的连接</li><li>可能是<strong>动态IP地址</strong></li><li>不直接与其他客户端通信</li></ul></li></ul></li><li>对等模式 <code>P2P</code><ul><li>几乎没有一直运行的服务器<ul><li>任意端系统之间可以进行通信</li></ul></li><li>每一个节点既是客户端又是服务器<ul><li><strong>自扩展性</strong>：新的peer节点带来新的服务能力和新的服务请求</li></ul></li><li>参与的主机间歇性连接且可以改变IP地址</li><li>例如：迅雷</li></ul></li><li>混合体<ul><li>Napster<ul><li>文件搜索：集中</li><li>文件传输：P2P</li></ul></li><li>即时通信<ul><li>在线检测：集中</li><li>两个用户之间聊天：P2P</li></ul></li></ul></li></ul><h4 id="常见的应用程序体系结构："><a href="#常见的应用程序体系结构：" class="headerlink" title="常见的应用程序体系结构："></a>常见的应用程序体系结构：</h4><ul><li><p>分层体系结构（Layered Architecture）：</p><p>  应用程序被划分为多个层次，每个层次负责不同的功能。例如，MVC（Model-View-Controller）框架就是一种分层体系结构。</p></li><li><p>事件驱动体系结构（Event-Driven Architecture）：</p><p>  应用程序通过事件的方式进行通信和交互。事件可以是用户的操作、消息的到达、计时器的触发等等。例如，GUI（Graphical User Interface）应用程序就是一种事件驱动体系结构。</p></li><li><p>微服务体系结构（Microservices Architecture）：</p><p>  应用程序被划分为多个小型的、相互独立的服务。每个服务可以独立地开发、部署和扩展，从而提高应用程序的灵活性和可维护性。</p></li><li><p>基于消息的体系结构（Message-Based Architecture）：</p><p>  应用程序通过消息进行通信和交互。消息可以是文本、XML、JSON等格式的数据。例如，企业消息总线（Enterprise Service Bus）就是一种基于消息的体系结构。</p></li><li><p>一体式体系结构（All-in-one architecture），etc.</p></li></ul><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>如何通信？</p><p>进程(process)与进程在相同的端系统上以进程间的通信机制互相通信，这个规则由操作系统决定。</p><p>而我们的重点是：两个<strong>不同的端系统</strong>之间是如何进行通信的——**交换报文(message)**。</p><ul><li>使用OS提供的通信服务</li><li>按照应用协议交换报文</li></ul><p>关于进程：</p><ul><li>客户端进程：发起通信的进程</li><li>服务端进程：等待连接的进程</li></ul><p>（P2P架构的应用也有客户端进程和服务端进程之分）</p><p>除此之外，分布式进程通信需要解决的问题如下：</p><ol><li>对进程进行编址（addressing）</li><li>传输层提供的服务：需要穿过层间的信息 + 层间信息的代表</li></ol><h3 id="TCP-socket"><a href="#TCP-socket" class="headerlink" title="TCP socket"></a>TCP socket</h3><p>为什么要有TCP socket?</p><p>不同的端口号对应了不同的协议 不同的进程，便于进行进程的寻址。</p><p>16bit的端口号 65536个状态</p><p>如果Socket API 每次传输报文，都携带如此多的信息，太繁琐易错，不便于管理</p><p>用个<strong>代号</strong>标示通信的双方或者单方：socket</p><p>就像OS打开文件返回的句柄一样</p><p>TCP socket:</p><ul><li>TCP服务，两个进程之间的通信需要之前要建立连接<ul><li>两个进程通信会持续一段时间，通信关系稳定</li></ul></li><li>可以用一个整数表示两个应用实体之间的通信关系 ，本地标示，类似Hash</li><li>穿过层间接口的信息量最小</li></ul><p>对于使用面向连接服务（TCP）的应用而言，套接字是4元组的一个具有本地意义的标示。</p><ul><li>四元组：源IP，源port，目标IP，目标port</li><li>唯一的指定了一个会话（2个进程之间的会话关系）</li><li>应用使用这个 ，与远程的应用进程通信</li><li>不必在每一个报文的发送都要指定这4元组</li><li>就像使用操作系统打开一个文件，OS返回一个文件句柄一样，以后使用这个文件句柄，而不是使用这个文件的目录名、文件名</li><li>简单，便于管理</li></ul><img src="https://pic1.zhimg.com/v2-8302577e2963b8a605e72234f25d6082_1440w.jpg?source=172ae18b" alt="avatar" style="zoom:80%;" /><h3 id="UDP-socket"><a href="#UDP-socket" class="headerlink" title="UDP socket"></a>UDP socket</h3><ul><li>UDP服务，两个进程之间的通信需要之前无需建立连接<ul><li>每个报文都是独立传输的</li><li>前后报文可能给不同的分布式进程</li></ul></li><li>因此，只能用一个整数表示本应用实体的标示<ul><li>因为这个报文可能传给另外一个分布式进程</li></ul></li><li>穿过层间接口的信息大小最小</li><li>UDP socket：本IP,本端口</li><li>但是传输报文时：必须要提供对方IP，port<ul><li>接收报文时： 传输层需要上传对方的IP，port</li></ul></li></ul><p>对于使用无连接服务（UDP）的应用而言，套接字是2元组的一个具有本地意义的标示</p><ul><li>2元组：IP，port（源端指定）</li><li>UDP套接字指定了应用所在的一个端节点（end point）</li><li>在发送数据报时，采用创建好的本地套接字（标示ID），就不必在发送每个报文中指明自己所采用的ip和port</li><li>但是在发送报文时，必须要指定对方的ip和udpport(另外一个段节点)</li></ul><p>进程向套接字发送报文或从套接字接收报文</p><h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><p>如何使用传输层提供的服务实现应用?</p><ul><li>定义应用层协议：报文格式，解释，时序等</li><li>编制程序，通过API调用网络基础设施提供通信服务传报文，解析报文，实现应用时序等</li></ul><p>应用层协议是什么？</p><p><strong>定义了</strong>：运行在不同端系统上 的应用<strong>如何相互交换报文</strong></p><p>应用协议仅仅是应用的一个组成部分</p><p>除此之外，还分成公开协议和专有协议</p><p>如何描述传输层的服务？</p><ul><li>数据丢失率</li><li>延时</li><li>吞吐</li><li>安全性</li></ul><h3 id="Internet-传输层提供的服务"><a href="#Internet-传输层提供的服务" class="headerlink" title="Internet 传输层提供的服务"></a>Internet 传输层提供的服务</h3><h4 id="TCP服务"><a href="#TCP服务" class="headerlink" title="TCP服务"></a>TCP服务</h4><ul><li>可靠的传输服务</li><li>流量控制：发送方不会淹没接收方</li><li>拥塞控制：当网络出现拥塞时，能抑制发送方</li><li>不能提供的服务：时间保证、最小吞吐量保证，安全</li><li>面向连接：要求在客户端进程和服务器进程之间建立连接</li></ul><h4 id="UDP服务"><a href="#UDP服务" class="headerlink" title="UDP服务"></a>UDP服务</h4><ul><li>不可靠数据传输</li><li>不提供的服务：可靠，流量控制，拥塞控制，时序，贷款保证，建立连接</li></ul><h4 id="UDP的存在有其必要性"><a href="#UDP的存在有其必要性" class="headerlink" title="UDP的存在有其必要性"></a>UDP的存在有其必要性</h4><ul><li>能够<strong>区分不同的进程</strong>，而IP服务不能<ul><li>在IP提供的主机到主机端到端功能的基础上，区分了主机的应用进程</li></ul></li><li><strong>无需建立连接</strong>，省去了建立连接时间，适合事务性应用</li><li><strong>不做可靠性的工作</strong>，例如检错重发，适合那些对实时性要求比较高而对正确性要求不高的应用</li><li>没有拥塞控制和流量控制，<strong>应用能够按照设定的速度发送数据</strong></li></ul><p><img src="https://cdnjson.com/images/2023/03/20/image.png" alt="avatar"></p><h4 id="安全TCP——SSL"><a href="#安全TCP——SSL" class="headerlink" title="安全TCP——SSL"></a>安全TCP——SSL</h4><p>原本的TCP和UDP，都是没有加密的，甚至于密码都是明文传输；</p><p>引入SSL，<strong>在TCP上面实现</strong>，提供加密的TCP连接；</p><ul><li>私密性</li><li>数据完整性</li><li>端到端的鉴别</li></ul><p><strong>SSL在应用层</strong>，应用采用SSL库，而SSL库使用传输层的TCP进行通信；</p><p>应用通过API将明文交给socket，SSL将其加密并在互联网上传输，详见Unit8。</p><blockquote><p>SSL是<strong>Secure Sockets Layer安全套接字层</strong>的缩写，是一系列<strong>加密技术</strong>，允许Web用户保护他们通过Internet传输的信息的<strong>隐私</strong>。</p><p>当您访问安全网站时，您会在 URL 旁边看到一个锁，表示您与该网站的通信<strong>已加密</strong>。</p><p><img src="https://s2.loli.net/2023/01/29/6mWG8plUqKEt2O1.png" alt="avatar"></p><p>该锁应该表明<strong>第三方将无法读取您发送或接收的任何信息</strong>。在后台，SSL通过将您的数据转换为只有收件人知道如何破译的编码消息来实现这一点。如果恶意方正在监听对话，它只会看到看似随机的字符串，而不会看到您的电子邮件、Facebook 帖子、信用卡号或其他私人信息的内容。</p></blockquote><h4 id="TCP三次握手四次挥手"><a href="#TCP三次握手四次挥手" class="headerlink" title="TCP三次握手四次挥手"></a>TCP三次握手四次挥手</h4><p>为了保证客户端和服务器端的可靠连接，TCP建立连接时<strong>必须</strong>要进行三次会话，也叫TCP三次握手，</p><p>进行三次握手的目的是为了<strong>确认双方的接收能力和发送能力是否正常</strong>。</p><img src="https://cdnjson.com/images/2023/03/21/image1ce75f8803f2d480.png" alt="avatar" style="zoom:80%;" /><blockquote><p>最开始的时候客户端和服务器都是处于CLOSED关闭状态。主动打开连接的为客户端，被动打开连接的是服务器。</p><p>TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了 <strong>LISTEN 监听状态</strong></p><p>第一次握手 TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN&#x3D;1，同时选择一个初始序列号 seq&#x3D;x ，此时，TCP客户端进程进入了 <strong>SYN-SENT 同步已发送状态</strong></p><p>第二次握手 TCP服务器收到请求报文后，如果同意连接，则会向客户端发出确认报文。确认报文中应该 ACK&#x3D;1，SYN&#x3D;1，确认号是ack&#x3D;x+1，同时也要为自己初始化一个序列号 seq&#x3D;y，此时，TCP服务器进程进入了 <strong>SYN-RCVD 同步收到状态</strong></p><p>第三次握手 TCP客户端收到确认后，还要向服务器给出确认。确认报文的ACK&#x3D;1，ack&#x3D;y+1，自己的序列号seq&#x3D;x+1，此时，TCP连接建立，客户端进入<strong>ESTABLISHED已建立连接状态</strong> 触发三次握手</p><p>有人可能会很疑惑为什么要进行第三次握手？<br>主要原因：<strong>防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误</strong></p><p><strong>第一次握手： 客户端向服务器端发送报文</strong><br>        证明客户端的发送能力正常<br><strong>第二次握手：服务器端接收到报文并向客户端发送报文</strong><br>        证明服务器端的接收能力、发送能力正常<br><strong>第三次握手：客户端向服务器发送报文</strong><br>        证明客户端的接收能力正常</p></blockquote><img src="https://cdnjson.com/images/2023/03/21/image24fec85472fe6e50.png" alt="avatar" style="zoom:80%;" /><blockquote><p>数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于<strong>ESTABLISHED</strong>状态，然后客户端主动关闭，服务器被动关闭。</p><p>第一次挥手 客户端发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN&#x3D;1，其序列号为seq&#x3D;u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入<strong>FIN-WAIT-1（终止等待1）</strong>状态</p><p>第二次挥手 服务器端接收到连接释放报文后，发出确认报文，ACK&#x3D;1，ack&#x3D;u+1，并且带上自己的序列号seq&#x3D;v，此时，服务端就进入了CLOSE-WAIT 关闭等待状态</p><p>第三次挥手 客户端接收到服务器端的确认请求后，客户端就会进入<strong>FIN-WAIT-2（终止等待2）</strong>状态，等待服务器发送连接释放报文，服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</p><p>第四次挥手 客户端收到服务器的连接释放报文后，必须发出确认，ACK&#x3D;1，ack&#x3D;w+1，而自己的序列号是seq&#x3D;u+1，此时，客户端就进入了<strong>TIME-WAIT（时间等待）</strong>状态，但此时TCP连接还未终止，必须要经过2MSL后（最长报文寿命），当客户端撤销相应的TCB后，客户端才会进入CLOSED关闭状态，服务器端接收到确认报文后，会立即进入CLOSED关闭状态，到这里TCP连接就断开了，四次挥手完成</p><p>为什么客户端要等待2MSL？<br>主要原因是为了保证客户端发送那个的第一个ACK报文能到服务器，因为这个ACK报文可能丢失，并且2MSL是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃，这样<strong>新的连接中不会出现旧连接的请求报文</strong>。</p></blockquote><hr><h2 id="Web-amp-HTTP"><a href="#Web-amp-HTTP" class="headerlink" title="Web &amp; HTTP"></a>Web &amp; HTTP</h2><h3 id="Web概述"><a href="#Web概述" class="headerlink" title="Web概述"></a>Web概述</h3><p>由一些<strong>对象</strong>组成，有哪些对象？</p><ul><li>HTML文件、JPEG图像、Java小程序、音视频文件etc.</li></ul><p>Web页含有一个<strong>基本的HTML文件</strong>，该基本HTML文件又包含若干对象的引用（链接）；</p><p>对象如何引用？</p><ul><li>通过URL对每个对象进行引用，URL包括访问协议，用户名，口令字，端口，目录文件等；</li></ul><p><img src="https://cdnjson.com/images/2023/03/20/image3119aaf482192bea.png" alt="avatar"></p><h3 id="HTTP概述"><a href="#HTTP概述" class="headerlink" title="HTTP概述"></a>HTTP概述</h3><p><strong>一句话解释</strong>：HTTP 是用于获取 HTML 文档等资源的<strong>协议</strong>——我们称之为<strong>超文本传输协议</strong>。</p><p>它是 Web 上任何数据交换的基础，在<strong>应用层</strong>上，是一种<strong>客户端-服务器协议</strong>，</p><p>这意味着请求由接收者（通常是 Web 浏览器）发起。</p><p>从获取的不同子文档（例如文本、布局描述、图像、视频、脚本等）重建完整的文档。</p><p>它使用TCP，默认端口号为80；</p><p>（HTTPS使用了SSL，默认端口号为443）</p><ul><li>具体过程为：客户发起一个与服务器的TCP连接（建立socket），服务器接受连接，随后在浏览器和Web服务器之间交换HTTP报文，最后TCP连接关闭。</li></ul><p><img src="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview/fetching_a_page.png" alt="avatar"></p><p>客户端和服务器通过交换单个消息（而不是数据流）进行通信。 </p><ul><li>客户端（通常是 Web 浏览器）发送的消息称为<strong>请求</strong>；</li><li>服务器作为应答发送的消息称为<strong>响应</strong>。</li></ul><p><strong>协议</strong>是定义如何在计算机内部或计算机之间交换数据的规则系统。设备之间的通信要求设备就正在交换的数据的格式达成一致。</p><p>定义格式的规则集称为协议。</p><p><img src="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview/http-layers.png" alt="avatar"></p><hr><h3 id="基于HTTP的系统组件"><a href="#基于HTTP的系统组件" class="headerlink" title="基于HTTP的系统组件"></a>基于HTTP的系统组件</h3><p>HTTP是一种<strong>客户端-服务器协议</strong>：请求由一个实体发送，即用户代理（或代表它的代理）。 大多数情况下，用户代理是一个Web浏览器，但它可以是任何东西。</p><p>每个单独的请求都发送到服务器，服务器处理它并提供称为<strong>响应</strong>的答案。</p><p>在客户端和服务器之间有许多实体，统称为<strong>代理Proxy</strong>，例如，它们执行不同的操作并充当网关or<strong>缓存Cache</strong>。</p><p>实际上，浏览器和处理请求的服务器之间有更多的计算机：有路由器、调制解调器等。 由于Web的分层设计，这些隐藏在网络和传输层中。 HTTP位于应用程序层的<strong>顶部</strong>。 虽然对于诊断网络问题很重要，但底层大多与 HTTP 的描述无关。</p><p><img src="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview/client-server-chain.png" alt="avatar"></p><h4 id="Proxy："><a href="#Proxy：" class="headerlink" title="Proxy："></a>Proxy：</h4><p><strong>代理服务器</strong>是在互联网的不同网络中导航时使用的<strong>中间程序或计算机</strong>。它们<strong>有助于访问万维网上的内容</strong>。</p><p>代理拦截请求并提供回响应；它可以转发或不转发请求（例如在缓存的情况下），并且可以修改请求（例如，在两个网络之间的边界处更改其标头）。</p><p>代理可以位于用户的本地计算机上，也可以位于用户计算机和 Internet 上的目标服务器之间的任何位置。通常有两种主要类型的代理服务器：由于 Web 堆栈的分层结构，其中大多数在传输、网络或物理级别运行，在 HTTP 层变得透明，并可能对性能产生重大影响。</p><ul><li>处理来自和发送到互联网上任何位置的请求的<strong>转发代理</strong>。</li><li>一种<strong>反向代理</strong>，从 Internet 接收请求并将其转发到内部网络中的服务器。</li></ul><p>代理的<strong>功能</strong>：</p><ul><li>缓存（缓存可以是公共的或私有的，就像浏览器缓存一样）</li><li>过滤（如防病毒扫描或家长控制）</li><li>负载平衡（允许多个服务器为不同的请求提供服务）</li><li>身份验证（控制对不同资源的访问）</li><li>日志记录（允许存储历史信息）</li></ul><h4 id="Cache："><a href="#Cache：" class="headerlink" title="Cache："></a>Cache：</h4><p><strong>缓存</strong>（Web 缓存或 HTTP 缓存）是临时存储 HTTP 响应的组件，以便只要满足某些条件，就可以将其用于后续 HTTP 请求。</p><p><strong>Web缓存</strong>（代理服务器）：</p><img src="https://cdnjson.com/images/2023/03/20/image28c57533d28138e0.png" alt="avatar" style="zoom:67%;" /><ul><li>缓存既是客户端又是服务器</li><li>通常缓存是由ISP安装 (大学、公司、居民区ISP)</li></ul><img src="https://cdnjson.com/images/2023/03/20/image526f313d27cbed65.png" alt="avatar" style="zoom: 67%;" /><img src="https://cdnjson.com/images/2023/03/20/image59b4b89bf717356d.png" alt="avatar" style="zoom:67%;" /><blockquote><p>这部分会有一些计算题，题型示例如下：</p><ul><li>更快的接入链路</li><li>安装本地缓存</li></ul></blockquote><h4 id="客户端：用户代理"><a href="#客户端：用户代理" class="headerlink" title="客户端：用户代理"></a>客户端：用户代理</h4><p>用户代理是代表用户执行操作的任何工具。 </p><p>浏览器<strong>始终</strong>是发起请求的实体，它<strong>从来</strong>都不是服务器。</p><h4 id="网络服务器"><a href="#网络服务器" class="headerlink" title="网络服务器"></a>网络服务器</h4><p>通信通道的另一端是服务器，它根据客户端的请求<strong>提供文档</strong>。 服务器实际上仅显示为一台计算机；</p><p>但它实际上可能是共享负载（负载平衡）的服务器的<strong>集合</strong>，或者是询问其他计算机（如缓存、数据库服务器或电子商务服务器）的<strong>复杂软件</strong>。</p><hr><h3 id="HTTP的基本方面"><a href="#HTTP的基本方面" class="headerlink" title="HTTP的基本方面"></a>HTTP的基本方面</h3><h4 id="HTTP是可扩展的"><a href="#HTTP是可扩展的" class="headerlink" title="HTTP是可扩展的"></a>HTTP是可扩展的</h4><p>HTTP &#x2F; 1.0中引入的<code>HTTP标头</code>使该协议易于扩展和试验。 </p><p>新功能甚至可以通过客户端和服务器之间关于新标头语义的简单协议来引入。</p><h4 id="HTTP是无状态的，但不是无会话的"><a href="#HTTP是无状态的，但不是无会话的" class="headerlink" title="HTTP是无状态的，但不是无会话的"></a>HTTP是无状态的，但不是无会话的</h4><p>服务器并不维护关于客户的任何信息</p><img src="https://cdnjson.com/images/2023/03/20/image0e6c0ee3d22f034b.png" alt="avatar" style="zoom: 80%;" /><ul><li><p>无状态的：在同一连接上连续执行的两个请求之间没有链接。</p><blockquote><p>具体来说，HTTP是无状态的意味着从客户端到服务器的每个请求都被视为一个独立的事务，不知道之前的任何请求。这意味着服务器不存储客户端的会话信息，也不保留任何来自该客户端的先前请求的内存。客户端负责维护状态，如果有必要，可以在每个请求中向服务器发送信息，例如身份验证凭据或会话ID。这种设计在可扩展性和可靠性方面非常有用，因为它允许服务器独立处理每个请求，并确保在服务器出现故障时不会丢失会话数据。</p></blockquote></li><li><p>有状态会话：HTTP cookie允许使用有状态会话。 使用标头可扩展性，HTTP Cookie 将添加到工作流中，从而允许在每个 HTTP 请求上创建会话以共享相同的上下文或相同的状态。</p></li></ul><h4 id="HTTP和连接"><a href="#HTTP和连接" class="headerlink" title="HTTP和连接"></a>HTTP和连接</h4><p>连接在传输层进行控制，因此从根本上超出了 HTTP 的范围。</p><p>HTTP 不要求基础传输协议基于连接;它只要求它是可靠的，或者不丢失消息。</p><p>在互联网上最常见的两种传输协议中，TCP是可靠的，UDP不是。 因此，<strong>HTTP依赖于基于连接的TCP标准</strong>。</p><p>更进一步地，HTTP分为<strong>非持久HTTP和可持久HTTP</strong></p><img src="https://cdnjson.com/images/2023/03/20/imagefdaa0ed04498039f.png" alt="avatar" style="zoom:80%;" /><p><strong>响应时间模型</strong>：</p><p><img src="https://cdnjson.com/images/2023/03/20/image0650084f136d9f1c.png" alt="avatar"></p><p>则可以得出：</p><img src="https://cdnjson.com/images/2023/03/20/image1710c48906cf7aff.png" alt="avatar" style="zoom:80%;" /><hr><h3 id="HTTP可以控制什么"><a href="#HTTP可以控制什么" class="headerlink" title="HTTP可以控制什么?"></a>HTTP可以控制什么?</h3><blockquote><ul><li>缓存： 文档的缓存方式可以通过 HTTP 控制。 服务器可以指示代理和客户端缓存什么以及缓存多长时间。 客户端可以指示中间缓存代理忽略存储的文档。</li><li>放宽原点约束： 为了防止窥探和其他隐私侵犯，Web 浏览器强制在网站之间严格隔离。 只有来自同一来源的页面才能访问网页的所有信息。 虽然这样的约束对服务器来说是一种负担，但 HTTP 标头可以放松服务器端的这种严格分离，允许文档成为来自不同域的信息的拼凑;这样做甚至可能有与安全相关的原因。</li><li>身份验证： 某些页面可能受到保护，以便只有特定用户才能访问它们。 基本身份验证可以通过 HTTP 提供，可以使用 WWW-Authenticate 和类似的标头，也可以通过使用 HTTP cookie 设置特定会话来提供。</li><li>代理和隧道： 服务器或客户端通常位于 Intranet 上，对其他计算机隐藏其真实 IP 地址。 然后，HTTP 请求通过代理来跨越此网络屏障。 并非所有代理都是 HTTP 代理。 例如，SOCKS协议在较低级别运行。 其他协议（如 ftp）可以由这些代理处理。</li><li>会议： 使用 HTTP Cookie 允许您将请求与服务器的状态相关联。 这会创建会话，尽管基本的HTTP是无状态协议。 这不仅对电子商务购物篮有用，而且对允许用户配置输出的任何站点也很有用。</li></ul></blockquote><hr><h3 id="HTTP流"><a href="#HTTP流" class="headerlink" title="HTTP流"></a>HTTP流</h3><p>当客户端想要与服务器，也可能是中间代理通信时，它会执行以下步骤：</p><ol><li><p>打开 TCP 连接：</p><p> TCP 连接用于发送一个或多个请求并接收应答。 客户端可以打开新连接、重用现有连接或打开与服务器的多个 TCP 连接。</p></li><li><p>发送HTTP消息：</p><p> HTTP消息（在HTTP &#x2F; 2之前）是人类可读的ASCII。 使用HTTP &#x2F; 2，这些简单的消息被封装在框架中，使它们无法直接读取，但原理保持不变。</p><p> 一个例子：</p> <img src="https://cdnjson.com/images/2023/03/20/image6d271a2fc58c258e.png" alt="avatar" style="zoom:80%;" />  </li><li><p>读取服务器发送的响应</p><p> 一个例子：</p> <img src="https://cdnjson.com/images/2023/03/20/image22be64134434b9e0.png" alt="avatar" style="zoom: 80%;" />  </li><li><p>关闭或重新使用连接以处理进一步的请求</p></li></ol><hr><h3 id="HTTP消息与报文"><a href="#HTTP消息与报文" class="headerlink" title="HTTP消息与报文"></a>HTTP消息与报文</h3><p>有两种类型的 HTTP 消息：请求和响应，每种都有自己的格式。</p><h4 id="请求："><a href="#请求：" class="headerlink" title="请求："></a>请求：</h4><img src="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview/http_request.png" alt="avatar" style="zoom:80%;" /><p>更形式化地：</p><img src="https://cdnjson.com/images/2023/03/20/imageac69b0bb3a3c845a.png" alt="avatar" style="zoom:80%;" /><p>关于提交表单输入：</p><ul><li><p>URL(Uniform Resource Locator统一资源定位符)：</p><ul><li><p>一个标准的URL语法组成是下面这样的：</p><p>  <code>scheme://login:password@address:port/path_to_resource?query_string#fragment</code></p><p>  抽象一下：传输协议 + 域名或IP地址 + [端口(端口为80时可省略)] + 资源路径 + 查询字符串</p></li><li><p><strong>GET</strong>：</p><p>  GET - 通常是从指定的服务器中获取数据，查询字符串（键值对）被附加在URL地址后面一起发送到服务器，如下面这样的：<code>http://localhost:8090/api/query?id=3</code>。</p></li><li><p><strong>POST</strong>：</p><p>  POST - 通常是提交数据给指定的服务器处理，当然也可以从服务器获取数据。使用POST方法时，查询字符串或发送的数据在POST信息中单独存在，和请求URL一起发送到服务器，而不是像GET方法一样直接放在URL中。</p></li></ul></li><li><p>GET和POST的区别：</p><ul><li>从上面的例子我们可以看到，GET请求消息体（body）为空，POST请求带有消息体（请区分请求body和响应body）。</li><li>GET提交的数据会放在URL之后，以<code>?</code>分割URL和传输数据，参数之间以&amp;相连，如<code>query?name=test1&amp;id=123456</code></li><li>POST方法是把提交的数据放在HTTP包的请求body中。</li><li>GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制。</li><li>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。</li></ul></li></ul><h4 id="响应："><a href="#响应：" class="headerlink" title="响应："></a>响应：</h4><img src="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview/http_response.png" alt="avatar" style="zoom:80%;" /><p><strong>HTTP响应状态码</strong>：</p><p>位于服务器-&gt;客户端的响应报文中的首行，一些例子如下：</p><img src="https://cdnjson.com/images/2023/03/20/image24df29d653810384.png" alt="avatar" style="zoom:80%;" /><hr><h3 id="HTTP-Cookies："><a href="#HTTP-Cookies：" class="headerlink" title="HTTP - Cookies："></a>HTTP - Cookies：</h3><p>HTTP cookies就是 <strong>服务器端发送给浏览器端的一小部分数据</strong></p><p>用户-服务器状态，有四个组成部分，可以用于用户验证，购物车，推荐和用户状态等。</p><img src="https://cdnjson.com/images/2023/03/20/image25e57c65ed133283.png" alt="avatar" style="zoom:67%;" /><p>Cookies可以<strong>维护状态</strong>，How？：</p><ul><li>协议端节点：在多个事务上 ，发送端和接收端维持状态</li><li>cookies: http报文携带状态信息</li></ul><p>Cookies与隐私：</p><img src="https://cdnjson.com/images/2023/03/20/image4af0dd2b5b6bab42.png" alt="avatar" style="zoom: 67%;" /><hr><h2 id="FTP文件传输协议"><a href="#FTP文件传输协议" class="headerlink" title="FTP文件传输协议"></a>FTP文件传输协议</h2><p>第七版的自顶向下计算机网络删除了这一部分内容，有可能是因为这个技术有点老，现在用的不是很多了。</p><p>了解即可。</p><p>默认端口号：21</p><p>FTP的RFC：959</p><img src="https://cdnjson.com/images/2023/03/21/imageafdfc0d77807b783.png" alt="avatar" style="zoom: 80%;" /><h3 id="控制连接和数据连接事分开的，两个不同的端口"><a href="#控制连接和数据连接事分开的，两个不同的端口" class="headerlink" title="控制连接和数据连接事分开的，两个不同的端口"></a>控制连接和数据连接事分开的，两个不同的端口</h3><p>HTTP只用一个端口</p><img src="https://cdnjson.com/images/2023/03/21/image1759ddbc37f71cbc.png" alt="avatar" style="zoom:67%;" /><p>服务主动向客户端20号端口发起一个连接</p><ul><li>带内的传数据</li><li>带外的传控制信息和指令</li></ul><h3 id="FTP协议有状态"><a href="#FTP协议有状态" class="headerlink" title="FTP协议有状态"></a>FTP协议有状态</h3><p>服务器要维护这个状态，与HTTP不一样。</p><hr><h2 id="Email"><a href="#Email" class="headerlink" title="Email"></a>Email</h2><p>电子邮件的三个主要组成部分：</p><ul><li>用户代理（邮件阅读器）</li><li>邮件服务器</li><li>简单邮件传输协议：SMTP</li></ul><img src="https://cdnjson.com/images/2023/03/21/imagee0d2ad6dbbeb693d.png" alt="avatar" style="zoom: 80%;" /><h3 id="邮件服务器"><a href="#邮件服务器" class="headerlink" title="邮件服务器"></a>邮件服务器</h3><p><strong>管理和维护</strong>发送给用户的邮件；</p><p>输出<strong>报文队列</strong>保持待发送邮件报文；</p><h3 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h3><p>RFC 2821；</p><p>SMTP使用持久连接；</p><p>SMTP使用CRLF.CRLF决定报文的尾部；</p><p>使用TCP在客户端和服务器之间发送报文；</p><p>默认端口号为25；</p><p>使用直接传输，即从发送方服务器到接收方服务器</p><p>传输的三个阶段：</p><ul><li>握手</li><li>传输报文</li><li>关闭</li></ul><p>命令&#x2F;响应交互：（报文必须是7位ASCII码）</p><ul><li>命令：ASCII文本</li><li>响应：状态码和状态信息</li></ul><p>与HTTP的对比：</p><img src="https://cdnjson.com/images/2023/03/21/image94f864dc927fc86b.png" alt="avatar" style="zoom:67%;" /><h3 id="邮件报文格式与多媒体扩展"><a href="#邮件报文格式与多媒体扩展" class="headerlink" title="邮件报文格式与多媒体扩展"></a>邮件报文格式与多媒体扩展</h3><img src="https://cdnjson.com/images/2023/03/21/image5fdf03bceeccec09.png" alt="avatar" style="zoom: 80%;" /><p>多媒体扩展：</p><p>MIME - multimedia mail extension</p><p>RFC 2045, 2056</p><p>在报文首部用额外的行申明MIME内容类型</p><h3 id="邮件访问协议"><a href="#邮件访问协议" class="headerlink" title="邮件访问协议"></a>邮件访问协议</h3><img src="https://cdnjson.com/images/2023/03/21/image64369186f029e146.png" alt="avatar" style="zoom:80%;" /><p>与SMTP的区别：</p><ul><li><p>SMTP是<strong>传送到接收方</strong>的邮件服务器</p></li><li><p>邮件访问协议是<strong>从服务器访问邮件</strong></p><p>  具体来说：</p><ul><li>POP：邮局访问协议——用户身份确认 (代理&lt;–&gt;服务器) 并下载</li><li>IMAP：Internet邮件访问协议——更多特性但也更复杂，在服务器上处理存储的报文</li><li>HTTP：Hotmail , Yahoo! Mail等——方便</li></ul></li></ul><h3 id="关于POP3协议的更多："><a href="#关于POP3协议的更多：" class="headerlink" title="关于POP3协议的更多："></a>关于POP3协议的更多：</h3><img src="https://cdnjson.com/images/2023/03/21/image5a65dcef36501dd0.png" alt="avatar" style="zoom: 80%;" /><img src="https://cdnjson.com/images/2023/03/21/imagebbaa174f5b19e4a5.png" alt="avatar" style="zoom:80%;" /><hr><h2 id="DNS-互联网的电话簿"><a href="#DNS-互联网的电话簿" class="headerlink" title="DNS - 互联网的电话簿"></a>DNS - 互联网的电话簿</h2><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><p>DNS（域名系统 Domain Name System ）是互联网连接资源的分层和分散命名系统；</p><p>DNS维护域名列表以及与其关联的资源（如 IP 地址）；</p><p>DNS最突出的功能是将人性化域名转换为数字IP地址；</p><p>将域名映射到相应 IP 地址的过程称为 DNS 查找，相比之下，反向 DNS 查找 （rDNS） 用于确定与 IP 地址关联的域名。</p><h3 id="额外的安全层？"><a href="#额外的安全层？" class="headerlink" title="额外的安全层？"></a>额外的安全层？</h3><p>默认情况下，DNS查询Request和响应Response以<strong>明文形式</strong>，通过UDP发送，也就是说网络、ISP 或任何能够监控传输的人都可以读取它们。即使网站使用 HTTPS，也会公开导航到该网站所需的 DNS 查询。</p><p>如何解决呢？事实上有两种办法：TLS上的DNS和HTTPS上的DNS，他们都是为加密明文DNS流量而开发的标准。</p><p><img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/7qcyOJwWyOt4EVJykiIRTn/30e34453409eb42fa1ec36680609ad8d/dns-traffic-over-tls-https.svg" alt="avatar"></p><h3 id="DNS-x2F-HTTPS-over-DNS"><a href="#DNS-x2F-HTTPS-over-DNS" class="headerlink" title="DNS &#x2F; HTTPS-over-DNS?"></a>DNS &#x2F; HTTPS-over-DNS?</h3><p>TLS 上的 DNS 或 DoT 是加密 DNS 查询以保持其安全和私密性的标准。</p><p>DoT 使用与 HTTPS 网站相同的安全协议 TLS 来加密和验证通信（TLS也称为”SSL”）。</p><p>DoT 在用户数据报协议 UDP 之上添加了 TLS 加密，该协议用于 DNS 查询。</p><p>此外，它还确保 DNS 请求和响应不会因中间人攻击而被篡改或伪造。</p><p>DNS over HTTPS，或DoH，是DoT的替代方案。</p><p>使用 DoH，DNS 查询和响应是加密的，但它们是通过 HTTP 或 HTTP&#x2F;2 协议发送的，而不是直接通过 UDP 发送的。</p><h4 id="有何不同？"><a href="#有何不同？" class="headerlink" title="有何不同？"></a><strong>有何不同</strong>？</h4><p>每个标准都是单独开发的，都有自己的 RFC（征求意见） 文档，</p><p>但 DoT 和 DoH 之间最重要的<strong>区别在于它们使用的端口</strong>。</p><p>DoT 仅使用端口 853，而 DoH 使用端口 443，这是<strong>所有其他 HTTPS 流量使用的端口</strong>。</p><p>由于 DoT 具有专用端口，因此任何具有网络可见性的人都可以看到 DoT 流量的来来去去，即使请求和响应本身是加密的。相比之下，在DoH中，DNS查询和响应伪装在其他HTTPS流量中，因为它们都来自同一端口。</p><h4 id="哪个更好？"><a href="#哪个更好？" class="headerlink" title="哪个更好？"></a>哪个更好？</h4><p>从网络安全的角度来看，DoT可以说更好。它使网络管理员能够监视和阻止 DNS 查询，这对于识别和阻止恶意流量非常重要。同时，DoH查询隐藏在常规HTTPS流量中，这意味着如果不阻止所有其他HTTPS流量，就无法轻松阻止它们。</p><p>但是，从隐私的角度来看，DoH可以说是可取的。使用 DoH，DNS 查询隐藏在较大的 HTTPS 流量中。这降低了网络管理员的可见性，但为用户提供了更多的隐私。</p><hr><h3 id="涉及-DNS-的常见攻击有哪些？"><a href="#涉及-DNS-的常见攻击有哪些？" class="headerlink" title="涉及 DNS 的常见攻击有哪些？"></a>涉及 DNS 的常见攻击有哪些？</h3><ul><li><strong>DNS 欺骗&#x2F;缓存中毒</strong>：这是一种将伪造的 DNS 数据引入 DNS 解析程序缓存的攻击，导致解析器返回域的错误 IP 地址。流量可以转移到恶意机器或攻击者想要的任何地方，而不是转到正确的网站;通常，这将是用于恶意目的（例如分发恶意软件或收集登录信息）的原始站点的副本。</li><li><strong>DNS 隧道</strong>：此攻击使用其他协议通过 DNS 查询和响应进行隧道传输。攻击者可以使用 SSH、TCP 或 HTTP 将恶意软件或被盗信息传递到 DNS 查询中，而大多数防火墙都不会检测到。</li><li><strong>DNS 劫持</strong>：在 DNS 劫持中，攻击者将查询重定向到其他域名服务器。这可以通过恶意软件或未经授权修改 DNS 服务器来完成。尽管结果与DNS欺骗的结果相似，但这是一种根本不同的攻击，因为它针对的是名称服务器上网站的DNS记录，而不是解析器的缓存。</li><li><strong>NXDOMAIN 攻击</strong>：这是一种 DNS 洪水攻击，攻击者用请求淹没 DNS 服务器，请求不存在的记录，试图导致合法流量的拒绝服务。这可以使用复杂的攻击工具来实现，这些工具可以为每个请求自动生成唯一的子域。NXDOMAIN 攻击还可以针对递归解析器，目的是用垃圾请求填充解析器的缓存。</li><li><strong>幻域攻击</strong>：幻像域攻击的结果与 DNS 解析器上的 NXDOMAIN 攻击类似。攻击者设置了一堆“幻像”域服务器，这些服务器要么响应请求非常慢，要么根本不响应。然后，解析器受到对这些域的大量请求的打击，解析器被占用等待响应，导致性能降低和拒绝服务。</li><li><strong>随机子域攻击</strong>：在这种情况下，攻击者会针对一个合法站点的多个随机、不存在的子域发送 DNS 查询。目标是为域的权威名称服务器创建拒绝服务，从而无法从名称服务器查找网站。作为副作用，为攻击者提供服务的ISP也可能受到影响，因为他们的递归解析器的缓存将加载错误请求。</li><li><strong>域锁定攻击</strong>：攻击者通过设置特殊域和解析器来与其他合法解析器创建 TCP 连接，从而策划这种形式的攻击。当目标解析器发送请求时，这些域会发回缓慢的随机数据包流，从而占用解析器的资源。</li><li><strong>基于僵尸网络的 CPE 攻击</strong>：这些攻击是使用 CPE 设备（客户端设备;这是服务提供商提供的供其客户使用的硬件，例如调制解调器、路由器、电缆盒等）进行的。攻击者破坏CPE，设备成为僵尸网络的一部分，用于对一个站点或域执行随机子域攻击。</li></ul><p><del>（怎么名字都这么帅的）</del></p><p><img src="https://www.cloudflare.com/img/learning/dns/dns-security/dns-hijacking.png" alt="avatar"></p><hr><h3 id="域名安全"><a href="#域名安全" class="headerlink" title="域名安全"></a>域名安全</h3><p>DNS 安全扩展 （DNSSEC） 是为缓解此问题而创建的安全协议。</p><p>DNSSEC 通过对数据进行数字签名来帮助确保其有效性，从而防止攻击。</p><p>为了确保安全查找，必须在 DNS 查找过程中的<strong>每个级别进行签名</strong>。</p><p>有关 DNSSEC 的更多内容请参考：<a href="https://blog.cloudflare.com/dnssec-an-introduction/?_gl=1*1k44464*_ga*MzE2OTQ0NzY1LjE2NzUxNDM3NzI.*_gid*NjAzODc2NjAyLjE2NzUxNDM3NzI.">DNSSEC: An Introduction (cloudflare.com)</a></p><hr><h3 id="其他内容："><a href="#其他内容：" class="headerlink" title="其他内容："></a>其他内容：</h3><h4 id="DNS防火墙："><a href="#DNS防火墙：" class="headerlink" title="DNS防火墙："></a>DNS防火墙：</h4><p>DNS firewall 是一种可为 DNS 服务器提供众多安全和性能服务的工具。</p><p>DNS firewall 位于用户的递归解析器与他们正尝试访问的网站或服务的权威性域名服务器之间。</p><p>防火墙可提供速率限制服务，以关闭试图淹没服务器的攻击者。如果服务器确实由于攻击或其他任何原因而停机，则 DNS firewall 可通过提供来自高速缓存的 DNS 响应来使运营商的站点或服务保持正常运行。</p><h4 id="用户隐私："><a href="#用户隐私：" class="headerlink" title="用户隐私："></a>用户隐私：</h4><p>DNS 查询未加密。即使用户使用像 1.1.1.1 这样不跟踪他们活动的 DNS 解析器，DNS 查询也会以明文形式在互联网上传输。这意味着拦截查询的任何人都可以看到用户正在访问哪些网站。</p><p><em>还有诸如DNS高速缓存中毒等内容我们暂且略过。</em></p><hr><h2 id="DomainName-域名"><a href="#DomainName-域名" class="headerlink" title="DomainName - 域名"></a>DomainName - 域名</h2><h3 id="0-简介："><a href="#0-简介：" class="headerlink" title="0. 简介："></a>0. 简介：</h3><p>域名是一个文本字符串，映射到一个数字 IP 地址，可用于从客户端软件访问网站。</p><p>简单来说，域名是用户在浏览器窗口中键入以访问特定网站的文本。</p><p>网站的实际地址是一个复杂的数字 IP 地址（例如 103.21.244.0），但由于 DNS 的存在，用户可以输入人类友好的域名并将其路由到他们要查找的网站。此过程称为 DNS 查找。</p><p>域名全部由域名注册管理机构管理。</p><h3 id="1-与URL的区别？"><a href="#1-与URL的区别？" class="headerlink" title="1. 与URL的区别？"></a>1. 与URL的区别？</h3><p>统一资源定位符（URL）有时也称为网址，包含站点的域名以及其他信息，如传输协议和路径等。</p><p>例如，在 URL<code>https://www.bilibili.com/anime/</code>中，<code>www.bilibili.com</code>是域名，而<code>https</code>是协议，<code>/anime/</code>是指向网站上特定页面的路径。</p><h3 id="2-域名的组成部分？"><a href="#2-域名的组成部分？" class="headerlink" title="2. 域名的组成部分？"></a>2. 域名的组成部分？</h3><p>域名通常分为两个或三个部分，各个部分用一个点分隔。</p><p>从右到左阅读时，域名中的<strong>标识符从最广泛到最具体</strong>。</p><p>域名中最后一个点右边的部分是顶级域 (TLD)。</p><p>其中包括<code>.com、.net和.org </code>等通用TLD，以及<code>.uk</code>和<code>.cn</code>等特定国家&#x2F;地区的 TLD。</p><p>TLD 的左侧是第二级域（2LD），如果 2LD 的左侧有任何内容，则称为第三级域（3LD）。</p><h3 id="3-查找可用域名："><a href="#3-查找可用域名：" class="headerlink" title="3. 查找可用域名："></a>3. 查找可用域名：</h3><p>法一：转到域名注册商的网站。他们中的大多数都提供<code>whois</code>服务，告诉您域名是否可用。</p><p>法二：如果使用具有内置 shell 的系统，请在其中键入命令，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ whois mozilla.org</span><br><span class="line">Domain Name:MOZILLA.ORG</span><br><span class="line">Domain ID: D1409563-LROR</span><br><span class="line">Creation Date: 1998-01-24T05:00:00Z</span><br><span class="line">Updated Date: 2013-12-08T01:16:57Z</span><br><span class="line">Registry Expiry Date: 2015-01-23T05:00:00Z</span><br><span class="line">Sponsoring Registrar:MarkMonitor Inc. (R37-LROR)</span><br><span class="line">Sponsoring Registrar IANA ID: 292</span><br><span class="line">WHOIS Server:</span><br><span class="line">Referral URL:</span><br><span class="line">Domain Status: clientDeleteProhibited</span><br><span class="line">Domain Status: clientTransferProhibited</span><br><span class="line">Domain Status: clientUpdateProhibited</span><br><span class="line">Registrant ID:mmr-33684</span><br><span class="line">Registrant Name:DNS Admin</span><br><span class="line">Registrant Organization:Mozilla Foundation</span><br><span class="line">Registrant Street: 650 Castro St Ste 300</span><br><span class="line">Registrant City:Mountain View</span><br><span class="line">Registrant State/Province:CA</span><br><span class="line">Registrant Postal Code:94041</span><br><span class="line">Registrant Country:US</span><br><span class="line">Registrant Phone:+1.6509030800</span><br></pre></td></tr></table></figure><h3 id="4-其他内容"><a href="#4-其他内容" class="headerlink" title="4. 其他内容"></a>4. 其他内容</h3><p>域名的最长保留期是十年。用户可以持有域名超过十年，因为注册商通常让他们无限期地续订域名。但是，用户从来没有真正拥有过这个域名，他们只是租用了它。</p><p><img src="https://www.cloudflare-cn.com/img/learning/dns/glossary/expired-domains/expired-domain-timeline.svg" alt="avatar"></p><p>如果没有人购买过期的域名，它可能会在一定时间后退回到原来的注册机构。它将不再可用，直到注册表决定释放它。</p><hr><h2 id="P2P应用"><a href="#P2P应用" class="headerlink" title="P2P应用"></a>P2P应用</h2><p>暂略</p><hr><h2 id="TCP套接字编程"><a href="#TCP套接字编程" class="headerlink" title="TCP套接字编程"></a>TCP套接字编程</h2><p>暂略</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;em&gt;Computer Networking A Top-Down Approach Learning Note Part 2&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;本文是笔者初学计算机网络的笔记和一些心得，难免会有部分疏漏和错误</summary>
      
    
    
    
    <category term="408" scheme="https://conqueror712.github.io/categories/408/"/>
    
    
  </entry>
  
  <entry>
    <title>XCPC - Retired - Essay</title>
    <link href="https://conqueror712.github.io/post/Retired.html"/>
    <id>https://conqueror712.github.io/post/Retired.html</id>
    <published>2023-03-18T13:45:55.000Z</published>
    <updated>2023-03-20T03:27:12.857Z</updated>
    
    <content type="html"><![CDATA[<img src="https://cdnjson.com/images/2023/03/18/LMFMCSZDLFXRTSDBO.jpg" alt="avatar" style="zoom: 25%;" /><blockquote><p><em>最后的气球</em></p></blockquote><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>退役啦，虽然根本称不上是什么所谓的ACMer，或者叫XCPCer，随便叫什么都可以，现在开始吧，这大约是传统。</p><hr><h2 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h2><p>曾几何时，天真的以为随便学一学就可以有好成绩，却多次面对难题望而生畏。<br>总想着时间还早，之后有状态的时候再努力努力也不迟，然而时间却再次给了我最冰冷而无情的一剑，一年的时间，说结束，也就结束了。没有变成厉害的大牛，只是从当初那个连语法错误都焦头烂额的菜鸟，变成了略知一二的自己，虽然也只是初窥门径。</p><p>强校的环境让我难以触摸参加正式比赛的门槛，但我承认这是因为自己的懒惰导致的，或许也因为没什么天赋吧，技不如人这件事，不是总有办法的。我曾多次幻想过，倘若我身处弱校，是否就有机会加入进XCPC的大家庭呢？我不得而知，或许这只是一个门外汉的望洋兴叹罢了。但转念一想，线上的公开赛不是可以参加吗？有取得好成绩吗？很可惜，答案是否定的。</p><p>谈起关于参加算法竞赛，你是否后悔这件事，显然，我是不后悔的。它充满魅力却又险象丛生。它曾让我无数次彻夜难眠，又暗地里教会了我很多，不只是算法知识而已。</p><p>时常看到别的ACMer的日常和比赛动态，我心中百感交集，我想，倘若真的有平行时空，是不是另一个世界的我，就像他们一样？<br>但在这三天打鱼两天晒网的一年里，我也从一个只会HelloWorld的小小白变成了可以几乎独立开发一个完整的项目的小白，也认识到了不同于纯净的算法世界的编程是什么样子的，即使这花费了我不少时间在上面，如果可以给自己找理由开脱的话，大概就是学了这些开发技术让我没有取得成绩吧（笑）。</p><p>说到理由，学习课内知识算一种理由吗？虽然绩点仅仅是年级的25%，但有这一点的话或许自己心里也会好受一些吧（笑）。<br>没有正式比赛经历，也没有获奖经历的退役小作文很乏味吧，不过我还是想写一写，就当做是写给自己看的了。</p><p>说来可惜，身边也没有志同道合的朋友与我同行，大一下被封在家里的那个春天有太多想要放弃的时候，黑暗的日子里只有一步一步的摸索，好几个月水平也没有任何起色，起起伏伏，跌跌撞撞。倘若当时没有我对象的鼓励，懦弱的我就提前退场了。</p><img src="https://cdnjson.com/images/2023/03/18/image.png" alt="avatar" style="zoom: 67%;" /><blockquote><p><em>那段艰难的日子和永远摆脱不了的灰名</em></p></blockquote><hr><h2 id="校赛与网友"><a href="#校赛与网友" class="headerlink" title="校赛与网友"></a>校赛与网友</h2><p>​所幸在秋天认识了一些网友，可以算是网友吧，在向他们学习的过程中明显感觉到比一人独行更强大的驱动力，很多之前不牢固的基础知识慢慢地补全，甚至第一次，也是唯一一次感受线下的团队赛，虽然是校内的选拔赛，但也给了我莫大的鼓舞和满足。接过气球的那双有些颤抖的手至今无法忘怀。</p><img src="https://cdnjson.com/images/2023/03/18/LQJRQ4OS3DJ9TN968T.jpg" alt="avatar" style="zoom: 33%;" /><blockquote><p><em>我的队伍，以及我们的气球</em></p></blockquote><p>​在此，容我向我的两位队友致歉，身为队长的我没有过硬的实力带领你们进入校队，怪我没有调出那道搜索qwq。真诚地感谢你们的支持与付出，谢谢你们给了我唯一一次这样难忘的经历，谢谢。在这一次新生赛之后看到队友夺金，我心里也算是有了个着落。加油，未来可期！</p><img src="https://cdnjson.com/images/2023/03/18/AP4ERSYPRRKCJFF6.jpg" alt="avatar" style="zoom:33%;" /><blockquote><p><em>杨亚老师给我们开颁奖仪式，好多人呀</em></p></blockquote><hr><h2 id="新生赛"><a href="#新生赛" class="headerlink" title="新生赛"></a>新生赛</h2><p>​说说这次新生赛，开局顺利地签了到，虽然还是手慢了一点，4min才写出签到，按理来说一分钟就够了的，但还是位列第七名，后面直到111分钟才过了下一个题。不过，因为最后封榜阶段开错了题目导致没有出第三题，以我的罚时（只交了3发，WA了一发），如果出了第三题那就至少是银牌了，甚至有可能冲金牌，但遗憾总是贯穿人生始终，最后10分钟才看到较为简单的题目的我已经无力回天，叹了口气写完了最后能写完的代码。结束之后，手迟迟没有从键盘上离开，我知道，属于我的算法竞赛生涯，大抵是结束了。</p><img src="https://cdnjson.com/images/2023/03/18/ELBZMK4CSBEHV0AR.jpg" alt="avatar" style="zoom:50%;" /><blockquote><p><em>赛后，学校为我们准备的好吃的，奶茶好甜，甜到发苦…</em></p></blockquote><img src="https://cdnjson.com/images/2023/03/18/VP8G7AJPXGZ0IYYUO.jpg" alt="avatar" style="zoom: 33%;" /><blockquote><p><em>学长在给我们开颁奖仪式，虽然获奖的并不是我qwq</em></p></blockquote><p>PS：</p><p>赛后，我在图书馆的卫生间把我拿到的珍贵的两颗气球的气放掉了，把瘪瘪的气球拿了回来，也算是亲手为自己的梦想埋上了土吧qwq</p><hr><h2 id="以后"><a href="#以后" class="headerlink" title="以后"></a>以后</h2><p>​以后还会打算法竞赛吗？首先，我没有机会打正式的XCPC了，但是一些小比赛，还有一些线上赛还是可以打一打，保持水平，毕竟以后的笔试还是需要的，而且这也是我的爱好（一个菜鸟恬不知耻的这样说，希望不会被大家笑话就好）。</p><p>​那么以后主要忙什么呢？我想，大概是找实习和学开发吧，现在是大二，明年要考研（学历学历还是学历）。嗯大概就是这样，以后的话会在博客分享一些开发、实习、考研乃至科研的相关内容，如果不嫌弃的话欢迎关注！</p><hr><h2 id="告别"><a href="#告别" class="headerlink" title="告别"></a>告别</h2><p>​差不多到说再见的时候了，天下没有不散的筵席，纵使我想让这筵席更久一些，再久一些，久到我的夙愿可以看见黎明的曙光……<br>但，梦醒了，我也差不多该踏上新的征程了。以后也没有机会再进入XCPC的世界了，即使我从未踏足过，只愿在门前多停留半步也好。</p><p>​或许，算法就像是童话故事，那么纯净，那么梦幻，却也深刻地影响着未来的我们，走到更远的地方。</p><p>​阵阵微风轻抚，朵朵鲜花盛开，缕缕阳光洒下……在这个万物迸发的春天，我却要挥手道别。</p><p>​那就再见吧，江湖路远，何处不天涯？</p><p><img src="https://cdnjson.com/images/2023/03/18/wallhaven-jxx725.jpg" alt="avatar"></p><hr><p>写于2023.03.18 晚。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;https://cdnjson.com/images/2023/03/18/LMFMCSZDLFXRTSDBO.jpg&quot; alt=&quot;avatar&quot; style=&quot;zoom: 25%;&quot; /&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;最后的气球&lt;/em&gt;&lt;/p</summary>
      
    
    
    
    <category term="XCPC" scheme="https://conqueror712.github.io/categories/XCPC/"/>
    
    
  </entry>
  
  <entry>
    <title>XCPC丨算法竞赛汇总</title>
    <link href="https://conqueror712.github.io/post/ICPC.html"/>
    <id>https://conqueror712.github.io/post/ICPC.html</id>
    <published>2023-03-18T12:01:25.000Z</published>
    <updated>2023-03-23T01:29:47.427Z</updated>
    
    <content type="html"><![CDATA[<p>前言：</p><p>2023.03.18正式退役啦，特此来把之前杂乱无章且错误百出的，有关算法竞赛的博客整合起来，汇总成此篇博客。</p><p>（其实是我自己的板子，如果大家有需要就拿去就好啦，能帮到各位的话也算是一种传承吧）</p><blockquote><p>个人博客：<a href="https://conqueror712.github.io/">https://conqueror712.github.io/</a></p><p>知乎：<a href="https://www.zhihu.com/people/soeur712/posts">https://www.zhihu.com/people/soeur712/posts</a></p><p>Bilibili：<a href="https://space.bilibili.com/57089326">https://space.bilibili.com/57089326</a></p><p>掘金：<a href="https://juejin.cn/user/1297878069809725/posts">https://juejin.cn/user/1297878069809725/posts</a></p></blockquote><hr><p><strong>Algorithm Model Version 1.0 - 2023.03 —— by Conqueror712</strong></p><hr><h1 id="Graph-Theory"><a href="#Graph-Theory" class="headerlink" title="Graph - Theory"></a>Graph - Theory</h1><h2 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h2><p>适用情况：单源最短路 + 可有负权</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度：O(nm)</span></span><br><span class="line"><span class="comment">// vector邻接表写法</span></span><br><span class="line">vector &lt;PII&gt; edge[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shortestpath</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">127</span>, <span class="built_in">sizeof</span>(dist));</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">// 在每次迭代中，遍历所有边，尝试用Relieve_Operation更新距离数组</span></span><br><span class="line">        <span class="type">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it : edge[i])&#123;</span><br><span class="line">            <span class="type">int</span> x = i; <span class="type">int</span> y = it.fir; <span class="type">int</span> v = it.sec;</span><br><span class="line">            <span class="keyword">if</span> (dist[x] &lt; (<span class="number">1</span> &lt;&lt; <span class="number">30</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span> (dist[x] + v &lt; dist[y])&#123;</span><br><span class="line">                    dist[y] = dist[x] + v; ok = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!ok)&#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[t];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><p>适用情况：单源最短路 + 无负权</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆优化Version 时间复杂度：O((n + m)logn)</span></span><br><span class="line"><span class="comment">// 用一个堆来维护dist数组，可以使用set，也可以使用priority_queue</span></span><br><span class="line">vector &lt;PII&gt; edge[N];</span><br><span class="line">set &lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">vector &lt;PII&gt; edge[N];</span><br><span class="line"><span class="type">int</span> n, m, dist[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">127</span>, <span class="built_in">sizeof</span>(dist));</span><br><span class="line">    dist[s] = <span class="number">0</span>; q.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        q.<span class="built_in">insert</span>(&#123;dist[i], i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x = q.<span class="built_in">begin</span>()-&gt;sec;</span><br><span class="line">        q.<span class="built_in">erase</span>(q.<span class="built_in">begin</span>());</span><br><span class="line">        <span class="keyword">if</span> (x == t || dist[x] &gt; (<span class="number">1</span> &lt;&lt; <span class="number">30</span>))&#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : edge[x])&#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[x] + p.sec &lt; dist[p.fir])&#123;</span><br><span class="line">                q.<span class="built_in">erase</span>(&#123;dist[p.fir], p.fir&#125;);</span><br><span class="line">                dist[p.fir] = dist[x] + p.sec;</span><br><span class="line">                q.<span class="built_in">insert</span>(&#123;dist[p.fir], p.fir&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[t];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h2><p>适用情况：多源最短路 + 可有负权</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空间优化Version 时间复杂度：O(n^3) 空间复杂度：O(n^2) </span></span><br><span class="line"><span class="comment">// 邻接矩阵写法</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="type">int</span> v[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Floyd</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(v, <span class="number">127</span>, <span class="built_in">sizeof</span>(v));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            v[i][j] = a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (v[i][k] &lt; (<span class="number">1</span> &lt;&lt; <span class="number">30</span>) &amp;&amp; v[k][j] &lt; (<span class="number">1</span> &lt;&lt; <span class="number">30</span>))&#123;</span><br><span class="line">                    v[i][j] = <span class="built_in">min</span>(v[i][j], v[i][k] + v[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h2><p>适用场景：稠密图</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆优化Version 时间复杂度：O((n+m)logn)</span></span><br><span class="line">set &lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">vector &lt;PII&gt; edge[N];   <span class="comment">// 边集</span></span><br><span class="line"><span class="type">int</span> n, m, dist[N];      <span class="comment">// dist集</span></span><br><span class="line"><span class="type">bool</span> b[N];              <span class="comment">// 存在性集</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(b, <span class="literal">false</span>, <span class="built_in">sizeof</span>(b));</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">127</span>, <span class="built_in">sizeof</span>(dist));</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        q.<span class="built_in">insert</span>(&#123;dist[i], i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x = q.<span class="built_in">begin</span>()-&gt;sec;</span><br><span class="line">        q.<span class="built_in">erase</span>(q.<span class="built_in">begin</span>());</span><br><span class="line">        <span class="keyword">if</span> (dist[x] &gt; (<span class="number">1</span> &lt;&lt; <span class="number">30</span>))&#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">        ++tot; ans += dist[x]; b[x] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : edge[x])&#123;</span><br><span class="line">            <span class="keyword">if</span> (!b[i.fir] &amp;&amp; i.sec &lt; dist[i.fir])&#123;</span><br><span class="line">                q.<span class="built_in">erase</span>(&#123;dist[i.fir], i.fir&#125;);</span><br><span class="line">                dist[i.fir] = i.sec;</span><br><span class="line">                q.<span class="built_in">insert</span>(&#123;dist[i.fir], i.fir&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tot != n)&#123; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123; <span class="keyword">return</span> ans; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h2><p>适用场景：稀疏图</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度：O(mlogn)</span></span><br><span class="line"><span class="type">int</span> n, m, fa[N];    <span class="comment">// fa是并查集的代表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y, v;    <span class="comment">// x, y代表这条边连接的两个点，v代表这条边的边权</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Node &amp;A) <span class="type">const</span>&#123;  <span class="comment">// 重构 &lt; 运算符</span></span><br><span class="line">        <span class="keyword">return</span> v &lt; A.v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; a[M];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FindSet</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == fa[i])&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[i] = <span class="built_in">FindSet</span>(fa[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        fa[i] = i;  <span class="comment">// 并查集初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + m + <span class="number">1</span>); <span class="comment">// 按边权排序</span></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>; <span class="type">int</span> cnt = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">FindSet</span>(a[i].x);</span><br><span class="line">        <span class="type">int</span> y = <span class="built_in">FindSet</span>(a[i].y);</span><br><span class="line">        <span class="keyword">if</span> (x != y)&#123;</span><br><span class="line">            fa[x] = y;</span><br><span class="line">            ans += a[i].v;</span><br><span class="line">            --cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">1</span>)&#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt != <span class="number">1</span>)&#123; <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">/*多于一个连通块*/</span> &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123; <span class="keyword">return</span> ans; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TopoSort"><a href="#TopoSort" class="headerlink" title="TopoSort"></a>TopoSort</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// STL写法 时间复杂度：O(n + m)</span></span><br><span class="line"><span class="comment">// 在进行TopoSort之前要先算好每个点的d，也就是入度</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">TopoSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 队列S</span></span><br><span class="line">    queue &lt;<span class="type">int</span>&gt; s, l;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!d[i])&#123;</span><br><span class="line">            <span class="comment">// 入度为0，加到S里面去</span></span><br><span class="line">            s.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当队列非空的时候</span></span><br><span class="line">    <span class="keyword">while</span> (s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="comment">// 将x加入到L的队尾，并把x从S中删去</span></span><br><span class="line">        <span class="type">int</span> x = s.<span class="built_in">front</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        l.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="comment">// 遍历x的所有边，令y的入度--，再判断如果此时y的入度为0，加进队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> y : edge[x])&#123;</span><br><span class="line">            <span class="keyword">if</span> (--d[y] == <span class="number">0</span>)&#123;</span><br><span class="line">                s.<span class="built_in">push</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断L里面有多少个点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">int</span>(l.<span class="built_in">size</span>()) == n)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;  </span><br><span class="line">        <span class="comment">// q中记录了一个合法的拓扑序列</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 有环</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字典序最小/最大的拓扑序 时间复杂度：O(nlogn + m)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">TopoSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 优先队列S</span></span><br><span class="line">    queue &lt;<span class="type">int</span>&gt; l;</span><br><span class="line">    priority_queue &lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!d[i])&#123;</span><br><span class="line">            <span class="comment">// 入度为0，加到S里面去</span></span><br><span class="line">            s.<span class="built_in">push</span>(-i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当队列非空的时候</span></span><br><span class="line">    <span class="keyword">while</span> (s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x = -s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        l.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="comment">// 遍历x的所有边，令y的入度--，再判断如果此时y的入度为0，加进队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> y : edge[x])&#123;</span><br><span class="line">            <span class="keyword">if</span> (--d[y] == <span class="number">0</span>)&#123;</span><br><span class="line">                s.<span class="built_in">push</span>(-y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (l.<span class="built_in">size</span>())&#123;</span><br><span class="line">        cout &lt;&lt; l.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        l.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Euler-Road"><a href="#Euler-Road" class="headerlink" title="Euler Road"></a>Euler Road</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有向图的欧拉路</span></span><br><span class="line"><span class="comment">// 此代码的假设是将图中所有的有向边改为无向边后，图中所有度非零的点是联通的</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>, M = <span class="number">10010</span>;</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; edge[N]; <span class="comment">// 存边</span></span><br><span class="line"><span class="comment">// f[i]表示i里面0到f[i - 1]那些边已经走过了 下次要走f[i]了 防止重复枚举</span></span><br><span class="line"><span class="comment">// ind入度 outd出度 c用来记路径</span></span><br><span class="line"><span class="type">int</span> n, m, l, f[N], ind[N], outd[N], c[M];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (f[x] &lt; outd[x])&#123;</span><br><span class="line"><span class="comment">// 这条边要存在</span></span><br><span class="line"><span class="type">int</span> y = edge[x][f[x]];</span><br><span class="line">f[x]++;</span><br><span class="line"><span class="built_in">dfs</span>(y);</span><br><span class="line">c[++l] = y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Euler</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// x是起点</span></span><br><span class="line"><span class="comment">// y表示有多少个点的出度比入度大1</span></span><br><span class="line"><span class="comment">// z是有多少点的出度不等于入度</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, z = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 枚举每个点</span></span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, n)&#123;</span><br><span class="line"><span class="comment">// y的情况</span></span><br><span class="line"><span class="keyword">if</span> (ind[i] + <span class="number">1</span> == outd[i])&#123;</span><br><span class="line"><span class="comment">// 可能是起点</span></span><br><span class="line">x = i, ++y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// z的情况</span></span><br><span class="line"><span class="keyword">if</span> (ind[i] != outd[i])&#123;</span><br><span class="line">++z;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!((y == <span class="number">1</span> &amp;&amp; z == <span class="number">2</span>) || !z))&#123;</span><br><span class="line"><span class="comment">// 没有欧拉路</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 起点还没找到 写!z也可以</span></span><br><span class="line"><span class="keyword">if</span> (!x)&#123;</span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, n)&#123;</span><br><span class="line"><span class="keyword">if</span> (ind[i])&#123;</span><br><span class="line">x = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">l = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">dfs</span>(x);</span><br><span class="line">c[++l] = x;</span><br><span class="line"><span class="keyword">if</span> (l == m + <span class="number">1</span>)&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// per(i, l, 1)&#123;</span></span><br><span class="line"><span class="comment">// cout &lt;&lt; c[i] &lt;&lt; &quot; \n&quot;[i == 1];</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -------------------------------</span></span><br><span class="line"><span class="comment">// 以下是main函数的一部分 记得更改d数组</span></span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, m)&#123;</span><br><span class="line"><span class="type">char</span> str[<span class="number">101</span>];</span><br><span class="line">cin &gt;&gt; str;</span><br><span class="line"><span class="type">int</span> x = str[<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>, y = str[<span class="built_in">strlen</span>(str) - <span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">edge[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">++outd[x];</span><br><span class="line">++ind[y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Euler</span>();</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无向图的欧拉路</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>, M = <span class="number">10010</span>;</span><br><span class="line"><span class="comment">// 存边 fir为去向 sec为idx</span></span><br><span class="line">vector &lt;PII&gt; edge[N];</span><br><span class="line"><span class="type">int</span> n, m, l, cnt = <span class="number">1</span>, f[N], d[N], v[N], c[M];</span><br><span class="line"><span class="type">bool</span> b[<span class="number">2</span> * M];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (f[x] &lt; v[x])&#123;</span><br><span class="line"><span class="comment">// 这条边要存在</span></span><br><span class="line"><span class="type">int</span> y = edge[x][f[x]].fir, idx = edge[x][f[x]].sec;</span><br><span class="line"><span class="keyword">if</span> (!b[idx])&#123;</span><br><span class="line">f[x]++;</span><br><span class="line">b[idx] = b[idx ^ <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">dfs</span>(y);</span><br><span class="line">c[++l] = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">f[x]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Euler</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 枚举每个点</span></span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, n)&#123;</span><br><span class="line"><span class="keyword">if</span> (d[i] &amp; <span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">// 可能是起点</span></span><br><span class="line">x = i, ++y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (y &amp;&amp; y != <span class="number">2</span>)&#123;</span><br><span class="line"><span class="comment">// 没有欧拉路</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!x)&#123;</span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, n)&#123;</span><br><span class="line"><span class="keyword">if</span> (d[i])&#123;</span><br><span class="line">x = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line"><span class="built_in">memset</span>(b, <span class="literal">false</span>, <span class="built_in">sizeof</span>(b));</span><br><span class="line">l = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">dfs</span>(x);</span><br><span class="line">c[++l] = x;</span><br><span class="line"><span class="keyword">if</span> (l != m + <span class="number">1</span>)&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">per</span>(i, l, <span class="number">1</span>)&#123;</span><br><span class="line">cout &lt;&lt; c[i] &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ------------------------------</span></span><br><span class="line"><span class="comment">// 以下是main函数的一部分 记得更改d数组</span></span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, m)&#123;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">edge[x].<span class="built_in">push_back</span>(&#123;y, ++cnt&#125;);</span><br><span class="line">edge[y].<span class="built_in">push_back</span>(&#123;x, ++cnt&#125;);</span><br><span class="line">++d[x];</span><br><span class="line">++d[y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, n)&#123;</span><br><span class="line">v[i] = edge[i].<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Euler</span>();</span><br></pre></td></tr></table></figure><h2 id="Bipartite-Graph"><a href="#Bipartite-Graph" class="headerlink" title="Bipartite Graph"></a>Bipartite Graph</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 染色法判别二分图 时间复杂度：O(n + m)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>;</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; edge[N];</span><br><span class="line"><span class="comment">// c数组存颜色 即color 1和2是不同的颜色 0代表还没染过色</span></span><br><span class="line"><span class="type">int</span> n, m, c[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">// 遍历x的边 然后递归下去就是遍历x的连通块</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> y : edge[x])&#123;</span><br><span class="line"><span class="keyword">if</span> (!c[y])&#123;</span><br><span class="line"><span class="comment">// 还没染过色 染之</span></span><br><span class="line">c[y] = <span class="number">3</span> - c[x];</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">dfs</span>(y))&#123;</span><br><span class="line"><span class="comment">// 染不动了</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (c[x] == c[y])&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="built_in">sizeof</span>(c))</span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, n)&#123;</span><br><span class="line"><span class="keyword">if</span> (!c[i])&#123;</span><br><span class="line">c[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">dfs</span>(i))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求二分图最大匹配 时间复杂度：O(nm)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="comment">// edge只记左边的点</span></span><br><span class="line">vector &lt;<span class="type">int</span>&gt; edge[N];</span><br><span class="line"><span class="comment">// v[i]表示有右边的第i个点 如果有匹配 匹配的是左边的哪个点 没有就为0</span></span><br><span class="line"><span class="type">int</span> n, m, n1, n2, v[N];</span><br><span class="line"><span class="type">bool</span> b[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">b[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> y : edge[x])&#123;</span><br><span class="line"><span class="keyword">if</span> (!v[y] || (!b[v[y]] &amp;&amp; <span class="built_in">Find</span>(v[y])))&#123;</span><br><span class="line">v[y] = x;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">match</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="built_in">sizeof</span>(v));</span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, n1)&#123;</span><br><span class="line"><span class="built_in">memset</span>(b, <span class="literal">false</span>, <span class="built_in">sizeof</span>(b));</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Find</span>(i))&#123;</span><br><span class="line"><span class="comment">// dfs</span></span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">最大独立集</span><br><span class="line">在图中选出最多的点，满足他们两两之间没有边相连。</span><br><span class="line"></span><br><span class="line">最大独立集.size = n - 最大匹配数</span><br><span class="line"></span><br><span class="line">最小点覆盖</span><br><span class="line">在图中选出最少的点，使得每条边的两个端点中至少有一个在集合里</span><br><span class="line"></span><br><span class="line">最小点覆盖.size = 最大匹配数</span><br></pre></td></tr></table></figure><hr><h1 id="Data-Structure"><a href="#Data-Structure" class="headerlink" title="Data - Structure"></a>Data - Structure</h1><p><em>Chain - Table：Skipped, I don’t like it.</em></p><hr><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组实现队列的简单操作</span></span><br><span class="line"><span class="type">int</span> q[<span class="number">100010</span>];</span><br><span class="line"><span class="type">int</span> front = <span class="number">1</span>, rear = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    q[++rear] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ++front;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;  <span class="comment">// 询问第k个元素</span></span><br><span class="line">    <span class="comment">// 如何判断队列里有几个元素？ rear - front + 1即可</span></span><br><span class="line">    <span class="keyword">return</span> q[front + k - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Top</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q[front];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组实现循环队列</span></span><br><span class="line"><span class="comment">// 有些时候 入队出队次数 远远大于 队伍的元素个数，那么开很大的数组就浪费空间了</span></span><br><span class="line"><span class="comment">// 于是我们就让 当队尾指针移动到数组末端时，再将其移动到数组头即可，反之亦然</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> size = <span class="number">1010</span>;            <span class="comment">// size要严格大于队列最长的时候的长度</span></span><br><span class="line"><span class="type">int</span> q[size];</span><br><span class="line"><span class="type">int</span> front = <span class="number">1</span>, rear = size;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    rear = rear % size + <span class="number">1</span>;</span><br><span class="line">    q[rear] = x;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    front = front % size + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rear % size + <span class="number">1</span> == front;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (front + x - <span class="number">1</span> &lt;= size)&#123;</span><br><span class="line">        <span class="keyword">return</span> q[front + x - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q[front + x - <span class="number">1</span> - size];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈的数组实现</span></span><br><span class="line"><span class="type">int</span> s[<span class="number">100010</span>];  <span class="comment">// 创建栈</span></span><br><span class="line"><span class="type">int</span> top = <span class="number">0</span>;  <span class="comment">// 创建头指针，一开始在底部</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    s[++top] = x;        <span class="comment">//先移动top 再赋值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        --top;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Top</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s[top];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;  <span class="comment">// 查询从栈顶往下数第k个元素是多少</span></span><br><span class="line">    <span class="keyword">return</span> s[top+<span class="number">1</span>-k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Binary-Tree"><a href="#Binary-Tree" class="headerlink" title="Binary - Tree"></a>Binary - Tree</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 指针建立二叉树</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *l, *r, *fa;</span><br><span class="line">&#125; a[<span class="number">100010</span>];</span><br><span class="line"><span class="comment">// 插入子节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(TreeNode *fa, TreeNode *p, <span class="type">int</span> flag)</span></span>&#123;</span><br><span class="line">    <span class="comment">// flag = 0 插入到左边 flag = 1 插入到右边</span></span><br><span class="line">    <span class="keyword">if</span> (!flag)&#123; fa-&gt;l = p; &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123; fa-&gt;r = p; &#125;</span><br><span class="line">    p-&gt;fa = fa;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(TreeNode *p)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; p-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;l) <span class="built_in">PreOrder</span>(p-&gt;l);</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;r) <span class="built_in">PreOrder</span>(p-&gt;r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(TreeNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;l) <span class="built_in">InOrder</span>(p-&gt;l);</span><br><span class="line">    cout &lt;&lt; p-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;r) <span class="built_in">InOrder</span>(p-&gt;r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(TreeNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;l) <span class="built_in">PostOrder</span>(p-&gt;l);</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;r) <span class="built_in">PostOrder</span>(p-&gt;r);</span><br><span class="line">    cout &lt;&lt; p-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> l, r; cin &gt;&gt; l &gt;&gt; r; a[i].val = i;</span><br><span class="line">        <span class="keyword">if</span> (l != <span class="number">0</span>)&#123; a[i].l = &amp;a[l]; a[l].fa = &amp;a[i]; &#125;</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="number">0</span>)&#123; a[i].r = &amp;a[r]; a[r].fa = &amp;a[i]; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">PreOrder</span>(&amp;a[<span class="number">1</span>]); cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">InOrder</span>(&amp;a[<span class="number">1</span>]); cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">PostOrder</span>(&amp;a[<span class="number">1</span>]); cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">0 0</span></span><br><span class="line"><span class="comment">4 0</span></span><br><span class="line"><span class="comment">0 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h2 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆的数组实现</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxsize = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>;    <span class="comment">// 记录当前size</span></span><br><span class="line"><span class="comment">// int heap[Maxsize]; 这是数组实现 我们选择vector</span></span><br><span class="line">vector &lt;<span class="type">int</span>&gt; heap;</span><br><span class="line"><span class="comment">// 每一次插入新的数据，都要和它的父节点比一比（判别依据是根据本来是大根堆||小根堆）</span></span><br><span class="line"><span class="comment">// 以小根堆举例，插入的复杂度为O(logn)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Up</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(k &gt; <span class="number">1</span> &amp;&amp; heap[k] &lt; heap[k / <span class="number">2</span>])&#123;</span><br><span class="line">        <span class="built_in">swap</span>(heap[k], heap[k / <span class="number">2</span>]);</span><br><span class="line">        k /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    heap[++len] = x;</span><br><span class="line">    <span class="built_in">Up</span>(len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 堆最常用的功能就是维护min||max</span></span><br><span class="line"><span class="comment">// 以小根堆为例，我们常常会求得最小的数字，然后让它出堆；</span></span><br><span class="line"><span class="comment">// 这时候我们就要从堆中删除堆顶元素。</span></span><br><span class="line"><span class="comment">// 由于这时除了堆顶为空，它的左右子树堆仍然满足堆结构。</span></span><br><span class="line"><span class="comment">// 为了操作简单，我们将堆尾元素放到堆顶，然后再将其&quot;逐 步 下 移&quot;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Down</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(k + k &lt;= len)&#123;</span><br><span class="line">        <span class="type">int</span> j = k + k;</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= len &amp;&amp; heap[j + <span class="number">1</span>] &lt; heap[j])&#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (heap[k] &lt;= heap[j])&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(heap[k], heap[j]);</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(heap[<span class="number">1</span>], heap[len]);</span><br><span class="line">    len--;</span><br><span class="line">    <span class="built_in">Down</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除堆中任意一个元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == len)&#123;</span><br><span class="line">        heap[len] = <span class="number">0</span>;</span><br><span class="line">        len--;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x = heap[p];</span><br><span class="line">    <span class="type">int</span> y = heap[len];</span><br><span class="line">    <span class="built_in">swap</span>(heap[p],heap[len]);</span><br><span class="line">    len--;</span><br><span class="line">    <span class="keyword">if</span> (y &lt; x)&#123;</span><br><span class="line">        <span class="built_in">Up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">Down</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// STL - Heap</span></span><br><span class="line"><span class="comment">// 大根堆：</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line"><span class="comment">// 小根堆：</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line"><span class="comment">// 基本操作：empty size top push pop...(没有clear)</span></span><br></pre></td></tr></table></figure><hr><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般的情况就用unordered_map来做就可以了，如果被卡了就换成map</span></span><br><span class="line"><span class="comment">// 如果需要解决值冲突，需要二次哈希甚至三次哈希，那么就需要用正经的哈希函数来搞了，我暂时用不到，故暂略之</span></span><br></pre></td></tr></table></figure><hr><h2 id="Monotone-Stack-and-Queue"><a href="#Monotone-Stack-and-Queue" class="headerlink" title="Monotone - Stack and Queue"></a>Monotone - Stack and Queue</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PS: 用的不是很好</span></span><br><span class="line"><span class="comment">// 单调栈模板</span></span><br><span class="line"><span class="comment">// 从下往上元素单调递减</span></span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, n)&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="comment">/* 栈非空 &amp;&amp; 栈顶元素 &lt; a[i] */</span>)&#123;</span><br><span class="line"><span class="comment">// 栈顶元素所在位置答案为i</span></span><br><span class="line"><span class="comment">// 弹出栈顶元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将a[i]入栈 并记录其位置</span></span><br><span class="line">&#125;<span class="comment">// 清空栈 栈中元素所在位置答案为0</span></span><br><span class="line"><span class="comment">// ---------------------------------------</span></span><br><span class="line"><span class="comment">// 单调队列模板</span></span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, n)&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="comment">/*队列非空 &amp;&amp; 队尾元素 &lt;= a[i]*/</span>)&#123;</span><br><span class="line"><span class="comment">// 弹出队尾元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将a[i]加入队尾</span></span><br><span class="line"><span class="comment">// 如果队首元素已经&quot;过气&quot;，将其出队</span></span><br><span class="line"><span class="comment">// 队首为当前区间的答案</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PS：用的不是很好</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line">VI edges[N];</span><br><span class="line"><span class="comment">// 数组里面的每一个元素都是一个vector，就是用vector来存树，当然也可以用链表来存</span></span><br><span class="line"><span class="comment">// edges[i]（这是个vector）就代表第i个点的所有子节点的下标</span></span><br><span class="line"><span class="type">int</span> n, fa[N];<span class="comment">// n代表树里面有多少个节点，fa[]代表节点的父节点编号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    edges[x].<span class="built_in">pb</span>(y);<span class="comment">// 给x节点添加一个儿子y</span></span><br><span class="line">    fa[y] = x;<span class="comment">// 更新y的父节点信息（对于有根树而言）</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintSon</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 遍历x的所有儿子</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : edges[x])&#123;</span><br><span class="line">        cout &lt;&lt; edges[x][i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">VI dfn;<span class="comment">// 有根树的DFS序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    dfn.<span class="built_in">pb</span>(x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="comment">/*x的所有儿子y*/</span>)&#123;</span><br><span class="line">        <span class="built_in">DFS</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有根树的BFS序 q中出现的元素顺序即BFS序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 将root加入队列q</span></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="comment">// x = q队首元素;</span></span><br><span class="line">        <span class="comment">// x出队;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="comment">/*x的所有儿子y*/</span>)&#123;</span><br><span class="line">            <span class="comment">// y入队;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Trie-Tree"><a href="#Trie-Tree" class="headerlink" title="Trie Tree"></a>Trie Tree</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> charsize = <span class="number">26</span>;    <span class="comment">// 字符集大小</span></span><br><span class="line"><span class="type">int</span> nxt[N][charsize];   <span class="comment">// 记录此节点的子节点编号（默认全是小写字母）</span></span><br><span class="line"><span class="type">bool</span> isEnd[N];  <span class="comment">// 表示此编号节点是否为终止节点</span></span><br><span class="line"><span class="type">int</span> root = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;    <span class="comment">// 表示当前的节点编号数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(string s, <span class="type">int</span> len)</span></span>&#123;  <span class="comment">// s为等待插入的字符串，0_base，len为字符串长度</span></span><br><span class="line">    <span class="type">int</span> now = <span class="number">0</span>;    <span class="comment">// 当前在哪个节点上</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;   <span class="comment">// 遍历</span></span><br><span class="line">        <span class="type">int</span> x = s[i] - <span class="string">&#x27;a&#x27;</span>;     <span class="comment">// 转成数字</span></span><br><span class="line">        <span class="keyword">if</span> (!nxt[now][x])&#123;     <span class="comment">// 如果当前节点没有子节点x，则创建之，并且给予编号</span></span><br><span class="line">            nxt[now][x] = ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        now = nxt[now][x];     <span class="comment">// 无论创建了新节点与否，都更新当前节点的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    isEnd[now] = <span class="literal">true</span>;          <span class="comment">// 最后的最后，把该字符串的最后一个字符的isEnd标记为true</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// s为等待插入的字符串，0_base，len为字符串长度</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">search</span><span class="params">(string s, <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> now = <span class="number">0</span>;    <span class="comment">//和上面一样，记录当前在看的节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;  <span class="comment">//遍历之</span></span><br><span class="line">        <span class="type">int</span> x = s[i] - <span class="string">&#x27;a&#x27;</span>;     <span class="comment">//转成数字</span></span><br><span class="line">        <span class="keyword">if</span> (!nxt[now][x])&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;<span class="comment">//如果当前节点没有子节点x，则直接返回false</span></span><br><span class="line">        now = nxt[now][x];     <span class="comment">//如果没有return则更新当前节点位置，继续循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isEnd[now];          <span class="comment">//最后进行判断最后一个字符是否是结束位置，返回即可</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 字典树的删除比较罕见 暂略</span></span><br><span class="line"><span class="comment">/*字符集较大的时候请使用哈希</span></span><br><span class="line"><span class="comment">struct TreeNode&#123;</span></span><br><span class="line"><span class="comment">    unordered_map &lt;char, int&gt; nxt;</span></span><br><span class="line"><span class="comment">    bool isEnd;</span></span><br><span class="line"><span class="comment">&#125; tree[N];*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 例题描述：n个字符串s1~sn和m组询问，每次询问一个字符串是否在s1~sn中出现过，有1，无0</span></span><br><span class="line">    ios;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">insert</span>(s, len);</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        cout &lt;&lt; <span class="built_in">search</span>(s, len) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Union-Find-Set"><a href="#Union-Find-Set" class="headerlink" title="Union - Find - Set"></a>Union - Find - Set</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一开始有n个元素，互相独立，则构成了n个集合，每个集合的代表元素就是它本身</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> fa[maxn + <span class="number">1</span>];   <span class="comment">// fa数组记录每个元素由谁代表</span></span><br><span class="line"><span class="type">int</span> sz[maxn + <span class="number">1</span>];   <span class="comment">// sz数组记录每个集合的元素个数</span></span><br><span class="line"><span class="type">int</span> dep[maxn + <span class="number">1</span>];  <span class="comment">// dep数组记录每个集合的树深度</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Initialize</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123; <span class="comment">// 一共有n个点</span></span><br><span class="line">        fa[i] = i;              <span class="comment">// 把代表元素设置为自己</span></span><br><span class="line">        sz[i] = dep[i] = <span class="number">1</span>;     <span class="comment">// 一开始的深度就是1，子树大小也是1，因为只有自己孤零零的一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Findset</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == fa[x])&#123;    <span class="comment">//如果就是代表元素就直接返回咯</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    fa[x] = <span class="built_in">Findset</span>(fa[x]);      <span class="comment">//在不是的情况下每一次都设置一遍</span></span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;<span class="comment">// 启发式合并O(logn)</span></span><br><span class="line">    <span class="type">int</span> fx = <span class="built_in">Findset</span>(x);</span><br><span class="line">    <span class="type">int</span> fy = <span class="built_in">Findset</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (fx == fy)&#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (sz[fx] &gt; sz[fy])&#123; <span class="built_in">swap</span>(fx, fy); &#125; <span class="comment">// 确定谁是骡子谁是马</span></span><br><span class="line">    fa[fx] = fy; sz[fy] += sz[fx];   <span class="comment">//子树的大小也要加起来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Segment-Tree"><a href="#Segment-Tree" class="headerlink" title="Segment Tree"></a>Segment Tree</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*线段树和树状数组在复杂度上同级, 但是树状数组的常数明显优于线段树, 其编程复杂度也远小于线段树. 树状数组的作用被线段树完全涵盖, 凡是可以使用树状数组解决的问题, 使用线段树一定可以解决, 但是线段树能够解决的问题树状数组未必能够解决。于是我们这里暂时就学线段树就可以了。*/</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="comment">// f[i]记录的是编号为i的节点 记录的区间和</span></span><br><span class="line"><span class="comment">// v[i]记录的是编号为i的节点 整体要加上v[i]</span></span><br><span class="line"><span class="type">int</span> n, m, f[<span class="number">4</span> * N], a[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuildTree</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">//k是编号 l r是左端点和右端点</span></span><br><span class="line"><span class="keyword">if</span> (l == r)&#123;</span><br><span class="line"><span class="comment">//走到叶子节点了，走不动了</span></span><br><span class="line">f[k] = a[l];<span class="comment">//f[k] = a[r]当然也可以，无所谓</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = (l + r) / <span class="number">2</span>;<span class="comment">//这里可以用(l + r) &gt;&gt; 1，也是除以2的意思</span></span><br><span class="line"><span class="comment">//获得了当前区间的中点，开始分割递归</span></span><br><span class="line"><span class="built_in">BuildTree</span>(k + k, l, mid);</span><br><span class="line"><span class="built_in">BuildTree</span>(k + k + <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">f[k] = f[k + k] + f[k + k + <span class="number">1</span>];</span><br><span class="line"><span class="comment">//这里是用到了完全二叉树的节点编号的性质，父节点为k，则两个子节点分别为k + k和k + k + 1</span></span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//整棵树就建好了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="comment">//k是编号</span></span><br><span class="line"><span class="comment">//递归的去从根节点开始加val，一直加到点x上</span></span><br><span class="line">f[k] += val;</span><br><span class="line"><span class="keyword">if</span> (l == r)&#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (x &lt;= mid)&#123;</span><br><span class="line"><span class="comment">//如果x在mid的左边，也就是说要往左子树递归</span></span><br><span class="line"><span class="built_in">Add</span>(k + k, l, mid, x, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//如果x在mid的右边，也就是说要往右子树递归</span></span><br><span class="line"><span class="built_in">Add</span>(k + k + <span class="number">1</span>, mid + <span class="number">1</span>, r, x, val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line"><span class="comment">//编号为k的点对应的区间是l~r，s~t是其子区间</span></span><br><span class="line"><span class="keyword">if</span> (l == s &amp;&amp; r == t)&#123; <span class="keyword">return</span> f[k]; &#125;</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (t &lt;= mid)&#123;</span><br><span class="line"><span class="comment">//如果s~t完全位于左区间</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">calc</span>(k + k, l, mid, s, t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s &gt; mid)&#123;</span><br><span class="line"><span class="comment">//如果s~t完全位于右区间</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">calc</span>(k + k + <span class="number">1</span>, mid + <span class="number">1</span>, r, s, t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//如果s~t横跨两边，加起来即可</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">calc</span>(k + k, l, mid, s, mid) + <span class="built_in">calc</span>(k + k + <span class="number">1</span>, mid + <span class="number">1</span>, r, mid + <span class="number">1</span>, t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios;</span><br><span class="line"><span class="comment">// m次操作</span></span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归建树</span></span><br><span class="line"><span class="built_in">BuildTree</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line"><span class="type">int</span> op, x, y;</span><br><span class="line">cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;</span><br><span class="line"><span class="keyword">if</span> (op == <span class="number">1</span>)&#123;<span class="comment">// 操作1：第x个数加上y</span></span><br><span class="line"><span class="built_in">Add</span>(<span class="number">1</span>, <span class="number">1</span>, n, x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="comment">// 操作2：查询区间x~y的区间和</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">calc</span>(<span class="number">1</span>, <span class="number">1</span>, n, x, y) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带标记的线段树</span></span><br><span class="line"><span class="comment">// 上面一部分 + 下面一部分</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500010</span>;</span><br><span class="line">ll n, m, a[N], f[<span class="number">4</span> * N], v[N]; <span class="comment">//f[i]记录的是编号为i的节点记录的区间和</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">BuildTree</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">//k是编号 l r是左端点和右端点</span></span><br><span class="line"><span class="keyword">if</span> (l == r)&#123;</span><br><span class="line"><span class="comment">//走到叶子节点了，走不动了</span></span><br><span class="line">f[k] = a[l];<span class="comment">//f[k] = a[r]当然也可以，无所谓</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;<span class="comment">//这里可以用(l + r) &gt;&gt; 1，也是除以2的意思</span></span><br><span class="line"><span class="comment">//获得了当前区间的中点，开始分割递归</span></span><br><span class="line"><span class="built_in">BuildTree</span>(k + k, l, mid);</span><br><span class="line"><span class="built_in">BuildTree</span>(k + k + <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">f[k] = f[k + k] + f[k + k + <span class="number">1</span>];</span><br><span class="line"><span class="comment">//这里是用到了完全二叉树的节点编号的性质，父节点为k，则两个子节点分别为k + k和k + k + 1</span></span><br><span class="line"><span class="comment">//整棵树就建好了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, ll z)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == x &amp;&amp; r == y)&#123;</span><br><span class="line">v[k] += z;<span class="comment">// 这里的f不用改，因为只考虑其子树下面的和</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">f[k] += (y - x + <span class="number">1</span>) * z;</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (y &lt;= mid)&#123;</span><br><span class="line"><span class="built_in">Insert</span>(k + k, l, mid, x, y, z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt; mid)&#123;</span><br><span class="line"><span class="built_in">Insert</span>(k + k + <span class="number">1</span>, mid + <span class="number">1</span>, r, x, y, z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">Insert</span>(k + k, l, mid, x, mid, z);</span><br><span class="line"><span class="built_in">Insert</span>(k + k + <span class="number">1</span>, mid + <span class="number">1</span>, r, mid + <span class="number">1</span>, y, z);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, ll p)</span></span>&#123;</span><br><span class="line"><span class="comment">//编号为k的点对应的区间是l~r x~y是其子区间 p是根到当前的点的v的和</span></span><br><span class="line">p += v[k];</span><br><span class="line"><span class="keyword">if</span> (l == x &amp;&amp; r == y)&#123;</span><br><span class="line"><span class="keyword">return</span> p * (r - l + <span class="number">1</span>) + f[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (y &lt;= mid)&#123;</span><br><span class="line"><span class="comment">//如果完全位于左区间</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">calc</span>(k + k, l, mid, x, y, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt; mid)&#123;</span><br><span class="line"><span class="comment">//如果完全位于右区间</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">calc</span>(k + k + <span class="number">1</span>, mid + <span class="number">1</span>, r, x, y, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//如果横跨两边，加起来即可</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">calc</span>(k + k, l, mid, x, mid, p) + <span class="built_in">calc</span>(k + k + <span class="number">1</span>, mid + <span class="number">1</span>, r, mid + <span class="number">1</span>, y, p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归建树</span></span><br><span class="line"><span class="built_in">BuildTree</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line"><span class="type">int</span> op, x, y; ll k;</span><br><span class="line">cin &gt;&gt; op;</span><br><span class="line"><span class="keyword">if</span> (op == <span class="number">1</span>)&#123;<span class="comment">//操作1：x~y的区间都加上k</span></span><br><span class="line">cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line"><span class="built_in">Insert</span>(<span class="number">1</span>, <span class="number">1</span>, n, x, y, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="comment">//操作2：查询区间x~y的区间和</span></span><br><span class="line">cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">cout &lt;&lt; <span class="built_in">calc</span>(<span class="number">1</span>, <span class="number">1</span>, n, x, y, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="Number-Theory"><a href="#Number-Theory" class="headerlink" title="Number - Theory"></a>Number - Theory</h1><h2 id="Exact-Division-amp-gcd-amp-lcm"><a href="#Exact-Division-amp-gcd-amp-lcm" class="headerlink" title="Exact - Division &amp; gcd &amp; lcm"></a>Exact - Division &amp; gcd &amp; lcm</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123; <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123; <span class="keyword">return</span> (a / <span class="built_in">gcd</span>(a, b)) * b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)&#123; x = <span class="number">1</span>, y = <span class="number">0</span>; <span class="keyword">return</span> a; &#125;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= (a / b) * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Prime-Sieve-amp-Block-By-Block"><a href="#Prime-Sieve-amp-Block-By-Block" class="headerlink" title="Prime Sieve &amp; Block - By - Block"></a>Prime Sieve &amp; Block - By - Block</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 试除法分解质因数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Divide</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i, s ++ ;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 试除法求所有约数</span></span><br><span class="line">vector &lt;<span class="type">int</span>&gt; <span class="built_in">get_divisors</span>(<span class="type">int</span> x)&#123;</span><br><span class="line">    vector &lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (i != x / i) res.<span class="built_in">push_back</span>(x / i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线性筛</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数 0_base</span></span><br><span class="line"><span class="type">bool</span> st[N];             <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++ )&#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++ )&#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Coresidual-amp-Euler-Func-amp-Inverse"><a href="#Coresidual-amp-Euler-Func-amp-Inverse" class="headerlink" title="Coresidual &amp; Euler Func &amp; Inverse"></a>Coresidual &amp; Euler Func &amp; Inverse</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给一个素数p 求1∼n关于p的逆元 (有四种求逆元的方法)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10100000</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> inv[N];</span><br><span class="line"><span class="type">int</span> n, p, ans = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; p &gt;&gt; n; inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        inv[i] = (p - p / i) * inv[p % i] % p;</span><br><span class="line">        ans ^= inv[i];  <span class="comment">// 由于输出可能很大 只需要求这些逆元的异或和即可</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 求欧拉函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">phi</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )&#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)&#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) res = res / x * (x - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Qmi-amp-Conbinatorial-Number"><a href="#Qmi-amp-Conbinatorial-Number" class="headerlink" title="Qmi &amp; Conbinatorial Number"></a>Qmi &amp; Conbinatorial Number</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速幂：求a^k%mod 时间复杂度O(logk)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    a %= mod; <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k)&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) &#123; res = res * a % mod; &#125;</span><br><span class="line">        a = a * a % mod; k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 快速乘</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function">ll <span class="title">quickmul</span><span class="params">(ll a, ll b, ll mod)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>; a %= mod;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)&#123; ans += a; ans %= mod; &#125;</span><br><span class="line">        a += a; a %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 矩阵乘法</span></span><br><span class="line"><span class="comment">//优化的 O(n^3 log k) 但是常数小了很多</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">aa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll w[N][N];</span><br><span class="line">    <span class="built_in">memset</span>(w, <span class="number">0</span>, <span class="built_in">sizeof</span>(w));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i][k])&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (a[k][j])&#123;</span><br><span class="line">                        w[i][j] += a[i][k] * a[k][j]; w[i][j] %= P;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(a, w, <span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 排列数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">A</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = m; i &gt;= <span class="number">1</span>; i--) &#123; res *= n; n--; &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>四种求组合数的方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通组合数 N^2：</span></span><br><span class="line"><span class="comment">// c[a][b] 表示从a个中选b个的方案数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j ++ )</span><br><span class="line">        <span class="keyword">if</span> (!j) c[i][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> c[i][j] = (c[i - <span class="number">1</span>][j] + c[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过预处理逆元的方式求组合数：</span></span><br><span class="line"><span class="comment">// 首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N]</span></span><br><span class="line"><span class="comment">// 如果取模的数是质数，可以用费马小定理求逆元</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k, <span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k)&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 预处理阶乘的余数和阶乘逆元的余数</span></span><br><span class="line">fact[<span class="number">0</span>] = infact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i ++ )&#123;</span><br><span class="line">    fact[i] = (LL)fact[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    infact[i] = (LL)infact[i - <span class="number">1</span>] * <span class="built_in">qmi</span>(i, mod - <span class="number">2</span>, mod) % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lucas定理：</span></span><br><span class="line"><span class="comment">// 若p是质数，则对于任意整数 1 &lt;= m &lt;= n，有：</span></span><br><span class="line"><span class="comment">// C(n, m) = C(n % p, m % p) * C(n / p, m / p) (mod p)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k, <span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">while</span> (k)&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span> <span class="comment">/* 通过定理求组合数C(a, b)*/</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    LL x = <span class="number">1</span>, y = <span class="number">1</span>;  <span class="comment">// x是分子，y是分母</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a, j = <span class="number">1</span>; j &lt;= b; i --, j ++ )&#123;</span><br><span class="line">        x = (LL)x * i % p;</span><br><span class="line">        y = (LL) y * j % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * (LL)<span class="built_in">qmi</span>(y, p - <span class="number">2</span>, p) % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lucas</span><span class="params">(LL a, LL b, <span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; p &amp;&amp; b &lt; p) <span class="keyword">return</span> <span class="built_in">C</span>(a, b, p);</span><br><span class="line">    <span class="keyword">return</span> (LL)<span class="built_in">C</span>(a % p, b % p, p) * <span class="built_in">lucas</span>(a / p, b / p, p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分解质因数法求组合数：</span></span><br><span class="line"><span class="comment">/* 当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用：</span></span><br><span class="line"><span class="comment">    1. 筛法求出范围内的所有质数</span></span><br><span class="line"><span class="comment">    2. 通过 C(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n! 中p的次数是 n / p + n / p^2 + n / p^3 + ...</span></span><br><span class="line"><span class="comment">    3. 用高精度乘法将所有质因子相乘 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> primes[N], cnt;     <span class="comment">// 存储所有质数</span></span><br><span class="line"><span class="type">int</span> sum[N];     <span class="comment">// 存储每个质数的次数</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个数是否已被筛掉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )&#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> p)</span><span class="comment">/*求n！中的次数*/</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)&#123;</span><br><span class="line">        res += n / p;</span><br><span class="line">        n /= p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a, <span class="type">int</span> b)</span><span class="comment">/*高精度乘低精度模板*/</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; c;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i ++ )&#123;</span><br><span class="line">        t += a[i] * b;</span><br><span class="line">        c.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (t)&#123;</span><br><span class="line">        c.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">get_primes</span>(a);  <span class="comment">// 预处理范围内的所有质数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i ++ )<span class="comment">/*求每个质因数的次数*/</span>&#123;</span><br><span class="line">    <span class="type">int</span> p = primes[i];</span><br><span class="line">    sum[i] = <span class="built_in">get</span>(a, p) - <span class="built_in">get</span>(b, p) - <span class="built_in">get</span>(a - b, p);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">res.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i ++ )     <span class="comment">// 用高精度乘法将所有质因子相乘</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; sum[i]; j ++ )</span><br><span class="line">        res = <span class="built_in">mul</span>(res, primes[i]);</span><br></pre></td></tr></table></figure><hr><h2 id="Gaussian-Elimination"><a href="#Gaussian-Elimination" class="headerlink" title="Gaussian Elimination"></a>Gaussian Elimination</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a[N][N]是增广矩阵</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gauss</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> c, r;</span><br><span class="line">    <span class="keyword">for</span> (c = <span class="number">0</span>, r = <span class="number">0</span>; c &lt; n; c ++ )&#123;</span><br><span class="line">        <span class="type">int</span> t = r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i ++ )   <span class="comment">// 找到绝对值最大的行</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; <span class="built_in">fabs</span>(a[t][c]))</span><br><span class="line">                t = i;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[t][c]) &lt; eps) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = c; i &lt;= n; i ++ ) <span class="built_in">swap</span>(a[t][i], a[r][i]);      <span class="comment">// 将绝对值最大的行换到最顶端</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= c; i -- ) a[r][i] /= a[r][c];      <span class="comment">// 将当前行的首位变成1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r + <span class="number">1</span>; i &lt; n; i ++ )       <span class="comment">// 用当前行将下面所有的列消成0</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; eps)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= c; j -- )</span><br><span class="line">                    a[i][j] -= a[r][j] * a[i][c];</span><br><span class="line">        r ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; n)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][n]) &gt; eps)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// 无解</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 有无穷多组解</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j ++ )</span><br><span class="line">            a[i][n] -= a[i][j] * a[j][n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 有唯一解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Chinese-Remainder-Theorem"><a href="#Chinese-Remainder-Theorem" class="headerlink" title="Chinese Remainder Theorem"></a>Chinese Remainder Theorem</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中国剩余定理可求解一元线性同余方程组</span></span><br><span class="line"><span class="function">ll <span class="title">CRT</span><span class="params">(<span class="type">int</span> k, ll* a, ll* r)</span> </span>&#123;</span><br><span class="line">    ll n = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) n = n * r[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        ll m = n / r[i], b, y;</span><br><span class="line">        <span class="built_in">exgcd</span>(m, r[i], b, y);  <span class="comment">// b * m mod r[i] = 1</span></span><br><span class="line">        ans = (ans + a[i] * m * b % n) % n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ans % n + n) % n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="Other-Algorithm"><a href="#Other-Algorithm" class="headerlink" title="Other Algorithm"></a>Other Algorithm</h1><h2 id="BFS-amp-DFS"><a href="#BFS-amp-DFS" class="headerlink" title="BFS &amp; DFS"></a>BFS &amp; DFS</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BFS</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BFS</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 表示1号点已经被遍历过</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="comment">/*遍历所有当前点的相邻位置*/</span>)&#123;</span><br><span class="line">            <span class="comment">// 用变量xxx表示新的点</span></span><br><span class="line">            <span class="keyword">if</span> (!st[<span class="comment">/*xxx*/</span>])&#123;</span><br><span class="line">                st[<span class="comment">/*xxx*/</span>] = <span class="literal">true</span>; <span class="comment">// 表示点j已经被遍历过</span></span><br><span class="line">                q.<span class="built_in">push</span>(<span class="comment">/*xxx*/</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// DFS</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">// st[u] 表示点u已经被遍历过</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="comment">/*遍历所有当前点的相邻位置*/</span>)&#123;</span><br><span class="line">        <span class="comment">// 用变量xxx表示新的点</span></span><br><span class="line">        <span class="keyword">if</span> (!st[<span class="comment">/*xxx*/</span>]) &#123;</span><br><span class="line">            <span class="built_in">DFS</span>(<span class="comment">/*xxx*/</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整数二分：</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;    <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 浮点数二分：</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">bsearch_3</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;   <span class="comment">// eps 表示精度，取决于题目对精度的要求</span></span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)&#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>KMP：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度</span></span><br><span class="line"><span class="comment">// 求模式串的Next数组：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i ++ )&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">    ne[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 匹配</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">    <span class="keyword">if</span> (j == m)&#123;</span><br><span class="line">        j = ne[j];</span><br><span class="line">        <span class="comment">// 匹配成功后的逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字串Substr：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;HelloWorld&quot;</span>;</span><br><span class="line">    <span class="comment">// substr(l, len) = [l, len)</span></span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, <span class="number">9</span>)&#123;</span><br><span class="line">        cout &lt;&lt; str.<span class="built_in">substr</span>(<span class="number">0</span>, i) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, <span class="number">9</span>)&#123;</span><br><span class="line">    cout &lt;&lt; str.<span class="built_in">substr</span>(<span class="number">9</span> - i, i) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// substr(l) = [l, end]</span></span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, <span class="number">9</span>)&#123;</span><br><span class="line">        cout &lt;&lt; str.<span class="built_in">substr</span>(i) &lt;&lt; endl;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Discretization-amp-Prefix-sum-amp-Difference"><a href="#Discretization-amp-Prefix-sum-amp-Difference" class="headerlink" title="Discretization &amp; Prefix sum &amp; Difference"></a>Discretization &amp; Prefix sum &amp; Difference</h2><p>高维前缀和</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="comment">//先求数组a关于第一个维度的前缀和&#123;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">        a[i][j]=a[i][j]+a[i][j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">    <span class="comment">//在已经求完一个维度前缀和的基础上求数组a关于第二个维度的前缀和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">        a[i][j]=a[i][j]+a[i<span class="number">-1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这种方式可以理解成二维前缀和是数组在求完关于第一个维度的前缀和，</span></span><br><span class="line"><span class="comment">然后再for一遍求它关于第二个维度的前缀和。</span></span><br><span class="line"><span class="comment">然后它在求三维以上前缀和的时候，就体现出这种写法在高维前缀和上的优越性了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=p;++k)&#123;</span><br><span class="line">            a[i][j][k]+=a[i<span class="number">-1</span>][j][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=p;++k)&#123;</span><br><span class="line">            a[i][j][k]+=a[i][j<span class="number">-1</span>][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=p;++k)&#123;</span><br><span class="line">            a[i][j][k]+=a[i][j][k<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// 无需借助容斥原理，求高维前缀和的复杂度变为O(|高维空间容量|*k)，可以处理k稍大一些的情况。</span></span><br></pre></td></tr></table></figure><p>差分：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    b[l] += c; b[r+<span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 二维</span></span><br><span class="line">a[i][j] = s[i][j] - s[i - <span class="number">1</span>][j] - s[i][j - <span class="number">1</span>] + s[i - <span class="number">1</span>][j - <span class="number">1</span>];<span class="comment">//子矩形加</span></span><br></pre></td></tr></table></figure><hr><h2 id="Double-Pointer"><a href="#Double-Pointer" class="headerlink" title="Double Pointer"></a>Double Pointer</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ )&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; i &amp;&amp; <span class="built_in">check</span>(i, j)) j ++ ;</span><br><span class="line">    <span class="comment">// 具体问题的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 常见问题分类：</span></span><br><span class="line"><span class="comment">    (1) 对于一个序列，用两个指针维护一段区间</span></span><br><span class="line"><span class="comment">    (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作 */</span></span><br></pre></td></tr></table></figure><hr><h2 id="High-Precision"><a href="#High-Precision" class="headerlink" title="High Precision"></a>High Precision</h2><p>高精度加：（没搞懂怎么用）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">add</span>(B, A);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )&#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>高精度减：（也没搞懂）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; <span class="built_in">int</span>(A.<span class="built_in">size</span>()); i ++ )&#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="built_in">int</span>(B.<span class="built_in">size</span>())) t -= B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">int</span>(C.<span class="built_in">size</span>()) &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Bit-Operation"><a href="#Bit-Operation" class="headerlink" title="Bit Operation"></a>Bit Operation</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回x的最后一位1以及以后</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; -x; &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Quick-Readin"><a href="#Quick-Readin" class="headerlink" title="Quick Readin"></a>Quick Readin</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">rd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Game-Theory"><a href="#Game-Theory" class="headerlink" title="Game Theory"></a>Game Theory</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">（更多是在平等博弈下讨论的）</span><br><span class="line">假设我们的游戏是**无环的**，即*不会存在能回到原来的状态从而无限进行下去的可能*；</span><br><span class="line">则该游戏存在的所有状态构成一个**有向无环图**；</span><br><span class="line">*注：以下都是基于Alice和Bob轮流进行游戏的情况下*</span><br><span class="line">**先手必胜态**和**先手必败态**都是指的当前局面下，下一步谁来走，而不是整局游戏的先手。</span><br><span class="line">必胜态触发的两种情况：（对必败态同理）</span><br><span class="line">1. 达到终止条件（胜利条件）</span><br><span class="line">2. 存在一个后继为必败态（随着后续的步骤会转变到必败态）</span><br><span class="line">如果存在平局的情况，那么我们可以采用：胜1平0负-1的状态表示方式，此时我们的dp方程就是min(后继)；</span><br><span class="line">不难想到，无论是平等博弈还是不平等博弈，我们都可以从**终点开始枚举**所有的状态，利用**动态规划**的思想。</span><br><span class="line">那么，什么情况下不能dp呢？</span><br><span class="line">就是当游戏局面很多的时候，没有办法把所有的状态都记下来的时候，就需要用到博弈论的手法了。</span><br></pre></td></tr></table></figure><hr><h2 id="Team-Mo"><a href="#Team-Mo" class="headerlink" title="Team Mo"></a>Team Mo</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> sign)</span> </span>&#123; <span class="comment">/*update nowAns*/</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">BLOCK_SIZE = <span class="built_in">int</span>(<span class="built_in">ceil</span>(<span class="built_in">pow</span>(n, <span class="number">0.5</span>)));</span><br><span class="line"><span class="built_in">sort</span>(querys, querys + m);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">    <span class="type">const</span> query &amp;q = querys[i];</span><br><span class="line">    <span class="keyword">while</span> (l &gt; q.l) <span class="built_in">move</span>(--l, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (r &lt; q.r) <span class="built_in">move</span>(r++, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (l &lt; q.l) <span class="built_in">move</span>(l++, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">while</span> (r &gt; q.r) <span class="built_in">move</span>(--r, <span class="number">-1</span>);</span><br><span class="line">    ans[q.id] = nowAns;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Computation-Geometry"><a href="#Computation-Geometry" class="headerlink" title="Computation Geometry"></a>Computation Geometry</h1><ul><li>精度：减少正反三角函数、除法、根号的使用次数。</li><li>简洁：多归纳，多模块化，少分类讨论。</li><li>除零： 所有除法都要考虑<code>0</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = b → abs(a − b) &lt; eps</span><br><span class="line">a &lt; b → a &lt; b − eps</span><br><span class="line">a &gt; b → a &gt; b + eps</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断两线段是否相交</span></span><br><span class="line"><span class="comment">// 注意：如果有#include &lt;math.h&gt;则需要注意y1, y2等变量需要放进局部变量而非全局变量，因为math.h中有同名函数。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span> &#123;</span><br><span class="line">    <span class="type">double</span> x1;</span><br><span class="line">    <span class="type">double</span> y1;</span><br><span class="line">    <span class="type">double</span> x2;</span><br><span class="line">    <span class="type">double</span> y2;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">intersection</span><span class="params">(<span class="type">const</span> Line &amp;l1, <span class="type">const</span> Line &amp;l2)</span></span>&#123;</span><br><span class="line">    <span class="comment">//快速排斥实验</span></span><br><span class="line">    <span class="keyword">if</span> ((l1.x1 &gt; l1.x2 ? l1.x1 : l1.x2) &lt; (l2.x1 &lt; l2.x2 ? l2.x1 : l2.x2) ||</span><br><span class="line">        (l1.y1 &gt; l1.y2 ? l1.y1 : l1.y2) &lt; (l2.y1 &lt; l2.y2 ? l2.y1 : l2.y2) ||</span><br><span class="line">        (l2.x1 &gt; l2.x2 ? l2.x1 : l2.x2) &lt; (l1.x1 &lt; l1.x2 ? l1.x1 : l1.x2) ||</span><br><span class="line">        (l2.y1 &gt; l2.y2 ? l2.y1 : l2.y2) &lt; (l1.y1 &lt; l1.y2 ? l1.y1 : l1.y2))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//跨立实验</span></span><br><span class="line">    <span class="keyword">if</span> ((((l1.x1 - l2.x1)*(l2.y2 - l2.y1) - (l1.y1 - l2.y1)*(l2.x2 - l2.x1))*</span><br><span class="line">        ((l1.x2 - l2.x1)*(l2.y2 - l2.y1) - (l1.y2 - l2.y1)*(l2.x2 - l2.x1))) &gt; <span class="number">0</span> ||</span><br><span class="line">        (((l2.x1 - l1.x1)*(l1.y2 - l1.y1) - (l2.y1 - l1.y1)*(l1.x2 - l1.x1))*</span><br><span class="line">        ((l2.x2 - l1.x1)*(l1.y2 - l1.y1) - (l2.y2 - l1.y1)*(l1.x2 - l1.x1))) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>偷的板子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);  <span class="comment">//π</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-8</span>;       <span class="comment">//精度控制</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> inf = <span class="number">1e100</span>;      <span class="comment">//无穷大</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sgn</span><span class="params">(<span class="type">double</span> s)</span>              <span class="comment">//判断浮点数的符号</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(s) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span>  <span class="comment">//判断x和y的大小关系,-1表示x&lt;y</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(x - y) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; y) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">r2d</span><span class="params">(<span class="type">double</span> rad)</span>  <span class="comment">//弧度转角度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rad / pi * <span class="number">180.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">d2r</span><span class="params">(<span class="type">double</span> degree)</span>  <span class="comment">//角度转弧度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> degree / <span class="number">180.0</span> * pi;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>  <span class="comment">//点与向量</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">double</span> a = <span class="number">0</span>, <span class="type">double</span> b = <span class="number">0</span>)</span><br><span class="line">        : <span class="built_in">x</span>(a), <span class="built_in">y</span>(b) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">()</span>  <span class="comment">//输入</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">debug</span><span class="params">()</span>  <span class="comment">//输出</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(%lf,%lf)\n&quot;</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>+(Point b)  <span class="comment">//向量相加</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Point</span>(x + b.x, y + b.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>-(Point b)  <span class="comment">//向量相减</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Point</span>(x - b.x, y - b.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>*(<span class="type">double</span> b)  <span class="comment">//向量数乘</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Point</span>(x * b, y * b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> <span class="keyword">operator</span>*(Point b)  <span class="comment">//向量内积</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x * b.x + y * b.y;</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>/(<span class="type">double</span> b)  <span class="comment">//除法</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Point</span>(x / b, y / b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Point&amp; b)  <span class="comment">//大小比较</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">cmp</span>(x, b.x) == <span class="number">0</span>) <span class="keyword">return</span> y &lt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &lt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Point&amp; b)  <span class="comment">//判等</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">cmp</span>(x, b.x) == <span class="number">0</span> &amp;&amp; <span class="built_in">cmp</span>(y, b.y) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">cross</span><span class="params">(Point b)</span> <span class="type">const</span>  <span class="comment">//向量叉乘</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * b.y - y * b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">angle</span><span class="params">()</span>  <span class="comment">//极角,弧度(-pi, pi]</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">atan2</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">length</span><span class="params">()</span>  <span class="comment">//模</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>((*<span class="keyword">this</span>) * (*<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">length2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (*<span class="keyword">this</span>) * (*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">angleTo</span><span class="params">(Point b)</span>  <span class="comment">//向量角度,弧度</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">acos</span>(((*<span class="keyword">this</span>) * b) / <span class="built_in">length</span>() / b.<span class="built_in">length</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">angleTo</span><span class="params">(Point a, Point b)</span>  <span class="comment">//从该点看其它两点的角度,弧度</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Point</span>(a - *<span class="keyword">this</span>).<span class="built_in">angleTo</span>(b - *<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">(Point a, Point b)</span>  <span class="comment">//求三点组成平行四边形有向面积</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (a - *<span class="keyword">this</span>).<span class="built_in">cross</span>(b - *<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">dist</span><span class="params">(Point b)</span>  <span class="comment">//求两点间欧式距离</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (*<span class="keyword">this</span> - b).<span class="built_in">length</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">dist2</span><span class="params">(Point b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (*<span class="keyword">this</span> - b).<span class="built_in">length2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">manhattanDis</span><span class="params">(Point b)</span>  <span class="comment">//求两点间曼哈顿距离</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">fabs</span>(x - b.x) + <span class="built_in">fabs</span>(y - b.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">rotate</span><span class="params">(Point p, <span class="type">double</span> ang)</span>  <span class="comment">//绕点p逆时针旋转ang弧度,不修改本身的值</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Point v = (*<span class="keyword">this</span>) - p;</span><br><span class="line">        <span class="type">double</span> c = <span class="built_in">cos</span>(ang), s = <span class="built_in">sin</span>(ang);</span><br><span class="line">        <span class="keyword">return</span> p + <span class="built_in">Point</span>(v.x * c - v.y * s, v.x * s + v.y * c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">rotate</span><span class="params">(<span class="type">double</span> ang)</span>  <span class="comment">//直接逆时针旋转ang弧度</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rotate</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>), ang);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">rotLeft</span><span class="params">()</span>  <span class="comment">//左转90</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Point</span>(-y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">rotRight</span><span class="params">()</span>  <span class="comment">//右转90</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Point</span>(y, -x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">regular</span><span class="params">()</span>  <span class="comment">//化为单位向量</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> / <span class="built_in">length</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">normal</span><span class="params">()</span>  <span class="comment">//左转90的单位法向量</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rotLeft</span>().<span class="built_in">regular</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">trunc</span><span class="params">(<span class="type">double</span> r)</span>  <span class="comment">//化为长度为r的向量</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">regular</span>() * r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">parrelTo</span><span class="params">(Point b)</span>  <span class="comment">//向量平行</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sgn</span>(<span class="built_in">cross</span>(b)) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">verticalTo</span><span class="params">(Point b)</span>  <span class="comment">//向量垂直</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sgn</span>((*<span class="keyword">this</span>) * b) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">toLeftTest</span><span class="params">(Point from, Point to, Point test)</span>  <span class="comment">//测试test在不在from-&gt;to的左边,1在左边,-1在右边,0共线</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sgn</span>((to - from).<span class="built_in">cross</span>(test - to));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Circle</span>  <span class="comment">//圆</span></span><br><span class="line">&#123;</span><br><span class="line">    Point o;   <span class="comment">//圆心</span></span><br><span class="line">    <span class="type">double</span> r;  <span class="comment">//半径</span></span><br><span class="line">    <span class="built_in">Circle</span>(Point o = <span class="built_in">Point</span>(), <span class="type">double</span> r = <span class="number">0.0</span>)</span><br><span class="line">        : <span class="built_in">o</span>(o), <span class="built_in">r</span>(r) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf%lf&quot;</span>, &amp;o.x, &amp;o.y, &amp;r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">debug</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(%lf,%lf,%lf)\n&quot;</span>, o.x, o.y, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Circle <span class="title">invertToCicle</span><span class="params">(Point P, <span class="type">double</span> R)</span>  <span class="comment">//外部反演点反演,反演为圆; p为反演中心,r为反演半径</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Circle ans;</span><br><span class="line">        <span class="type">double</span> d1 = P.<span class="built_in">dist</span>(o);</span><br><span class="line">        ans.r = r / (d1 * d1 - r * r) * R * R;</span><br><span class="line">        <span class="type">double</span> d2 = R * R / (d1 - r) - ans.r;</span><br><span class="line">        ans.o = P + (o - P) * (d2 / d1);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span></span><br><span class="line">&#123;</span><br><span class="line">    Point pos;</span><br><span class="line">    Vector to;</span><br><span class="line">    <span class="built_in">Line</span>(Point p = <span class="built_in">Point</span>(), Vector t = <span class="built_in">Point</span>())  <span class="comment">//顶点和方向向量</span></span><br><span class="line">        : <span class="built_in">pos</span>(p), <span class="built_in">to</span>(t)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> Line <span class="title">tp</span><span class="params">(Point a, Point b)</span>  <span class="comment">//两点构造</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Line</span>(a, b - a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Line</span>(<span class="type">double</span> x1, <span class="type">double</span> y1, <span class="type">double</span> x2, <span class="type">double</span> y2)  <span class="comment">//两点构造</span></span><br><span class="line">    &#123;</span><br><span class="line">        pos = <span class="built_in">Point</span>(x1, y1), to = <span class="built_in">Point</span>(x2, y2) - <span class="built_in">Point</span>(x1, y1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">point</span><span class="params">(<span class="type">double</span> s)</span>  <span class="comment">//获取某处的一个点</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pos + to * s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">angle</span><span class="params">()</span>  <span class="comment">//获得直线倾角,[0,pi)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">acos</span>(to.<span class="built_in">regular</span>().x * <span class="built_in">sgn</span>(to.<span class="built_in">regular</span>().y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">onLine</span><span class="params">(Point s)</span>  <span class="comment">//判断点与直线的位置关系0在直线外;1在直线上</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sgn</span>(to.<span class="built_in">cross</span>(s - pos)) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(Line l)  <span class="comment">//两条直线是否是同一条(重合)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> l.<span class="built_in">onLine</span>(<span class="built_in">point</span>(<span class="number">0</span>)) &amp;&amp; l.<span class="built_in">onLine</span>(<span class="built_in">point</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(Line l)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> !((*<span class="keyword">this</span>) == l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">parrelTo</span><span class="params">(Line l)</span>  <span class="comment">//直线平行</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> to.<span class="built_in">parrelTo</span>(l.to);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">verticalTo</span><span class="params">(Line l)</span>  <span class="comment">//直线垂直</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> to.<span class="built_in">verticalTo</span>(l.to);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">insWithLine</span><span class="params">(Line l)</span>  <span class="comment">//与另一条直线的交点</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">point</span>(l.to.<span class="built_in">cross</span>(pos - l.pos) / to.<span class="built_in">cross</span>(l.to));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">disToPoint</span><span class="params">(Point s)</span>  <span class="comment">//点到直线的距离</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">fabs</span>(to.<span class="built_in">cross</span>(s - pos) / to.<span class="built_in">length</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">projection</span><span class="params">(Point s)</span>  <span class="comment">//点在直线上的投影</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">point</span>((to * (s - pos)) / (to * to));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Circle <span class="title">invertToCircle</span><span class="params">(Point P, <span class="type">double</span> R)</span>  <span class="comment">//直线外一点反演为圆</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">Line <span class="title">lp</span><span class="params">(P, to.rotLeft())</span></span>;</span><br><span class="line">        Point ps = <span class="keyword">this</span>-&gt;<span class="built_in">insWithLine</span>(lp);</span><br><span class="line">        Circle c;</span><br><span class="line">        c.r = R * R / <span class="keyword">this</span>-&gt;<span class="built_in">disToPoint</span>(P) / <span class="number">2.0</span>;</span><br><span class="line">        c.o = P + (ps - P).<span class="built_in">regular</span>() * c.r;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">disToSegment</span><span class="params">(Point s, Point a, Point b)</span>  <span class="comment">//点到线段ab最短距离</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> (s - a).<span class="built_in">length</span>();</span><br><span class="line">    Vector v1 = b - a, v2 = s - a, v3 = s - b;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sgn</span>(v1 * v2) &lt; <span class="number">0</span>) <span class="keyword">return</span> v2.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sgn</span>(v1 * v3) &gt; <span class="number">0</span>) <span class="keyword">return</span> v3.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Line</span>(a, b - a).<span class="built_in">disToPoint</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">(Point a, Point b, Point c)</span>  <span class="comment">//三角形面积</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>((b - a).<span class="built_in">cross</span>(c - a) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">onSegment</span><span class="params">(Point p, Point a, Point b)</span>  <span class="comment">//点是否在线段上</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">sgn</span>((a - p).<span class="built_in">cross</span>(b - p)) == <span class="number">0</span> &amp;&amp; <span class="built_in">sgn</span>((a - p) * (b - p)) &lt; <span class="number">0</span>) || p == a || p == b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">insWithSegment</span><span class="params">(Line l, Point a, Point b, Point&amp; ans)</span>  <span class="comment">//直线与线段相交</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l.<span class="built_in">parrelTo</span>(<span class="built_in">Line</span>(a, b - a))) <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//不相交</span></span><br><span class="line">    ans = l.<span class="built_in">insWithLine</span>(<span class="built_in">Line</span>(a, b - a));</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">onSegment</span>(ans, a, b)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (ans == a || ans == b) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//与端点相交</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;                            <span class="comment">//相交</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">segmentIns</span><span class="params">(Point a1, Point a2, Point b1, Point b2)</span>  <span class="comment">//判断线段是否相交</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> c1 = (a2 - a1).<span class="built_in">cross</span>(b1 - a1), c2 = (a2 - a1).<span class="built_in">cross</span>(b2 - a1);</span><br><span class="line">    <span class="type">double</span> c3 = (b2 - b1).<span class="built_in">cross</span>(a1 - b1), c4 = (b2 - b1).<span class="built_in">cross</span>(a2 - b1);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">sgn</span>(c1) || !<span class="built_in">sgn</span>(c2) || !<span class="built_in">sgn</span>(c3) || !<span class="built_in">sgn</span>(c4)) &#123;  <span class="comment">//控制是否可以在顶点处相交</span></span><br><span class="line">        <span class="type">bool</span> f1 = <span class="built_in">onSegment</span>(b1, a1, a2);</span><br><span class="line">        <span class="type">bool</span> f2 = <span class="built_in">onSegment</span>(b2, a1, a2);</span><br><span class="line">        <span class="type">bool</span> f3 = <span class="built_in">onSegment</span>(a1, b1, b2);</span><br><span class="line">        <span class="type">bool</span> f4 = <span class="built_in">onSegment</span>(a2, b1, b2);</span><br><span class="line">        <span class="type">bool</span> f = (f1 | f2 | f3 | f4);</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sgn</span>(c1) * <span class="built_in">sgn</span>(c2) &lt; <span class="number">0</span> &amp;&amp; <span class="built_in">sgn</span>(c3) * <span class="built_in">sgn</span>(c4) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">polygonArea</span><span class="params">(Point* p, <span class="type">int</span> n)</span>  <span class="comment">//计算多边形有向面积,点需要按顺序排列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) s += (p[i] - p[<span class="number">0</span>]).<span class="built_in">cross</span>(p[i + <span class="number">1</span>] - p[<span class="number">0</span>]) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">polygonPerimeter</span><span class="params">(Point* p, <span class="type">int</span> n)</span>  <span class="comment">//计算多边形周长,点需要按顺序排列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> ans = <span class="number">0</span>;</span><br><span class="line">    p[n] = p[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) ans += p[i].<span class="built_in">dist</span>(p[i + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quad</span><span class="params">(Point a)</span>  <span class="comment">// 判断象限的函数，每个象限包括半个坐标轴</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">cmp</span>(a.x, <span class="number">0</span>) &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">cmp</span>(a.y, <span class="number">0</span>) &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">cmp</span>(a.x, <span class="number">0</span>) &lt;= <span class="number">0</span> &amp;&amp; <span class="built_in">cmp</span>(a.y, <span class="number">0</span>) &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">cmp</span>(a.x, <span class="number">0</span>) &lt; <span class="number">0</span> &amp;&amp; <span class="built_in">cmp</span>(a.y, <span class="number">0</span>) &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">cmp</span>(a.x, <span class="number">0</span>) &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">cmp</span>(a.y, <span class="number">0</span>) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sortByPolarAngle</span><span class="params">(Point at, Point* begin, Point* end)</span>  <span class="comment">//极角逆时针排序，以at为极点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(begin, end, [&amp;](Point a, Point b) &#123;</span><br><span class="line">        a = a - at, b = b - at;</span><br><span class="line">        <span class="type">int</span> l1 = <span class="built_in">quad</span>(a), l2 = <span class="built_in">quad</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (l1 == l2) &#123;</span><br><span class="line">            <span class="type">double</span> c = a.<span class="built_in">cross</span>(b);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">cmp</span>(c, <span class="number">0</span>) &gt; <span class="number">0</span> || (<span class="built_in">cmp</span>(c, <span class="number">0</span>) == <span class="number">0</span> &amp;&amp; a.<span class="built_in">length</span>() &lt; b.<span class="built_in">length</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l1 &lt; l2;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gramhamScan</span><span class="params">(Point* res, <span class="type">int</span> n, Point* ans)</span>  <span class="comment">//求凸包,O(nlogn),ans存放答案,返回凸包上点的数量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Point p = res[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, top = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (res[i] &lt; p) p = res[i], k = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(res[<span class="number">0</span>], res[k]), <span class="built_in">sortByPolarAngle</span>(res[<span class="number">0</span>], res + <span class="number">1</span>, res + n), ans[<span class="number">0</span>] = res[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &gt; <span class="number">2</span> &amp;&amp; <span class="built_in">sgn</span>((ans[top - <span class="number">1</span>] - ans[top - <span class="number">2</span>]).<span class="built_in">cross</span>(res[i] - ans[top - <span class="number">2</span>])) &lt;= <span class="number">0</span>) --top;</span><br><span class="line">        ans[top++] = res[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">rotatingCalipers</span><span class="params">(Point* poly, <span class="type">int</span> n)</span>  <span class="comment">//旋转卡壳,返回凸包直径</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">2</span>;</span><br><span class="line">    poly[n] = poly[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">area</span>(poly[i], poly[i + <span class="number">1</span>], poly[j]) &lt; <span class="built_in">area</span>(poly[i], poly[i + <span class="number">1</span>], poly[j + <span class="number">1</span>])) &#123;</span><br><span class="line">            ++j;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; n) j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, <span class="built_in">max</span>(poly[i].<span class="built_in">dist</span>(poly[j]), poly[i + <span class="number">1</span>].<span class="built_in">dist</span>(poly[j])));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isPointInPolygon</span><span class="params">(Point p, Point* poly, <span class="type">int</span> n)</span>  <span class="comment">//点在多边形内1;在外-1;在边界上0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> wn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">onSegment</span>(p, poly[i], poly[(i + <span class="number">1</span>) % n])) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> k = <span class="built_in">sgn</span>((poly[(i + <span class="number">1</span>) % n] - poly[i]).<span class="built_in">cross</span>(p - poly[i]));</span><br><span class="line">        <span class="type">int</span> d1 = <span class="built_in">sgn</span>(poly[i].y - p.y);</span><br><span class="line">        <span class="type">int</span> d2 = <span class="built_in">sgn</span>(poly[(i + <span class="number">1</span>) % n].y - p.y);</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; d1 &lt;= <span class="number">0</span> &amp;&amp; d2 &gt; <span class="number">0</span>) wn++;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">0</span> &amp;&amp; d2 &lt;= <span class="number">0</span> &amp;&amp; d1 &gt; <span class="number">0</span>) wn--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wn != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前言：&lt;/p&gt;
&lt;p&gt;2023.03.18正式退役啦，特此来把之前杂乱无章且错误百出的，有关算法竞赛的博客整合起来，汇总成此篇博客。&lt;/p&gt;
&lt;p&gt;（其实是我自己的板子，如果大家有需要就拿去就好啦，能帮到各位的话也算是一种传承吧）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;个</summary>
      
    
    
    
    <category term="XCPC" scheme="https://conqueror712.github.io/categories/XCPC/"/>
    
    
  </entry>
  
  <entry>
    <title>计网- Ep1 - 概述「 万字长文」丨学习记录</title>
    <link href="https://conqueror712.github.io/post/Computer-Network.html"/>
    <id>https://conqueror712.github.io/post/Computer-Network.html</id>
    <published>2023-02-09T12:03:22.000Z</published>
    <updated>2023-04-23T03:09:43.776Z</updated>
    
    <content type="html"><![CDATA[<p><em>Computer Networking A Top-Down Approach Learning Note Part 1</em></p><hr><p><strong>前言</strong>：</p><p>本文是笔者初学计算机网络的笔记和一些心得，难免会有部分疏漏和错误，还请各位读者积极指出，不吝赐教。</p><p>有一些内容是笔者认为对自己暂时没那么重要的部分，就没有放上去，具体的内容可以查看相关的书籍。</p><p>观前提醒：本文篇幅较长，若您只是想看其中的某一小节的知识，直接点击目录进行跳转即可！</p><p>事不宜迟，我们开始吧！</p><blockquote><p>个人博客：<a href="https://conqueror712.github.io/">https://conqueror712.github.io/</a></p><p>知乎：<a href="https://www.zhihu.com/people/soeur712/posts">https://www.zhihu.com/people/soeur712/posts</a></p><p>Bilibili：<a href="https://space.bilibili.com/57089326">https://space.bilibili.com/57089326</a></p><p>掘金：<a href="https://juejin.cn/user/1297878069809725/posts">https://juejin.cn/user/1297878069809725/posts</a></p></blockquote><hr><h1 id="Unit-1-计算机网络概述"><a href="#Unit-1-计算机网络概述" class="headerlink" title="Unit 1 计算机网络概述"></a>Unit 1 计算机网络概述</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>该课程的总体教学目标需要掌握计网的什么？</p><ul><li>基本概念</li><li>工作原理</li><li>常用技术</li></ul><p>计算机网络为什么比较难学？</p><p>有很多的**”定性的、逻辑描述的推理”**；</p><p>与数学物理不同，倒是有点像政治，有着比较强的**”表述性”**；</p><p>在学习的过程中应当”取其精华”，尤其是面对一些晦涩难懂且冗长的概念。</p><p>这一章节作为导论，有什么”关键词”吗？</p><p><strong>框架、术语、原理、历史。</strong></p><p>此外，每一章大致分为两个部分：原理 + 实例；</p><p>其中，原理又有两个部分：功能 + 服务（一般是向上层提供接口的服务）</p><p><img src="https://s2.loli.net/2023/02/05/CmaRS2pUiZKVYP5.png" alt="avatar"></p><hr><h2 id="什么是Internet"><a href="#什么是Internet" class="headerlink" title="什么是Internet?"></a>什么是Internet?</h2><p><img src="https://s2.loli.net/2023/02/05/ejtp8fUq4HBGIRO.png" alt="avatar"></p><h3 id="从具体构成角度："><a href="#从具体构成角度：" class="headerlink" title="从具体构成角度："></a>从具体构成角度：</h3><p>互联网只是网络的一种，广义的网络就是<strong>节点 + 边</strong>，例如蜘蛛网、家族图谱等等。</p><p><img src="https://cdnjson.com/images/2023/03/23/image5d8db9ed618aaa1b.png" alt="avatar"></p><ul><li>主机节点：主机<code>host</code> &#x3D; 端系统<code>end system</code>，图例是<code>□</code>，还包括运行的网络应用程序；</li><li>数据交换节点：负责转发数据，图例是<code>○</code>；</li><li>通信链路：以<code>带宽bps，即bit/s</code>作为传输速率衡量标准，常见的有光纤、同轴电缆、卫星、无线电等；</li><li>接入链路：<code>□与○之间</code>；</li><li>骨干链路：<code>○与○之间</code>；</li><li>交换机：在链路层；</li><li>路由器：在网络层；</li></ul><h4 id="互联网："><a href="#互联网：" class="headerlink" title="互联网："></a>互联网：</h4><ul><li>由TCP和IP协议为主的一簇协议支撑工作的那个网，概括来说可以称为<strong>网络的网络</strong>；</li><li>松散的层次结构，互联的ISP (Internet Service Provider)因特网服务提供商；</li><li>公共Internet，专用intranet；</li><li>标准：RFC文档 → IETF；</li></ul><h4 id="协议："><a href="#协议：" class="headerlink" title="协议："></a>协议：</h4><ul><li>对等层的实体，在通信的过程中需要遵守的规范的集合。</li><li>协议控制发送</li><li>定义了在两个或多个通信实体之间交换的报文<strong>格式</strong>和<strong>次序</strong>，以及在报文传输、接收或其他事件方面所采取的<strong>动作</strong>。</li><li>PDU (Protocol Data Unit)协议数据单元，是指对等层次之间传递的数据单位。<ul><li>物理层的PDU是<code>bit</code></li><li>数据链路层的PDU是<code>数据帧frame</code></li><li>网络层的PDU是<code>数据包packet</code></li><li>传输层的PDU是<code>数据段segment</code></li><li>其他更高层次的PDU是数据<code>data</code></li></ul></li></ul><h3 id="从服务角度："><a href="#从服务角度：" class="headerlink" title="从服务角度："></a>从服务角度：</h3><p>包括分布式应用进程和为分布式应用进程提供通讯服务的基础设施。</p><h4 id="分布式应用进程："><a href="#分布式应用进程：" class="headerlink" title="分布式应用进程："></a>分布式应用进程：</h4><p>使用通信设施进行通信，包括Web、VoIP、Email、社交网络、电商等等；</p><h4 id="基础设施："><a href="#基础设施：" class="headerlink" title="基础设施："></a>基础设施：</h4><p>形式是API，将发送和接收数据的APPS与互联网连接起来，组成如下：</p><ul><li>主机</li><li>应用层以下的所有协议实体</li><li>网络的部分</li></ul><p>类型如下：区别就在于”打招呼与否”</p><ul><li>面向连接的可靠服务，用<code>TCP / IP()</code></li><li>无连接的不可靠服务，用<code>UDP</code></li></ul><blockquote><p>[缩写说明]：</p><ul><li>TCP Transmission Control Protocal是传输控制协议；</li><li>IP Internet Protocol是网际协议；</li><li>IETF Internet Engineering Task Force因特网工程任务组；</li><li>RFC Request for commets请求评论；</li><li>API Application Programming Interface应用程序编程接口；</li></ul></blockquote><h3 id="谁在运营互联网？"><a href="#谁在运营互联网？" class="headerlink" title="谁在运营互联网？"></a>谁在运营互联网？</h3><p>没有人经营互联网。它被组织为一个分散的网络网络。</p><p>数以千计的公司、大学、政府和其他实体运营自己的网络，并根据<strong>自愿互连协议</strong>相互交换流量。</p><ul><li><strong>IETF</strong>（互联网工程任务组）组织管理了<strong>使互联网工作的共享技术标准</strong>。</li><li><strong>ICANN</strong>（互联网名称与数字地址分配机构）负责分发域名和IP地址（计算机用来在互联网上相互识别的数字），但是并不控制谁可以连接到互联网。</li></ul><p><img src="http://web.stanford.edu/class/msande91si/www-spr04/readings/week1/InternetWhitepaper_files/ruswp_diag4.gif" alt="avatar"></p><h3 id="什么是IPv6？"><a href="#什么是IPv6？" class="headerlink" title="什么是IPv6？"></a>什么是IPv6？</h3><p>目前的互联网标准，称为IPv4，只允许大约4亿个IP地址。这在1970年代被认为是一个很大的数字，但今天，IPv4地址的供应几乎耗尽。</p><p>因此，互联网工程师开发了一种名为IPv6的新标准。IPv6允许数量惊人，确切的数字是<strong>39位数</strong>，确保几乎永远不会再耗尽。</p><p>具体的结构等细节这里不展开叙述。</p><h3 id="无线互联网如何工作？"><a href="#无线互联网如何工作？" class="headerlink" title="无线互联网如何工作？"></a>无线互联网如何工作？</h3><p>无线互联网有两种基本类型：</p><ul><li>WIFI：任何人都可以购买WIFI网络设备，为了防止互相干扰，WIFI网络的功率和范围有严格的限制；</li><li>蜂窝：更加集中，通过将服务区域分解为单元来工作，单元小到一个街区，大到数英里宽，每个单元的重心都有一个塔来提供服务，当设备从一个小区移动到另一个小区时，网络会自动将设备从一个塔转移到另一个塔，允许用户继续通信而不会中断。蜂窝网络使用许可用于其<strong>专用的频谱</strong>，由于该频谱稀缺，因此通常通过拍卖授予。</li></ul><p><img src="http://web.stanford.edu/class/msande91si/www-spr04/readings/week1/InternetWhitepaper_files/ruswp_diag3.gif" alt="avatar"></p><h3 id="什么是云？"><a href="#什么是云？" class="headerlink" title="什么是云？"></a>什么是云？</h3><p>云描述了一种在 2000 年代初流行的计算方法。通过将文件存储在服务器上并通过互联网交付软件，云计算为用户提供了更简单、更可靠的计算体验。</p><hr><h2 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h2><p><img src="https://s2.loli.net/2023/02/06/UByjCsFYKgawRHn.png" alt="avatar"></p><h3 id="何为网络边缘？"><a href="#何为网络边缘？" class="headerlink" title="何为网络边缘？"></a>何为网络边缘？</h3><p><strong>采用网络设施的面向连接的服务；</strong></p><p>说白了，就是上文提到过的那些”方的”，也就是主机节点和应用程序<code>□</code>，它们是edge；</p><p>网络边缘是计算机网络的部件，当然还有其他的部件，一起构成了网络结构：</p><p><img src="https://cdnjson.com/images/2023/03/23/image743f3bbf41c6554c.png" alt="avatar"></p><hr><h3 id="应用进程间的通讯方式："><a href="#应用进程间的通讯方式：" class="headerlink" title="应用进程间的通讯方式："></a>应用进程间的通讯方式：</h3><p>主要有两种模式</p><h4 id="CS模式"><a href="#CS模式" class="headerlink" title="CS模式"></a>CS模式</h4><p>即客户端-服务器模式，这种模式是<strong>主从的</strong>，资源在服务器，客户端来请求之；</p><p>客户端是主动的，而服务器是被动的；</p><p>会有什么问题呢？</p><p>就是当Client太多的时候，需要好多的Server构成Server Farm，</p><p>从而导致更大的扩容代价和宕机代价，</p><p>总体来说就是<strong>可扩展性差</strong>。</p><h4 id="P2P模式"><a href="#P2P模式" class="headerlink" title="P2P模式"></a>P2P模式</h4><p>即peer - peer模式，是对等的一种模式，而非主从；</p><p>每个节点既可以是Client，也可以是Server，构成分布式的系统，<strong>可扩展性好</strong>；</p><p>例如迅雷等文件分发软件，就是利用P2P模式来进行更好的工作，传统的话是使用FTP；</p><blockquote><p>举例来说，如果你要下载一个文件，它会给你分成三个片段，你将会从不同的三个节点获得一部分片段，最后拼接汇集在一起，这样就实现了带宽的提升，速率的提升。</p></blockquote><hr><h3 id="关于连接服务："><a href="#关于连接服务：" class="headerlink" title="关于连接服务："></a>关于连接服务：</h3><p>共同点：都是采用网络设施进行的。</p><p><img src="https://cdnjson.com/images/2023/03/23/image30aa3f256f40a3aa.png" alt="avatar"></p><h4 id="TCP服务"><a href="#TCP服务" class="headerlink" title="TCP服务"></a>TCP服务</h4><ul><li>可靠：不出错、不乱序、不重复、不丢失；</li><li>流量控制：维护一个Balance，协调发送方和接收方的速率；</li><li>拥塞控制：维护一个Balance，协调链路上的节点的通行能力，类似道路车流量控制；</li></ul><h4 id="UDP服务"><a href="#UDP服务" class="headerlink" title="UDP服务"></a>UDP服务</h4><ul><li>无连接：上来就发送，就是任性</li><li>不可靠：丢了一些也没关系</li><li>无流量控制</li><li>无拥塞控制</li></ul><p>对于无连接服务，这里有补充：</p><p><img src="https://s2.loli.net/2023/02/09/IFwhJQifvaKbPu3.png" alt="avatar"></p><hr><h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><p>网络分类：</p><p><img src="https://cdnjson.com/images/2023/03/23/image7eaaa24dbd1b5bb1.png" alt="avatar"></p><p>基本问题：<strong>数据怎样通过网络进行传输？</strong></p><p>网络核心包括分组交换机以及网络链路，它们一起构成了<strong>网状网络</strong>；</p><h3 id="分组交换："><a href="#分组交换：" class="headerlink" title="分组交换："></a>分组交换：</h3><p>关键功能：<strong>路由 + 转发</strong></p><ul><li>路由：决定分组采用的源到目标的路径，路由算法；</li><li>转发：将分组从路由器的输入链路转移到输出链路；</li></ul><p>特点：</p><ul><li>将要传送的数据分成一个个单位：分组packet；</li><li>将分组packet从一个路由器传到相邻路由器hop，一段段最终从源端传送到目标端；</li><li>每段：采用链路的最大传输能力，即带宽；</li></ul><p><img src="https://s2.loli.net/2023/02/08/i8aqtym1HWz3ATd.png" alt="avatar"></p><h4 id="存储转发传输"><a href="#存储转发传输" class="headerlink" title="存储转发传输"></a>存储转发传输</h4><ul><li>被传输到下一个链路之前，整个分组必须到达路由器；</li><li>在一个速率为<code>R</code> bps的链路 ，一个长度为<code>L</code> bits 的分组 的存储转发延时： <code>L/R</code> s；</li></ul><h4 id="排队延时和分组丢失"><a href="#排队延时和分组丢失" class="headerlink" title="排队延时和分组丢失"></a>排队延时和分组丢失</h4><p><img src="https://s2.loli.net/2023/02/08/hGF62ZPvNKTErOq.png" alt="avatar"></p><ul><li>如果到达速率 &gt; 链路的输出速率，则分组将会排队，形成queue；</li><li>但如果路由器的缓存用完了，分组将会被抛弃，俗称丢包；</li></ul><h4 id="统计多路复用"><a href="#统计多路复用" class="headerlink" title="统计多路复用"></a>统计多路复用</h4><p><img src="https://s2.loli.net/2023/02/08/kVEIqCre7obDHF1.png" alt="avatar"></p><h4 id="转发表和路由选择协议"><a href="#转发表和路由选择协议" class="headerlink" title="转发表和路由选择协议"></a>转发表和路由选择协议</h4><p>路由器怎样决定它应当向哪条链路进行转发呢？</p><p>在因特网中，每个端系统具有一个称为IP地址的地址，当源主机要向目标端系统发送一个packet时，源在该分组的首部包含了目的地的IP地址，方便路由器进行转发；</p><p>另外，每台路由器具有一个<strong>转发表</strong>，用于将目的地址（或者一部分）映射为输出链路。</p><p>但是，转发表示如何进行设置的？是人工的还是自动的？实际上是通过<strong>路由选择协议</strong>来实现自动设置转发表，在后面的章节会详细介绍（第四章）。</p><h4 id="分组交换的网络层"><a href="#分组交换的网络层" class="headerlink" title="分组交换的网络层"></a>分组交换的网络层</h4><blockquote><ol><li><p>数据报网络： </p><p> 分组的目标地址决定下一跳</p><p> 在不同的阶段，路由可以改变</p><p> 类似：问路</p><p> Internent</p></li><li><p>虚电路网络：</p><p> 每个分组都带标签（虚电路标识 VC ID），标签决定下一跳</p><p> 在呼叫建立时决定路径，在整个呼叫中路径保持不变</p><p> 路由器维持每个呼叫的状态信息</p><p> X.25 和ATM</p></li></ol></blockquote><p><em>其工作原理暂略</em></p><hr><h3 id="电路交换："><a href="#电路交换：" class="headerlink" title="电路交换："></a>电路交换：</h3><p>这是一种端到端 end-to-end 的连接</p><ul><li>为每个呼叫<strong>预留</strong>一条专有电路：如电话网；</li><li>专用资源：不共享，即每个呼叫一旦建立起来就能够保证性能；</li><li>如果呼叫没有数据发送，被分配的资源就会被浪费；</li><li>通常被传统电话网络采用，不适合计算机之间的通信；<ul><li>连接建立时间长；</li><li>计算机之间的通信有突发性，如果使用电路交换则浪费的片较多；</li></ul></li></ul><h4 id="电路交换-网络资源分片"><a href="#电路交换-网络资源分片" class="headerlink" title="电路交换-网络资源分片"></a>电路交换-网络资源分片</h4><p>网络资源，如带宽被分成片</p><ul><li>FDM 频分复用</li><li>TDM 时分复用</li><li>WDM 波分复用</li></ul><p><img src="https://s2.loli.net/2023/02/08/2eDUayYI1VsgCwX.png" alt="avatar"></p><h4 id="电路交换-计算"><a href="#电路交换-计算" class="headerlink" title="电路交换-计算"></a>电路交换-计算</h4><p><img src="https://s2.loli.net/2023/02/08/Ep6Xf7Lhr2ayGPH.png" alt="avatar"></p><hr><h3 id="分组交换网中的时延、丢包和吞吐量详解："><a href="#分组交换网中的时延、丢包和吞吐量详解：" class="headerlink" title="分组交换网中的时延、丢包和吞吐量详解："></a>分组交换网中的时延、丢包和吞吐量详解：</h3><h4 id="四种时延："><a href="#四种时延：" class="headerlink" title="四种时延："></a>四种时延：</h4><p><img src="https://cdnjson.com/images/2023/03/23/image238dd675d5273d52.png" alt="avatar"></p><ul><li>处理时延：检查分组首部和决定将该分组导向何处所需要的时间是处理时延的一部分；</li><li>排队时延：在队列中，当分组在链路上等待传输时，它经受排队时延；</li><li>传输时延：<code>L / R</code>，也就是路由器将分组从队列中推出去的时间；</li><li>传播时延：从链路起点到终点的物理传播需要的时间；</li></ul><h4 id="流量强度："><a href="#流量强度：" class="headerlink" title="流量强度："></a><strong>流量强度</strong>：</h4><p><code>L * a / R</code>，<code>a</code>是表示分组到达队列的平均速率，单位是<code>分组/秒</code>，即<code>pkt/s</code>；</p><p><img src="https://s2.loli.net/2023/02/08/pEzcJ6yqtaZl5A4.png" alt="avatar"></p><h4 id="丢包："><a href="#丢包：" class="headerlink" title="丢包："></a><strong>丢包</strong>：</h4><p>随着流量强度接近1，队列将满，路由器将丢弃后续分组。</p><h4 id="端到端时延："><a href="#端到端时延：" class="headerlink" title="端到端时延："></a>端到端时延：</h4><p><img src="https://s2.loli.net/2023/02/08/cGiBtFpqmgaOxYD.png" alt="avatar"></p><h5 id="1-Traceroute："><a href="#1-Traceroute：" class="headerlink" title="1. Traceroute："></a>1. Traceroute：</h5><p>Traceroute是一个简单的程序，它能够在任何因特网上运行。</p><p>当用户指定一个目的主机名字时，源主机中的该程序朝着该目的地发送多个特殊的分组。</p><p>更具体的内容暂略。</p><h5 id="2-端系统、应用程序和其他时延"><a href="#2-端系统、应用程序和其他时延" class="headerlink" title="2. 端系统、应用程序和其他时延"></a>2. 端系统、应用程序和其他时延</h5><p>这种填充一个分组的时间称为分组化时延，可能较大。</p><h4 id="计算机网络中的吞吐量"><a href="#计算机网络中的吞吐量" class="headerlink" title="计算机网络中的吞吐量"></a>计算机网络中的吞吐量</h4><p>吞吐量分为<strong>瞬时吞吐量</strong>和<strong>平均吞吐量</strong>；</p><ul><li>瞬时吞吐量：是主机接收到文件的速率，以bps计；</li><li>平均吞吐量：如果该文件由<code>F bit</code>，主机B接收到所有<code>F bit</code>用去了<code>T秒</code>，则文件传送的平均吞吐量是<code>F / T bps</code>；</li></ul><h5 id="瓶颈链路"><a href="#瓶颈链路" class="headerlink" title="瓶颈链路"></a>瓶颈链路</h5><p><img src="https://s2.loli.net/2023/02/08/gLapHFwhsI7WqyN.png" alt="avatar"></p><hr><h2 id="接入网与物理媒体"><a href="#接入网与物理媒体" class="headerlink" title="接入网与物理媒体"></a>接入网与物理媒体</h2><p>接入网是指host与edge router相连的这条物理链路；</p><p>三个方式：</p><ul><li>家庭接入网络</li><li>单位接入网络（学校、公司）</li><li>无线接入网络</li></ul><p>两个注意：</p><ul><li>接入网络的带宽？</li><li>共享 or 专用？</li></ul><h3 id="家庭接入："><a href="#家庭接入：" class="headerlink" title="家庭接入："></a>家庭接入：</h3><p><img src="https://s2.loli.net/2023/02/08/qMKP6JzvwNAlVmi.png" alt="avatar"></p><ul><li>DSL 数字用户线，即接入网<ul><li>采用现存的到交换局DSLAM的电话线；<ul><li>DSL线路上的数据被传到互联网；</li><li>DSL线路上的语音被传到电话网；</li></ul></li><li>&lt; 2.5 Mbps上行传输速率(typically &lt; 1 Mbps)；</li><li>&lt; 24 Mbps下行传输速率(typically &lt; 10 Mbps)；</li></ul></li></ul><p><img src="https://s2.loli.net/2023/02/08/dzcoI4xFt3kKDEW.png" alt="avatar"></p><hr><ul><li><p>电缆</p><p>  <img src="https://s2.loli.net/2023/02/08/AfL1I4be9KXhJtB.png" alt="avatar"></p></li></ul><hr><ul><li>FTTH 光纤到户<ul><li>又称线缆网络，有线电视信号线缆双向改造；</li><li>FDM: 在不同频段传输不同信道的数据，数字电视和上网数据（上下行）；</li><li>HFC: hybrid fiber coax<ul><li>非对称: 最高30Mbps的下行传输速率, 2 Mbps 上行传输速率；</li></ul></li><li><strong>线缆和光纤网络</strong>将家庭用户接入到ISP路由器；</li><li>各用户共享到线缆头端的接入网络；<ul><li>与DSL不同，DSL每个用户一个专用线路到CO (Central Office)；</li></ul></li></ul></li></ul><p><img src="https://s2.loli.net/2023/02/08/K3CfPj7cB6nm54F.png" alt="avatar"></p><hr><ul><li>拨号 + 卫星<ul><li>利用modem，将上网数据<strong>调制</strong>加载音频信号上，在电话线上传输，在局端将其中的数据<strong>解调</strong>出来，反之亦然；<ul><li>调频</li><li>调幅</li><li>调相位</li><li>综合调制</li></ul></li><li>56Kbps 的速率直接接入路由器 (通常更低)；</li><li>不能同时上网和打电话：不能总是在线；</li></ul></li></ul><hr><h3 id="企业接入网络："><a href="#企业接入网络：" class="headerlink" title="企业接入网络："></a>企业接入网络：</h3><p><img src="https://s2.loli.net/2023/02/08/OypJYFo6GZ1HmMc.png" alt="avatar"></p><ul><li>以太网</li><li>WiFi</li></ul><hr><h3 id="广域无线接入网络："><a href="#广域无线接入网络：" class="headerlink" title="广域无线接入网络："></a>广域无线接入网络：</h3><p>各无线端系统共享无线接入网络（端系统到无线路由器），通过基站（接入站）；</p><p><img src="https://s2.loli.net/2023/02/08/oVwYQ3TDIbL1vMJ.png" alt="avatar"></p><hr><h3 id="物理媒体："><a href="#物理媒体：" class="headerlink" title="物理媒体："></a>物理媒体：</h3><p><img src="https://cdnjson.com/images/2023/03/23/imagefdc98297cb8f7d9e.png" alt="avatar"></p><p><img src="https://s2.loli.net/2023/02/08/x85PnRkLuey3gmH.png" alt="avatar"></p><p><img src="https://s2.loli.net/2023/02/08/R6fuCnWYScw9Khy.png" alt="avatar"></p><hr><h2 id="Internet结构和ISP"><a href="#Internet结构和ISP" class="headerlink" title="Internet结构和ISP"></a>Internet结构和ISP</h2><h3 id="互联网络结构：网络的网络"><a href="#互联网络结构：网络的网络" class="headerlink" title="互联网络结构：网络的网络"></a>互联网络结构：网络的网络</h3><p>端系统通过<strong>接入ISP</strong>来连接到互联网；</p><p>若将每个接入ISP都连接到全局ISP，客户ISPs和提供者ISPs又经纪合约，这样一定会有竞争者有利可图，一定存在竞争，于是不能直接这么干；</p><p><img src="https://s2.loli.net/2023/02/09/jEsRQm896bUuTCF.png" alt="avatar"></p><ul><li>POP: 高层ISP面向客户网络的接入点，涉及费用结算<ul><li>如一个低层ISP接入多个高层ISP，多宿（multi home）</li></ul></li><li>对等接入：2个ISP对等互接，不涉及费用结算</li><li>IXP：多个对等ISP互联互通之处，通常不涉及费用结算<ul><li>对等接入</li></ul></li><li>ICP自己部署专用网络，同时和各级ISP连接</li></ul><hr><h2 id="协议层次及服务模型"><a href="#协议层次及服务模型" class="headerlink" title="协议层次及服务模型"></a>协议层次及服务模型</h2><p>网络有很多构成元素和设备：</p><ul><li>主机</li><li>路由器</li><li>各种媒体的链路</li><li>应用</li><li>协议</li><li>硬件，软件</li><li>…</li></ul><p>如何组织和实现这个复杂的网络功能呢？答案是<strong>分层</strong>！</p><h3 id="层次化方式实现复杂网络功能："><a href="#层次化方式实现复杂网络功能：" class="headerlink" title="层次化方式实现复杂网络功能："></a>层次化方式实现复杂网络功能：</h3><ul><li>将网络复杂的功能分层功能明确的<strong>层次</strong>，每一层实现了其中一个或一组<strong>功能</strong>，功能中有其上层可以使用的功能：<strong>服务</strong>；</li><li>本层协议实体相互交互执行本层的<strong>协议动作</strong>，<em>目的是实现本层功能，通过接口为上层提供更好的服务</em>；</li><li>在实现本层协议的时候，直接利用了下层所提供的服务；</li><li>本层的服务：借助下层服务实现的本层协议实体之间交互带来的新功能（上层可以利用的）+ 更下层所提供的服务；</li></ul><h3 id="服务与协议："><a href="#服务与协议：" class="headerlink" title="服务与协议："></a>服务与协议：</h3><h4 id="服务与协议的区别"><a href="#服务与协议的区别" class="headerlink" title="服务与协议的区别"></a>服务与协议的区别</h4><ul><li>服务(Service)：低层实体<strong>向上层</strong>实体提供它们之间的通信的能力，是通过原语(primitive)来操作的，垂直的</li><li>协议(protocol) ：<strong>对等层</strong>实体(peer entity)之间在相互通信的过程中，需要遵循的规则的集合，水平的</li></ul><h4 id="服务与协议的联系"><a href="#服务与协议的联系" class="headerlink" title="服务与协议的联系"></a>服务与协议的联系</h4><ul><li>本层协议的实现要靠下层提供的服务来实现</li><li>本层实体通过协议为上层提供更高级的服务</li></ul><h3 id="什么是数据包？"><a href="#什么是数据包？" class="headerlink" title="什么是数据包？"></a>什么是数据包？</h3><p>数据包是通过互联网传输的<strong>信息的基本单位</strong>。将信息拆分成小的、可消化的部分可以更有效地利用网络的容量。</p><p>数据包的组成：</p><ul><li>标头：包含帮助数据包到达其目标的信息，包括<strong>数据包的长度、源和目标</strong>，以及帮助接收方检测数据包在传输过程中是否损坏的<strong>校验和值</strong>。</li><li>实际数据：一个数据包最多可以包含 64 KB 的数据，大约是 20 页的纯文本。</li></ul><p>此外，如果互联网路由器遇到拥塞或其他技术问题，则可以通过简单地丢弃数据包来处理它。发送计算机负责检测数据包未到达其目标并发送另一个副本。这种方法似乎违反直觉，但它简化了互联网的核心基础设施，以更低的成本实现更高的性能。</p><h3 id="数据单元DU："><a href="#数据单元DU：" class="headerlink" title="数据单元DU："></a>数据单元DU：</h3><p><img src="https://s2.loli.net/2023/02/09/LAfnrGHpzymOXt1.png" alt="avatar"></p><p>上文提到过的：</p><p>PDU (Protocol Data Unit)协议数据单元，是指对等层次之间传递的数据单位。</p><ul><li>物理层的PDU是<code>bit</code></li><li>数据链路层的PDU是<code>数据帧frame</code></li><li>网络层的PDU是<code>数据包packet</code></li><li>传输层的PDU是<code>数据段segment</code></li><li>其他更高层次的PDU是数据<code>data</code></li></ul><p><strong>具体来说</strong>：</p><p><img src="https://cdnjson.com/images/2023/03/23/image94c1d7406046a3d4.png" alt="avatar"></p><h3 id="分层处理和实现复杂系统的好处？"><a href="#分层处理和实现复杂系统的好处？" class="headerlink" title="分层处理和实现复杂系统的好处？"></a>分层处理和实现复杂系统的好处？</h3><ul><li>概念化：结构清晰，便于标示网络组件，以及描述其相互关系<ul><li>分层参考模型</li></ul></li><li>结构化：模块化更易于维护和系统升级<ul><li>针对某一层的改变是独立的</li></ul></li></ul><h3 id="Internet协议栈："><a href="#Internet协议栈：" class="headerlink" title="Internet协议栈："></a>Internet协议栈：</h3><p>应用层: 网络应用</p><ul><li>为人类用户或者其他应用进程提供网络应用服务</li><li>FTP，SMTP，HTTP，DNS</li></ul><p>传输层: 主机之间的数据传输</p><ul><li>在网络层提供的端到端通信基础上，细分为进程 到进程，将不可靠的通信变成可靠地通信</li><li>TCP，UDP</li></ul><p>网络层: 为数据包从源到目的选择路由</p><ul><li>主机主机之间的通信，端到端通信，不可靠</li><li>IP，路由协议</li></ul><p>链路层: 相邻网络节点间的数据传输</p><ul><li>2个相邻2点的通信，点到点通信，可靠或不可靠</li><li>点对对协议PPP，802.11(wifi)，Ethernet</li></ul><p>物理层: 在线路上传送bit</p><p><img src="https://cdnjson.com/images/2023/03/23/image58791ea91b1bcfce.png" alt="avatar"></p><h3 id="ISO-x2F-OSI-参考模型："><a href="#ISO-x2F-OSI-参考模型：" class="headerlink" title="ISO &#x2F; OSI 参考模型："></a>ISO &#x2F; OSI 参考模型：</h3><p><img src="https://s2.loli.net/2023/02/09/sUY6iWKrzgXEuAk.png" alt="avatar"></p><h3 id="封装与解封装："><a href="#封装与解封装：" class="headerlink" title="封装与解封装："></a>封装与解封装：</h3><p><img src="https://s2.loli.net/2023/02/09/ujJOm6TViNrvBZw.png" alt="avatar"></p><hr><h2 id="面对攻击的网络"><a href="#面对攻击的网络" class="headerlink" title="面对攻击的网络"></a>面对攻击的网络</h2><p>网络安全领域主要探讨以下问题：</p><ul><li>坏家伙如何攻击计算机网络？</li><li>我们如何防御以免受他们的攻击？</li></ul><h3 id="坏家伙能够经因特网将有害程序放入你的计算机中："><a href="#坏家伙能够经因特网将有害程序放入你的计算机中：" class="headerlink" title="坏家伙能够经因特网将有害程序放入你的计算机中："></a>坏家伙能够经因特网将有害程序放入你的计算机中：</h3><p>一些<strong>恶意软件</strong>，会做各种不正当的事情，包括但不限于删除我们的文件，安装间谍软件来收集隐私信息。</p><p>受害的主机也会变成数以千计的受害设备网络中的一员，被统称为<strong>僵尸网络</strong>。</p><p>如今（当时是2013年），多数恶意软件是通过<strong>自我复制</strong>来操作的，通过病毒或蠕虫的方式扩散：</p><ul><li>病毒：是一种需要某种形式的用户交互来感染用户设备的恶意软件，典型的例子是包含恶意可执行代码的电子邮件附件。</li><li>蠕虫：是一种无需任何明显用户交互就能进入设备的恶意软件，那些应用程序可能从因特网接收恶意软件并运行它，生成了蠕虫。新近感染设备中的蠕虫则能扫描因特网，搜索其他运行相同易受感染的网络应用程序的主机，一经发现便发送一个自身副本。</li></ul><h3 id="坏家伙能够攻击服务器和网络基础设施："><a href="#坏家伙能够攻击服务器和网络基础设施：" class="headerlink" title="坏家伙能够攻击服务器和网络基础设施："></a>坏家伙能够攻击服务器和网络基础设施：</h3><p>另一种宽泛类型的安全性威胁称为<strong>拒绝服务攻击</strong>（Denial-of-Service (DoS) attack），顾名思义，DoS攻击使得网络、主机或其他基础设施部分不能由合法用户所使用。Web服务器、电子邮件服务器、DNS服务器等都可以作为DoS攻击的目标。一般有如下三种类型：</p><ul><li><strong>弱点攻击</strong>：这涉及向一台目标主机上运行的易受攻击的应用程序或操作系统发送制作精细的报文，如果适当顺序的多个分组发送给一个易受攻击的应用程序或操作系统，该服务器可能停止运行，或者更糟糕的是主机可能崩溃。</li><li><strong>带宽洪泛</strong>：攻击者向目标主机发送大量的分组，分组数量之多使得目标的接入链路变得拥塞，使得合法的分组无法到达服务器。</li><li><strong>连接洪泛</strong>：攻击者在目标主机中创建大量的半开或者全开TCP连接，该主机因为这些伪造的连接而陷入困境，并停止接受合法的连接。</li></ul><p>值得一提的是，<strong>分布式DoS</strong>(Distributed DoS)攻击就是大名鼎鼎的DDoS攻击，攻击者控制多个源并让每个源向目标猛烈发送流量，比起单一主机的DoS，DDoS更加难以检测和防范。</p><p><img src="https://s2.loli.net/2023/02/09/gaZ2Cz9KfmYvEIM.png" alt="avatar"></p><h3 id="坏家伙能够嗅探分组："><a href="#坏家伙能够嗅探分组：" class="headerlink" title="坏家伙能够嗅探分组："></a>坏家伙能够嗅探分组：</h3><p>当无处不在的因特网接入极为便利并使得令人惊奇的新应用程序为移动用户所用的同时，也产生了重大的安全弱点——在无线传输设备的附近放置一台被动的接收机，该接收机就能得到传输的每个分组的副本。记录每个流经的分组副本的被动接收机也被称为<strong>分组嗅探器</strong>(packet sniffer)。</p><p>当然，这也能够部署在有线环境中，这里先略过。</p><p>因为分组嗅探器是被动的，也就是说它们不向信道中注入分组，所以难以检测它们的存在，因此，我们向无线信道发送分组的时候，<strong>必须接受这样的可能性</strong>。</p><h3 id="坏家伙能够伪装成你信任的人："><a href="#坏家伙能够伪装成你信任的人：" class="headerlink" title="坏家伙能够伪装成你信任的人："></a>坏家伙能够伪装成你信任的人：</h3><p>这个大家还是挺熟悉的，后面再介绍更加细节的内容。</p><p>这里就介绍一个概念：</p><p>将具有虚假源地址的分组注入因特网的能力被称为<strong>IP哄骗</strong> (IP spoofing)；</p><hr><h2 id="8-计算机网络的历史"><a href="#8-计算机网络的历史" class="headerlink" title="8. 计算机网络的历史"></a>8. 计算机网络的历史</h2><p><img src="https://s2.loli.net/2023/02/09/lt87ge4ZbTCksoW.png" alt="avatar"></p><p>具体内容待补充，敬请期待！</p><p><em>“不闻不若闻之，闻之不若见之，见之不若知之，知之不若行之。”</em></p><hr><h1 id="Unit-1-5-待整理的网络知识"><a href="#Unit-1-5-待整理的网络知识" class="headerlink" title="Unit 1.5 待整理的网络知识"></a>Unit 1.5 待整理的网络知识</h1><h2 id="一、什么是域名系统？"><a href="#一、什么是域名系统？" class="headerlink" title="一、什么是域名系统？"></a>一、什么是域名系统？</h2><p>域名系统<code>DNS</code>是您可以通过在浏览器中键入<code>github.com</code>而不是难以记住的数字地址，如216.148.41.12来访问网页的原因。</p><blockquote><p>域名系统由位于加利福尼亚州的非营利组织ICANN 管理。ICANN成立于1998年。它被美国商务部授予对DNS的权力，尽管它越来越多地声称自己独立于美国政府。</p><p>有两种类型的域名。第一个是通用顶级域 （gTLD），例如 .com、.edu、.org 和 .gov。由于互联网起源于美国，因此这些域名往往在那里最受欢迎。这些域的权限通常委托给私人组织。</p><p>还有国家代码顶级域 （ccTLD）。世界上每个国家都有自己的 2 个字母代码。例如，美国的 ccTLD 是 .us，英国的 ccTLD 是 .uk，中国的 ccTLD 是 .cn。这些域名由每个国家&#x2F;地区的当局管理。一些 ccTLD，如 .tv（代表岛国图瓦卢）和 .io（英属印度洋领地），在本国以外的地方很受欢迎。</p></blockquote><p><img src="http://web.stanford.edu/class/msande91si/www-spr04/readings/week1/InternetWhitepaper_files/ruswp_diag6.gif" alt="avatar"></p><hr><h2 id="二、浏览器的工作原理简述"><a href="#二、浏览器的工作原理简述" class="headerlink" title="二、浏览器的工作原理简述"></a>二、浏览器的工作原理简述</h2><h3 id="0-概述Overview："><a href="#0-概述Overview：" class="headerlink" title="0. 概述Overview："></a>0. 概述Overview：</h3><p>Web性能的两个主要问题：</p><ol><li>与<strong>延迟</strong>有关的问题</li><li>与大多数情况下浏览器是<strong>单线程</strong>的事实有关的问题</li></ol><blockquote><p>延迟是影响我们确保快速加载页面的能力的最大威胁。</p><p>对于流畅的交互，开发人员的目标是确保高性能的网站交互，从平滑滚动到响应触摸。<strong>渲染时间是关键</strong>，要确保主线程能够完成我们投入的所有工作，并且仍然始终可用于处理用户交互。通过了解浏览器的单线程性质并在可能和适当的情况下最小化主线程的职责，可以提高 Web 性能，以确保呈现流畅和对交互的即时响应。</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2c2ce0c78bd4510825974bec7e046d0~tplv-k3u1fbpfcp-zoom-1.image" alt="avatar"></p><hr><h3 id="1-导航Navigation："><a href="#1-导航Navigation：" class="headerlink" title="1. 导航Navigation："></a>1. 导航Navigation：</h3><p>导航是加载网页的第一步；</p><p>每当用户通过在地址栏中输入 URL、单击链接、提交表单以及其他操作来请求页面时，就是导航。</p><p>Web 性能的目标之一是<strong>最大程度地减少完成导航所需的时间</strong>。</p><h4 id="域名解析查找DNS-Lookup："><a href="#域名解析查找DNS-Lookup：" class="headerlink" title="域名解析查找DNS Lookup："></a>域名解析查找DNS Lookup：</h4><p>那么怎么进行导航呢？</p><ol><li>浏览器缓存：首先检查浏览器的DNS缓存，看看是否有缓存的域名解析结果。</li><li>系统缓存：如果浏览器缓存没有结果，系统将检查操作系统的DNS缓存。</li><li>路由器缓存：如果系统缓存没有结果，路由器也会检查其DNS缓存。</li><li>本地DNS服务器：如果路由器缓存没有结果，系统将询问本地DNS服务器，看看它是否已经缓存了域名解析结果。</li><li>根DNS服务器：如果本地DNS服务器没有结果，它将询问根DNS服务器，试图获得域名的解析。</li><li>授权DNS服务器：根DNS服务器会向授权DNS服务器查询，以获取更详细的域名解析信息。</li><li>权威DNS服务器：最后，授权DNS服务器将询问权威DNS服务器，以确定该域名的IP地址。</li><li>缓存结果：找到的结果将被缓存，以便在将来不必再次查询。</li></ol><p><img src="https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work/latency.jpg" alt="avatar"></p><h4 id="TCP三次握手："><a href="#TCP三次握手：" class="headerlink" title="TCP三次握手："></a>TCP三次握手：</h4><p>一旦知道 IP 地址，浏览器就会通过 TCP 三向握手建立与服务器的连接。</p><p>TCP的三向握手技术通常被称为“SYN-SYN-ACK”（或更准确地说是SYN，SYN-ACK，ACK）。</p><p>TCP三次握手是一种网络协议中的握手过程，主要用于确保客户端与服务器之间的可靠通信。步骤如下：</p><ol><li>客户端发送一个SYN（Synchronize）请求报文到服务器，请求建立一个连接。</li><li>服务器收到SYN请求后，回应一个SYN-ACK（Synchronize-Acknowledge）报文，表示同意建立连接。</li><li>客户端收到SYN-ACK报文后，再发送一个ACK（Acknowledge）报文，确认连接建立完成。</li></ol><p>完成三次握手后，客户端与服务器间的连接就建立成功。这样可以确保两端在建立连接前，已经确认了对方的可用性，避免了网络中的垃圾数据或攻击行为。</p><h4 id="TLS协商："><a href="#TLS协商：" class="headerlink" title="TLS协商："></a>TLS协商：</h4><p>对于通过HTTPS建立的安全连接，需要再次“握手”。</p><p>这种握手，或者更确切地说是TLS协商，确定将使用哪种密码来加密通信，验证服务器，并在开始实际数据传输之前建立安全连接。这需要在实际发送内容请求之前再往返服务器三次。</p><p>虽然使连接安全会增加页面加载时间，但安全连接值得延迟费用，因为浏览器和 Web 服务器之间传输的数据无法被第三方解密。</p><p>TLS协商的过程一般包括以下步骤：</p><ol><li>客户端发送”Client Hello”报文给服务器，其中包含了客户端支持的加密协议、会话ID、随机数等信息。</li><li>服务器收到”Client Hello”报文后，会回复”Server Hello”报文给客户端，其中包含了服务器选择的加密协议、会话ID、随机数等信息。</li><li>客户端和服务器通过协商后确定的加密协议进行密钥交换，以确定本次通信的密钥。</li><li>双方确认协商结果后，通信开始加密传输数据。</li></ol><p>TLS协商的过程确保了客户端和服务器之间的通信是安全的，防止了数据在传输过程中的泄露和篡改。</p><p><img src="https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work/ssl.jpg" alt="avatar"></p><hr><h3 id="2-响应Response："><a href="#2-响应Response：" class="headerlink" title="2. 响应Response："></a>2. 响应Response：</h3><p>现在，导航已经结束了，来到了响应的阶段。</p><p>一旦我们与 Web 服务器建立了连接，浏览器就会<strong>代表用户发送初始 HTTP-GET 请求</strong>，</p><p>对于网站来说，该请求通常是 HTML 文件。一旦服务器收到请求，它将回复相关的响应标头和HTML的内容。</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en-US&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>My simple page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;styles.css&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;myscript.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;heading&quot;</span>&gt;</span>My Page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph with a <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://example.com/about&quot;</span>&gt;</span>link<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;myimage.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;image description&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;anotherscript.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="HTTP请求方法："><a href="#HTTP请求方法：" class="headerlink" title="HTTP请求方法："></a>HTTP请求方法：</h4><ul><li>GET 该方法请求指定资源的表示形式。使用的请求应仅检索数据。</li><li>HEAD 该方法请求与请求相同的响应，但没有响应正文。</li><li>POST 该方法将实体提交到指定的资源，这通常会导致服务器的状态更改或副作用。</li><li>PUT 该方法将目标资源的所有当前表示形式替换为请求有效负载。</li><li>DELETE 该方法删除指定的资源。</li><li>CONNECT 该方法建立到目标资源标识的服务器的隧道。</li><li>OPTIONS 该方法描述目标资源的通信选项。</li><li>TRACE 该方法沿目标资源的路径执行消息环回测试。</li><li>PATCH 该方法对资源应用部分修改。</li></ul><h4 id="TCP慢启动-x2F-14KB规则："><a href="#TCP慢启动-x2F-14KB规则：" class="headerlink" title="TCP慢启动 &#x2F; 14KB规则："></a>TCP慢启动 &#x2F; 14KB规则：</h4><p>TCP 慢启动有助于<strong>提高网络能力的传输速度</strong>。</p><p>TCP 慢启动是一种算法，<strong>用于检测数据包传输的可用带宽，并平衡网络连接的速度</strong>。</p><p>它可以防止出现最初功能未知的网络拥塞，并缓慢增加扩散的信息量，直到找到网络的最大容量。</p><p>第一个响应数据包将为 14KB。这是TCP慢启动的一部分，这是一种平衡网络连接速度的算法。</p><p>慢启动会<strong>逐渐增加传输的数据量，直到确定网络的最大带宽</strong>。</p><p>在TCP慢启动中，在收到初始数据包后，服务器将下一个数据包的大小<strong>加倍至28KB</strong>左右。后续数据包的大小会增加，<strong>直到达到预定阈值或遇到拥塞</strong>。</p><p>大概可以理解为逐步试探的倍增过程。</p><h4 id="拥塞控制："><a href="#拥塞控制：" class="headerlink" title="拥塞控制："></a>拥塞控制：</h4><p>当<strong>服务器</strong>以 <strong>TCP 数据包</strong>的形式发送数据时，用户的<strong>客户端</strong>通过<strong>返回确认或 ACK</strong> 来确认传递。</p><p>连接的容量有限，具体取决于硬件和网络条件。如果服务器发送太多数据包太快，它们将<strong>被丢弃</strong>。</p><p>服务器将其注册为缺少的 ACK。拥塞控制算法使用已发送数据包和 ACK 的此流来确定发送速率。</p><hr><h4 id="解析Parsing："><a href="#解析Parsing：" class="headerlink" title="解析Parsing："></a>解析Parsing：</h4><p>一旦浏览器收到第一个数据块，它就可以开始解析收到的信息。</p><p>解析意味着分析程序并将其转换为运行时环境可以实际运行的内部格式，例如浏览器中的 JavaScript 引擎。</p><p>解析是浏览器将它通过网络接收的数据转换为 <strong>DOM</strong> 和 <strong>CSSOM</strong> 的步骤，<strong>渲染器</strong>使用它来将页面绘制到屏幕上。</p><blockquote><p><strong>具体来说</strong>：</p><p>浏览器将 HTML 解析为 DOM 树。HTML 解析涉及标记化和树构造。HTML 标记包括开始和结束标记，以及属性名称和值。如果文档格式正确，则解析它既简单又快速。解析器将标记化的输入解析到文档中，从而构建文档树。</p><p>当 HTML 解析器找到非阻塞资源（如图像）时，浏览器将请求这些资源并继续解析。遇到 CSS 文件时，解析可以继续，但标记（尤其是那些没有异步或属性的标记）会阻止呈现，并暂停 HTML 解析。<code>&lt;script&gt;defer</code></p><p>当浏览器遇到 CSS 样式时，它会将文本解析为 CSS 对象模型（或 CSSOM），这是一种数据结构，然后用于样式布局和绘画。然后，浏览器从这两种结构创建一个呈现树，以便能够将内容绘制到屏幕上。JavaScript 也会被下载、解析，然后执行。</p></blockquote><h4 id="构建DOM树："><a href="#构建DOM树：" class="headerlink" title="构建DOM树："></a>构建DOM树：</h4><p>DOM 树描述文档的内容。<html> 元素是文档树的第一个标记和根节点。</p><p>树反映了不同标签之间的关系和层次结构。嵌套在其他标签中的标签是子节点。</p><p>DOM 节点的数量越多，构建 DOM 树所需的时间就越长。</p><p><img src="https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work/dom.gif" alt="avatar"></p><h4 id="预加载扫描仪Preload-Scanner："><a href="#预加载扫描仪Preload-Scanner：" class="headerlink" title="预加载扫描仪Preload Scanner："></a>预加载扫描仪Preload Scanner：</h4><blockquote><p>当浏览器构建 DOM 树时，此过程占用主线程。</p><p>发生这种情况时，预加载扫描程序将解析可用内容并请求高优先级资源，如 CSS、JavaScript 和 Web 字体。</p><p>多亏了预加载扫描程序，我们不必等到解析器找到对外部资源的引用来请求它。</p><p>它将在后台检索资源，以便在主 HTML 解析器到达请求的资产时，它们可能已经在运行中，或者已被下载。预加载扫查器提供的优化可减少阻塞。</p></blockquote><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;styles.css&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;myscript.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;myimage.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;image description&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;anotherscript.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在此示例中，当主线程解析 HTML 和 CSS 时，预加载扫描程序将找到脚本和图像，并开始下载它们。若要确保脚本不会阻止进程，请添加属性，或者如果 JavaScript 解析和执行顺序很重要，请添加属性。</p><h4 id="构建CSSOM树："><a href="#构建CSSOM树：" class="headerlink" title="构建CSSOM树："></a>构建CSSOM树：</h4><p>关键呈现路径中的第二步是处理 CSS 并构建 CSSOM 树。</p><p>CSS 对象模型类似于 DOM。DOM 和 CSSOM 都是树。它们是独立的数据结构。</p><p>浏览器将 CSS 规则转换为它可以理解和使用的样式映射。浏览器遍历 CSS 中的每个规则集，根据 CSS 选择器创建具有父、子和同级关系的节点树。</p><p><img src="https://s2.loli.net/2023/01/30/wzGjACSikPZ6rWp.png" alt="avatar"></p><p>除此之外，还有一些内容例如JavaScript编译和构建辅助功能树等等，这里不展开叙述。</p><hr><h3 id="3-渲染Render"><a href="#3-渲染Render" class="headerlink" title="3. 渲染Render"></a>3. 渲染Render</h3><p>接下来是渲染部分，以下是四个比较重要的内容：</p><h4 id="Style"><a href="#Style" class="headerlink" title="Style"></a>Style</h4><p>关键渲染路径中的第三步是将 DOM 和 CSSOM 组合到渲染树中。计算样式树或渲染树的构造从 DOM 树的根开始，遍历每个可见节点。</p><h4 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h4><p>关键渲染路径中的第四步是在渲染树上运行布局，以计算每个节点的几何体。<em>布局</em>是确定呈现树中所有节点的宽度、高度和位置的过程，也是确定页面上每个对象的大小和位置的过程。<em>重排</em>是页面任何部分或整个文档的任何后续大小和位置确定。</p><h4 id="Paint"><a href="#Paint" class="headerlink" title="Paint"></a>Paint</h4><p>关键渲染路径的最后一步是将各个节点绘制到屏幕上，第一次出现称为第一次有意义的绘制。在绘画或光栅化阶段，浏览器将布局阶段计算的每个框转换为屏幕上的实际像素。绘画涉及将元素的每个视觉部分绘制到屏幕上，包括文本、颜色、边框、阴影以及按钮和图像等替换元素。浏览器需要非常快速地完成此操作。</p><h4 id="Compositing"><a href="#Compositing" class="headerlink" title="Compositing"></a>Compositing</h4><p>一旦主线程完成页面绘制，你会认为我们会“一切就绪”。事实未必如此。如果加载包含 JavaScript，该 JavaScript 已正确延迟，并且仅在 onload 事件触发后执行，则主线程可能繁忙，并且不可用于滚动、触摸和其他交互。</p><p>到这一步，浏览器的工作基本上就算是完成了。</p><hr><h2 id="三、Hosting"><a href="#三、Hosting" class="headerlink" title="三、Hosting"></a>三、Hosting</h2><h3 id="0-概述Overview：-1"><a href="#0-概述Overview：-1" class="headerlink" title="0. 概述Overview："></a>0. 概述Overview：</h3><p>Hosting是指<strong>将网站存储在服务器上</strong>，以便全球用户<strong>通过互联网访问该网站</strong>的服务。它包括：</p><ol><li>服务器租赁：为网站提供存储空间和带宽</li><li>网络架构：确保网站可以连接到互联网</li><li>技术支持：协助解决网站运行问题</li><li>网站维护：保证服务器性能和安全性</li></ol><p>有多种不同的Hosting服务，如共享Hosting，虚拟专用服务器（VPS）和独立专用服务器（Dedicated Server）。</p><p>根据网站的需求，个人或企业可以选择合适的Hosting服务。</p><h3 id="1-Hosting细节："><a href="#1-Hosting细节：" class="headerlink" title="1. Hosting细节："></a>1. Hosting细节：</h3><ol><li>备份：一些Hosting提供商提供定期备份功能，以确保数据安全</li><li>安全：保护网站免受黑客攻击，提供SSL证书等安全功能是一项重要的任务</li><li>可扩展性：随着网站的发展，需要更多的存储空间和带宽，因此要选择可扩展的Hosting服务</li><li>性能：网站速度和可用性对用户体验有很大影响，因此要选择高性能的Hosting服务</li><li>技术支持：良好的技术支持是网站运行的重要保证，选择提供全天候技术支持的Hosting提供商是一个好选择。</li></ol><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;em&gt;Computer Networking A Top-Down Approach Learning Note Part 1&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;本文是笔者初学计算机网络的笔记和一些心得，难免会有部分</summary>
      
    
    
    
    <category term="408" scheme="https://conqueror712.github.io/categories/408/"/>
    
    
  </entry>
  
  <entry>
    <title>RabbitMQ丨学习记录</title>
    <link href="https://conqueror712.github.io/post/RabbitMQ.html"/>
    <id>https://conqueror712.github.io/post/RabbitMQ.html</id>
    <published>2023-02-01T02:42:42.000Z</published>
    <updated>2023-03-23T01:23:35.115Z</updated>
    
    <content type="html"><![CDATA[<h1 id="零、前言"><a href="#零、前言" class="headerlink" title="零、前言"></a>零、前言</h1><p>本文记录了笔者在学习消息队列和RabbitMQ的基础知识的过程，</p><p>若笔者有任何疏忽纰漏之处，烦请不吝赐教。</p><p>本文会不断的补充、修改和完善，期待您的宝贵意见。</p><blockquote><p>个人博客：<a href="https://conqueror712.github.io/">https://conqueror712.github.io/</a></p><p>知乎：<a href="https://www.zhihu.com/people/soeur712/posts">https://www.zhihu.com/people/soeur712/posts</a></p><p>Bilibili：<a href="https://space.bilibili.com/57089326">https://space.bilibili.com/57089326</a></p><p>掘金：<a href="https://juejin.cn/user/1297878069809725/posts">https://juejin.cn/user/1297878069809725/posts</a></p></blockquote><h2 id="什么是中间件？为什么要使用它？"><a href="#什么是中间件？为什么要使用它？" class="headerlink" title="什么是中间件？为什么要使用它？"></a>什么是中间件？为什么要使用它？</h2><p>中间件 Middleware 是<strong>处于操作系统和应用程序之间的软件</strong>。</p><p>人们在使用中间件时，往往是一组中间件<strong>集成在一起</strong>，构成一个平台（包括开发平台和运行平台），</p><p>但在这组中间件中必须要有一个<strong>通信中间件</strong>，即<code>中间件 = 平台 + 通信</code>，</p><p>这个定义也限定了只有<strong>用于分布式系统</strong>中才能称为中间件，同时还可以把它与支撑软件和实用软件区分开来。</p><p>中间件<strong>屏蔽了底层操作系统的复杂性</strong>，使程序开发人员面对一个简单而统一的开发环境，减少程序设计的复杂性，将注意力集中在自己的业务上，不必再为程序在不同系统软件上的移植而重复工作，从而大大减少了技术上的负担。</p><p>中间件带给应用系统的，不只是开发的简便、开发周期的缩短，也减少了系统的维护、运行和管理的工作量，还减少了计算机总体费用的投入。</p><p>中间件应该具有以下的<strong>特点</strong>：</p><ul><li>满足大量应用的需要</li><li>运行于多种硬件和OS平台</li><li>支持分布计算，提供跨网络、硬件和OS平台的透明性的应用或服务的交互</li><li>支持标准的协议</li><li>支持标准的接口</li></ul><p>另外，中间件的技术一般现在一些互联网公司或者项目中使用比较多，如果仅仅还只是一个初创公司建议还是使用单体架构，最多加个缓存中间件即可，不要盲目追求新或者所谓的高性能，而<strong>追求的背后一定是业务的驱动和项目的驱动</strong>。</p><h2 id="MindMap："><a href="#MindMap：" class="headerlink" title="MindMap："></a><strong>MindMap</strong>：</h2><p><img src="https://s2.loli.net/2023/02/01/bB8HDJIs2tlKSXw.png" alt="avatar"></p><h2 id="学习目标与技巧"><a href="#学习目标与技巧" class="headerlink" title="学习目标与技巧"></a>学习目标与技巧</h2><p><strong>我们需要理解和掌握</strong>：</p><ul><li>什么是消息中间件</li><li>什么是协议</li><li>什么是持久化</li><li>消息分发</li><li>消息的高可用</li><li>消息的集群</li><li>消息的容错</li><li>消息的冗余</li></ul><p><strong>一些可供参考的方法</strong>：</p><ul><li>理解中间件在项目架构中的作用，以及各中间件的底层实现；</li><li>可以使用一些类比的生活概念去理解中间件；</li><li>使用一些流程图或者脑图的方式去梳理各个中间件在架构中的作用；</li><li>思考中间件在项目中设计的和使用的原因；</li><li>学会查看中间件的源码以及开开源项目和博客。</li></ul><hr><h1 id="一、分布式架构与消息中间件"><a href="#一、分布式架构与消息中间件" class="headerlink" title="一、分布式架构与消息中间件"></a>一、分布式架构与消息中间件</h1><h2 id="0-分布式架构"><a href="#0-分布式架构" class="headerlink" title="0. 分布式架构"></a>0. 分布式架构</h2><p>通俗解释分布式系统：<strong>一个请求由服务器端的多个服务协同处理完成</strong>。</p><p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/02/28/kuangstudyd40834ed-a15f-4606-bb36-ce475b05a949.png" alt="avatar"></p><blockquote><p><strong>存在问题</strong><br>1：学习成本高，技术栈过多；<br>2：运维成本和服务器成本增高；<br>3：人员的成本也会增高；<br>4：项目的负载度也会上升；<br>5：面临的错误和容错性也会成倍增加；<br>6：占用的服务器端口和通讯的选择的成本高；<br>7：安全性的考虑和因素逼迫可能选择RMI&#x2F;MQ相关的服务器端通讯。</p><p><strong>好处</strong><br>1：服务系统的独立，占用的服务器资源减少和占用的硬件成本减少；<br>确切的说是：可以合理的分配服务资源，不造成服务器资源的浪费；<br>2：系统的独立维护和部署，耦合度降低，可插拔性；<br>3：系统的架构和技术栈的选择可以变的灵活；<br>4：弹性的部署，不会造成平台因部署造成的瘫痪和停服的状态。</p></blockquote><hr><h2 id="1-消息中间件"><a href="#1-消息中间件" class="headerlink" title="1. 消息中间件"></a>1. 消息中间件</h2><h3 id="消息中间件的主要作用："><a href="#消息中间件的主要作用：" class="headerlink" title="消息中间件的主要作用："></a>消息中间件的<strong>主要作用</strong>：</h3><ul><li>利用可靠的消息传递机制进行<strong>系统和系统直接的通讯</strong>；</li><li>通过提供消息传递和消息的排队机制，它可以在分布式系统环境下<strong>扩展进程间的通讯</strong>。</li></ul><h3 id="消息中间件的应用场景："><a href="#消息中间件的应用场景：" class="headerlink" title="消息中间件的应用场景："></a>消息中间件的应用场景：</h3><ul><li>跨系统数据传递；</li><li>高并发的流量削峰；</li><li>数据的分发和异步处理；</li><li>大数据分析与传递；</li><li>分布式事务；</li></ul><p>很常见的一个例子就是电商的并发订单。</p><h3 id="消息中间件的本质及设计："><a href="#消息中间件的本质及设计：" class="headerlink" title="消息中间件的本质及设计："></a>消息中间件的本质及设计：</h3><p>它是一种接受数据，接受请求、存储数据、发送数据等功能的技术服务。</p><p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/02/28/kuangstudy7c171d88-687a-4c6c-8a97-2b257467172e.png" alt="avatar"></p><h3 id="消息中间件的核心组成部分："><a href="#消息中间件的核心组成部分：" class="headerlink" title="消息中间件的核心组成部分："></a>消息中间件的核心组成部分：</h3><ul><li>消息的协议</li><li>消息的持久化机制</li><li>消息的分发策略</li><li>消息的高可用，高可靠</li><li>消息的容错机制</li></ul><hr><h1 id="二、消息与消息队列"><a href="#二、消息与消息队列" class="headerlink" title="二、消息与消息队列"></a>二、消息与消息队列</h1><h2 id="0-网络协议简介"><a href="#0-网络协议简介" class="headerlink" title="0. 网络协议简介"></a>0. 网络协议简介</h2><p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/03/02/kuangstudy9e91d500-e775-45f3-92fa-78a6278efc51.png" alt="avatar"></p><p>协议：</p><ol><li>计算机底层操作系统和应用程序通讯时共同遵守的一组约定，只有遵循共同的约定和规范，系统和底层操作系统之间才能相互交流。</li><li>和一般的网络应用程序的不同它主要负责数据的接受和传递，所以性能比较的高。</li><li>协议对数据格式和计算机之间交换数据都必须严格遵守规范。</li></ol><p>协议的<strong>三要素</strong>：</p><ol><li>语法：语法是用户数据与控制信息的结构与格式，以及数据出现的顺序。</li><li>语义：语义是解释控制信息每个部分的意义。它规定了需要发出何种控制信息，以及完成的动作与做出什么样的响应。</li><li>时序：时序是对事件发生顺序的详细说明。</li></ol><blockquote><p>以HTTP请求协议举例：</p><p>语法：http规定了请求报文和响应报文的格式。<br>语义：客户端主动发起请求称之为请求。<br>时序：一个请求对应一个响应，注意是先有请求再有响应。</p></blockquote><blockquote><p>Q：为什么消息中间件不直接使用HTTP协议呢？</p><p>A：首先因为http请求报文头和响应报文头是比较复杂的，包含了cookie，数据的加密解密，状态码，响应码等附加的功能，但是对于一个消息而言，我们并不需要这么复杂，也没有这个必要性，它其实就是负责数据传递，存储，分发就行，一定要追求的是高性能。尽量简洁，快速。其次大部分情况下http大部分都是短链接，在实际的交互过程中，一个请求到响应很有可能会中断，中断以后就不会就行持久化，就会造成请求的丢失。这样就不利于消息中间件的业务场景，因为消息中间件可能是一个长期的获取消息的过程，出现问题和故障要对数据或消息就行持久化等，目的是为了保证消息和数据的高可靠和稳健的运行。</p></blockquote><hr><h3 id="AMQP协议"><a href="#AMQP协议" class="headerlink" title="AMQP协议"></a>AMQP协议</h3><p>Advanced Message Queuing Protocol 高级消息队列协议</p><p>它是一种面向消息中间件的开放标准，支持应用程序之间安全可靠的通信。</p><p>它提供了一个灵活和可扩展的消息体系结构，具有事务、路由和消息持久性等特性。</p><p>特点：</p><ul><li>分布式事务支持。</li><li>消息的持久化支持。</li><li>高性能和高可靠的消息处理优势。</li></ul><h3 id="MQTT协议"><a href="#MQTT协议" class="headerlink" title="MQTT协议"></a>MQTT协议</h3><p>Message Queueing Telemetry Transport </p><p>它是一种轻量级的发布-订阅消息传递协议，专为资源受限的设备和低带宽的网络设计。</p><p>它被广泛应用于物联网(Internet of Things)和M2M (Machine-to-Machine)通信，为设备之间的数据传输和接收提供了一种简单高效的机制。</p><p>特点：</p><ul><li>轻量</li><li>结构简单</li><li>传输快，不支持事务</li><li>没有持久化设计。</li></ul><p>应用场景：</p><ul><li>适用于计算能力有限</li><li>低带宽</li><li>网络不稳定的场景。</li></ul><h3 id="OpenMessage协议"><a href="#OpenMessage协议" class="headerlink" title="OpenMessage协议"></a>OpenMessage协议</h3><p>它是阿里巴巴集团为其中间件产品RocketMQ开发的专有消息协议。</p><p>它提供高性能和可靠的消息传递，具有消息排序、容错和发布-订阅消息等特性。</p><p>特点：</p><ul><li>结构简单</li><li>解析速度快</li><li>支持事务和持久化设计。</li></ul><h3 id="Kafka协议"><a href="#Kafka协议" class="headerlink" title="Kafka协议"></a>Kafka协议</h3><p>Kafka协议是基于TCP&#x2F;IP的二进制协议。</p><p>其消息内部是通过长度来分割，由一些基本数据类型组成。</p><p>特点：</p><ul><li>结构简单</li><li>解析速度快</li><li>无事务支持</li><li>有持久化设计</li></ul><hr><h2 id="1-MQ持久化"><a href="#1-MQ持久化" class="headerlink" title="1. MQ持久化"></a>1. MQ持久化</h2><p>持久化就是将数据存入磁盘，而不是存在内存中随服务器重启断开而消失，使数据能够永久保存。</p><p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/02/28/kuangstudyf908e193-4ca3-44b7-87d0-cbb17b55a107.png" alt="avatar"></p><hr><h2 id="2-消息的分发策略"><a href="#2-消息的分发策略" class="headerlink" title="2. 消息的分发策略"></a>2. 消息的分发策略</h2><p>由于MQ有<strong>生产者、存储信息和消费者</strong>这三个角色，</p><p>那么当生产者生成消息之后，MQ进行存储，消费者通过<code>push</code>和<code>pull</code>来进行获取消息。</p><p>MQ就是一种推送的过程。</p><p>具体来说：</p><p>消息分发策略是指<strong>用于确定哪些消费者从消息传递系统哪里接收什么特定消息的技术</strong>。</p><p>以下是常见的消息分发策略。</p><ul><li><p>Fan-Out：这种策略包括同时向所有订阅者或消费者发送消息。</p></li><li><p>Fan-In：这种策略涉及一次将消息发送给一个consumer，通常采用轮询方式。</p></li><li><p>负载平衡：此策略涉及基于消费者的处理能力和当前工作负载等因素以平衡的方式将消息分发给消费者。</p></li><li><p>分片Sharding：这种策略涉及将消息分成更小的块，称为分片(shard)，并将它们分发给不同的消费者进行并行处理。</p></li><li><p>过滤Filtering：此策略涉及根据预定义的过滤器(如消息内容或消费者类型)将消息发送给消费者的子集。</p></li><li><p>路由Routing：此策略涉及根据其路由键(由消息发布者确定)将消息发送给特定的消费者。</p></li></ul><hr><h2 id="3-MQ高可用和高可靠"><a href="#3-MQ高可用和高可靠" class="headerlink" title="3. MQ高可用和高可靠"></a>3. MQ高可用和高可靠</h2><h3 id="高可用？"><a href="#高可用？" class="headerlink" title="高可用？"></a>高可用？</h3><p>指产品在规定的条件和规定的时间内处于<strong>可执行规定功能状态的能力</strong>。</p><p>高可用有以下几种<strong>集群模式</strong>，都是为了保证消息服务器不会寄，就算寄了依然可以很快的修复或者维持基本功能。</p><ul><li>Master-slave主从共享数据的部署方式</li><li>Master- slave主从同步部署方式</li><li>多主集群同步部署模式</li><li>多主集群转发部署模式</li><li>Master-slave与Breoker-cluster组合的方案</li></ul><h3 id="高可靠？"><a href="#高可靠？" class="headerlink" title="高可靠？"></a>高可靠？</h3><p>指系统可以<strong>无故障地持续运行</strong>，若一个系统突然崩溃、报错、异常，能不影响线上业务的正常运行，且出错的几率极低。</p><p>若想达到高可靠性，需要考虑以下两点：</p><ul><li>消息的传输：通过协议来保证系统间数据解析的正确性。</li><li>消息的存储可靠：通过持久化来保证消息的可靠性。</li></ul><hr><h1 id="三、RabbitMQ入门"><a href="#三、RabbitMQ入门" class="headerlink" title="三、RabbitMQ入门"></a>三、RabbitMQ入门</h1><blockquote><p>环境：</p><ul><li>Windows 10</li><li>Docker</li><li>VSCode</li><li>勤劳的双手</li></ul></blockquote><p><em>笔者致力于创作上至老奶奶，下至小狗狗都能看懂的教程！</em></p><h2 id="0-Docker下安装RabbitMQ"><a href="#0-Docker下安装RabbitMQ" class="headerlink" title="0. Docker下安装RabbitMQ"></a>0. Docker下安装RabbitMQ</h2><h3 id="拉取镜像："><a href="#拉取镜像：" class="headerlink" title="拉取镜像："></a>拉取镜像：</h3><p>在cmd中直接输入以下即可，实测不需要打开管理员权限，也不需要切换目录；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker search rabbitMq</span><br><span class="line"></span><br><span class="line">docker pull docker.io/rabbitmq:3.8-management</span><br></pre></td></tr></table></figure><h3 id="创建容器："><a href="#创建容器：" class="headerlink" title="创建容器："></a>创建容器：</h3><p>进入 Docker Desktop 查看镜像ID，当然你也可以<code>docker images</code></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/829e35d4eaca409789a9b316e6a30334~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>将其复制并在cmd中输入以下指令来创建rabbitMq容器：</p><p><code>docker run --name rabbitmq -d -p 15672:15672 -p 5672:5672 818bf18535d7</code></p><p>参数说明：</p><ul><li><code>--name</code>是容器名称，这里我们使用的是<code>rabbitmq</code></li><li><code>-d</code>是令容器后台运行</li><li><code>-p</code>是设置容器内部端口号与主机的映射，web端口默认值为<code>15672</code>，数据通信端口默认值为<code>5672</code></li></ul><p>如果返回一大串容器ID那就说明创建成功啦！</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c90c89a804c04178aa9e10d9bc453eeb~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h3 id="查看状态："><a href="#查看状态：" class="headerlink" title="查看状态："></a>查看状态：</h3><p>这个时候我们可以查看容器是否在运行，当然你也可以使用<code>docker ps</code>来查看</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d09b86a5bfa54900af5361ed1c366de2~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>同样的，我们在这里把容器ID复制下来之后使用<code>docker logs -f &lt;ID&gt;</code>可以查看容器的日志；</p><p>特别地，容器的ID可以简写，前提是保证前缀不与其他容器的相同。</p><p>就像这样：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87bba41248a7409992a835504cd6b1cc~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><hr><h2 id="1-Web端的简单测试"><a href="#1-Web端的简单测试" class="headerlink" title="1. Web端的简单测试"></a>1. Web端的简单测试</h2><h3 id="进入Web端："><a href="#进入Web端：" class="headerlink" title="进入Web端："></a>进入Web端：</h3><p>首先进入cmd输入<code>ipconfig</code>获取本机IP：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7380674c5874444bfa3eab1de3de6c3~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>随后输入<code>&lt;IP&gt;:15672</code>进入RabbitMQ的Web端，</p><p>例如笔者就是<code>192.168.1.4:15672</code>，随后出现如下界面：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1dcada7a7e04ee980a0be35a7d2df24~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>这个时候我们还没有创建任何账户，默认使用<code>guest</code>进行登录（账密都是）：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a42acef3e2544458b6394896a74faef2~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>Oh非常好，我们看到了想要的界面！</p><hr><h3 id="创建新的账户："><a href="#创建新的账户：" class="headerlink" title="创建新的账户："></a>创建新的账户：</h3><p>人活一世，总不能连个名字都没有，接下来我们就来创建一个新的账户，</p><p>毕竟guest有各种访问限制；</p><p>我们首先<strong>进入容器</strong>：<code>docker exec -i -t &lt;容器ID&gt; bin/bash</code></p><p>当然你也可以使用点击即送的方法进入，不过这次并不推荐：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c5f7f91484e429b9c526d4fe7a6de7e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>随后<strong>添加用户</strong>：<code>rabbitmqctl add_user &lt;username&gt; &lt;password&gt;</code></p><p>方便起见，我们就用root了，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@638f5fe7d784:/# rabbitmqctl add_user root 13243546</span><br><span class="line">Adding user &quot;root&quot; ...</span><br><span class="line">Done. Don&#x27;t forget to grant the user permissions to some virtual hosts! See &#x27;rabbitmqctl help set_permissions&#x27; to learn more.</span><br></pre></td></tr></table></figure><p>这个时候root还不是”root”呀，我们不能袖手旁观，需要<strong>赋予权限</strong>：</p><p><code>rabbitmqctl set_permissions -p / root &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</code></p><p>这样可能还不够，还需要给其赋予administrator的角色：</p><p><code>rabbitmqctl set_user_tags root administrator</code></p><h3 id="查看所用用户："><a href="#查看所用用户：" class="headerlink" title="查看所用用户："></a>查看所用用户：</h3><p><code>rabbitmqctl list_users</code></p><p>以上的cmd效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@638f5fe7d784:/# rabbitmqctl set_permissions -p / root &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br><span class="line">Setting permissions for user &quot;root&quot; in vhost &quot;/&quot; ...</span><br><span class="line">root@638f5fe7d784:/# rabbitmqctl set_user_tags root administrator</span><br><span class="line">Setting tags for user &quot;root&quot; to [administrator] ...</span><br><span class="line">root@638f5fe7d784:/# rabbitmqctl list_users</span><br><span class="line">Listing users ...</span><br><span class="line">user    tags</span><br><span class="line">guest   [administrator]</span><br><span class="line">root    [administrator]</span><br></pre></td></tr></table></figure><h3 id="回到Web端，再次登录："><a href="#回到Web端，再次登录：" class="headerlink" title="回到Web端，再次登录："></a>回到Web端，再次登录：</h3><p>这时可以关闭退出容器了，直接<code>exit + 右上角</code>关闭cmd即可；</p><p>然后Log Out一下guest账户，重新输入刚才的账户：</p><p>可以看到，我们卷土重来了！</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afb205703f6b488780a1ca70283d6e25~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><hr><h2 id="2-Go-RabbitMQ实现HelloWorld"><a href="#2-Go-RabbitMQ实现HelloWorld" class="headerlink" title="2. Go + RabbitMQ实现HelloWorld"></a>2. Go + RabbitMQ实现HelloWorld</h2><p>没错，你没有看错，又是<code>HelloWorld</code>，话不多说让我们进入正题：</p><p>打开cmd，进入你想要的项目文件夹，老规矩<code>go mod init &lt;...&gt;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go mod init go-rabbitmq-demo</span><br><span class="line">go: creating new go.mod: module go-rabbitmq-demo</span><br><span class="line">code .  // 打开我们亲爱的VSCode</span><br></pre></td></tr></table></figure><p>随后创建send.go</p><p>引入<code>github.com/streadway/amqp</code>并<code>go mod tidy</code></p><h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><p>定义一个辅助函数用于检查每个amqp调用的返回值；</p><p>发送方和接收方最好都要有；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义辅助函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">failOnError</span><span class="params">(err <span class="type">error</span>, msg <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatalf(<span class="string">&quot;%s: %s&quot;</span>, msg, err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="send-go主函数"><a href="#send-go主函数" class="headerlink" title="send.go主函数"></a>send.go主函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 建立与 RabbitMQ 的连接</span></span><br><span class="line">    <span class="comment">// 配置连接套接字，定义连接的协议与身份验证</span></span><br><span class="line">    conn, err := amqp.Dial(<span class="string">&quot;amqp://guest:guest@localhost:5672/&quot;</span>)</span><br><span class="line">    failOnError(err, <span class="string">&quot;Failed to connect to RabbitMQ&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建通道来传递消息</span></span><br><span class="line">    ch, err := conn.Channel()</span><br><span class="line">    failOnError(err, <span class="string">&quot;Failed to open a channel&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> ch.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明要发送到的队列</span></span><br><span class="line">    q, err := ch.QueueDeclare(</span><br><span class="line">        <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">        <span class="literal">false</span>,</span><br><span class="line">        <span class="literal">false</span>,</span><br><span class="line">        <span class="literal">false</span>,</span><br><span class="line">        <span class="literal">false</span>,</span><br><span class="line">        <span class="literal">nil</span>,</span><br><span class="line">    )</span><br><span class="line">    failOnError(err, <span class="string">&quot;Failed to declare a queue&quot;</span>)</span><br><span class="line">    <span class="comment">// ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)</span></span><br><span class="line">    <span class="comment">// defer cancel()</span></span><br><span class="line"></span><br><span class="line">    body := <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将消息发布到声明的队列</span></span><br><span class="line">    err = ch.Publish(</span><br><span class="line">        <span class="string">&quot;&quot;</span>,</span><br><span class="line">        q.Name,</span><br><span class="line">        <span class="literal">false</span>,</span><br><span class="line">        <span class="literal">false</span>,</span><br><span class="line">        amqp.Publishing&#123;</span><br><span class="line">            ContentType: <span class="string">&quot;text/plain&quot;</span>,</span><br><span class="line">            Body:        []<span class="type">byte</span>(body),</span><br><span class="line">        &#125;)</span><br><span class="line">    failOnError(err, <span class="string">&quot;Failed to publish a message&quot;</span>)</span><br><span class="line">    <span class="comment">// log.Printf(&quot; [x] Sent %s\n&quot;, body)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="receive-go主函数"><a href="#receive-go主函数" class="headerlink" title="receive.go主函数"></a>receive.go主函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 建立与 RabbitMQ 的连接</span></span><br><span class="line">    conn, err := amqp.Dial(<span class="string">&quot;amqp://guest:guest@localhost:5672/&quot;</span>)</span><br><span class="line">    failOnError(err, <span class="string">&quot;Failed to connect to RabbitMQ&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取通道</span></span><br><span class="line">    ch, err := conn.Channel()</span><br><span class="line">    failOnError(err, <span class="string">&quot;Failed to open a channel&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> ch.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明队列</span></span><br><span class="line">    q, err := ch.QueueDeclare(</span><br><span class="line">        <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">        <span class="literal">false</span>,</span><br><span class="line">        <span class="literal">false</span>,</span><br><span class="line">        <span class="literal">false</span>,</span><br><span class="line">        <span class="literal">false</span>,</span><br><span class="line">        <span class="literal">nil</span>,</span><br><span class="line">    )</span><br><span class="line">    failOnError(err, <span class="string">&quot;Failed to declare a queue&quot;</span>)</span><br><span class="line"></span><br><span class="line">    msgs, err := ch.Consume(</span><br><span class="line">        q.Name, <span class="comment">// queue</span></span><br><span class="line">        <span class="string">&quot;&quot;</span>,     <span class="comment">// consumer</span></span><br><span class="line">        <span class="literal">true</span>,   <span class="comment">// auto-ack</span></span><br><span class="line">        <span class="literal">false</span>,  <span class="comment">// exclusive</span></span><br><span class="line">        <span class="literal">false</span>,  <span class="comment">// no-local</span></span><br><span class="line">        <span class="literal">false</span>,  <span class="comment">// no-wait</span></span><br><span class="line">        <span class="literal">nil</span>,    <span class="comment">// args</span></span><br><span class="line">    )</span><br><span class="line">    failOnError(err, <span class="string">&quot;Failed to register a consumer&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> forever <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> d := <span class="keyword">range</span> msgs &#123;</span><br><span class="line">            log.Printf(<span class="string">&quot;Received a message: %s&quot;</span>, d.Body)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    log.Printf(<span class="string">&quot; [*] Waiting for messages. To exit press CTRL+C&quot;</span>)</span><br><span class="line">    &lt;-forever</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="运行！"><a href="#运行！" class="headerlink" title="运行！"></a>运行！</h3><p>分别在两个cmd里面执行<code>go run send.go</code>和<code>go run receive.go</code></p><p>注意，<code>send</code>可以执行多次之后再执行<code>receive</code>，也可以先开启<code>receive</code>，读者不妨自己尝试一下；</p><p>我们可以在Web端看到，Channel中有数据的情况：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9ecbca20ad34c709f77526162c1d41f~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>终端的情况是这样的：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/221f097bdec64106bc3ecc12fe65270a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h3 id="文件目录结构"><a href="#文件目录结构" class="headerlink" title="文件目录结构"></a>文件目录结构</h3><p>很简单，就这四个东西：</p><p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5368c5bc790d41a183dba9283c2b496c~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"  /></p><hr><p>THE END.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;零、前言&quot;&gt;&lt;a href=&quot;#零、前言&quot; class=&quot;headerlink&quot; title=&quot;零、前言&quot;&gt;&lt;/a&gt;零、前言&lt;/h1&gt;&lt;p&gt;本文记录了笔者在学习消息队列和RabbitMQ的基础知识的过程，&lt;/p&gt;
&lt;p&gt;若笔者有任何疏忽纰漏之处，烦请不吝赐教。&lt;/</summary>
      
    
    
    
    <category term="Devlopment-Tech" scheme="https://conqueror712.github.io/categories/Devlopment-Tech/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker + VSCode丨学习记录</title>
    <link href="https://conqueror712.github.io/post/Docker.html"/>
    <id>https://conqueror712.github.io/post/Docker.html</id>
    <published>2023-01-29T06:06:45.000Z</published>
    <updated>2023-03-23T01:30:57.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="零、前言："><a href="#零、前言：" class="headerlink" title="零、前言："></a>零、前言：</h1><p>本文是笔者从零开始学习Docker的学习记录。</p><p>若笔者有任何疏忽纰漏之处，烦请不吝赐教。</p><blockquote><p>个人博客：<a href="https://conqueror712.github.io/">https://conqueror712.github.io/</a></p><p>知乎：<a href="https://www.zhihu.com/people/soeur712/posts">https://www.zhihu.com/people/soeur712/posts</a></p><p>Bilibili：<a href="https://space.bilibili.com/57089326">https://space.bilibili.com/57089326</a></p><p>掘金：<a href="https://juejin.cn/user/1297878069809725/posts">https://juejin.cn/user/1297878069809725/posts</a></p></blockquote><h1 id="一、Docker简介："><a href="#一、Docker简介：" class="headerlink" title="一、Docker简介："></a>一、Docker简介：</h1><p>Docker 是一个应用打包、分发、部署的工具<br>你也可以把它理解为一个轻量的虚拟机，它只虚拟你软件需要的运行环境，多余的一点都不要，<br>而普通虚拟机则是一个完整而庞大的系统，包含各种不管你要不要的软件。</p><p>Docker 的入门知识还有以下几点需要了解：</p><ol><li><p>镜像 (image) 和容器 (container) 的关系：镜像是容器的模板，容器是镜像运行时的实例。</p></li><li><p>Docker Hub：Docker Hub 是一个公共镜像仓库，可以在这里搜索和下载镜像。</p></li><li><p>Dockerfile: 一个Dockerfile 文件是一个文本文件，包含了一条条指令，它告诉Docker如何构建一个镜像.</p></li><li><p>容器网络:Docker支持多种网络模式,包括host,bridge,overlay等.</p></li><li><p>数据管理:Docker支持将容器中的数据挂载到宿主机上,或者将容器间共享数据.</p></li><li><p>使用docker-compose:docker-compose是一个用来管理多个容器的工具,可以通过一个配置文件来管理多个容器,并且可以一键启动和停止.</p></li><li><p>注意事项：</p><ul><li><p>不要在root用户下运行Docker，需要使用sudo</p></li><li><p>在开发过程中，需要注意容器的版本管理，保证不同环境的稳定性</p></li><li><p>需要注意容器的网络配置，确保容器之间可以互相访问</p></li><li><p>容器中的数据需要及时备份</p></li></ul></li></ol><hr><h1 id="二、小试牛刀"><a href="#二、小试牛刀" class="headerlink" title="二、小试牛刀"></a>二、小试牛刀</h1><h2 id="快速开始："><a href="#快速开始：" class="headerlink" title="快速开始："></a>快速开始：</h2><p>一个非常简单的办法，结合vscode：</p><p>以一个Go项目举例：</p><p><code>docker run -dit -v /d/goenv:/root/goenv golang</code><br>注意：地址可以自己更换</p><p><code>docker run</code> 是用来启动一个新的 Docker 容器的命令。</p><ul><li><code>-d</code> : 后台运行容器，即在后台运行容器而不阻塞当前的终端。</li><li><code>-i</code> : 保留标准输入的活性，这样可以在容器中使用命令行</li><li><code>-t</code> : 分配一个伪终端（tty），这样可以在容器中使用命令行</li><li><code>-v /d/goenv:/root/goenv</code> : 使用 <code>-v</code> 选项将主机的 <code>/d/goenv</code> 目录挂载到容器的 <code>/root/goenv</code> 目录。这样就可以在容器中访问主机上的文件。</li><li><code>golang</code> : 指定要使用的 Docker 镜像的名称。</li></ul><p>然后使用VSCODE连接就行了<br>之后就是初始化等等的操作<br><code>go mod init goenv</code><br>编写<code>main.go</code>等等…</p><p><strong>重要概念</strong>：</p><p><strong>镜像</strong>：可以理解为软件安装包，可以方便的进行传播和安装。<br><strong>容器</strong>：软件安装后的状态，每个软件运行环境都是独立的、隔离的，称之为容器。</p><p><strong>常用相关命令</strong>：</p><p><code>docker ps</code> 查看当前运行中的容器<br><code>docker images</code> 查看镜像列表<br><code>docker rm container-id</code> 删除指定 id 的容器<br><code>docker stop/start container-id</code> 停止&#x2F;启动指定 id 的容器<br><code>docker rmi image-id</code> 删除指定 id 的镜像<br><code>docker volume ls</code> 查看 volume 列表<br><code>docker network ls</code> 查看网络列表</p><hr><h2 id="Docker-VS-普通虚拟机："><a href="#Docker-VS-普通虚拟机：" class="headerlink" title="Docker VS 普通虚拟机："></a>Docker VS 普通虚拟机：</h2><table><thead><tr><th>特性</th><th>普通虚拟机</th><th>Docker</th></tr></thead><tbody><tr><td>跨平台</td><td>通常只能在桌面级系统运行，例如 Windows&#x2F;Mac，无法在不带图形界面的服务器上运行</td><td>支持的系统非常多，各类 windows 和 Linux 都支持</td></tr><tr><td>性能</td><td>性能损耗大，内存占用高，因为是把整个完整系统都虚拟出来了</td><td>性能好，只虚拟软件所需运行环境，最大化减少没用的配置</td></tr><tr><td>自动化</td><td>需要手动安装所有东西</td><td>一个命令就可以自动部署好所需环境</td></tr><tr><td>稳定性</td><td>稳定性不高，不同系统差异大</td><td>稳定性好，不同系统都一样部署方式</td></tr></tbody></table><h3 id="开发方面与WSL2的对比："><a href="#开发方面与WSL2的对比：" class="headerlink" title="开发方面与WSL2的对比："></a>开发方面与WSL2的对比：</h3><p>Docker 和 WSL 2 两者都可以在 Windows 系统上提供 Linux 环境，但是它们的工作原理和用途是有区别的。</p><p>WSL 2 是 Windows Subsystem for Linux 的第二版，可以在 Windows 系统上运行 Linux 子系统，并且支持运行原生 Linux 应用程序。WSL 2 可以让开发者在 Windows 上使用 Linux 环境进行开发，并且可以直接访问 Windows 系统上的文件。</p><p>Docker 是一个容器化平台，可以在宿主机上运行多个独立的容器，每个容器都可以运行不同的应用程序。Docker 可以将应用程序和其所需的环境封装在一起，方便进行部署和移植。使用Docker，可以在不同的环境下,方便的部署和调试，并且可以隔离这些环境，不会相互影响.</p><p>总的来说，WSL 2 主要用于在 Windows 上使用 Linux 环境进行开发，而 Docker 则更多用于将应用程序和其所需的环境封装在容器中，方便进行部署和移植。</p><hr><h2 id="镜像加速源："><a href="#镜像加速源：" class="headerlink" title="镜像加速源："></a>镜像加速源：</h2><table><thead><tr><th>镜像加速器</th><th>镜像加速器地址</th></tr></thead><tbody><tr><td>Docker 中国官方镜像</td><td><a href="https://registry.docker-cn.com/">https://registry.docker-cn.com</a></td></tr><tr><td>DaoCloud 镜像站</td><td><a href="http://f1361db2.m.daocloud.io/">http://f1361db2.m.daocloud.io</a></td></tr><tr><td>Azure 中国镜像</td><td><a href="https://dockerhub.azk8s.cn/">https://dockerhub.azk8s.cn</a></td></tr><tr><td>科大镜像站</td><td><a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn</a></td></tr><tr><td>阿里云</td><td>https:&#x2F;&#x2F;<your_code>.mirror.aliyuncs.com</td></tr><tr><td>七牛云</td><td><a href="https://reg-mirror.qiniu.com/">https://reg-mirror.qiniu.com</a></td></tr><tr><td>网易云</td><td><a href="https://hub-mirror.c.163.com/">https://hub-mirror.c.163.com</a></td></tr><tr><td>腾讯云</td><td><a href="https://mirror.ccs.tencentyun.com/">https://mirror.ccs.tencentyun.com</a></td></tr></tbody></table><hr><h2 id="Docker安装软件："><a href="#Docker安装软件：" class="headerlink" title="Docker安装软件："></a>Docker安装软件：</h2><blockquote><h3 id="直接安装的缺点"><a href="#直接安装的缺点" class="headerlink" title="直接安装的缺点"></a>直接安装的缺点</h3><ul><li>安装麻烦，可能有各种依赖，运行报错。例如：WordPress，ElasticSearch，Redis，ELK</li><li>可能对 Windows 并不友好，运行有各种兼容问题，软件只支持 Linux 上跑</li><li>不方便安装多版本软件，不能共存。</li><li>电脑安装了一堆软件，拖慢电脑速度。</li><li>不同系统和硬件，安装方式不一样</li></ul><h3 id="Docker-安装的优点"><a href="#Docker-安装的优点" class="headerlink" title="Docker 安装的优点"></a>Docker 安装的优点</h3><ul><li>一个命令就可以安装好，快速方便</li><li>有大量的镜像，可直接使用</li><li>没有系统兼容问题，Linux 专享软件也照样跑</li><li>支持软件多版本共存</li><li>用完就丢，不拖慢电脑速度</li><li>不同系统和硬件，只要安装好 Docker 其他都一样了，一个命令搞定所有</li></ul></blockquote><hr><h2 id="VSCode-Docker"><a href="#VSCode-Docker" class="headerlink" title="VSCode + Docker"></a>VSCode + Docker</h2><h3 id="使用VSCode打开Docker中已开启的镜像："><a href="#使用VSCode打开Docker中已开启的镜像：" class="headerlink" title="使用VSCode打开Docker中已开启的镜像："></a>使用VSCode打开Docker中已开启的镜像：</h3><p>在VSCode中安装Docker插件之后，直接点击，会看到很多已创建好的镜像，</p><p>右键然后在VSCode里打开就好了（具体的名字可能不是这个，翻译问题）</p><h3 id="code-workspace文件说明："><a href="#code-workspace文件说明：" class="headerlink" title=".code-workspace文件说明："></a>.code-workspace文件说明：</h3><p><code>.code-workspace</code> 文件是 Visual Studio Code 的工作区文件，它用于记录打开的文件夹和已安装的插件等配置信息。</p><p>在 Visual Studio Code 中，你可以通过以下方式生成 <code>.code-workspace</code> 文件：</p><ol><li>在文件资源管理器中，右键单击文件夹并选择 “Save Workspace As…” 来保存当前工作区。</li><li>选择 “File” 菜单中的 “Save Workspace As…” 来保存当前工作区。</li><li>在命令面板中输入 “Save Workspace As…” 并回车来保存当前工作区。</li></ol><p>保存后的工作区文件将会以 <code>.code-workspace</code> 为扩展名保存在你指定的位置.</p><hr><h1 id="三、继续向前"><a href="#三、继续向前" class="headerlink" title="三、继续向前"></a>三、继续向前</h1><h2 id="DockerFile相关："><a href="#DockerFile相关：" class="headerlink" title="DockerFile相关："></a>DockerFile相关：</h2><p>先看一个例子：</p><blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">11</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> easydoc.net</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制代码</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> . /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置容器启动后的默认运行目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行命令，安装依赖</span></span><br><span class="line"><span class="comment"># RUN 命令可以有多个，但是可以用 &amp;&amp; 连接多个命令来减少层级。</span></span><br><span class="line"><span class="comment"># 例如 RUN npm install &amp;&amp; cd /app &amp;&amp; mkdir logs</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm install --registry=https://registry.npm.taobao.org</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CMD 指令只能一个，是容器启动后执行的命令，算是程序的入口。</span></span><br><span class="line"><span class="comment"># 如果还需要运行其他命令可以用 &amp;&amp; 连接，也可以写成一个shell脚本去执行。</span></span><br><span class="line"><span class="comment"># 例如 CMD cd /app &amp;&amp; ./start.sh</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> node app.js</span></span><br></pre></td></tr></table></figure></blockquote><p>Dockerfile 是用来构建 Docker 镜像的配置文件。其中，<code>RUN</code> 指令是用来在镜像构建过程中执行命令的。</p><p>在这个例子中，<code>RUN npm install --registry=https://registry.npm.taobao.org</code> 的作用是安装 npm 包，并将 npm 的镜像源设置为淘宝镜像，为了加速npm 的安装速度。</p><p>这个命令会在Docker容器中执行，会在容器中安装npm的包，在这个命令执行完成后，npm包已经安装在容器中了。</p><p>注意：使用 npm install 命令前需要先使用COPY或者ADD指令将项目文件复制到容器中。</p><p>参考：<a href="https://docs.docker.com/engine/reference/builder/#run">Dockerfile reference | Docker Documentation</a></p><hr><h2 id="目录挂载："><a href="#目录挂载：" class="headerlink" title="目录挂载："></a>目录挂载：</h2><p>目录挂载可以解决的问题：</p><ul><li>使用 Docker 运行后，倘若修改项目代码不会立刻生效，需要重新<code>build</code>和<code>run</code>，很麻烦。</li><li>容器里面产生的数据，例如 log 文件，数据库备份文件，容器删除后就丢失了。</li></ul><p><strong>目录挂载的方式</strong>：</p><ul><li><code>bind mount</code> 直接把宿主机目录映射到容器内，适合挂代码目录和配置文件。可挂到多个容器上</li><li><code>volume</code> 由容器创建和管理，创建在宿主机，所以删除容器不会丢失，官方推荐，更高效，Linux 文件系统，适合存储数据库数据。可挂到多个容器上</li><li><code>tmpfs mount</code> 适合存储临时文件，存宿主机内存中。不可多容器共享。</li></ul><p><code>bind mount</code> 方式用绝对路径 <code>-v D:/code:/app</code></p><p><code>volume</code> 方式，只需要一个名字 <code>-v db-data:/app</code>，注意，这里的<code>db-data</code>就是名字，这块区域由容器自己来创建。</p><p>bind mount例：<code>docker run -p 9090:8080 --name test-hello -v D:/code:/app -d golang:v1</code></p><ul><li>这里是把项目的代码目录挂载到容器里面的<code>/app</code>目录</li><li>把容器的8080暴露到伺服器的9090端口</li><li>容器名字命名为test-hello</li><li>挂载绝对目录</li><li><code>-d</code>表示在后台运行</li><li><code>golang:v1</code>指定镜像的名字和版本</li></ul><p>于是我们的代码就愉快的跑起来了；</p><hr><p>余下内容未完待续…</p><p>谢谢大家的阅读，欢迎互动，也欢迎访问我的博客！</p><p><a href="https://conqueror712.gitee.io/conqueror712.gitee.io/">落雨乄天珀夜 (gitee.io)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;零、前言：&quot;&gt;&lt;a href=&quot;#零、前言：&quot; class=&quot;headerlink&quot; title=&quot;零、前言：&quot;&gt;&lt;/a&gt;零、前言：&lt;/h1&gt;&lt;p&gt;本文是笔者从零开始学习Docker的学习记录。&lt;/p&gt;
&lt;p&gt;若笔者有任何疏忽纰漏之处，烦请不吝赐教。&lt;/p&gt;
&lt;b</summary>
      
    
    
    
    <category term="Devlopment-Tech" scheme="https://conqueror712.github.io/categories/Devlopment-Tech/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis丨学习记录</title>
    <link href="https://conqueror712.github.io/post/Redis.html"/>
    <id>https://conqueror712.github.io/post/Redis.html</id>
    <published>2023-01-29T06:00:41.000Z</published>
    <updated>2023-03-23T01:21:38.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="零、前言"><a href="#零、前言" class="headerlink" title="零、前言"></a>零、前言</h1><p>本文是笔者从零开始学习Redis的学习记录。</p><p>若笔者有任何疏忽纰漏之处，烦请不吝赐教。</p><blockquote><p>个人博客：<a href="https://conqueror712.github.io/">https://conqueror712.github.io/</a></p><p>知乎：<a href="https://www.zhihu.com/people/soeur712/posts">https://www.zhihu.com/people/soeur712/posts</a></p><p>Bilibili：<a href="https://space.bilibili.com/57089326">https://space.bilibili.com/57089326</a></p><p>掘金：<a href="https://juejin.cn/user/1297878069809725/posts">https://juejin.cn/user/1297878069809725/posts</a></p></blockquote><hr><h1 id="一、开门见山"><a href="#一、开门见山" class="headerlink" title="一、开门见山"></a>一、开门见山</h1><p>源码：<a href="https://github.com/redis/redis">https://github.com/redis/redis</a></p><h2 id="Redis是什么？"><a href="#Redis是什么？" class="headerlink" title="Redis是什么？"></a><strong>Redis</strong>是什么？</h2><ul><li><p><strong>基于内存的多模型数据库，毫秒级的延迟</strong></p></li><li><p>Remote Dictionary Server</p></li><li><p>是一个由<code>Salvatore Sanfilippo</code>写的<code>key-value</code>存储系统；</p></li><li><p>是<strong>跨平台的非关系型数据库</strong>；</p></li><li><p>是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的 API。</p></li></ul><h2 id="Redis有什么特点？"><a href="#Redis有什么特点？" class="headerlink" title="Redis有什么特点？"></a>Redis有什么特点？</h2><ul><li>Redis 通常被称为<strong>数据结构服务器</strong>，因为值可以是字符串、哈希、列表、集合和有序集合等类型。</li><li>Redis支持<strong>数据的持久化</strong>，可以将<strong>内存中的数据保存在磁盘中</strong>，重启的时候可以再次加载进行使用。</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47f76ed6d91f496ab5279e68a691b317~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h2 id="Redis的优势有哪些？"><a href="#Redis的优势有哪些？" class="headerlink" title="Redis的优势有哪些？"></a>Redis的优势有哪些？</h2><ul><li>性能极高</li><li>丰富的数据类型，因此你不需要把它塞进一堆表或者JSON文档里</li><li>原子 – Redis的所有操作都是原子性的，意思就是<strong>要么成功执行要么失败完全不执行</strong>。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</li><li>丰富的特性 – Redis还支持 publish&#x2F;subscribe, 通知, key 过期等等特性。</li></ul><h2 id="Redis的其他补充？"><a href="#Redis的其他补充？" class="headerlink" title="Redis的其他补充？"></a>Redis的其他补充？</h2><ul><li>缓存也可以用于存储持久化数据</li><li>传统的关系型数据库没办法做到快速把数据传递给终端用户</li><li>数据总是会在内存上进行修改和读取，而不是在慢得多的硬盘上，但与此同时，它会把数据存储在硬盘上，这样就可以按需对数据进行重建，因此数据库是完全持久化的</li><li>Redis完全可以作为主数据库，并且可以显著地降低复杂度</li><li>多模型——可以通过扩展模块来支持多种数据库范式，可以按需引用，如下图所示：</li></ul><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/111409e98b124e52a3229eb9a02f433b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><hr><h2 id="Redis如何安装？"><a href="#Redis如何安装？" class="headerlink" title="Redis如何安装？"></a>Redis如何安装？</h2><ol><li>在<a href="https://github.com/tporadowski/redis/releases%E4%B8%AD%E9%80%89%E6%8B%A9%60.zip%60%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E5%B9%B6%E8%A7%A3%E5%8E%8B%EF%BC%88%E5%BD%93%E7%84%B6%E4%B9%9F%E5%8F%AF%E4%BB%A5%E9%80%89%E5%88%AB%E7%9A%84%EF%BC%89%EF%BC%8C%E7%84%B6%E5%90%8Erename%E4%B8%BAredis">https://github.com/tporadowski/redis/releases中选择`.zip`格式的文件下载并解压（当然也可以选别的），然后rename为redis</a></li><li>在解压路径下打开<code>cmd</code>并输入<code>redis-server.exe redis.windows.conf</code>，你会看到如下图所示的样子：</li></ol><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/721cdc037d934682b7c19999cd6fde1c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><ol start="3"><li>添加环境变量，地址就是解压地址</li><li>保持上面这个<code>cmd</code>窗口不要关闭的情况下再开启一个<code>cmd</code>，运行<code>redis-cli.exe -h 127.0.0.1 -p &lt;your port num&gt;</code>（好像都是6379？），这里如果报错，你可能需要WIN+R开启cmd而不是用其他的方法</li></ol><p>（Redis的配置暂略，有需要更改的话会再补充相关内容）</p><hr><h1 id="二、继续向前"><a href="#二、继续向前" class="headerlink" title="二、继续向前"></a>二、继续向前</h1><h2 id="Redis命令"><a href="#Redis命令" class="headerlink" title="Redis命令"></a>Redis命令</h2><p>可参考网站：</p><p><a href="http://doc.redisfans.com/">Redis 命令参考 — Redis 命令参考 (redisfans.com)</a></p><p><a href="https://redis.io/commands/">Commands | Redis</a></p><p>在端口启动的情况下，输入<code>redis-cli</code>即可进入redis客户端，输入<code>PING</code>输出<code>PONG</code>即证明成功启动。</p><h2 id="Redis键"><a href="#Redis键" class="headerlink" title="Redis键"></a>Redis键</h2><h4 id="Redis键的基本命令："><a href="#Redis键的基本命令：" class="headerlink" title="Redis键的基本命令："></a>Redis键的基本命令：</h4><ul><li><a href="http://doc.redisfans.com/key/del.html">DEL</a></li><li><a href="http://doc.redisfans.com/key/dump.html">DUMP</a></li><li><a href="http://doc.redisfans.com/key/exists.html">EXISTS</a></li><li><a href="http://doc.redisfans.com/key/expire.html">EXPIRE</a></li><li><a href="http://doc.redisfans.com/key/expireat.html">EXPIREAT</a></li><li><a href="http://doc.redisfans.com/key/keys.html">KEYS</a></li><li><a href="http://doc.redisfans.com/key/migrate.html">MIGRATE</a></li><li><a href="http://doc.redisfans.com/key/move.html">MOVE</a></li><li><a href="http://doc.redisfans.com/key/object.html">OBJECT</a></li><li><a href="http://doc.redisfans.com/key/persist.html">PERSIST</a></li><li><a href="http://doc.redisfans.com/key/pexpire.html">PEXPIRE</a></li><li><a href="http://doc.redisfans.com/key/pexpireat.html">PEXPIREAT</a></li><li><a href="http://doc.redisfans.com/key/pttl.html">PTTL</a></li><li><a href="http://doc.redisfans.com/key/randomkey.html">RANDOMKEY</a></li><li><a href="http://doc.redisfans.com/key/rename.html">RENAME</a></li><li><a href="http://doc.redisfans.com/key/renamenx.html">RENAMENX</a></li><li><a href="http://doc.redisfans.com/key/restore.html">RESTORE</a></li><li><a href="http://doc.redisfans.com/key/sort.html">SORT</a></li><li><a href="http://doc.redisfans.com/key/ttl.html">TTL</a></li><li><a href="http://doc.redisfans.com/key/type.html">TYPE</a></li><li><a href="http://doc.redisfans.com/key/scan.html">SCAN</a></li></ul><h2 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h2><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>特点：</p><ul><li>一个key对应一个value</li><li>string类型是<strong>二进制安全的</strong>，意思是 redis 的 string 可以包含任何数据例如jpg图片或者序列化的对象</li><li>string类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB</li></ul><p>demo：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afbaaffa219b4132a784d18b6e4fb886~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h4 id="string的基本命令："><a href="#string的基本命令：" class="headerlink" title="string的基本命令："></a>string的基本命令：</h4><ul><li><a href="http://doc.redisfans.com/string/append.html">APPEND</a></li><li><a href="http://doc.redisfans.com/string/bitcount.html">BITCOUNT</a></li><li><a href="http://doc.redisfans.com/string/bitop.html">BITOP</a></li><li><a href="http://doc.redisfans.com/string/decr.html">DECR</a></li><li><a href="http://doc.redisfans.com/string/decrby.html">DECRBY</a></li><li><a href="http://doc.redisfans.com/string/get.html">GET</a></li><li><a href="http://doc.redisfans.com/string/getbit.html">GETBIT</a></li><li><a href="http://doc.redisfans.com/string/getrange.html">GETRANGE</a></li><li><a href="http://doc.redisfans.com/string/getset.html">GETSET</a></li><li><a href="http://doc.redisfans.com/string/incr.html">INCR</a></li><li><a href="http://doc.redisfans.com/string/incrby.html">INCRBY</a></li><li><a href="http://doc.redisfans.com/string/incrbyfloat.html">INCRBYFLOAT</a></li><li><a href="http://doc.redisfans.com/string/mget.html">MGET</a></li><li><a href="http://doc.redisfans.com/string/mset.html">MSET</a></li><li><a href="http://doc.redisfans.com/string/msetnx.html">MSETNX</a></li><li><a href="http://doc.redisfans.com/string/psetex.html">PSETEX</a></li><li><a href="http://doc.redisfans.com/string/set.html">SET</a></li><li><a href="http://doc.redisfans.com/string/setbit.html">SETBIT</a></li><li><a href="http://doc.redisfans.com/string/setex.html">SETEX</a></li><li><a href="http://doc.redisfans.com/string/setnx.html">SETNX</a></li><li><a href="http://doc.redisfans.com/string/setrange.html">SETRANGE</a></li><li><a href="http://doc.redisfans.com/string/strlen.html">STRLEN</a></li></ul><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>特点：</p><ul><li>hash是一个键值对集合</li><li>hash是一个string类型的field和value的映射表，特别适合存储对象</li><li>每个 hash 可以存储 2^32 -1 键值对</li></ul><p>demo：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5fb120be05054b8c821f8fc3665fd5bf~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h4 id="hash的基本命令："><a href="#hash的基本命令：" class="headerlink" title="hash的基本命令："></a>hash的基本命令：</h4><ul><li><a href="http://doc.redisfans.com/hash/hdel.html">HDEL</a></li><li><a href="http://doc.redisfans.com/hash/hexists.html">HEXISTS</a></li><li><a href="http://doc.redisfans.com/hash/hget.html">HGET</a></li><li><a href="http://doc.redisfans.com/hash/hgetall.html">HGETALL</a></li><li><a href="http://doc.redisfans.com/hash/hincrby.html">HINCRBY</a></li><li><a href="http://doc.redisfans.com/hash/hincrbyfloat.html">HINCRBYFLOAT</a></li><li><a href="http://doc.redisfans.com/hash/hkeys.html">HKEYS</a></li><li><a href="http://doc.redisfans.com/hash/hlen.html">HLEN</a></li><li><a href="http://doc.redisfans.com/hash/hmget.html">HMGET</a></li><li><a href="http://doc.redisfans.com/hash/hmset.html">HMSET</a></li><li><a href="http://doc.redisfans.com/hash/hset.html">HSET</a></li><li><a href="http://doc.redisfans.com/hash/hsetnx.html">HSETNX</a></li><li><a href="http://doc.redisfans.com/hash/hvals.html">HVALS</a></li><li><a href="http://doc.redisfans.com/hash/hscan.html">HSCAN</a></li></ul><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>特点：</p><ul><li>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部L或者尾部R</li><li>列表最多也可存储 2^32 - 1 元素</li></ul><p>demo：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b062f37a3774659a04f8014bcbe5e69~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h4 id="list的基本命令："><a href="#list的基本命令：" class="headerlink" title="list的基本命令："></a>list的基本命令：</h4><ul><li><a href="http://doc.redisfans.com/list/blpop.html">BLPOP</a></li><li><a href="http://doc.redisfans.com/list/brpop.html">BRPOP</a></li><li><a href="http://doc.redisfans.com/list/brpoplpush.html">BRPOPLPUSH</a></li><li><a href="http://doc.redisfans.com/list/lindex.html">LINDEX</a></li><li><a href="http://doc.redisfans.com/list/linsert.html">LINSERT</a></li><li><a href="http://doc.redisfans.com/list/llen.html">LLEN</a></li><li><a href="http://doc.redisfans.com/list/lpop.html">LPOP</a></li><li><a href="http://doc.redisfans.com/list/lpush.html">LPUSH</a></li><li><a href="http://doc.redisfans.com/list/lpushx.html">LPUSHX</a></li><li><a href="http://doc.redisfans.com/list/lrange.html">LRANGE</a></li><li><a href="http://doc.redisfans.com/list/lrem.html">LREM</a></li><li><a href="http://doc.redisfans.com/list/lset.html">LSET</a></li><li><a href="http://doc.redisfans.com/list/ltrim.html">LTRIM</a></li><li><a href="http://doc.redisfans.com/list/rpop.html">RPOP</a></li><li><a href="http://doc.redisfans.com/list/rpoplpush.html">RPOPLPUSH</a></li><li><a href="http://doc.redisfans.com/list/rpush.html">RPUSH</a></li><li><a href="http://doc.redisfans.com/list/rpushx.html">RPUSHX</a></li></ul><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>特点：</p><ul><li>Redis 的 Set 是 string 类型的无序集合</li><li>set是通过哈希表实现的，所以R U D的复杂度都是 O(1)</li><li>集合的唯一性</li><li>集合中最大的成员数为 2^32 - 1</li></ul><p>demo：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5c0d8e077e548089a934fe1bd9aa35f~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>可以看到是唯一的且无序的</p><h4 id="set的基本命令："><a href="#set的基本命令：" class="headerlink" title="set的基本命令："></a>set的基本命令：</h4><ul><li><a href="http://doc.redisfans.com/set/sadd.html">SADD</a></li><li><a href="http://doc.redisfans.com/set/scard.html">SCARD</a></li><li><a href="http://doc.redisfans.com/set/sdiff.html">SDIFF</a></li><li><a href="http://doc.redisfans.com/set/sdiffstore.html">SDIFFSTORE</a></li><li><a href="http://doc.redisfans.com/set/sinter.html">SINTER</a></li><li><a href="http://doc.redisfans.com/set/sinterstore.html">SINTERSTORE</a></li><li><a href="http://doc.redisfans.com/set/sismember.html">SISMEMBER</a></li><li><a href="http://doc.redisfans.com/set/smembers.html">SMEMBERS</a></li><li><a href="http://doc.redisfans.com/set/smove.html">SMOVE</a></li><li><a href="http://doc.redisfans.com/set/spop.html">SPOP</a></li><li><a href="http://doc.redisfans.com/set/srandmember.html">SRANDMEMBER</a></li><li><a href="http://doc.redisfans.com/set/srem.html">SREM</a></li><li><a href="http://doc.redisfans.com/set/sunion.html">SUNION</a></li><li><a href="http://doc.redisfans.com/set/sunionstore.html">SUNIONSTORE</a></li><li><a href="http://doc.redisfans.com/set/sscan.html">SSCAN</a></li></ul><h3 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h3><p>特点：</p><ul><li>集合的唯一性</li><li>有序集合</li><li>每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</li><li>zset的成员是唯一的,但分数(score)却可以重复。</li></ul><p>demo：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c9b3c2b3f174bc4b890ba562cb7aaba~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>可以看到是唯一的且有序的，但是score可以重复</p><h4 id="zset的基本命令："><a href="#zset的基本命令：" class="headerlink" title="zset的基本命令："></a>zset的基本命令：</h4><ul><li><a href="http://doc.redisfans.com/sorted_set/zadd.html">ZADD</a></li><li><a href="http://doc.redisfans.com/sorted_set/zcard.html">ZCARD</a></li><li><a href="http://doc.redisfans.com/sorted_set/zcount.html">ZCOUNT</a></li><li><a href="http://doc.redisfans.com/sorted_set/zincrby.html">ZINCRBY</a></li><li><a href="http://doc.redisfans.com/sorted_set/zrange.html">ZRANGE</a></li><li><a href="http://doc.redisfans.com/sorted_set/zrangebyscore.html">ZRANGEBYSCORE</a></li><li><a href="http://doc.redisfans.com/sorted_set/zrank.html">ZRANK</a></li><li><a href="http://doc.redisfans.com/sorted_set/zrem.html">ZREM</a></li><li><a href="http://doc.redisfans.com/sorted_set/zremrangebyrank.html">ZREMRANGEBYRANK</a></li><li><a href="http://doc.redisfans.com/sorted_set/zremrangebyscore.html">ZREMRANGEBYSCORE</a></li><li><a href="http://doc.redisfans.com/sorted_set/zrevrange.html">ZREVRANGE</a></li><li><a href="http://doc.redisfans.com/sorted_set/zrevrangebyscore.html">ZREVRANGEBYSCORE</a></li><li><a href="http://doc.redisfans.com/sorted_set/zrevrank.html">ZREVRANK</a></li><li><a href="http://doc.redisfans.com/sorted_set/zscore.html">ZSCORE</a></li><li><a href="http://doc.redisfans.com/sorted_set/zunionstore.html">ZUNIONSTORE</a></li><li><a href="http://doc.redisfans.com/sorted_set/zinterstore.html">ZINTERSTORE</a></li><li><a href="http://doc.redisfans.com/sorted_set/zscan.html">ZSCAN</a></li></ul><hr><h2 id="Redis-HyperLogLog"><a href="#Redis-HyperLogLog" class="headerlink" title="Redis-HyperLogLog"></a>Redis-HyperLogLog</h2><p><strong>简介</strong>：</p><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p><p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p><p>Q：什么是基数？</p><p>A：基数就是集合内去重后元素的个数</p><p>Q：什么是基数估计？</p><p>A：基数估计就是在误差可接受的范围内，快速计算基数。</p><p>demo：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f889cd76071f4c89bed355b3d02d9495~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h3 id="HyperLogLog的基本命令："><a href="#HyperLogLog的基本命令：" class="headerlink" title="HyperLogLog的基本命令："></a>HyperLogLog的基本命令：</h3><table><thead><tr><th align="left">Num</th><th align="left">命令及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">[PFADD key element <a href="https://www.runoob.com/redis/hyperloglog-pfadd.html">element …]</a> ——添加指定元素到 HyperLogLog 中。</td></tr><tr><td align="left">2</td><td align="left">[PFCOUNT key <a href="https://www.runoob.com/redis/hyperloglog-pfcount.html">key …]</a> ——返回给定 HyperLogLog 的基数估算值。</td></tr><tr><td align="left">3</td><td align="left">[PFMERGE destkey sourcekey <a href="https://www.runoob.com/redis/hyperloglog-pfmerge.html">sourcekey …]</a> ——将多个 HyperLogLog 合并为一个 HyperLogLog</td></tr></tbody></table><hr><h2 id="Redis-Pub-x2F-Sub-发布订阅"><a href="#Redis-Pub-x2F-Sub-发布订阅" class="headerlink" title="Redis-Pub&#x2F;Sub-发布订阅"></a>Redis-Pub&#x2F;Sub-发布订阅</h2><p>Redis 发布订阅 (pub&#x2F;sub) 是一种<strong>消息通信模式</strong>：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p><p><strong>图解</strong>：（图源Runoob）</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81c27914648d43f7bfef07cd16b845c6~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>注意：如果需要测试，可能会需要开启多个<code>redis-cli</code>客户端</p><p>demo：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fae085ad25ce4f6b99411775dae75811~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>其中msg的命令是<code>PUBLISH FallenChat &quot;something&quot;</code></p><h3 id="发布订阅的基本命令："><a href="#发布订阅的基本命令：" class="headerlink" title="发布订阅的基本命令："></a>发布订阅的基本命令：</h3><ul><li><a href="http://doc.redisfans.com/pub_sub/psubscribe.html">PSUBSCRIBE</a></li><li><a href="http://doc.redisfans.com/pub_sub/publish.html">PUBLISH</a></li><li><a href="http://doc.redisfans.com/pub_sub/pubsub.html">PUBSUB</a></li><li><a href="http://doc.redisfans.com/pub_sub/punsubscribe.html">PUNSUBSCRIBE</a></li><li><a href="http://doc.redisfans.com/pub_sub/subscribe.html">SUBSCRIBE</a></li><li><a href="http://doc.redisfans.com/pub_sub/unsubscribe.html">UNSUBSCRIBE</a></li></ul><hr><h2 id="Redis-Transaction-事务"><a href="#Redis-Transaction-事务" class="headerlink" title="Redis-Transaction-事务"></a>Redis-Transaction-事务</h2><p>Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：</p><ul><li>批量操作在发送 EXEC 命令前被放入<strong>队列缓存</strong></li><li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。</li><li>在事务执行过程，其他客户端提交的命令请求<strong>不会</strong>插入到事务执行命令序列中</li></ul><p>一个事务从开始到执行会经历以下<strong>三个阶段</strong>：</p><ul><li>开始事务</li><li>命令入队</li><li>执行事务</li></ul><p>demo：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0839a16a7a5547f8a243058a72665233~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>特别地：单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</p><h3 id="事务的基本命令："><a href="#事务的基本命令：" class="headerlink" title="事务的基本命令："></a>事务的基本命令：</h3><ul><li><a href="http://doc.redisfans.com/transaction/discard.html">DISCARD</a></li><li><a href="http://doc.redisfans.com/transaction/exec.html">EXEC</a></li><li><a href="http://doc.redisfans.com/transaction/multi.html">MULTI</a></li><li><a href="http://doc.redisfans.com/transaction/unwatch.html">UNWATCH</a></li><li><a href="http://doc.redisfans.com/transaction/watch.html">WATCH</a></li></ul><hr><h2 id="Redis-Script-脚本"><a href="#Redis-Script-脚本" class="headerlink" title="Redis-Script-脚本"></a>Redis-Script-脚本</h2><p>Redis 脚本使用<code>Lua</code>解释器来执行脚本。 Redis 2.6 版本通过内嵌支持 Lua 环境。</p><p>执行脚本的常用命令为 <strong>EVAL</strong></p><h3 id="Lua简介："><a href="#Lua简介：" class="headerlink" title="Lua简介："></a>Lua简介：</h3><p>Q：Lua？</p><p>A：Lua 是一种轻量小巧的<strong>脚本语言</strong>，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。</p><p>A：其<strong>设计目的</strong>是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。</p><p><strong>Lua特性</strong>：</p><ul><li><strong>轻量级</strong>: 它用标准C语言编写并以源代码形式开放，编译后仅仅一百余K，可以很方便的嵌入别的程序里。</li><li><strong>可扩展</strong>: Lua提供了非常易于使用的扩展接口和机制：由宿主语言(通常是C或C++)提供这些功能，Lua可以使用它们，就像是本来就内置的功能一样。</li><li>其它特性：<ul><li>支持面向过程(procedure-oriented)编程和函数式编程(functional programming)；</li><li>自动内存管理；只提供了一种通用类型的表（table），用它可以实现数组，哈希表，集合，对象；</li><li>语言内置模式匹配；闭包(closure)；函数也可以看做一个值；提供多线程（协同进程，并非操作系统所支持的线程）支持；</li><li>通过闭包和table可以很方便地支持面向对象编程所需要的一些关键机制，比如数据抽象，虚函数，继承和重载等。</li></ul></li></ul><p><strong>Lua应用场景</strong>：</p><ul><li>游戏开发</li><li>独立应用脚本</li><li>Web 应用脚本</li><li>扩展和数据库插件如：MySQL Proxy 和 MySQL WorkBench</li><li>安全系统，如入侵检测系统</li></ul><hr><p>回到Redis</p><p>demo：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb7417415d474aea96ca488dcaa75d37~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h3 id="脚本的基本命令："><a href="#脚本的基本命令：" class="headerlink" title="脚本的基本命令："></a>脚本的基本命令：</h3><ul><li><a href="http://doc.redisfans.com/script/eval.html">EVAL</a></li><li><a href="http://doc.redisfans.com/script/evalsha.html">EVALSHA</a></li><li><a href="http://doc.redisfans.com/script/script_exists.html">SCRIPT EXISTS</a></li><li><a href="http://doc.redisfans.com/script/script_flush.html">SCRIPT FLUSH</a></li><li><a href="http://doc.redisfans.com/script/script_kill.html">SCRIPT KILL</a></li><li><a href="http://doc.redisfans.com/script/script_load.html">SCRIPT LOAD</a></li></ul><hr><h2 id="Redis-Connection-连接"><a href="#Redis-Connection-连接" class="headerlink" title="Redis-Connection-连接"></a>Redis-Connection-连接</h2><p>Redis 连接命令主要是用于连接 redis 服务</p><h3 id="连接的基本命令："><a href="#连接的基本命令：" class="headerlink" title="连接的基本命令："></a>连接的基本命令：</h3><ul><li><a href="http://doc.redisfans.com/connection/auth.html">AUTH</a></li><li><a href="http://doc.redisfans.com/connection/echo.html">ECHO</a></li><li><a href="http://doc.redisfans.com/connection/ping.html">PING</a></li><li><a href="http://doc.redisfans.com/connection/quit.html">QUIT</a></li><li><a href="http://doc.redisfans.com/connection/select.html">SELECT</a></li></ul><hr><h2 id="Redis-Server-服务器"><a href="#Redis-Server-服务器" class="headerlink" title="Redis-Server-服务器"></a>Redis-Server-服务器</h2><p>Redis 服务器命令主要是用于管理 redis 服务</p><p>输入<code>INFO</code>就可以查看，由于内容过多就不一一展示了，下面是一部分</p><p>demo：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3722d8245af4e72aa1b2d6134747903~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h3 id="服务器的基本命令："><a href="#服务器的基本命令：" class="headerlink" title="服务器的基本命令："></a>服务器的基本命令：</h3><ul><li><a href="http://doc.redisfans.com/server/bgrewriteaof.html">BGREWRITEAOF</a></li><li><a href="http://doc.redisfans.com/server/bgsave.html">BGSAVE</a></li><li><a href="http://doc.redisfans.com/server/client_getname.html">CLIENT GETNAME</a></li><li><a href="http://doc.redisfans.com/server/client_kill.html">CLIENT KILL</a></li><li><a href="http://doc.redisfans.com/server/client_list.html">CLIENT LIST</a></li><li><a href="http://doc.redisfans.com/server/client_setname.html">CLIENT SETNAME</a></li><li><a href="http://doc.redisfans.com/server/config_get.html">CONFIG GET</a></li><li><a href="http://doc.redisfans.com/server/config_resetstat.html">CONFIG RESETSTAT</a></li><li><a href="http://doc.redisfans.com/server/config_rewrite.html">CONFIG REWRITE</a></li><li><a href="http://doc.redisfans.com/server/config_set.html">CONFIG SET</a></li><li><a href="http://doc.redisfans.com/server/dbsize.html">DBSIZE</a></li><li><a href="http://doc.redisfans.com/server/debug_object.html">DEBUG OBJECT</a></li><li><a href="http://doc.redisfans.com/server/debug_segfault.html">DEBUG SEGFAULT</a></li><li><a href="http://doc.redisfans.com/server/flushall.html">FLUSHALL</a></li><li><a href="http://doc.redisfans.com/server/flushdb.html">FLUSHDB</a></li><li><a href="http://doc.redisfans.com/server/info.html">INFO</a></li><li><a href="http://doc.redisfans.com/server/lastsave.html">LASTSAVE</a></li><li><a href="http://doc.redisfans.com/server/monitor.html">MONITOR</a></li><li><a href="http://doc.redisfans.com/server/psync.html">PSYNC</a></li><li><a href="http://doc.redisfans.com/server/save.html">SAVE</a></li><li><a href="http://doc.redisfans.com/server/shutdown.html">SHUTDOWN</a></li><li><a href="http://doc.redisfans.com/server/slaveof.html">SLAVEOF</a></li><li><a href="http://doc.redisfans.com/server/slowlog.html">SLOWLOG</a></li><li><a href="http://doc.redisfans.com/server/sync.html">SYNC</a></li><li><a href="http://doc.redisfans.com/server/time.html">TIME</a></li></ul><hr><h2 id="Redis-GEO"><a href="#Redis-GEO" class="headerlink" title="Redis-GEO"></a>Redis-GEO</h2><p>Redis GEO 主要用于存储地理位置信息，并对存储的信息进行操作。（After V3.2）</p><p>Redis GEO 常用的操作方法：</p><ul><li>geoadd：添加地理位置的坐标。</li><li>geopos：获取地理位置的坐标。</li><li>geodist：计算两个位置之间的距离。</li><li>georadius：根据用户给定的经纬度坐标来获取指定范围内的地理位置集合。</li><li>georadiusbymember：根据储存在位置集合里面的某个地点获取指定范围内的地理位置集合。</li><li>geohash：返回一个或多个位置对象的 geohash 值。</li></ul><p>demo待补充</p><hr><h2 id="Redis-Stream"><a href="#Redis-Stream" class="headerlink" title="Redis-Stream"></a>Redis-Stream</h2><p>（After V5.0）</p><blockquote><p>Redis Stream 主要用于消息队列（MQ，Message Queue），Redis 本身是有一个 Redis 发布订阅 (pub&#x2F;sub) 来实现消息队列的功能，但它有个缺点就是<strong>消息无法持久化</strong>，如果出现网络断开、Redis 宕机等，消息就会被丢弃。</p><p>而 Redis Stream 提供了<strong>消息的持久化</strong>和<strong>主备复制</strong>功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。</p></blockquote><p>结构示意图：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a73c211f11bd45f389b5565ef98b12ee~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><ul><li>有一个消息链表</li><li>每个Stream都有唯一的名称，就是key，在首次使用 xadd 指令追加消息时自动创建。</li></ul><blockquote><ul><li><strong>Consumer Group</strong> ：消费组，使用 XGROUP CREATE 命令创建，一个消费组有多个消费者(Consumer)。</li><li><strong>last_delivered_id</strong> ：游标，每个消费组会有个游标 last_delivered_id，任意一个消费者读取了消息都会使游标 last_delivered_id 往前移动。</li><li><strong>pending_ids</strong> ：消费者(Consumer)的状态变量，作用是维护消费者的未确认的 id。 pending_ids 记录了当前已经被客户端读取的消息，但是还没有 ack (Acknowledge character：确认字符）。</li></ul></blockquote><h3 id="消息队列相关命令："><a href="#消息队列相关命令：" class="headerlink" title="消息队列相关命令："></a><strong>消息队列相关命令：</strong></h3><ul><li><strong>XADD</strong> - 添加消息到末尾</li><li><strong>XTRIM</strong> - 对流进行修剪，限制长度</li><li><strong>XDEL</strong> - 删除消息</li><li><strong>XLEN</strong> - 获取流包含的元素数量，即消息长度</li><li><strong>XRANGE</strong> - 获取消息列表，会自动过滤已经删除的消息</li><li><strong>XREVRANGE</strong> - 反向获取消息列表，ID 从大到小</li><li><strong>XREAD</strong> - 以阻塞或非阻塞方式获取消息列表</li></ul><h3 id="消费者组相关命令："><a href="#消费者组相关命令：" class="headerlink" title="消费者组相关命令："></a><strong>消费者组相关命令：</strong></h3><ul><li><strong>XGROUP CREATE</strong> - 创建消费者组</li><li><strong>XREADGROUP GROUP</strong> - 读取消费者组中的消息</li><li><strong>XACK</strong> - 将消息标记为”已处理”</li><li><strong>XGROUP SETID</strong> - 为消费者组设置新的最后递送消息ID</li><li><strong>XGROUP DELCONSUMER</strong> - 删除消费者</li><li><strong>XGROUP DESTROY</strong> - 删除消费者组</li><li><strong>XPENDING</strong> - 显示待处理消息的相关信息</li><li><strong>XCLAIM</strong> - 转移消息的归属权</li><li><strong>XINFO</strong> - 查看流和消费者组的相关信息；</li><li><strong>XINFO GROUPS</strong> - 打印消费者组的信息；</li><li><strong>XINFO STREAM</strong> - 打印流信息</li></ul><p>demo待补充</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;零、前言&quot;&gt;&lt;a href=&quot;#零、前言&quot; class=&quot;headerlink&quot; title=&quot;零、前言&quot;&gt;&lt;/a&gt;零、前言&lt;/h1&gt;&lt;p&gt;本文是笔者从零开始学习Redis的学习记录。&lt;/p&gt;
&lt;p&gt;若笔者有任何疏忽纰漏之处，烦请不吝赐教。&lt;/p&gt;
&lt;blockq</summary>
      
    
    
    
    <category term="Devlopment-Tech" scheme="https://conqueror712.github.io/categories/Devlopment-Tech/"/>
    
    
  </entry>
  
  <entry>
    <title>深度学习 - Ep0 - 引言与前置知识丨学习记录</title>
    <link href="https://conqueror712.github.io/post/DeepLearningNote.html"/>
    <id>https://conqueror712.github.io/post/DeepLearningNote.html</id>
    <published>2023-01-01T13:32:11.000Z</published>
    <updated>2023-03-27T02:24:11.917Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h3><p>本篇内容目前用于记录自己一开始学习深度学习的学习过程，方便自己查阅，或许正在看本文的你对其中的一些内容有所疑惑，这大概是本人为了方便自己阅读和理解所以写的不够清楚的原因所致，如果你有任何想询问的问题，欢迎在以下任何平台提问！</p><blockquote><p>个人博客：<a href="https://conqueror712.github.io/">https://conqueror712.github.io/</a></p><p>知乎：<a href="https://www.zhihu.com/people/soeur712/posts">https://www.zhihu.com/people/soeur712/posts</a></p><p>Bilibili：<a href="https://space.bilibili.com/57089326">https://space.bilibili.com/57089326</a></p><p>掘金：<a href="https://juejin.cn/user/1297878069809725/posts">https://juejin.cn/user/1297878069809725/posts</a></p></blockquote><h3 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h3><p>本篇不会发表在知乎和掘金平台，仅作为个人的一个记录。</p><p>本篇内容较为杂乱，请<strong>谨慎阅读</strong>！</p><hr><h1 id="00-Pytorch入门"><a href="#00-Pytorch入门" class="headerlink" title="00 - Pytorch入门"></a><strong>00 - Pytorch入门</strong></h1><p>Anaconda Prompt的一些操作：</p><h2 id="创建环境与加载数据："><a href="#创建环境与加载数据：" class="headerlink" title="创建环境与加载数据："></a><strong>创建环境与加载数据：</strong></h2><p><code>conda create -n name1 python=3.9</code></p><p>这里 -n 后面的内容是你创建的环境的名字，</p><p>随后如果出现 <code>The following NEW packages will be INSTALLED:</code>，yes即可。</p><p><strong>激活and取消激活这些包的指令：</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda activate &lt;环境名&gt;</span><br><span class="line">conda deactivate</span><br></pre></td></tr></table></figure><p><code>pip list</code>可以知道这个环境中有哪些工具包</p><p><code>nvidia-smi</code>可以知道自己的英伟达显卡的具体信息，CUDA9.2版本需要396.26版本</p><p>复制安装指令，安装即可。</p><p>安装过程中出现如下信息同上操作：</p><p><code>The following NEW packages will be INSTALLED:</code></p><p>随后再次使用pip list查看是否有Pytorch即可（过程太慢请使用镜像）。</p><p>另一种检查方法是键入<code>python</code>进入python，然后<code>import torch</code></p><p>随后再输入<code>torch.cuda.is_available()</code>，如果返回True则成功。</p><p>在Pytorch中安装Jupyter</p><p><code>conda install nb_conda</code></p><p>随后键入jupyter notebook即可</p><hr><p> 下面是一些调用数据的实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyData</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="comment"># 初始化，根据这个类来创建特定的实例时需要</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root_dir, label_dir</span>):</span><br><span class="line">        self.root_dir = root_dir</span><br><span class="line">        self.label_dir = label_dir</span><br><span class="line">        self.path = os.path.join(self.root_dir, self.label_dir)</span><br><span class="line">        self.img_path = os.listdir(self.path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">        img_name = self.img_path[idx]</span><br><span class="line">        img_item_path = os.path.join(self.root_dir, self.label_dir, img_name)</span><br><span class="line">        img = Image.<span class="built_in">open</span>(img_item_path)</span><br><span class="line">        label = self.label_dir</span><br><span class="line">        <span class="keyword">return</span> img, label</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.img_path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root_dir = <span class="string">&quot;dataset/train&quot;</span></span><br><span class="line">ants_label_dir = <span class="string">&quot;ants&quot;</span></span><br><span class="line">bees_label_dir = <span class="string">&quot;bees&quot;</span></span><br><span class="line">ants_dataset = MyData(root_dir, ants_label_dir)</span><br><span class="line">bees_dataset = MyData(root_dir, bees_label_dir)</span><br><span class="line"></span><br><span class="line">train_dataset = ants_dataset + bees_dataset</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然，也可以通过修改文件夹名字来进行如上操作，这里就不给出了。</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/07/20/Qyeo9GJg4FjxEc8.png" alt="avatar"></p><p><img src="https://s2.loli.net/2022/07/20/jzoCbfUGEZOQsJq.png" alt="avatar"></p><hr><h2 id="MMCV配置环境"><a href="#MMCV配置环境" class="headerlink" title="MMCV配置环境"></a><strong>MMCV配置环境</strong></h2><ul><li>Linux &#x2F; Windows</li><li>Python</li><li>Pytorch</li><li>CUDA</li><li>gcc &amp;&amp; g++ (5.4+)</li><li>mmcv-full</li></ul><hr><h3 id="Windows环境-or-Linux环境："><a href="#Windows环境-or-Linux环境：" class="headerlink" title="Windows环境 or Linux环境："></a>Windows环境 or Linux环境：</h3><p>我们先来看mmcv，安装mmcv的前提是环境中需要有Pytorch。</p><p>Pytorch我选择在conda中进行安装，并且采用了国内的镜像。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">conda config <span class="literal">--add</span> channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/ </span><br><span class="line">conda config <span class="literal">--add</span> channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda<span class="literal">-forge</span>/ </span><br><span class="line">conda config <span class="literal">--add</span> channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config <span class="literal">--add</span> channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ </span><br><span class="line">conda config <span class="literal">--add</span> channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/peterjc123/</span><br><span class="line">conda config <span class="literal">--add</span> channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/</span><br><span class="line">conda config <span class="literal">--set</span> show_channel_urls yes</span><br></pre></td></tr></table></figure><ol><li>创建并激活conda虚拟环境：</li></ol><p><code>conda create -n mmcv python=3.8 -y</code></p><p><code>conda activate mmcv</code></p><ol start="2"><li>安装Pytorch和Torchvision：</li></ol><p><code>conda install pytorch==1.10.0 torchvision cudatoolkit=11.3 -c pytorch</code></p><p>注意，这里版本号之间不仅需要更改成自己需要的版本，还需要注意对应关系。</p><p>值得一提的是，如果采用国内的镜像，则需要去掉<code>-c</code>，否则还是会很慢。</p><ol start="3"><li>安装最新版mmcv-full（注意，这是使用预编译包，如果要从源码编译，则直接跳转至下文！）：</li></ol><p><code>pip install mmcv-full -f https://download.openmmlab.com/mmcv/dist/&#123;cu_version&#125;/&#123;torch_version&#125;/index.html</code></p><p>注意，链接中的 <code>&#123;cu_version&#125;</code> 和 <code>&#123;torch_version&#125;</code> 根据自身需求替换成实际的版本号。</p><p>本人在安装的时候使用的指令是：</p><p><code>pip install mmcv-full -f https://download.openmmlab.com/mmcv/dist/cu113/torch1.10.0/index.html</code></p><p>值得一提的是，貌似还有一种安装方法是用MIM，但本人在Linux下试了一次没有成功。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip3 install openmim</span><br><span class="line">mim install mmcv<span class="literal">-full</span>==<span class="number">1.5</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure><hr><h3 id="查看环境版本指令："><a href="#查看环境版本指令：" class="headerlink" title="查看环境版本指令："></a>查看环境版本指令：</h3><p><code>python --version</code>Python</p><p><code>print(torch.__version__)</code>Pytorch（python环境下，并且导入torch）</p><p><code>nvcc -V</code>CUDA</p><p><code>gcc -v</code>gcc</p><p><code>print(mmedit.__version__)</code> mmedit（python环境下，并且导入mmedit）</p><hr><p>直到这里，都属于安装MMCV的阶段，以上步骤在Windows和Linux下几乎都一样，接下来到了从源码上编译MMCV，Windows就要复杂一些了，具体如下：</p><h3 id="Windows环境编译MMCV："><a href="#Windows环境编译MMCV：" class="headerlink" title="Windows环境编译MMCV："></a>Windows环境编译MMCV：</h3><p>依赖：</p><ul><li>Git</li><li>Visual Studio</li><li>Anaconda（推荐） | Miniconda</li><li>CUDA</li></ul><p>注意需要启用的是Anaconda命令行而非一般的命令行。</p><p>这里防止出错，直接部分<em>引用官方文档</em>：</p><p>创建一个新的 Conda 环境</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create <span class="literal">--name</span> mmcv python=<span class="number">3.8</span>  <span class="comment"># 经测试，3.6, 3.7, 3.8 也能通过</span></span><br><span class="line">conda activate mmcv  <span class="comment"># 确保做任何操作前先激活环境</span></span><br></pre></td></tr></table></figure><p>安装 PyTorch 时，可以根据需要安装支持 CUDA 或不支持 CUDA 的版本</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CUDA version</span></span><br><span class="line">conda install pytorch==<span class="number">1.10</span>.<span class="number">0</span> torchvision cudatoolkit=<span class="number">11.3</span> <span class="literal">-c</span> pytorch</span><br><span class="line"><span class="comment"># 注意，这里的版本一定要对应，否则会报错！</span></span><br></pre></td></tr></table></figure><p>准备 MMCV 源代码</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/<span class="built_in">open-mmlab</span>/mmcv.git</span><br><span class="line"><span class="built_in">cd</span> mmcv</span><br></pre></td></tr></table></figure><p>安装所需 Python 依赖包</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install <span class="literal">-r</span> requirements/runtime.txt</span><br></pre></td></tr></table></figure><p><strong>建议安装 <code>ninja</code> 以加快编译速度</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install <span class="literal">-r</span> requirements/optional.txt</span><br></pre></td></tr></table></figure><p>接下来就要开始编译过程了：</p><p>设置 MSVC 编译器</p><p>设置环境变量。添加 <code>C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\bin\Hostx86\x64</code> 到 <code>PATH</code>，则 <code>cl.exe</code> 可以在命令行中运行，如下所示，以下是测试部分：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(base) <span class="built_in">PS</span> C:\Users\xxx&gt; cl</span><br><span class="line">Microsoft (<span class="built_in">R</span>) C/C++ Optimizing  Compiler Version <span class="number">19.27</span>.<span class="number">29111</span> <span class="keyword">for</span> x64</span><br><span class="line">Copyright (C) Microsoft Corporation.   All rights reserved.</span><br><span class="line"></span><br><span class="line">usage: cl [ <span class="type">option...</span> ] filename... [ / <span class="type">link</span> <span class="type">linkoption...</span> ]</span><br></pre></td></tr></table></figure><p>为了兼容性，我们使用 x86-hosted 以及 x64-targeted 版本，即路径中的 <code>Hostx86\x64</code> （注意先后顺序）。</p><p>因为 PyTorch 将解析 <code>cl.exe</code> 的输出以检查其版本，只有 utf-8 将会被识别，你可能需要将系统语言更改为英语。</p><p>控制面板 -&gt; 地区-&gt; 管理-&gt; 非 Unicode 来进行语言转换。</p><p>设置环境变量（注意这里是PS终端）：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$env:MMCV_WITH_OPS</span> = <span class="number">1</span></span><br><span class="line"><span class="variable">$env:MAX_JOBS</span> = <span class="number">8</span>  <span class="comment"># 根据你可用CPU以及内存量进行设置</span></span><br></pre></td></tr></table></figure><p>检查 <code>CUDA_PATH</code> 或者 <code>CUDA_HOME</code> 环境变量已经存在在 <code>envs</code> 之中</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(base) <span class="built_in">PS</span> C:\Users\WRH&gt; <span class="built_in">ls</span> env:</span><br><span class="line"></span><br><span class="line">Name                           Value</span><br><span class="line"><span class="literal">----</span>                           <span class="literal">-----</span></span><br><span class="line">CUDA_PATH                      C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.<span class="number">3</span></span><br><span class="line">CUDA_PATH_V11_3                C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.<span class="number">3</span></span><br><span class="line">CUDA_PATH_V11_7                C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.<span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>如 果 没 有</strong>，你可以按照下面的步骤设置</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$env:CUDA_HOME</span> = <span class="string">&quot;C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.3&quot;</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="variable">$env:CUDA_HOME</span> = <span class="variable">$env:CUDA_PATH_V11_3</span>  <span class="comment"># CUDA_PATH_V11_3 已经在环境变量中</span></span><br></pre></td></tr></table></figure><h3 id="设置-CUDA-的目标架构"><a href="#设置-CUDA-的目标架构" class="headerlink" title="设置 CUDA 的目标架构"></a>设置 CUDA 的目标架构</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$env:TORCH_CUDA_ARCH_LIST</span>=<span class="string">&quot;6.1&quot;</span> <span class="comment"># 支持 GTX 1080（本人是1050qwq）</span></span><br><span class="line"><span class="comment"># 或者用所有支持的版本，但可能会变得很慢</span></span><br><span class="line"><span class="variable">$env:TORCH_CUDA_ARCH_LIST</span>=<span class="string">&quot;3.5 3.7 5.0 5.2 6.0 6.1 7.0 7.5&quot;</span></span><br></pre></td></tr></table></figure><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$env:MMCV_WITH_OPS</span> = <span class="number">1</span></span><br><span class="line"><span class="variable">$env:MAX_JOBS</span> = <span class="number">8</span> <span class="comment"># 根据你可用CPU以及内存量进行设置（保守点可以输4）</span></span><br><span class="line">conda activate mmcv <span class="comment"># 激活环境</span></span><br><span class="line"><span class="built_in">cd</span> mmcv  <span class="comment"># 改变路径</span></span><br><span class="line">python setup.py build_ext  <span class="comment"># 如果成功, cl 将被启动用于编译算子</span></span><br><span class="line">python setup.py develop <span class="comment"># 安装</span></span><br><span class="line">pip list <span class="comment"># 检查是否安装成功</span></span><br></pre></td></tr></table></figure><p>与此同时，我们可以进行MMEditing的安装：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/<span class="built_in">open-mmlab</span>/mmediting.git</span><br><span class="line"><span class="built_in">cd</span> mmediting</span><br><span class="line">pip3 install <span class="literal">-e</span> .</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">python <span class="literal">-c</span> <span class="string">&quot;import mmedit; print(mmedit.__version__)&quot;</span></span><br><span class="line"><span class="comment"># Example output: 0.14.0</span></span><br></pre></td></tr></table></figure><hr><h1 id="01-Abstract"><a href="#01-Abstract" class="headerlink" title="01-Abstract"></a>01-Abstract</h1><p>本文介绍了笔者在学习《动手学深度学习》课程中的笔记。</p><p>这一Part的内容是深度学习基础。</p><p>后续将会补充更多的公式推导和原理部分。</p><p>敬请期待！</p><hr><h1 id="02-Guide-Topic"><a href="#02-Guide-Topic" class="headerlink" title="02-Guide Topic"></a>02-Guide Topic</h1><p>The most import thing of deep learning is <strong>Neural Network</strong>.</p><p>The Neural Network is a <strong>language</strong>, it is very <strong>flexible</strong>.</p><p>AutoGluon⭐</p><p>Book Version 1: <a href="https://zh/d2.ai/">https://zh/d2.ai/</a></p><p>Book Version 2: <a href="https://zh-v2.d2l.ai/">https://zh-v2.d2l.ai/</a></p><p>Source Code: <a href="https://github.com./d2l-ai/d2l-zh">https://github.com./d2l-ai/d2l-zh</a></p><p>Course Web: <a href="https://courses.d2l.ai/zh-v2">https://courses.d2l.ai/zh-v2</a></p><p>Discuss: <a href="https://discuss.pytorch.org/">https://discuss.pytorch.org/</a> <a href="https://discuss.d2l.ai/c/16">https://discuss.d2l.ai/c/16</a></p><h2 id="Introduce-DeepLearning"><a href="#Introduce-DeepLearning" class="headerlink" title="Introduce DeepLearning"></a>Introduce DeepLearning</h2><p>The target of this course: </p><ul><li>introduce the classic and new model like LeNet, ResNet, LSTM, BERT,…</li><li>Basic Machine Learning</li><li>Practice</li></ul><h2 id="The-Application-of-DL"><a href="#The-Application-of-DL" class="headerlink" title="The  Application of DL"></a>The  Application of DL</h2><p>图片分类：2012年深度学习开始之后错误率迅速降低，目前大约5%</p><p><a href="https://qz.com/1034972/the-data-that-changed-thedirection-of-ai-research-and-possibly-the-world/">https://qz.com/1034972/the-data-that-changed-thedirection-of-ai-research-and-possibly-the-world/</a></p><p>物体检测和分割</p><p>样式迁移：可以初步理解为，加滤镜</p><p>人脸合成</p><p>文字生成图片<a href="https://openai.com/blog/dall-e/">DALL·E: Creating Images from Text (openai.com)</a></p><p>文字生成</p><p>无人驾驶</p><p><em>广告推荐的预测与训练步骤：</em>特征提取→模型→点击率预测→训练数据→特征和用户点击→模型</p><p>模型的可解释性：XAI，DL上做的还不太好，ML上还行</p><h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><p>流程如下：</p><ol><li><p><code>ssh ubuntu@&lt;IP&gt;</code>连接云服务器，如果直接能在服务器的terminal上操作也可以</p></li><li><p><code>sudo apt update</code>更新一下机器，因为一开始就是一个裸的ubuntu啥也没有</p></li><li><p><code>sudo apt install build-essential</code>装一些开发环境，例如gcc</p></li><li><p><code>sudo apt install python3.8</code>安装python</p></li><li><p>miniconda安装，去官网复制对应版本和需求的链接，下载：<code>wget &lt;link&gt;</code> → 安装：<code>bash Miniconda3-latest-Linux-x64_64.sh（根据自己的文件进行替换）</code>默认装在根目录下面就可以</p></li><li><p>进入conda环境：<code>bash</code>（直接在terminal里打bash）之后可以直接在base环境里来用，也可以新创建一个环境。 </p></li><li><p>内部环境的安装：<code>pip install jupyter d2l torch torchvision</code>（本地记得换源）</p></li><li><p>课程记事本的下载：<code>http://zh-v2.d2l.ai</code>→<code>在Jupyter记事本文件这里复制链接</code>→<code>wget &lt;link&gt;</code></p></li><li><p>如果服务器里没有zip，则需要安装一个zip<code>sudo spt install zip</code>，之后<code>ls</code>可以显示一下名称，然后再进行解压即可<code>unzip d2l-zh.zip</code></p><p>之后再<code>ls</code>可以看到解压出来了三个文件夹<code>mxnet pytorch tensorflow</code></p><p>进入pytorch的文件夹查看有什么东西<code>cd pytorch/``ls</code></p></li><li><p>PPT的下载可以直接<code>git clone &lt;link&gt;</code>（链接在github里，是仓库）</p></li><li><p>运行jupyter<code>jupyter notebook</code>（会出现一个链接，需要将远端的<code>link</code>map到本地<code>ssh -L8888:localhost:8888 ubuntu@&lt;IP&gt;</code>）（这里的8888是远程的端口）</p><p>值得一提的是，打开jupyter之后笔记有幻灯片格式，还有非幻灯片格式，若想打开幻灯片格式则需要安装一个插件<code>pip install rise</code></p></li></ol><hr><h1 id="03-Pre-Knowledge"><a href="#03-Pre-Knowledge" class="headerlink" title="03-Pre Knowledge"></a>03-Pre Knowledge</h1><h2 id="Data-Operation"><a href="#Data-Operation" class="headerlink" title="Data Operation"></a>Data Operation</h2><p>机器学习中用到的最多的数据结构：N维数组</p><p>访问元素的几种常用方法：</p><ul><li>一个元素<code>[1, 2]</code></li><li>一行<code>[1, :]</code></li><li>子区域<code>[1:3, 1:]</code></li><li>子区域<code>[::3, ::2]</code></li></ul><p>除此之外，还可以通过<code>-1</code>来访问最后一个元素</p><h3 id="Tensor张量"><a href="#Tensor张量" class="headerlink" title="Tensor张量"></a>Tensor张量</h3><p>张量表示一个数值组成的数组，这个数组可能有多个维度。</p><p><code>x = torch.arange(12)</code></p><p>我们可以通过张量的<code>shape</code>属性来访问张量的形状和<strong>张量</strong>中<strong>元素的总数</strong><br><code>x.shape</code></p><p><code>x.numel</code></p><p>要改变一个张量的形状而不改变元素的数量和数值，我们可以调用<code>reshape</code>函数</p><p><code>X = x.reshape(3, 4)</code></p><p>使用全0，全1或其他常量或者从特定分布中随机采样的数字</p><p><code>torch.zeros((2, 3, 4))</code></p><p><code>torch.ones((2, 3, 4))</code></p><p>也可以直接在定义的时候就赋好初始值，这里不过多赘述；</p><p>常见的四则运算等都可以被升级为按元素运算；</p><p>把多个张量连接在一起</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X = torch.arange(<span class="number">12</span>, dtype=torch.float32).reshape((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">Y = torch.tensor([[<span class="number">2.0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line">torch.cat((X, Y), dim=<span class="number">0</span>), torch.cat((X, Y), dim=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>通过逻辑运算符构建二元张量；</p><p>对张量中所有元素求和会获得一个只有一个元素的张量<code>X.sum()</code>；</p><p>即使形状不同，我们仍然可以通过调用<strong>广播机制</strong>来执行按元素操作； </p><p>还有一些赋值的方法：<code>X[0:2, :]  = 12</code>；</p><p>运行一些操作可能会导致为新结果分配内存：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">before = <span class="built_in">id</span>(Y) <span class="comment"># 在Python中，id()类似于指针的意思</span></span><br><span class="line">Y = Y + X</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(Y) == before)</span><br><span class="line"><span class="comment"># output = False</span></span><br></pre></td></tr></table></figure><p>执行原地内存操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new_Y = torch.zeros_like(Y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;id(new_Y):&quot;</span>, <span class="built_in">id</span>(new_Y))</span><br><span class="line">new_Y[:] = X + Y</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;id(new_Y):&quot;</span>, <span class="built_in">id</span>(new_Y))</span><br></pre></td></tr></table></figure><p>转换为NumPy张量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A = X.numpy()</span><br><span class="line">B = torch.tensor(A)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(A), <span class="built_in">type</span>(B)) <span class="comment"># 查看数据类型</span></span><br><span class="line"><span class="comment"># 将大小为1的张量转换为Python标量：</span></span><br><span class="line">a = torch.tensor([<span class="number">3.5</span>])</span><br><span class="line">a, a.item(), <span class="built_in">float</span>(a), <span class="built_in">int</span>(a)</span><br><span class="line"><span class="comment"># output = (tensor([3.5000]), 3.5, 3.5, 3)</span></span><br></pre></td></tr></table></figure><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>作用：读取csv文件→做一定的特征预处理→变成pytorch能用的一个tenser(张量)</p><p>创建一个人工数据集，并存储在csv（逗号分隔值）文件；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.makedirs(os.path.join(<span class="string">&#x27;..&#x27;</span>, <span class="string">&#x27;data&#x27;</span>), exist_ok=<span class="literal">True</span>)</span><br><span class="line">data_file = os.path.join(<span class="string">&#x27;..&#x27;</span>, <span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;house_tiny.csv&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(data_file, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&#x27;NumRooms,Alley,Price\n&#x27;</span>)  <span class="comment"># 列名</span></span><br><span class="line">    f.write(<span class="string">&#x27;NA,Pave,127500\n&#x27;</span>)  <span class="comment"># 每行表示一个数据样本</span></span><br><span class="line">    f.write(<span class="string">&#x27;2,NA,106000\n&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;4,NA,178100\n&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;NA,NA,140000\n&#x27;</span>)</span><br></pre></td></tr></table></figure><p>从创建的csv文件中加载原始数据集；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = pd.read_csv(data_file)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"><span class="comment"># 事实上这里也可直接写成data，不使用print，会保留HTML格式</span></span><br></pre></td></tr></table></figure><p>处理缺失的数据，典型的方法是<strong>插值</strong>和<strong>删除</strong>，代码就不放了，可以直接看<a href="https://zh-v2.d2l.ai/chapter_preliminaries/pandas.html">2.2. 数据预处理 — 动手学深度学习 2.0.0-beta1 documentation (d2l.ai)</a></p><hr><h2 id="Linear-Algebra"><a href="#Linear-Algebra" class="headerlink" title="Linear Algebra"></a>Linear Algebra</h2><h3 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h3><p>c &#x3D; A * b  hence  ||c|| &lt;&#x3D; ||A|| * ||b||</p><p>取决于如何衡量b和c的长度</p><p>常见范数：</p><ul><li>矩阵范数：最小的满足上面公式的值</li><li>Frobenius范数（具体公式不给出了）</li></ul><p>正定矩阵：如果一个矩阵是正定的，那么它乘上任何一个行向量或者列向量之后值都是大于等于0的；</p><h3 id="哈达玛积"><a href="#哈达玛积" class="headerlink" title="哈达玛积"></a>哈达玛积</h3><p>两个矩阵按元素乘法</p><h3 id="亚导数"><a href="#亚导数" class="headerlink" title="亚导数"></a>亚导数</h3><p>将导数拓展到不可微的函数</p><h3 id="向量链式法则"><a href="#向量链式法则" class="headerlink" title="向量链式法则"></a>向量链式法则</h3><p>略</p><h3 id="自动求导"><a href="#自动求导" class="headerlink" title="自动求导"></a>自动求导</h3><p>自动求导计算一个函数在指定值上的导数</p><p>有别于符号求导和数值求导</p><h3 id="计算图"><a href="#计算图" class="headerlink" title="计算图"></a>计算图</h3><p>将代码分解成操作子</p><p>将计算表示成一个无环图</p><p>（显式构造、隐式构造）</p><hr><h2 id="Matrix-Calculation"><a href="#Matrix-Calculation" class="headerlink" title="Matrix Calculation"></a>Matrix Calculation</h2><h3 id="导数"><a href="#导数" class="headerlink" title="导数"></a>导数</h3><ul><li><p>标量导数（回忆一下即可）</p></li><li><p>亚导数（将导数拓展到不可微的函数）</p></li><li><p>向量的导数（注意方向是如何变化的）<strong>（梯度与等高线正交，指向值变化最大的方向）</strong></p><img src="https://s2.loli.net/2023/01/01/tp45niawvJU9qlo.png" alt="avatar" style="zoom:50%;" /></li><li><p>拓展到矩阵以及更高维度的张量</p><p><img src="https://s2.loli.net/2023/01/01/ZqCuXydNbRKawoQ.png" alt="avatar"></p></li></ul><p>机器学习不关心P问题，只关心NP问题，所以一般不会处理凸函数问题，因为凸函数问题显然可以很容易得到最优解。（下面补充一下P与NP的内容好了）</p><h3 id="P与NP问题"><a href="#P与NP问题" class="headerlink" title="P与NP问题"></a>P与NP问题</h3><blockquote><p>**<em>P类问题*<strong>：所有可以在<a href="https://baike.baidu.com/item/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%97%B6%E9%97%B4?fromModule=lemma_inlink">多项式时间</a>内求解的判定问题构成P类问题。</strong></em>判定问题***<em>：</em>判断是否有一种能够解决某一类问题的能行算法的研究课题。</p><p>**<em>NP类问题*<strong>：所有的非确定性多项式时间可解的判定问题构成NP类问题。</strong></em>非确定性算法***：非确定性算法将问题分解成猜测和验证两个阶段。算法的猜测阶段是非确定性的，算法的验证阶段是确定性的，它验证猜测阶段给出解的正确性。设算法A是解一个判定问题Q的非确定性算法，如果A的验证阶段能在多项式时间内完成，则称A是一个多项式时间非确定性算法。有些计算问题是确定性的，例如加减乘除，只要按照公式推导，按部就班一步步来，就可以得到结果。但是，有些问题是无法按部就班直接地计算出来。比如，找大<a href="https://baike.baidu.com/item/%E8%B4%A8%E6%95%B0?fromModule=lemma_inlink">质数</a>的问题。有没有一个公式能推出下一个<a href="https://baike.baidu.com/item/%E8%B4%A8%E6%95%B0?fromModule=lemma_inlink">质数</a>是多少呢？这种问题的答案，是无法直接计算得到的，只能通过间接的“猜算”来得到结果。这也就是非确定性问题。而这些问题的通常有个算法，它不能直接告诉你答案是什么，但可以告诉你，某个可能的结果是正确的答案还是错误的。这个可以告诉你“猜算”的答案正确与否的算法，假如可以在多项式（polynomial）时间内算出来，就叫做多项式非确定性问题。</p><p>***NPC问题***<strong>：</strong>NP中的某些问题的复杂性与整个类的复杂性相关联.这些问题中任何一个如果存在多项式时间的算法,那么所有NP问题都是多项式时间可解的.这些问题被称为NP-完全问题(NPC问题)。</p></blockquote><hr><h2 id="自动求导-1"><a href="#自动求导-1" class="headerlink" title="自动求导"></a>自动求导</h2><h3 id="向量链式法则-1"><a href="#向量链式法则-1" class="headerlink" title="向量链式法则"></a>向量链式法则</h3><p><img src="https://s2.loli.net/2023/01/01/g5DQzkZC49jmqlF.png" alt="avatar"></p><p>接下来我们看一个例子：</p><p><img src="https://s2.loli.net/2023/01/01/4aYqp7nE9HCgDW6.png" alt="avatar"></p><h3 id="不同的求导："><a href="#不同的求导：" class="headerlink" title="不同的求导："></a>不同的求导：</h3><ul><li>自动求导：计算一个函数在指定值上的导数</li><li>符号求导：显式的一个求导</li><li>数值求导：用数值来拟合，不需要知道具体的表达式</li></ul><h3 id="计算图："><a href="#计算图：" class="headerlink" title="计算图："></a>计算图：</h3><p>计算图是Pytorch内部自动计算导数的一个方式；</p><p>其实等同于用链式法则求导的一个过程，有点像同路相乘异路相加；</p><ul><li>将代码分解成操作子</li><li>将计算表示成一个有向无环图DAG</li></ul><p>构造计算图有显式构造和隐式构造两种方式，数学上一般是显示，Pytorch是隐式；</p><h3 id="自动求导的模式："><a href="#自动求导的模式：" class="headerlink" title="自动求导的模式："></a>自动求导的模式：</h3><p><img src="https://s2.loli.net/2023/01/01/QfPDEl9yCiHLMVt.png" alt="avatar"></p><p><img src="https://s2.loli.net/2023/01/01/FS3pXUNqrdWjEBO.png" alt="avatar"></p><p><strong>其实，反向传播就是人们用手来算复合函数求导的过程，是一样的。</strong></p><p>demo代码如下<a href="https://zh-v2.d2l.ai/chapter_preliminaries/autograd.html#id2">2.5. 自动微分 — 动手学深度学习 2.0.0 documentation (d2l.ai)</a></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;写在前面：&quot;&gt;&lt;a href=&quot;#写在前面：&quot; class=&quot;headerlink&quot; title=&quot;写在前面：&quot;&gt;&lt;/a&gt;写在前面：&lt;/h3&gt;&lt;p&gt;本篇内容目前用于记录自己一开始学习深度学习的学习过程，方便自己查阅，或许正在看本文的你对其中的一些内容有所疑惑，这大</summary>
      
    
    
    
    <category term="AI" scheme="https://conqueror712.github.io/categories/AI/"/>
    
    
  </entry>
  
</feed>
