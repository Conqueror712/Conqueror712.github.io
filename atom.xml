<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>落雨乄天珀夜</title>
  
  
  <link href="https://conqueror712.github.io/atom.xml" rel="self"/>
  
  <link href="https://conqueror712.github.io/"/>
  <updated>2023-03-30T01:30:54.655Z</updated>
  <id>https://conqueror712.github.io/</id>
  
  <author>
    <name>落雨乄天珀夜</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>初识 - 文献综述丨学习记录</title>
    <link href="https://conqueror712.github.io/post/Literature-Review.html"/>
    <id>https://conqueror712.github.io/post/Literature-Review.html</id>
    <published>2023-03-29T13:25:35.000Z</published>
    <updated>2023-03-30T01:30:54.655Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>鉴于笔者差不多也要开始写文献综述了，而作为一个这方面的萌新，对此可以说是一窍不通。</p><p>下面就记录我自己的经验，关于学习如何写一个文献综述，以及如何写好一个文献综述。</p><p>话说这篇文章事实上就是对于网上的内容进行的一个”小综述”，大概算是吧（笑）。</p><blockquote><p>个人博客：<a href="https://conqueror712.github.io/">https://conqueror712.github.io/</a></p><p>知乎：<a href="https://www.zhihu.com/people/soeur712/posts">https://www.zhihu.com/people/soeur712/posts</a></p><p>Bilibili：<a href="https://space.bilibili.com/57089326">https://space.bilibili.com/57089326</a></p><p>掘金：<a href="https://juejin.cn/user/1297878069809725/posts">https://juejin.cn/user/1297878069809725/posts</a></p></blockquote><hr><p>文献综述还有一些别名：研究综述、国内外研究现状</p><p>定义：在全面掌握分析某一学术问题或者研究领域相关文献的基础上，对该学术问题或研究领域在一定时期内已有的研究成果、存在的问题进行<strong>分析、归纳、整理和评述</strong>而形成的一种不同于研究论文的文体。</p><p>文献综述反映当前某一领域中某分支学科或重要专题的历史现状、最新进展、学术见解和建议，它往往能反映出有关问题的新动态、新趋势、新水平、新原理和新技术等等。作者一般不在其中发表个人见解和建议，也不做任何评论，只是客观概括地反映事实。</p><hr><h1 id="文献综述有什么用："><a href="#文献综述有什么用：" class="headerlink" title="文献综述有什么用："></a>文献综述有什么用：</h1><ul><li>是科研新手非常好的入门方式</li><li>可以整理自己的<strong>思路</strong></li><li>避免与已有的研究<strong>重复</strong></li><li>明确现有研究和自己将要做的研究的<strong>必要性与价值</strong></li><li>体现研究者对于相关研究领域的<strong>熟悉程度</strong></li></ul><hr><h1 id="如何入门文献综述："><a href="#如何入门文献综述：" class="headerlink" title="如何入门文献综述："></a>如何入门文献综述：</h1><h2 id="选题："><a href="#选题：" class="headerlink" title="选题："></a>选题：</h2><blockquote><p>良好的开始是成功的一半</p></blockquote><ul><li>新颖性</li><li>可行性</li><li>选题的意义和价值</li></ul><p>具体来说：</p><p><strong>新颖性</strong>主要看是不是能在这个领域贡献新的知识，判断方法与思路：</p><ol><li>是否呈现新事实 or 发现新现象</li><li>是否有新的阐释</li><li>是否提出新问题</li><li>是否拓展新视角</li></ol><p><strong>可行性</strong>顾名思义，既要有一定的相关文献作为基础，又不能选择已经比较完善的领域。</p><p><strong>选题的意义和价值</strong>，这大致可以分为两个方面，理论意义和实践意义。理论意义就是指这个选题是否可以丰富和完善已有的理论研究内容，促进该领域的进一步发展；实践意义就是说是否对现实生活有用，考虑经济效益和社会效益。</p><hr><h2 id="检索："><a href="#检索：" class="headerlink" title="检索："></a>检索：</h2><p>盲目的检索只会徒增自己的时间成本，甚至会影响到之后的研究。</p><p>需要真正明确自己的研究方向，再进行检索。</p><hr><h2 id="看："><a href="#看：" class="headerlink" title="看："></a>看：</h2><p>高效阅读？带着以下的问题：</p><ol><li><p>这篇文章主要解决哪些问题？</p></li><li><p>针对这些问题，作者采用了哪些方法？</p></li><li><p>这些方法各具有哪些优点和不足？</p></li><li><p>目前该领域的最新研究进展如何？</p></li></ol><p>其次，有一些需要注意的点：</p><ul><li>看前言、摘要和绪论，根据关键词，找到适合的书来看。注意不要看的太仔细，不要拘泥于一两个知识点</li><li>找关键词：从师兄师姐或者课题组的其他同学的论文的关键词</li><li>尽可能多的看，看二三十篇开始动手整理</li></ul><hr><h2 id="写："><a href="#写：" class="headerlink" title="写："></a>写：</h2><ul><li>将绪论部分求同存异，然后按自己的逻辑编排，便于了解课题和打基础</li><li>找到一个方向从而缩小关注的范围，便于深入，这一步可以问一问老师</li></ul><hr><h2 id="再看："><a href="#再看：" class="headerlink" title="再看："></a>再看：</h2><ul><li>关注方法，关键性能指标，原理等</li><li>分类，比较</li></ul><hr><h2 id="深入细节："><a href="#深入细节：" class="headerlink" title="深入细节："></a>深入细节：</h2><ul><li>继续看文献，但是要统计和比较</li><li>对别人的图表要有自己的分析，当成未知结论的图，重新分析得出自己的结论，提出新的问题和方法</li><li>熟练应用数学特别是统计</li><li>耐心，文献不是一天看完的，一般这一周期都会持续三个月以上的时间</li></ul><hr><h2 id="关于参考文献："><a href="#关于参考文献：" class="headerlink" title="关于参考文献："></a>关于参考文献：</h2><p>参考文献是很重要的，一定要<strong>认真对待</strong>。</p><p>一个合格的参考文献需要有：</p><ul><li>全面性</li><li>新进性</li><li>权威性、代表性</li><li>相关性</li><li>实事求是性</li></ul><hr><h1 id="文献综述的常见问题："><a href="#文献综述的常见问题：" class="headerlink" title="文献综述的常见问题："></a>文献综述的常见问题：</h1><ul><li>内容不完整</li><li>逻辑混乱</li><li>避重就轻</li><li>只述不评</li><li>个人观点过多</li></ul><hr><h1 id="什么是一个优秀的文献综述："><a href="#什么是一个优秀的文献综述：" class="headerlink" title="什么是一个优秀的文献综述："></a>什么是一个优秀的文献综述：</h1><blockquote><ol><li><p>在将要研究的主题之下，我们<strong>已经知道了什么</strong>？</p></li><li><p>研究的主要概念或主要变量具有怎样的<strong>特征</strong>？</p></li><li><p>这些主要的概念或变量之间具有怎样的<strong>关系</strong>？</p></li><li><p>有关这个研究主题，<strong>已有的理论</strong>有哪些？</p></li><li><p>在已有的研究中，存在怎样的<strong>缺陷或不足</strong>？</p></li><li><p>还有哪些观点<strong>有待检验</strong>？</p></li><li><p>哪些证据是<strong>缺乏的、不全面的、互相矛盾或非常局限的</strong>？</p></li><li><p><strong>为什么</strong>要研究目前所确定的这个问题？</p></li><li><p>你希望当前的研究对这个主题有怎样的<strong>贡献</strong>（你的<strong>研究价值</strong>是什么）？</p></li><li><p>已有的研究设计或研究方法，存在哪些有<strong>待改进之处</strong></p></li></ol></blockquote><hr><h1 id="文献综述结构："><a href="#文献综述结构：" class="headerlink" title="文献综述结构："></a>文献综述结构：</h1><p>研究背景&#x2F;研究目的与意义，研究现状，评述，参考文献；</p><p>（大致如上，但是不仅限于此）</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h1&gt;&lt;p&gt;鉴于笔者差不多也要开始写文献综述了，而作为一个这方面的萌新，对此可以说是一窍不通。&lt;/p&gt;
&lt;p&gt;下面就记录我自己的经验，关于学习如</summary>
      
    
    
    
    <category term="Experience" scheme="https://conqueror712.github.io/categories/Experience/"/>
    
    
  </entry>
  
  <entry>
    <title>深度学习 - Ep2 - 多层感知机丨学习记录</title>
    <link href="https://conqueror712.github.io/post/DL-MLP.html"/>
    <id>https://conqueror712.github.io/post/DL-MLP.html</id>
    <published>2023-03-27T14:52:05.000Z</published>
    <updated>2023-03-29T05:25:10.259Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>本篇内容记录笔者学习深度学习的学习过程，如果你有任何想询问的问题，欢迎在以下任何平台提问！</p><p>参考书：《动手学深度学习》</p><blockquote><p>个人博客：<a href="https://conqueror712.github.io/">https://conqueror712.github.io/</a></p><p>知乎：<a href="https://www.zhihu.com/people/soeur712/posts">https://www.zhihu.com/people/soeur712/posts</a></p><p>Bilibili：<a href="https://space.bilibili.com/57089326">https://space.bilibili.com/57089326</a></p><p>掘金：<a href="https://juejin.cn/user/1297878069809725/posts">https://juejin.cn/user/1297878069809725/posts</a></p></blockquote><p>注：本文将会随着笔者的学习过程随时补充。</p><hr><h1 id="多层感知机："><a href="#多层感知机：" class="headerlink" title="多层感知机："></a>多层感知机：</h1><p>从单层神经网络到多层神经网络。</p><h2 id="隐藏层："><a href="#隐藏层：" class="headerlink" title="隐藏层："></a>隐藏层：</h2><p><img src="https://img.picgo.net/2023/03/29/IJ2BQGEC9_LWUSKH3EZD7ae2acf350291795.png" alt="avatar"></p><hr><h2 id="激活函数："><a href="#激活函数：" class="headerlink" title="激活函数："></a>激活函数：</h2><p><img src="https://img.picgo.net/2023/03/29/image296b3f3f52baec2d.png" alt="avatar"></p><hr><h1 id="权重衰减："><a href="#权重衰减：" class="headerlink" title="权重衰减："></a>权重衰减：</h1><p>权重衰减可以帮助缓解过拟合问题。</p><p>在深度学习中，模型的过拟合问题通常是由于模型过于复杂或训练数据不足等原因造成的。</p><p>权重衰减是一种<strong>正则化技术</strong>，它通过在模型的损失函数中增加一个惩罚项来减少模型中的过度拟合。</p><ul><li><strong>正则化</strong>：是处理过拟合的常用方法：在训练集的损失函数中<strong>加入惩罚项</strong>，以<strong>降低学习到的模型的复杂度</strong>。</li><li>保持模型简单的一个特别的选择是使用$L_2$惩罚的权重衰减。这会导致学习算法更新步骤中的权重衰减。</li><li>权重衰减功能在深度学习框架的优化器中提供。</li><li>在同一训练代码实现中，不同的参数集可以有不同的更新行为。</li></ul><p><img src="https://cdnjson.com/images/2023/03/29/image.png" alt="avatar"></p><p>权重衰减通过在损失函数中<strong>添加L1或L2范数惩罚项</strong>来实现。</p><ul><li>L1惩罚项将模型中所有参数的绝对值之和作为惩罚项</li><li>L2惩罚项将模型中所有参数的平方和作为惩罚项。</li></ul><p>这些惩罚项的引入使得模型在训练过程中更加倾向于使用较小的参数值，从而减少了过拟合的风险。</p><hr><h1 id="Dropout-暂退法："><a href="#Dropout-暂退法：" class="headerlink" title="Dropout - 暂退法："></a>Dropout - 暂退法：</h1><p>我们希望模型能够<strong>深度挖掘特征</strong>，即<strong>将其权重分散到多个特征中</strong>，而不是<strong>过于依赖少数潜在的虚假关联</strong>。</p><h2 id="重新审视过拟合："><a href="#重新审视过拟合：" class="headerlink" title="重新审视过拟合："></a>重新审视过拟合：</h2><p><img src="https://cdnjson.com/images/2023/03/29/imagee9b5c48d72dac33f.png" alt="avatar"></p><h2 id="扰动的稳健性："><a href="#扰动的稳健性：" class="headerlink" title="扰动的稳健性："></a>扰动的稳健性：</h2><p><img src="https://cdnjson.com/images/2023/03/29/image78c95bd6be4ede4a.png" alt="avatar"></p><p>所以说，Dropout可以改进深层网络的泛化性。</p><p>Dropout是一种在神经网络中进行正则化的方法，</p><p>它通过在训练期间随机屏蔽一部分神经元来减少模型的复杂度，从而避免过拟合的问题。</p><blockquote><p>在每次训练迭代中，</p><p>dropout会随机选择一些神经元，</p><p>将其输出设置为0，</p><p>从而减少这些神经元的贡献，</p><p>同时也促使神经元之间的相互作用变得更加分散和平均。</p></blockquote><hr><h1 id="前向-x2F-反向传播和计算图："><a href="#前向-x2F-反向传播和计算图：" class="headerlink" title="前向 &#x2F; 反向传播和计算图："></a>前向 &#x2F; 反向传播和计算图：</h1><p>前向传播：<strong>按顺序（从输入层到输出层）计算和存储神经网络中每层的结果。</strong></p><p>反向传播：计算神经网络参数梯度的方法。 该方法根据微积分中的<strong>链式规则</strong>，按相反的顺序从输出层到输入层遍历网络。</p><p><img src="https://cdnjson.com/images/2023/03/29/imagea4b38c7f912cc1d2.png" alt="avatar"> </p><hr><p>计算图有助于我们可视化计算中操作符和变量的依赖关系。</p><h2 id="前向传播计算图："><a href="#前向传播计算图：" class="headerlink" title="前向传播计算图："></a>前向传播计算图：</h2><p><img src="https://zh-v2.d2l.ai/_images/forward.svg" alt="avatar"></p><ul><li>前向传播在神经网络定义的计算图中按顺序计算和存储中间变量，它的顺序是从输入层到输出层。</li><li>反向传播按相反的顺序（从输出层到输入层）计算和存储神经网络的中间变量和参数的梯度。</li><li>在训练深度学习模型时，前向传播和反向传播是相互依赖的。</li><li>训练比预测需要更多的内存。</li></ul><hr><h1 id="数值稳定性和模型初始化："><a href="#数值稳定性和模型初始化：" class="headerlink" title="数值稳定性和模型初始化："></a>数值稳定性和模型初始化：</h1><p>梯度爆炸指的是在深度神经网络训练过程中，梯度值变得异常巨大，导致网络中的某些权重值在更新时发生了非常大的变化。这会导致模型的参数更新过于剧烈，使得模型在训练过程中无法收敛到合适的解决方案，也可能导致数值计算溢出等问题。</p><p>相反，梯度消失是指在深度神经网络训练过程中，梯度值变得非常小，甚至接近于0，导致网络的某些权重值几乎不会被更新，从而使得模型无法学习到足够的特征和模式，导致模型欠拟合的问题。</p><p>梯度爆炸和梯度消失通常是由于神经网络结构太深，导致梯度在反向传播过程中指数级别地增加或减少，使得梯度难以传播到浅层网络，或者使得梯度不稳定而难以优化。为了缓解这些问题，可以采取一些技术，如权重初始化、使用梯度截断和层归一化等方法来稳定训练过程，并提高深度神经网络的性能和泛化能力。</p><h2 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h2><ul><li>梯度消失和梯度爆炸是深度网络中常见的问题。在参数初始化时需要非常小心，以确保梯度和参数可以得到很好的控制。</li><li>需要用启发式的初始化方法来确保初始梯度既不太大也不太小。</li><li>ReLU激活函数缓解了梯度消失问题，这样可以加速收敛。</li><li>随机初始化是保证在进行优化前打破对称性的关键。</li><li>Xavier初始化表明，对于每一层，输出的方差不受输入数量的影响，任何梯度的方差不受输出数量的影响。</li></ul><hr><p>附注：</p><p>关于环境和分布偏移，这里先以一言以蔽之：</p><p><strong>环境偏移指的是训练和测试数据之间的差异，而分布偏移指的是测试数据和目标分布之间的差异。</strong></p><p>有关内容纷繁复杂，后续单开一篇文章来记录。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h1&gt;&lt;p&gt;本篇内容记录笔者学习深度学习的学习过程，如果你有任何想询问的问题，欢迎在以下任何平台提问！&lt;/p&gt;
&lt;p&gt;参考书：《动手学深度学习》</summary>
      
    
    
    
    <category term="AI" scheme="https://conqueror712.github.io/categories/AI/"/>
    
    
  </entry>
  
  <entry>
    <title>深度学习 - Ep1 - 线性神经网络丨学习记录</title>
    <link href="https://conqueror712.github.io/post/DL-LinearNN.html"/>
    <id>https://conqueror712.github.io/post/DL-LinearNN.html</id>
    <published>2023-03-27T02:20:05.000Z</published>
    <updated>2023-03-27T10:33:36.780Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>本篇内容记录笔者学习深度学习的学习过程，如果你有任何想询问的问题，欢迎在以下任何平台提问！</p><blockquote><p>个人博客：<a href="https://conqueror712.github.io/">https://conqueror712.github.io/</a></p><p>知乎：<a href="https://www.zhihu.com/people/soeur712/posts">https://www.zhihu.com/people/soeur712/posts</a></p><p>Bilibili：<a href="https://space.bilibili.com/57089326">https://space.bilibili.com/57089326</a></p><p>掘金：<a href="https://juejin.cn/user/1297878069809725/posts">https://juejin.cn/user/1297878069809725/posts</a></p></blockquote><p>注：本文将会随着笔者的学习过程随时补充。</p><hr><h1 id="线性回归："><a href="#线性回归：" class="headerlink" title="线性回归："></a>线性回归：</h1><p><img src="https://cdnjson.com/images/2023/03/27/image00739de91ba022ad.png" alt="avatar"></p><h2 id="线性模型："><a href="#线性模型：" class="headerlink" title="线性模型："></a>线性模型：</h2><p>n维输入：$\vec{x}&#x3D;[x_1,x_2,…,x_n]^T$</p><p>有：</p><ul><li>n维权重：$\vec{w}&#x3D;[w_1, w_2, …, w_n]^T$</li><li>标量偏差$b$</li></ul><p>输出是输入的加权和：$y&#x3D;&lt;\vec{w},\vec{x}&gt;+b$</p><p>如此，线性模型（有显式解）可以看作单层的神经网络（带权的层为1）</p><hr><h2 id="损失函数："><a href="#损失函数：" class="headerlink" title="损失函数："></a>损失函数：</h2><p><img src="https://cdnjson.com/images/2023/03/27/image9853c9b4dd51251a.png" alt="avatar"></p><p>平方误差损失函数：$l^{(i)}(\vec{w},b)&#x3D;\frac{1}{2}(\hat{y}^{(i)}-y^{(i)})^2$</p><p>其中，$\hat{y}^{(i)}$是预测值，$y^{(i)}$是真实标签</p><hr><h2 id="随机梯度下降："><a href="#随机梯度下降：" class="headerlink" title="随机梯度下降："></a>随机梯度下降：</h2><p><img src="https://cdnjson.com/images/2023/03/27/imageaf856f6cb117078e.png" alt="avatar"></p><blockquote><p>最小化目标函数 &lt;&#x3D;&gt;  执行极大似然估计</p></blockquote><p>梯度下降中的参数更新公式：$\overrightarrow{w_t} &#x3D; \overrightarrow{w_{t-1}} - η\frac{\partial{l}}{\partial{\overrightarrow{w_{t-1}}}}$</p><p>其中：$η$是学习率（步长的超参数），$\frac{\partial{l}}{\partial{\overrightarrow{w_{t-1}}}}$是梯度</p><hr><h1 id="Softmax回归："><a href="#Softmax回归：" class="headerlink" title="Softmax回归："></a>Softmax回归：</h1><p>Softmax实际上是一个分类问题；</p><p>回归：估计一个连续值</p><ul><li>单连续值输出</li><li>自然区间R</li><li>与真实值的区别作为损失</li></ul><p>分类：预测一个离散类别</p><ul><li>通常多个输出</li><li>输出$i$是预测为第$i$类的置信度（对分类问题，只关心对于正确类的置信度是否足够大）</li></ul><h2 id="一些数据集："><a href="#一些数据集：" class="headerlink" title="一些数据集："></a>一些数据集：</h2><p>MNIST：手写数字识别（10类）</p><p>ImageNet：自然物品分类（1000类）</p><h2 id="回归→分类："><a href="#回归→分类：" class="headerlink" title="回归→分类："></a>回归→分类：</h2><p><img src="https://cdnjson.com/images/2023/03/27/image42108b108f54af64.png" alt="avatar"></p><h2 id="全连接层的开销："><a href="#全连接层的开销：" class="headerlink" title="全连接层的开销："></a>全连接层的开销：</h2><p><img src="https://zh-v2.d2l.ai/_images/softmaxreg.svg" alt="avatar"></p><p>像这样的二分图，对于$d$个输入和$q$个输出:</p><p>原本：参数开销$O(dq)$，这实在是太高了！</p><p>优化：$O(\frac{dq}{n})$，$n$为超参数，可以灵活指定，用以平衡<strong>参数节约</strong>和<strong>模型有效性</strong>。</p><h2 id="交叉熵损失："><a href="#交叉熵损失：" class="headerlink" title="交叉熵损失："></a>交叉熵损失：</h2><p>交叉熵，衡量2个概率的区别，原始公式如下：</p><p>$H(p, q) &#x3D; \Sigma_i-p_ilog(q_i)$</p><p>以此作为损失，有损失函数：</p><p>$l(y, \hat{y})&#x3D;-\Sigma_iy_ilog\hat{y_i}&#x3D;-log\hat{y_y}$</p><p>其梯度是<strong>真实概率和预测概率的区别</strong>：</p><p>$\sigma_{o_i}l(y, \hat{y})&#x3D;softmax(o)_i-y_i$（o是置信度）</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h1&gt;&lt;p&gt;本篇内容记录笔者学习深度学习的学习过程，如果你有任何想询问的问题，欢迎在以下任何平台提问！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="AI" scheme="https://conqueror712.github.io/categories/AI/"/>
    
    
  </entry>
  
  <entry>
    <title>Neo4J - Ep1丨学习记录</title>
    <link href="https://conqueror712.github.io/post/Neo4J.html"/>
    <id>https://conqueror712.github.io/post/Neo4J.html</id>
    <published>2023-03-25T06:47:09.000Z</published>
    <updated>2023-03-25T11:09:21.746Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><blockquote><p>Abstract：本文的主要内容是<strong>图数据库的入门</strong>以及<strong>Neo4j的基础知识</strong>。</p></blockquote><p>笔者近日在学习有关知识图谱Knowledge Graph的相关内容。</p><p>Neo4j是项目所需的一款功能强大的应用，特此来学习之，并记录于本文。</p><p>笔者是AI领域的小白，作为初学者，文章中难免会有出错或者不恰当的部分，烦请读者朋友们指出（在以下任意平台）。</p><blockquote><p>个人博客：<a href="https://conqueror712.github.io/">https://conqueror712.github.io/</a></p><p>知乎：<a href="https://www.zhihu.com/people/soeur712/posts">https://www.zhihu.com/people/soeur712/posts</a></p><p>Bilibili：<a href="https://space.bilibili.com/57089326">https://space.bilibili.com/57089326</a></p><p>掘金：<a href="https://juejin.cn/user/1297878069809725/posts">https://juejin.cn/user/1297878069809725/posts</a></p></blockquote><p>还有要说明的是，笔者此前的文章存在一个问题是，篇幅过长，</p><p>这不仅导致读者不愿意看，就连笔者自己再次翻阅的时候都只能利用<code>Ctrl+F</code>才能找到我要找的内容。</p><p>故拆分之，便于阅读和查看，每篇文章控制在<code>1.5k~3.5k</code>字之间。</p><p><strong>注意：本文不是教程，只是个人学习的记录和心得，可能会对你有帮助，建议配合官方文档一起学习！</strong></p><p>官方文档链接：<a href="https://graphacademy.neo4j.com/courses/neo4j-fundamentals/">https://graphacademy.neo4j.com/courses/neo4j-fundamentals/</a></p><hr><h1 id="Neo4j-AuraDB入门："><a href="#Neo4j-AuraDB入门：" class="headerlink" title="Neo4j - AuraDB入门："></a>Neo4j - AuraDB入门：</h1><blockquote><p>入门部分会有五个板块：</p><ol><li>Create a database</li><li>View online courses</li><li>Start console tour</li><li>Open Sample Guide</li><li>More resources</li></ol></blockquote><p>首先进入网址：<a href="https://console.neo4j.io/?product=aura-db#create-database/free">https://console.neo4j.io/?product=aura-db#create-database/free</a></p><p>我们就暂时用免费版来学习，点击Start Here，随后会生成一个随机的初始密码，就像这样：</p><img src="https://cdnjson.com/images/2023/03/25/image7ad4ea336942c883.png" alt="avatar" style="zoom:67%;" /><blockquote><p>随后我们会修改这个密码，这实在是太难记了！</p></blockquote><img src="https://cdnjson.com/images/2023/03/25/imagea399953d4c3854ba.png" alt="avatar" style="zoom: 67%;" /><blockquote><p>可以看到，我们已经创建成功了，它在欢迎我们呢！</p><p>到此为止，都非常顺利，不过我们马上就遇到了第一个难题：他居然推荐我们先学四个课程再来玩这个，</p></blockquote><img src="https://cdnjson.com/images/2023/03/25/image9a1551da7ded5ee0.png" alt="avatar" style="zoom: 67%;" /><blockquote><p>那好吧，作为优秀的新时代新青年，我们秉承磨刀不误砍柴工的精神，先去学一下这些课程。</p><p>官方告诉我们，这四门课程总共需要6个小时才能学完，</p><p>不要紧，俗话说的好，慢慢来才比较快，接下来我们就进入课程的学习吧。</p></blockquote><p>（已经学完了或者认为自己不需要学的读者可以直接跳到下一部分）</p><hr><h1 id="Neo4j-基础知识："><a href="#Neo4j-基础知识：" class="headerlink" title="Neo4j - 基础知识："></a>Neo4j - 基础知识：</h1><p>这些课程都有官方的中文版教程，有能力的读者可以自行前往阅读，</p><p>这里笔者给出自己的学习过程，以及一些在学习过程中的见解。</p><p>注意：与官方文档中重复的部分就不予记录了，查阅即可！</p><p>（文档链接还是最上面的链接，大家Start Here之后就有了）</p><h2 id="以图的方式去思考"><a href="#以图的方式去思考" class="headerlink" title="以图的方式去思考"></a>以图的方式去思考</h2><h3 id="关于概念："><a href="#关于概念：" class="headerlink" title="关于概念："></a>关于概念：</h3><p>七桥问题→图论的诞生：节点 + 边</p><p>现在看来，图是一种非常有用的工具，可以帮我们<strong>建模和分析数据</strong>，广泛应用于解决复杂问题上，包括<strong>路线查找、供应链分析和实时推荐</strong>。</p><blockquote><p>学到这里，你会发现这个网站的教程居然还有课堂小测！这真是太良心了，感动哭了</p></blockquote><p>在知识图谱中，我们经常听到”对象”，”实体”这样的名词，事实上，这都是”节点”的别名，它可以代表任何你想代表的<strong>事物</strong>。</p><p>而”关系”，也就是”边”，通常是<strong>动词</strong>。</p><p>关系是图数据库中最重要的元素。</p><hr><h3 id="关于图的遍历："><a href="#关于图的遍历：" class="headerlink" title="关于图的遍历："></a>关于图的遍历：</h3><p><code>Neo4j</code>的<code>Cypher</code>语言针对节点遍历进行了优化，因此<strong>边不会被多次遍历</strong>，这对应用程序来说是一个巨大的<strong>性能提升</strong>。</p><hr><h3 id="Graphs-are-Everywhere："><a href="#Graphs-are-Everywhere：" class="headerlink" title="Graphs are Everywhere："></a>Graphs are Everywhere：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MATCH (c:Category)-[:HAS_CHILD|HAS_PRODUCT*1..3]-&gt;(p:Product)</span><br><span class="line">RETURN p.id, p.title, collect(c.name) AS categories</span><br></pre></td></tr></table></figure><p>解释：</p><ol><li>查找距离类别节点最多三个关系远的产品节点</li><li>查询匹配到的产品节点的id和title属性，同时返回一个集合categories，其中包含了这些产品所属的所有类别的名称。</li></ol><p>为什么推荐算法中常用图数据库？</p><p>因为图数据库的优势在于，需要<strong>遍历更小比例的图就能生成推荐</strong>。 </p><p>你可以简单地从一个产品节点遍历购买该产品的用户，然后再遍历他们购买的后续产品。</p><p>不仅如此，图和图数据库还可以用到方方面面，Neo4j Graphgist站点有许多示例数据模型。</p><hr><h2 id="属性图"><a href="#属性图" class="headerlink" title="属性图"></a>属性图</h2><blockquote><p>哦！我们大概终于是遇到了一个新的概念——属性图。</p></blockquote><p>我们可以使用两个额外的元素来为数据提供一些<strong>附加的上下文</strong>。</p><h3 id="什么是属性图"><a href="#什么是属性图" class="headerlink" title="什么是属性图"></a>什么是属性图</h3><h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><p>只需要一张图就可以解释清楚，这也是官方文档中给出的图：</p><blockquote><p>看！那些黑框框里面的<strong>零个、一个或多个</strong>词就是标签。</p></blockquote><img src="https://cdnjson.com/images/2023/03/25/imageb82978e7e936b587.png" alt="avatar" style="zoom: 33%;" /><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><blockquote><p>同样给出一张图，不过这可能就得多说两句了，</p></blockquote><p>为节点添加属性，可以使其<strong>具体化</strong>。</p><p>属性是<strong>键值对</strong>的形式。</p><p>不需要为具有特定标签的每个节点都指定属性。 如果节点的属性不存在，则将其视为 <code>null</code>。</p><img src="https://cdnjson.com/images/2023/03/25/image3eafeaa374eb730c.png" alt="avatar" style="zoom: 33%;" /><h4 id="边的类型和属性以及方向"><a href="#边的类型和属性以及方向" class="headerlink" title="边的类型和属性以及方向"></a>边的类型和属性以及方向</h4><p>不仅是点，边（关系）也是有标签和属性的，只不过把”标签”换成了”类型”。</p><p>并且和点不同的是，Neo4j的<strong>每个关系必须有一个类型</strong>，</p><p>这不仅<strong>完善了图的含义</strong>，还便于我们对图进行<strong>部分遍历</strong>。</p><blockquote><p>什么是部分遍历呢？就比如说我们只关心谁在哪工作，不关心谁和谁结婚。</p></blockquote><p>当然，如果是这样的话我们可能需要进行多源遍历，这需要看情况。</p><p>对于关系的属性，这些可以指加权图中的<strong>权值</strong>，或者只是为关系<strong>提供额外的上下文</strong>。</p><img src="https://cdnjson.com/images/2023/03/25/image7b7b24b869445a4f.png" alt="avatar" style="zoom: 33%;" /><p>除此之外，在Neo4j中，图的每个关系<strong>必须</strong>有方向。</p><p>不过，尽管方向是必需的，但可以在任一方向查询关系，或在查询时完全忽略。</p><hr><h3 id="原生图的优势"><a href="#原生图的优势" class="headerlink" title="原生图的优势"></a>原生图的优势</h3><blockquote><p>接下来的内容可能有点陌生了，至少对于笔者这样的新手来说是这样的，</p><p>理解和学习可能会花费更多的时间，</p><p>不过没关系，让我们继续吧！</p></blockquote><p>Neo4j是一个原生图数据库，这意味着从数据存储到查询语言的所有内容都是<strong>专门为遍历而设计的</strong>。</p><p>Neo4j符合<strong>ACID</strong>标准——事务中的一组修改将全部提交或失败。</p><h4 id="无索引邻接IFA"><a href="#无索引邻接IFA" class="headerlink" title="无索引邻接IFA"></a>无索引邻接IFA</h4><p>提交数据库事务时，对<strong>关系的引用</strong>与<strong>关系开始和结束处的节点</strong>一起存储。 </p><p>由于每个节点都知道与其连接的每个传入和传出关系，底层图引擎将简单地<strong>查询内存中的指针</strong>——这是计算机非常擅长的。</p><p>查询过程：</p><ol><li>根据指定的锚点计划查询</li><li>使用索引来检索锚节点</li><li>按照指针检索所需的结果节点</li></ol><p>与关系数据库访问相比，IFA 的好处是：</p><ul><li>更少的<strong>索引查找</strong></li><li>没有<strong>表扫描</strong></li><li>减少<strong>数据重复</strong></li></ul><p>还是不好理解？没关系，以下这个例子会帮助到你！</p><blockquote><p>假设你要规划一次旅行，并且需要找到一个好的餐厅去享受美食。</p><p>你可能会在互联网上搜索各种餐厅的信息，并且想了解它们的菜单、位置、评价等信息。</p><p>如果这些信息存储在一个关系型数据库中，那么你可能需要<strong>进行多个查询</strong>来获取所有信息。</p><p>例如，你可能需要先查询餐厅表格，然后再查询菜单表格和评论表格，最后将这些信息整合起来以得出你需要的信息。这种查询方式需要多次查询和连接多个表格，因此查询速度可能会比较慢。</p><p>相比之下，如果这些信息存储在一个图数据库中，那么你只需要进行一个查询，就能够得到所有相关的信息。</p><p>图数据库使用图的方式来存储数据，其中节点表示实体，边表示实体之间的关系。</p><p>例如，在图数据库中，你可以使用<strong>一个节点表示餐厅，另一个节点表示菜单，使用一条边表示餐厅和菜单之间的关系。</strong>这种查询方式只需要一次查询和一次遍历，因此查询速度会比较快！</p></blockquote><h3 id="从其他数据库到图数据库"><a href="#从其他数据库到图数据库" class="headerlink" title="从其他数据库到图数据库"></a>从其他数据库到图数据库</h3><p>随着关系数据库中记录数的增加，查询变得<strong>越来越慢</strong>。 </p><p>图数据库中的查询时间将<strong>与查询期间实际触及的数据大小保持一致</strong>。</p><p>将关系视为<strong>一等公民</strong>也可以在开始时提供优势。 </p><p>在<strong>图中建模关系</strong>比创建<strong>数据透视表</strong>来表示<strong>多对多</strong>关系更<strong>自然</strong>。</p><p>也就是说，总结起来就是一句话：</p><blockquote><p>可以将关系模型实现为图模型，这样对于理解起来会更方便！</p></blockquote><p>除此之外，<strong>键值存储</strong>和<strong>文档存储</strong>也是可以实现用图来提高性能的存储方式。</p><hr><h2 id="你的第一个图"><a href="#你的第一个图" class="headerlink" title="你的第一个图"></a>你的第一个图</h2><h3 id="电影图数据"><a href="#电影图数据" class="headerlink" title="电影图数据"></a>电影图数据</h3><p>这部分内容是一个图数据库的例子，帮助理解上述知识，</p><p>这里放一张图，以示实际应用中的图数据库是什么样子的：</p><img src="https://cdnjson.com/images/2023/03/25/image310d0d810246e431.png" alt="avatar" style="zoom: 67%;" /><p>具体的内容就不展开了，大家可以自行前往查看。</p><blockquote><p>可能有的读者会大失所望，还以为是要开始创建第一个项目了呢！</p><p>先别着急，还记得一开始官方教程中告诉我们的吗？这刚刚是第一个基础，还有三个基础等着我们呢！</p><p>先让我们庆祝一下，我们已经完成了第一部分的学习！</p></blockquote><img src="https://cdnjson.com/images/2023/03/25/imageb3709901b8436875.png" alt="avatar" style="zoom: 67%;" /><blockquote><p>甚至给我颁发了一个证书 XD</p></blockquote><img src="https://cdnjson.com/images/2023/03/25/image48542dc349b9f728.png" alt="avatar" style="zoom:50%;" /><hr><p>Thanks for reading and see you next time!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Abstract：本文的主要内容是&lt;strong&gt;图数据库的入门&lt;/strong&gt;以及&lt;strong&gt;Ne</summary>
      
    
    
    
    <category term="AI" scheme="https://conqueror712.github.io/categories/AI/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机网络 - 中丨学习记录</title>
    <link href="https://conqueror712.github.io/post/Computer-Network-2.html"/>
    <id>https://conqueror712.github.io/post/Computer-Network-2.html</id>
    <published>2023-03-20T02:58:59.000Z</published>
    <updated>2023-03-25T06:53:57.951Z</updated>
    
    <content type="html"><![CDATA[<p><em>Computer Networking A Top-Down Approach Learning Note Part 2</em></p><p><strong>前言的前言</strong>：</p><p>本文是笔者初学计算机网络的笔记和一些心得，难免会有部分疏漏和错误，还请各位读者积极指出，不吝赐教。</p><p>有一些内容是笔者认为对自己暂时没那么重要的部分，就没有放上去，具体的内容可以查看相关的书籍。</p><p>还有要补充的就是，计算机网络的学习记录将会分为上中下三部分，</p><p>这一部分，也就是中，主要是涵盖了《自顶向下计算机网络》的第二章到第？章的内容。</p><p>事不宜迟，我们开始吧！</p><blockquote><p>个人博客：<a href="https://conqueror712.github.io/">https://conqueror712.github.io/</a></p><p>知乎：<a href="https://www.zhihu.com/people/soeur712/posts">https://www.zhihu.com/people/soeur712/posts</a></p><p>Bilibili：<a href="https://space.bilibili.com/57089326">https://space.bilibili.com/57089326</a></p><p>掘金：<a href="https://juejin.cn/user/1297878069809725/posts">https://juejin.cn/user/1297878069809725/posts</a></p></blockquote><hr><h1 id="Unit-2-应用层"><a href="#Unit-2-应用层" class="headerlink" title="Unit 2 应用层"></a>Unit 2 应用层</h1><h2 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h2><p>网络核心中没有应用层软件</p><p>想法 → 网络应用</p><p>研发网络应用程序的核心：写出能够运行在不同的端系统和通过网络彼此通信的程序。</p><h3 id="网络-x2F-应用程序体系结构"><a href="#网络-x2F-应用程序体系结构" class="headerlink" title="网络&#x2F;应用程序体系结构"></a>网络&#x2F;应用程序体系结构</h3><p>Network architecture and applicaiton architecture are both the “design and structure”.</p><h4 id="常见的网络体系结构："><a href="#常见的网络体系结构：" class="headerlink" title="常见的网络体系结构："></a>常见的网络体系结构：</h4><ul><li>客户 - 服务器模式 <code>C - S</code><ul><li>服务器：<ul><li>一直运行</li><li><strong>固定的IP地址</strong>和周知的端口号，不像DHCP获取的动态IP</li><li>扩展性：服务器农场</li></ul></li><li>客户端：<ul><li>主动与服务器通信</li><li>与互联网有间歇性的连接</li><li>可能是<strong>动态IP地址</strong></li><li>不直接与其他客户端通信</li></ul></li></ul></li><li>对等模式 <code>P2P</code><ul><li>几乎没有一直运行的服务器<ul><li>任意端系统之间可以进行通信</li></ul></li><li>每一个节点既是客户端又是服务器<ul><li><strong>自扩展性</strong>：新的peer节点带来新的服务能力和新的服务请求</li></ul></li><li>参与的主机间歇性连接且可以改变IP地址</li><li>例如：迅雷</li></ul></li><li>混合体<ul><li>Napster<ul><li>文件搜索：集中</li><li>文件传输：P2P</li></ul></li><li>即时通信<ul><li>在线检测：集中</li><li>两个用户之间聊天：P2P</li></ul></li></ul></li></ul><h4 id="常见的应用程序体系结构："><a href="#常见的应用程序体系结构：" class="headerlink" title="常见的应用程序体系结构："></a>常见的应用程序体系结构：</h4><ul><li><p>分层体系结构（Layered Architecture）：</p><p>  应用程序被划分为多个层次，每个层次负责不同的功能。例如，MVC（Model-View-Controller）框架就是一种分层体系结构。</p></li><li><p>事件驱动体系结构（Event-Driven Architecture）：</p><p>  应用程序通过事件的方式进行通信和交互。事件可以是用户的操作、消息的到达、计时器的触发等等。例如，GUI（Graphical User Interface）应用程序就是一种事件驱动体系结构。</p></li><li><p>微服务体系结构（Microservices Architecture）：</p><p>  应用程序被划分为多个小型的、相互独立的服务。每个服务可以独立地开发、部署和扩展，从而提高应用程序的灵活性和可维护性。</p></li><li><p>基于消息的体系结构（Message-Based Architecture）：</p><p>  应用程序通过消息进行通信和交互。消息可以是文本、XML、JSON等格式的数据。例如，企业消息总线（Enterprise Service Bus）就是一种基于消息的体系结构。</p></li><li><p>一体式体系结构（All-in-one architecture），etc.</p></li></ul><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>如何通信？</p><p>进程(process)与进程在相同的端系统上以进程间的通信机制互相通信，这个规则由操作系统决定。</p><p>而我们的重点是：两个<strong>不同的端系统</strong>之间是如何进行通信的——**交换报文(message)**。</p><ul><li>使用OS提供的通信服务</li><li>按照应用协议交换报文</li></ul><p>关于进程：</p><ul><li>客户端进程：发起通信的进程</li><li>服务端进程：等待连接的进程</li></ul><p>（P2P架构的应用也有客户端进程和服务端进程之分）</p><p>除此之外，分布式进程通信需要解决的问题如下：</p><ol><li>对进程进行编址（addressing）</li><li>传输层提供的服务：需要穿过层间的信息 + 层间信息的代表</li></ol><h3 id="TCP-socket"><a href="#TCP-socket" class="headerlink" title="TCP socket"></a>TCP socket</h3><p>为什么要有TCP socket?</p><p>不同的端口号对应了不同的协议 不同的进程，便于进行进程的寻址。</p><p>16bit的端口号 65536个状态</p><p>如果Socket API 每次传输报文，都携带如此多的信息，太繁琐易错，不便于管理</p><p>用个<strong>代号</strong>标示通信的双方或者单方：socket</p><p>就像OS打开文件返回的句柄一样</p><p>TCP socket:</p><ul><li>TCP服务，两个进程之间的通信需要之前要建立连接<ul><li>两个进程通信会持续一段时间，通信关系稳定</li></ul></li><li>可以用一个整数表示两个应用实体之间的通信关系 ，本地标示，类似Hash</li><li>穿过层间接口的信息量最小</li></ul><p>对于使用面向连接服务（TCP）的应用而言，套接字是4元组的一个具有本地意义的标示。</p><ul><li>四元组：源IP，源port，目标IP，目标port</li><li>唯一的指定了一个会话（2个进程之间的会话关系）</li><li>应用使用这个 ，与远程的应用进程通信</li><li>不必在每一个报文的发送都要指定这4元组</li><li>就像使用操作系统打开一个文件，OS返回一个文件句柄一样，以后使用这个文件句柄，而不是使用这个文件的目录名、文件名</li><li>简单，便于管理</li></ul><img src="https://pic1.zhimg.com/v2-8302577e2963b8a605e72234f25d6082_1440w.jpg?source=172ae18b" alt="avatar" style="zoom:80%;" /><h3 id="UDP-socket"><a href="#UDP-socket" class="headerlink" title="UDP socket"></a>UDP socket</h3><ul><li>UDP服务，两个进程之间的通信需要之前无需建立连接<ul><li>每个报文都是独立传输的</li><li>前后报文可能给不同的分布式进程</li></ul></li><li>因此，只能用一个整数表示本应用实体的标示<ul><li>因为这个报文可能传给另外一个分布式进程</li></ul></li><li>穿过层间接口的信息大小最小</li><li>UDP socket：本IP,本端口</li><li>但是传输报文时：必须要提供对方IP，port<ul><li>接收报文时： 传输层需要上传对方的IP，port</li></ul></li></ul><p>对于使用无连接服务（UDP）的应用而言，套接字是2元组的一个具有本地意义的标示</p><ul><li>2元组：IP，port（源端指定）</li><li>UDP套接字指定了应用所在的一个端节点（end point）</li><li>在发送数据报时，采用创建好的本地套接字（标示ID），就不必在发送每个报文中指明自己所采用的ip和port</li><li>但是在发送报文时，必须要指定对方的ip和udpport(另外一个段节点)</li></ul><p>进程向套接字发送报文或从套接字接收报文</p><h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><p>如何使用传输层提供的服务实现应用?</p><ul><li>定义应用层协议：报文格式，解释，时序等</li><li>编制程序，通过API调用网络基础设施提供通信服务传报文，解析报文，实现应用时序等</li></ul><p>应用层协议是什么？</p><p><strong>定义了</strong>：运行在不同端系统上 的应用<strong>如何相互交换报文</strong></p><p>应用协议仅仅是应用的一个组成部分</p><p>除此之外，还分成公开协议和专有协议</p><p>如何描述传输层的服务？</p><ul><li>数据丢失率</li><li>延时</li><li>吞吐</li><li>安全性</li></ul><h3 id="Internet-传输层提供的服务"><a href="#Internet-传输层提供的服务" class="headerlink" title="Internet 传输层提供的服务"></a>Internet 传输层提供的服务</h3><h4 id="TCP服务"><a href="#TCP服务" class="headerlink" title="TCP服务"></a>TCP服务</h4><ul><li>可靠的传输服务</li><li>流量控制：发送方不会淹没接收方</li><li>拥塞控制：当网络出现拥塞时，能抑制发送方</li><li>不能提供的服务：时间保证、最小吞吐量保证，安全</li><li>面向连接：要求在客户端进程和服务器进程之间建立连接</li></ul><h4 id="UDP服务"><a href="#UDP服务" class="headerlink" title="UDP服务"></a>UDP服务</h4><ul><li>不可靠数据传输</li><li>不提供的服务：可靠，流量控制，拥塞控制，时序，贷款保证，建立连接</li></ul><h4 id="UDP的存在有其必要性"><a href="#UDP的存在有其必要性" class="headerlink" title="UDP的存在有其必要性"></a>UDP的存在有其必要性</h4><ul><li>能够<strong>区分不同的进程</strong>，而IP服务不能<ul><li>在IP提供的主机到主机端到端功能的基础上，区分了主机的应用进程</li></ul></li><li><strong>无需建立连接</strong>，省去了建立连接时间，适合事务性应用</li><li><strong>不做可靠性的工作</strong>，例如检错重发，适合那些对实时性要求比较高而对正确性要求不高的应用</li><li>没有拥塞控制和流量控制，<strong>应用能够按照设定的速度发送数据</strong></li></ul><p><img src="https://cdnjson.com/images/2023/03/20/image.png" alt="avatar"></p><h4 id="安全TCP——SSL"><a href="#安全TCP——SSL" class="headerlink" title="安全TCP——SSL"></a>安全TCP——SSL</h4><p>原本的TCP和UDP，都是没有加密的，甚至于密码都是明文传输；</p><p>引入SSL，<strong>在TCP上面实现</strong>，提供加密的TCP连接；</p><ul><li>私密性</li><li>数据完整性</li><li>端到端的鉴别</li></ul><p><strong>SSL在应用层</strong>，应用采用SSL库，而SSL库使用传输层的TCP进行通信；</p><p>应用通过API将明文交给socket，SSL将其加密并在互联网上传输，详见Unit8。</p><blockquote><p>SSL是<strong>Secure Sockets Layer安全套接字层</strong>的缩写，是一系列<strong>加密技术</strong>，允许Web用户保护他们通过Internet传输的信息的<strong>隐私</strong>。</p><p>当您访问安全网站时，您会在 URL 旁边看到一个锁，表示您与该网站的通信<strong>已加密</strong>。</p><p><img src="https://s2.loli.net/2023/01/29/6mWG8plUqKEt2O1.png" alt="avatar"></p><p>该锁应该表明<strong>第三方将无法读取您发送或接收的任何信息</strong>。在后台，SSL通过将您的数据转换为只有收件人知道如何破译的编码消息来实现这一点。如果恶意方正在监听对话，它只会看到看似随机的字符串，而不会看到您的电子邮件、Facebook 帖子、信用卡号或其他私人信息的内容。</p></blockquote><h4 id="TCP三次握手四次挥手"><a href="#TCP三次握手四次挥手" class="headerlink" title="TCP三次握手四次挥手"></a>TCP三次握手四次挥手</h4><p>为了保证客户端和服务器端的可靠连接，TCP建立连接时<strong>必须</strong>要进行三次会话，也叫TCP三次握手，</p><p>进行三次握手的目的是为了<strong>确认双方的接收能力和发送能力是否正常</strong>。</p><img src="https://cdnjson.com/images/2023/03/21/image1ce75f8803f2d480.png" alt="avatar" style="zoom:80%;" /><blockquote><p>最开始的时候客户端和服务器都是处于CLOSED关闭状态。主动打开连接的为客户端，被动打开连接的是服务器。</p><p>TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了 <strong>LISTEN 监听状态</strong></p><p>第一次握手 TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN&#x3D;1，同时选择一个初始序列号 seq&#x3D;x ，此时，TCP客户端进程进入了 <strong>SYN-SENT 同步已发送状态</strong></p><p>第二次握手 TCP服务器收到请求报文后，如果同意连接，则会向客户端发出确认报文。确认报文中应该 ACK&#x3D;1，SYN&#x3D;1，确认号是ack&#x3D;x+1，同时也要为自己初始化一个序列号 seq&#x3D;y，此时，TCP服务器进程进入了 <strong>SYN-RCVD 同步收到状态</strong></p><p>第三次握手 TCP客户端收到确认后，还要向服务器给出确认。确认报文的ACK&#x3D;1，ack&#x3D;y+1，自己的序列号seq&#x3D;x+1，此时，TCP连接建立，客户端进入<strong>ESTABLISHED已建立连接状态</strong> 触发三次握手</p><p>有人可能会很疑惑为什么要进行第三次握手？<br>主要原因：<strong>防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误</strong></p><p><strong>第一次握手： 客户端向服务器端发送报文</strong><br>        证明客户端的发送能力正常<br><strong>第二次握手：服务器端接收到报文并向客户端发送报文</strong><br>        证明服务器端的接收能力、发送能力正常<br><strong>第三次握手：客户端向服务器发送报文</strong><br>        证明客户端的接收能力正常</p></blockquote><img src="https://cdnjson.com/images/2023/03/21/image24fec85472fe6e50.png" alt="avatar" style="zoom:80%;" /><blockquote><p>数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于<strong>ESTABLISHED</strong>状态，然后客户端主动关闭，服务器被动关闭。</p><p>第一次挥手 客户端发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN&#x3D;1，其序列号为seq&#x3D;u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入<strong>FIN-WAIT-1（终止等待1）</strong>状态</p><p>第二次挥手 服务器端接收到连接释放报文后，发出确认报文，ACK&#x3D;1，ack&#x3D;u+1，并且带上自己的序列号seq&#x3D;v，此时，服务端就进入了CLOSE-WAIT 关闭等待状态</p><p>第三次挥手 客户端接收到服务器端的确认请求后，客户端就会进入<strong>FIN-WAIT-2（终止等待2）</strong>状态，等待服务器发送连接释放报文，服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</p><p>第四次挥手 客户端收到服务器的连接释放报文后，必须发出确认，ACK&#x3D;1，ack&#x3D;w+1，而自己的序列号是seq&#x3D;u+1，此时，客户端就进入了<strong>TIME-WAIT（时间等待）</strong>状态，但此时TCP连接还未终止，必须要经过2MSL后（最长报文寿命），当客户端撤销相应的TCB后，客户端才会进入CLOSED关闭状态，服务器端接收到确认报文后，会立即进入CLOSED关闭状态，到这里TCP连接就断开了，四次挥手完成</p><p>为什么客户端要等待2MSL？<br>主要原因是为了保证客户端发送那个的第一个ACK报文能到服务器，因为这个ACK报文可能丢失，并且2MSL是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃，这样<strong>新的连接中不会出现旧连接的请求报文</strong>。</p></blockquote><hr><h2 id="Web-amp-HTTP"><a href="#Web-amp-HTTP" class="headerlink" title="Web &amp; HTTP"></a>Web &amp; HTTP</h2><h3 id="Web概述"><a href="#Web概述" class="headerlink" title="Web概述"></a>Web概述</h3><p>由一些<strong>对象</strong>组成，有哪些对象？</p><ul><li>HTML文件、JPEG图像、Java小程序、音视频文件etc.</li></ul><p>Web页含有一个<strong>基本的HTML文件</strong>，该基本HTML文件又包含若干对象的引用（链接）；</p><p>对象如何引用？</p><ul><li>通过URL对每个对象进行引用，URL包括访问协议，用户名，口令字，端口，目录文件等；</li></ul><p><img src="https://cdnjson.com/images/2023/03/20/image3119aaf482192bea.png" alt="avatar"></p><h3 id="HTTP概述"><a href="#HTTP概述" class="headerlink" title="HTTP概述"></a>HTTP概述</h3><p><strong>一句话解释</strong>：HTTP 是用于获取 HTML 文档等资源的<strong>协议</strong>——我们称之为<strong>超文本传输协议</strong>。</p><p>它是 Web 上任何数据交换的基础，在<strong>应用层</strong>上，是一种<strong>客户端-服务器协议</strong>，</p><p>这意味着请求由接收者（通常是 Web 浏览器）发起。</p><p>从获取的不同子文档（例如文本、布局描述、图像、视频、脚本等）重建完整的文档。</p><p>它使用TCP，默认端口号为80；</p><p>（HTTPS使用了SSL，默认端口号为443）</p><ul><li>具体过程为：客户发起一个与服务器的TCP连接（建立socket），服务器接受连接，随后在浏览器和Web服务器之间交换HTTP报文，最后TCP连接关闭。</li></ul><p><img src="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview/fetching_a_page.png" alt="avatar"></p><p>客户端和服务器通过交换单个消息（而不是数据流）进行通信。 </p><ul><li>客户端（通常是 Web 浏览器）发送的消息称为<strong>请求</strong>；</li><li>服务器作为应答发送的消息称为<strong>响应</strong>。</li></ul><p><strong>协议</strong>是定义如何在计算机内部或计算机之间交换数据的规则系统。设备之间的通信要求设备就正在交换的数据的格式达成一致。</p><p>定义格式的规则集称为协议。</p><p><img src="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview/http-layers.png" alt="avatar"></p><hr><h3 id="基于HTTP的系统组件"><a href="#基于HTTP的系统组件" class="headerlink" title="基于HTTP的系统组件"></a>基于HTTP的系统组件</h3><p>HTTP是一种<strong>客户端-服务器协议</strong>：请求由一个实体发送，即用户代理（或代表它的代理）。 大多数情况下，用户代理是一个Web浏览器，但它可以是任何东西。</p><p>每个单独的请求都发送到服务器，服务器处理它并提供称为<strong>响应</strong>的答案。</p><p>在客户端和服务器之间有许多实体，统称为<strong>代理Proxy</strong>，例如，它们执行不同的操作并充当网关or<strong>缓存Cache</strong>。</p><p>实际上，浏览器和处理请求的服务器之间有更多的计算机：有路由器、调制解调器等。 由于Web的分层设计，这些隐藏在网络和传输层中。 HTTP位于应用程序层的<strong>顶部</strong>。 虽然对于诊断网络问题很重要，但底层大多与 HTTP 的描述无关。</p><p><img src="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview/client-server-chain.png" alt="avatar"></p><h4 id="Proxy："><a href="#Proxy：" class="headerlink" title="Proxy："></a>Proxy：</h4><p><strong>代理服务器</strong>是在互联网的不同网络中导航时使用的<strong>中间程序或计算机</strong>。它们<strong>有助于访问万维网上的内容</strong>。</p><p>代理拦截请求并提供回响应；它可以转发或不转发请求（例如在缓存的情况下），并且可以修改请求（例如，在两个网络之间的边界处更改其标头）。</p><p>代理可以位于用户的本地计算机上，也可以位于用户计算机和 Internet 上的目标服务器之间的任何位置。通常有两种主要类型的代理服务器：由于 Web 堆栈的分层结构，其中大多数在传输、网络或物理级别运行，在 HTTP 层变得透明，并可能对性能产生重大影响。</p><ul><li>处理来自和发送到互联网上任何位置的请求的<strong>转发代理</strong>。</li><li>一种<strong>反向代理</strong>，从 Internet 接收请求并将其转发到内部网络中的服务器。</li></ul><p>代理的<strong>功能</strong>：</p><ul><li>缓存（缓存可以是公共的或私有的，就像浏览器缓存一样）</li><li>过滤（如防病毒扫描或家长控制）</li><li>负载平衡（允许多个服务器为不同的请求提供服务）</li><li>身份验证（控制对不同资源的访问）</li><li>日志记录（允许存储历史信息）</li></ul><h4 id="Cache："><a href="#Cache：" class="headerlink" title="Cache："></a>Cache：</h4><p><strong>缓存</strong>（Web 缓存或 HTTP 缓存）是临时存储 HTTP 响应的组件，以便只要满足某些条件，就可以将其用于后续 HTTP 请求。</p><p><strong>Web缓存</strong>（代理服务器）：</p><img src="https://cdnjson.com/images/2023/03/20/image28c57533d28138e0.png" alt="avatar" style="zoom:67%;" /><ul><li>缓存既是客户端又是服务器</li><li>通常缓存是由ISP安装 (大学、公司、居民区ISP)</li></ul><img src="https://cdnjson.com/images/2023/03/20/image526f313d27cbed65.png" alt="avatar" style="zoom: 67%;" /><img src="https://cdnjson.com/images/2023/03/20/image59b4b89bf717356d.png" alt="avatar" style="zoom:67%;" /><blockquote><p>这部分会有一些计算题，题型示例如下：</p><ul><li>更快的接入链路</li><li>安装本地缓存</li></ul></blockquote><h4 id="客户端：用户代理"><a href="#客户端：用户代理" class="headerlink" title="客户端：用户代理"></a>客户端：用户代理</h4><p>用户代理是代表用户执行操作的任何工具。 </p><p>浏览器<strong>始终</strong>是发起请求的实体，它<strong>从来</strong>都不是服务器。</p><h4 id="网络服务器"><a href="#网络服务器" class="headerlink" title="网络服务器"></a>网络服务器</h4><p>通信通道的另一端是服务器，它根据客户端的请求<strong>提供文档</strong>。 服务器实际上仅显示为一台计算机；</p><p>但它实际上可能是共享负载（负载平衡）的服务器的<strong>集合</strong>，或者是询问其他计算机（如缓存、数据库服务器或电子商务服务器）的<strong>复杂软件</strong>。</p><hr><h3 id="HTTP的基本方面"><a href="#HTTP的基本方面" class="headerlink" title="HTTP的基本方面"></a>HTTP的基本方面</h3><h4 id="HTTP是可扩展的"><a href="#HTTP是可扩展的" class="headerlink" title="HTTP是可扩展的"></a>HTTP是可扩展的</h4><p>HTTP &#x2F; 1.0中引入的<code>HTTP标头</code>使该协议易于扩展和试验。 </p><p>新功能甚至可以通过客户端和服务器之间关于新标头语义的简单协议来引入。</p><h4 id="HTTP是无状态的，但不是无会话的"><a href="#HTTP是无状态的，但不是无会话的" class="headerlink" title="HTTP是无状态的，但不是无会话的"></a>HTTP是无状态的，但不是无会话的</h4><p>服务器并不维护关于客户的任何信息</p><img src="https://cdnjson.com/images/2023/03/20/image0e6c0ee3d22f034b.png" alt="avatar" style="zoom: 80%;" /><ul><li><p>无状态的：在同一连接上连续执行的两个请求之间没有链接。</p><blockquote><p>具体来说，HTTP是无状态的意味着从客户端到服务器的每个请求都被视为一个独立的事务，不知道之前的任何请求。这意味着服务器不存储客户端的会话信息，也不保留任何来自该客户端的先前请求的内存。客户端负责维护状态，如果有必要，可以在每个请求中向服务器发送信息，例如身份验证凭据或会话ID。这种设计在可扩展性和可靠性方面非常有用，因为它允许服务器独立处理每个请求，并确保在服务器出现故障时不会丢失会话数据。</p></blockquote></li><li><p>有状态会话：HTTP cookie允许使用有状态会话。 使用标头可扩展性，HTTP Cookie 将添加到工作流中，从而允许在每个 HTTP 请求上创建会话以共享相同的上下文或相同的状态。</p></li></ul><h4 id="HTTP和连接"><a href="#HTTP和连接" class="headerlink" title="HTTP和连接"></a>HTTP和连接</h4><p>连接在传输层进行控制，因此从根本上超出了 HTTP 的范围。</p><p>HTTP 不要求基础传输协议基于连接;它只要求它是可靠的，或者不丢失消息。</p><p>在互联网上最常见的两种传输协议中，TCP是可靠的，UDP不是。 因此，<strong>HTTP依赖于基于连接的TCP标准</strong>。</p><p>更进一步地，HTTP分为<strong>非持久HTTP和可持久HTTP</strong></p><img src="https://cdnjson.com/images/2023/03/20/imagefdaa0ed04498039f.png" alt="avatar" style="zoom:80%;" /><p><strong>响应时间模型</strong>：</p><p><img src="https://cdnjson.com/images/2023/03/20/image0650084f136d9f1c.png" alt="avatar"></p><p>则可以得出：</p><img src="https://cdnjson.com/images/2023/03/20/image1710c48906cf7aff.png" alt="avatar" style="zoom:80%;" /><hr><h3 id="HTTP可以控制什么"><a href="#HTTP可以控制什么" class="headerlink" title="HTTP可以控制什么?"></a>HTTP可以控制什么?</h3><blockquote><ul><li>缓存： 文档的缓存方式可以通过 HTTP 控制。 服务器可以指示代理和客户端缓存什么以及缓存多长时间。 客户端可以指示中间缓存代理忽略存储的文档。</li><li>放宽原点约束： 为了防止窥探和其他隐私侵犯，Web 浏览器强制在网站之间严格隔离。 只有来自同一来源的页面才能访问网页的所有信息。 虽然这样的约束对服务器来说是一种负担，但 HTTP 标头可以放松服务器端的这种严格分离，允许文档成为来自不同域的信息的拼凑;这样做甚至可能有与安全相关的原因。</li><li>身份验证： 某些页面可能受到保护，以便只有特定用户才能访问它们。 基本身份验证可以通过 HTTP 提供，可以使用 WWW-Authenticate 和类似的标头，也可以通过使用 HTTP cookie 设置特定会话来提供。</li><li>代理和隧道： 服务器或客户端通常位于 Intranet 上，对其他计算机隐藏其真实 IP 地址。 然后，HTTP 请求通过代理来跨越此网络屏障。 并非所有代理都是 HTTP 代理。 例如，SOCKS协议在较低级别运行。 其他协议（如 ftp）可以由这些代理处理。</li><li>会议： 使用 HTTP Cookie 允许您将请求与服务器的状态相关联。 这会创建会话，尽管基本的HTTP是无状态协议。 这不仅对电子商务购物篮有用，而且对允许用户配置输出的任何站点也很有用。</li></ul></blockquote><hr><h3 id="HTTP流"><a href="#HTTP流" class="headerlink" title="HTTP流"></a>HTTP流</h3><p>当客户端想要与服务器，也可能是中间代理通信时，它会执行以下步骤：</p><ol><li><p>打开 TCP 连接：</p><p> TCP 连接用于发送一个或多个请求并接收应答。 客户端可以打开新连接、重用现有连接或打开与服务器的多个 TCP 连接。</p></li><li><p>发送HTTP消息：</p><p> HTTP消息（在HTTP &#x2F; 2之前）是人类可读的ASCII。 使用HTTP &#x2F; 2，这些简单的消息被封装在框架中，使它们无法直接读取，但原理保持不变。</p><p> 一个例子：</p> <img src="https://cdnjson.com/images/2023/03/20/image6d271a2fc58c258e.png" alt="avatar" style="zoom:80%;" />  </li><li><p>读取服务器发送的响应</p><p> 一个例子：</p> <img src="https://cdnjson.com/images/2023/03/20/image22be64134434b9e0.png" alt="avatar" style="zoom: 80%;" />  </li><li><p>关闭或重新使用连接以处理进一步的请求</p></li></ol><hr><h3 id="HTTP消息与报文"><a href="#HTTP消息与报文" class="headerlink" title="HTTP消息与报文"></a>HTTP消息与报文</h3><p>有两种类型的 HTTP 消息：请求和响应，每种都有自己的格式。</p><h4 id="请求："><a href="#请求：" class="headerlink" title="请求："></a>请求：</h4><img src="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview/http_request.png" alt="avatar" style="zoom:80%;" /><p>更形式化地：</p><img src="https://cdnjson.com/images/2023/03/20/imageac69b0bb3a3c845a.png" alt="avatar" style="zoom:80%;" /><p>关于提交表单输入：</p><ul><li><p>URL(Uniform Resource Locator统一资源定位符)：</p><ul><li><p>一个标准的URL语法组成是下面这样的：</p><p>  <code>scheme://login:password@address:port/path_to_resource?query_string#fragment</code></p><p>  抽象一下：传输协议 + 域名或IP地址 + [端口(端口为80时可省略)] + 资源路径 + 查询字符串</p></li><li><p><strong>GET</strong>：</p><p>  GET - 通常是从指定的服务器中获取数据，查询字符串（键值对）被附加在URL地址后面一起发送到服务器，如下面这样的：<code>http://localhost:8090/api/query?id=3</code>。</p></li><li><p><strong>POST</strong>：</p><p>  POST - 通常是提交数据给指定的服务器处理，当然也可以从服务器获取数据。使用POST方法时，查询字符串或发送的数据在POST信息中单独存在，和请求URL一起发送到服务器，而不是像GET方法一样直接放在URL中。</p></li></ul></li><li><p>GET和POST的区别：</p><ul><li>从上面的例子我们可以看到，GET请求消息体（body）为空，POST请求带有消息体（请区分请求body和响应body）。</li><li>GET提交的数据会放在URL之后，以<code>?</code>分割URL和传输数据，参数之间以&amp;相连，如<code>query?name=test1&amp;id=123456</code></li><li>POST方法是把提交的数据放在HTTP包的请求body中。</li><li>GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制。</li><li>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。</li></ul></li></ul><h4 id="响应："><a href="#响应：" class="headerlink" title="响应："></a>响应：</h4><img src="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview/http_response.png" alt="avatar" style="zoom:80%;" /><p><strong>HTTP响应状态码</strong>：</p><p>位于服务器-&gt;客户端的响应报文中的首行，一些例子如下：</p><img src="https://cdnjson.com/images/2023/03/20/image24df29d653810384.png" alt="avatar" style="zoom:80%;" /><hr><h3 id="HTTP-Cookies："><a href="#HTTP-Cookies：" class="headerlink" title="HTTP - Cookies："></a>HTTP - Cookies：</h3><p>HTTP cookies就是 <strong>服务器端发送给浏览器端的一小部分数据</strong></p><p>用户-服务器状态，有四个组成部分，可以用于用户验证，购物车，推荐和用户状态等。</p><img src="https://cdnjson.com/images/2023/03/20/image25e57c65ed133283.png" alt="avatar" style="zoom:67%;" /><p>Cookies可以<strong>维护状态</strong>，How？：</p><ul><li>协议端节点：在多个事务上 ，发送端和接收端维持状态</li><li>cookies: http报文携带状态信息</li></ul><p>Cookies与隐私：</p><img src="https://cdnjson.com/images/2023/03/20/image4af0dd2b5b6bab42.png" alt="avatar" style="zoom: 67%;" /><hr><h2 id="FTP文件传输协议"><a href="#FTP文件传输协议" class="headerlink" title="FTP文件传输协议"></a>FTP文件传输协议</h2><p>第七版的自顶向下计算机网络删除了这一部分内容，有可能是因为这个技术有点老，现在用的不是很多了。</p><p>了解即可。</p><p>默认端口号：21</p><p>FTP的RFC：959</p><img src="https://cdnjson.com/images/2023/03/21/imageafdfc0d77807b783.png" alt="avatar" style="zoom: 80%;" /><h3 id="控制连接和数据连接事分开的，两个不同的端口"><a href="#控制连接和数据连接事分开的，两个不同的端口" class="headerlink" title="控制连接和数据连接事分开的，两个不同的端口"></a>控制连接和数据连接事分开的，两个不同的端口</h3><p>HTTP只用一个端口</p><img src="https://cdnjson.com/images/2023/03/21/image1759ddbc37f71cbc.png" alt="avatar" style="zoom:67%;" /><p>服务主动向客户端20号端口发起一个连接</p><ul><li>带内的传数据</li><li>带外的传控制信息和指令</li></ul><h3 id="FTP协议有状态"><a href="#FTP协议有状态" class="headerlink" title="FTP协议有状态"></a>FTP协议有状态</h3><p>服务器要维护这个状态，与HTTP不一样。</p><hr><h2 id="Email"><a href="#Email" class="headerlink" title="Email"></a>Email</h2><p>电子邮件的三个主要组成部分：</p><ul><li>用户代理（邮件阅读器）</li><li>邮件服务器</li><li>简单邮件传输协议：SMTP</li></ul><img src="https://cdnjson.com/images/2023/03/21/imagee0d2ad6dbbeb693d.png" alt="avatar" style="zoom: 80%;" /><h3 id="邮件服务器"><a href="#邮件服务器" class="headerlink" title="邮件服务器"></a>邮件服务器</h3><p><strong>管理和维护</strong>发送给用户的邮件；</p><p>输出<strong>报文队列</strong>保持待发送邮件报文；</p><h3 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h3><p>RFC 2821；</p><p>SMTP使用持久连接；</p><p>SMTP使用CRLF.CRLF决定报文的尾部；</p><p>使用TCP在客户端和服务器之间发送报文；</p><p>默认端口号为25；</p><p>使用直接传输，即从发送方服务器到接收方服务器</p><p>传输的三个阶段：</p><ul><li>握手</li><li>传输报文</li><li>关闭</li></ul><p>命令&#x2F;响应交互：（报文必须是7位ASCII码）</p><ul><li>命令：ASCII文本</li><li>响应：状态码和状态信息</li></ul><p>与HTTP的对比：</p><img src="https://cdnjson.com/images/2023/03/21/image94f864dc927fc86b.png" alt="avatar" style="zoom:67%;" /><h3 id="邮件报文格式与多媒体扩展"><a href="#邮件报文格式与多媒体扩展" class="headerlink" title="邮件报文格式与多媒体扩展"></a>邮件报文格式与多媒体扩展</h3><img src="https://cdnjson.com/images/2023/03/21/image5fdf03bceeccec09.png" alt="avatar" style="zoom: 80%;" /><p>多媒体扩展：</p><p>MIME - multimedia mail extension</p><p>RFC 2045, 2056</p><p>在报文首部用额外的行申明MIME内容类型</p><h3 id="邮件访问协议"><a href="#邮件访问协议" class="headerlink" title="邮件访问协议"></a>邮件访问协议</h3><img src="https://cdnjson.com/images/2023/03/21/image64369186f029e146.png" alt="avatar" style="zoom:80%;" /><p>与SMTP的区别：</p><ul><li><p>SMTP是<strong>传送到接收方</strong>的邮件服务器</p></li><li><p>邮件访问协议是<strong>从服务器访问邮件</strong></p><p>  具体来说：</p><ul><li>POP：邮局访问协议——用户身份确认 (代理&lt;–&gt;服务器) 并下载</li><li>IMAP：Internet邮件访问协议——更多特性但也更复杂，在服务器上处理存储的报文</li><li>HTTP：Hotmail , Yahoo! Mail等——方便</li></ul></li></ul><h3 id="关于POP3协议的更多："><a href="#关于POP3协议的更多：" class="headerlink" title="关于POP3协议的更多："></a>关于POP3协议的更多：</h3><img src="https://cdnjson.com/images/2023/03/21/image5a65dcef36501dd0.png" alt="avatar" style="zoom: 80%;" /><img src="https://cdnjson.com/images/2023/03/21/imagebbaa174f5b19e4a5.png" alt="avatar" style="zoom:80%;" /><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;em&gt;Computer Networking A Top-Down Approach Learning Note Part 2&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前言的前言&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;本文是笔者初学计算机网络的笔记和一些心得，难免会有部分疏漏</summary>
      
    
    
    
    <category term="408" scheme="https://conqueror712.github.io/categories/408/"/>
    
    
  </entry>
  
  <entry>
    <title>XCPC - Retired - Essay</title>
    <link href="https://conqueror712.github.io/post/Retired.html"/>
    <id>https://conqueror712.github.io/post/Retired.html</id>
    <published>2023-03-18T13:45:55.000Z</published>
    <updated>2023-03-20T03:27:12.857Z</updated>
    
    <content type="html"><![CDATA[<img src="https://cdnjson.com/images/2023/03/18/LMFMCSZDLFXRTSDBO.jpg" alt="avatar" style="zoom: 25%;" /><blockquote><p><em>最后的气球</em></p></blockquote><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>退役啦，虽然根本称不上是什么所谓的ACMer，或者叫XCPCer，随便叫什么都可以，现在开始吧，这大约是传统。</p><hr><h2 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h2><p>曾几何时，天真的以为随便学一学就可以有好成绩，却多次面对难题望而生畏。<br>总想着时间还早，之后有状态的时候再努力努力也不迟，然而时间却再次给了我最冰冷而无情的一剑，一年的时间，说结束，也就结束了。没有变成厉害的大牛，只是从当初那个连语法错误都焦头烂额的菜鸟，变成了略知一二的自己，虽然也只是初窥门径。</p><p>强校的环境让我难以触摸参加正式比赛的门槛，但我承认这是因为自己的懒惰导致的，或许也因为没什么天赋吧，技不如人这件事，不是总有办法的。我曾多次幻想过，倘若我身处弱校，是否就有机会加入进XCPC的大家庭呢？我不得而知，或许这只是一个门外汉的望洋兴叹罢了。但转念一想，线上的公开赛不是可以参加吗？有取得好成绩吗？很可惜，答案是否定的。</p><p>谈起关于参加算法竞赛，你是否后悔这件事，显然，我是不后悔的。它充满魅力却又险象丛生。它曾让我无数次彻夜难眠，又暗地里教会了我很多，不只是算法知识而已。</p><p>时常看到别的ACMer的日常和比赛动态，我心中百感交集，我想，倘若真的有平行时空，是不是另一个世界的我，就像他们一样？<br>但在这三天打鱼两天晒网的一年里，我也从一个只会HelloWorld的小小白变成了可以几乎独立开发一个完整的项目的小白，也认识到了不同于纯净的算法世界的编程是什么样子的，即使这花费了我不少时间在上面，如果可以给自己找理由开脱的话，大概就是学了这些开发技术让我没有取得成绩吧（笑）。</p><p>说到理由，学习课内知识算一种理由吗？虽然绩点仅仅是年级的25%，但有这一点的话或许自己心里也会好受一些吧（笑）。<br>没有正式比赛经历，也没有获奖经历的退役小作文很乏味吧，不过我还是想写一写，就当做是写给自己看的了。</p><p>说来可惜，身边也没有志同道合的朋友与我同行，大一下被封在家里的那个春天有太多想要放弃的时候，黑暗的日子里只有一步一步的摸索，好几个月水平也没有任何起色，起起伏伏，跌跌撞撞。倘若当时没有我对象的鼓励，懦弱的我就提前退场了。</p><img src="https://cdnjson.com/images/2023/03/18/image.png" alt="avatar" style="zoom: 67%;" /><blockquote><p><em>那段艰难的日子和永远摆脱不了的灰名</em></p></blockquote><hr><h2 id="校赛与网友"><a href="#校赛与网友" class="headerlink" title="校赛与网友"></a>校赛与网友</h2><p>​所幸在秋天认识了一些网友，可以算是网友吧，在向他们学习的过程中明显感觉到比一人独行更强大的驱动力，很多之前不牢固的基础知识慢慢地补全，甚至第一次，也是唯一一次感受线下的团队赛，虽然是校内的选拔赛，但也给了我莫大的鼓舞和满足。接过气球的那双有些颤抖的手至今无法忘怀。</p><img src="https://cdnjson.com/images/2023/03/18/LQJRQ4OS3DJ9TN968T.jpg" alt="avatar" style="zoom: 33%;" /><blockquote><p><em>我的队伍，以及我们的气球</em></p></blockquote><p>​在此，容我向我的两位队友致歉，身为队长的我没有过硬的实力带领你们进入校队，怪我没有调出那道搜索qwq。真诚地感谢你们的支持与付出，谢谢你们给了我唯一一次这样难忘的经历，谢谢。在这一次新生赛之后看到队友夺金，我心里也算是有了个着落。加油，未来可期！</p><img src="https://cdnjson.com/images/2023/03/18/AP4ERSYPRRKCJFF6.jpg" alt="avatar" style="zoom:33%;" /><blockquote><p><em>杨亚老师给我们开颁奖仪式，好多人呀</em></p></blockquote><hr><h2 id="新生赛"><a href="#新生赛" class="headerlink" title="新生赛"></a>新生赛</h2><p>​说说这次新生赛，开局顺利地签了到，虽然还是手慢了一点，4min才写出签到，按理来说一分钟就够了的，但还是位列第七名，后面直到111分钟才过了下一个题。不过，因为最后封榜阶段开错了题目导致没有出第三题，以我的罚时（只交了3发，WA了一发），如果出了第三题那就至少是银牌了，甚至有可能冲金牌，但遗憾总是贯穿人生始终，最后10分钟才看到较为简单的题目的我已经无力回天，叹了口气写完了最后能写完的代码。结束之后，手迟迟没有从键盘上离开，我知道，属于我的算法竞赛生涯，大抵是结束了。</p><img src="https://cdnjson.com/images/2023/03/18/ELBZMK4CSBEHV0AR.jpg" alt="avatar" style="zoom:50%;" /><blockquote><p><em>赛后，学校为我们准备的好吃的，奶茶好甜，甜到发苦…</em></p></blockquote><img src="https://cdnjson.com/images/2023/03/18/VP8G7AJPXGZ0IYYUO.jpg" alt="avatar" style="zoom: 33%;" /><blockquote><p><em>学长在给我们开颁奖仪式，虽然获奖的并不是我qwq</em></p></blockquote><p>PS：</p><p>赛后，我在图书馆的卫生间把我拿到的珍贵的两颗气球的气放掉了，把瘪瘪的气球拿了回来，也算是亲手为自己的梦想埋上了土吧qwq</p><hr><h2 id="以后"><a href="#以后" class="headerlink" title="以后"></a>以后</h2><p>​以后还会打算法竞赛吗？首先，我没有机会打正式的XCPC了，但是一些小比赛，还有一些线上赛还是可以打一打，保持水平，毕竟以后的笔试还是需要的，而且这也是我的爱好（一个菜鸟恬不知耻的这样说，希望不会被大家笑话就好）。</p><p>​那么以后主要忙什么呢？我想，大概是找实习和学开发吧，现在是大二，明年要考研（学历学历还是学历）。嗯大概就是这样，以后的话会在博客分享一些开发、实习、考研乃至科研的相关内容，如果不嫌弃的话欢迎关注！</p><hr><h2 id="告别"><a href="#告别" class="headerlink" title="告别"></a>告别</h2><p>​差不多到说再见的时候了，天下没有不散的筵席，纵使我想让这筵席更久一些，再久一些，久到我的夙愿可以看见黎明的曙光……<br>但，梦醒了，我也差不多该踏上新的征程了。以后也没有机会再进入XCPC的世界了，即使我从未踏足过，只愿在门前多停留半步也好。</p><p>​或许，算法就像是童话故事，那么纯净，那么梦幻，却也深刻地影响着未来的我们，走到更远的地方。</p><p>​阵阵微风轻抚，朵朵鲜花盛开，缕缕阳光洒下……在这个万物迸发的春天，我却要挥手道别。</p><p>​那就再见吧，江湖路远，何处不天涯？</p><p><img src="https://cdnjson.com/images/2023/03/18/wallhaven-jxx725.jpg" alt="avatar"></p><hr><p>写于2023.03.18 晚。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;https://cdnjson.com/images/2023/03/18/LMFMCSZDLFXRTSDBO.jpg&quot; alt=&quot;avatar&quot; style=&quot;zoom: 25%;&quot; /&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;最后的气球&lt;/em&gt;&lt;/p</summary>
      
    
    
    
    <category term="XCPC" scheme="https://conqueror712.github.io/categories/XCPC/"/>
    
    
  </entry>
  
  <entry>
    <title>XCPC丨算法竞赛汇总</title>
    <link href="https://conqueror712.github.io/post/ICPC.html"/>
    <id>https://conqueror712.github.io/post/ICPC.html</id>
    <published>2023-03-18T12:01:25.000Z</published>
    <updated>2023-03-23T01:29:47.427Z</updated>
    
    <content type="html"><![CDATA[<p>前言：</p><p>2023.03.18正式退役啦，特此来把之前杂乱无章且错误百出的，有关算法竞赛的博客整合起来，汇总成此篇博客。</p><p>（其实是我自己的板子，如果大家有需要就拿去就好啦，能帮到各位的话也算是一种传承吧）</p><blockquote><p>个人博客：<a href="https://conqueror712.github.io/">https://conqueror712.github.io/</a></p><p>知乎：<a href="https://www.zhihu.com/people/soeur712/posts">https://www.zhihu.com/people/soeur712/posts</a></p><p>Bilibili：<a href="https://space.bilibili.com/57089326">https://space.bilibili.com/57089326</a></p><p>掘金：<a href="https://juejin.cn/user/1297878069809725/posts">https://juejin.cn/user/1297878069809725/posts</a></p></blockquote><hr><p><strong>Algorithm Model Version 1.0 - 2023.03 —— by Conqueror712</strong></p><hr><h1 id="Graph-Theory"><a href="#Graph-Theory" class="headerlink" title="Graph - Theory"></a>Graph - Theory</h1><h2 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h2><p>适用情况：单源最短路 + 可有负权</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度：O(nm)</span></span><br><span class="line"><span class="comment">// vector邻接表写法</span></span><br><span class="line">vector &lt;PII&gt; edge[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shortestpath</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">127</span>, <span class="built_in">sizeof</span>(dist));</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">// 在每次迭代中，遍历所有边，尝试用Relieve_Operation更新距离数组</span></span><br><span class="line">        <span class="type">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it : edge[i])&#123;</span><br><span class="line">            <span class="type">int</span> x = i; <span class="type">int</span> y = it.fir; <span class="type">int</span> v = it.sec;</span><br><span class="line">            <span class="keyword">if</span> (dist[x] &lt; (<span class="number">1</span> &lt;&lt; <span class="number">30</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span> (dist[x] + v &lt; dist[y])&#123;</span><br><span class="line">                    dist[y] = dist[x] + v; ok = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!ok)&#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[t];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><p>适用情况：单源最短路 + 无负权</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆优化Version 时间复杂度：O((n + m)logn)</span></span><br><span class="line"><span class="comment">// 用一个堆来维护dist数组，可以使用set，也可以使用priority_queue</span></span><br><span class="line">vector &lt;PII&gt; edge[N];</span><br><span class="line">set &lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">vector &lt;PII&gt; edge[N];</span><br><span class="line"><span class="type">int</span> n, m, dist[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">127</span>, <span class="built_in">sizeof</span>(dist));</span><br><span class="line">    dist[s] = <span class="number">0</span>; q.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        q.<span class="built_in">insert</span>(&#123;dist[i], i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x = q.<span class="built_in">begin</span>()-&gt;sec;</span><br><span class="line">        q.<span class="built_in">erase</span>(q.<span class="built_in">begin</span>());</span><br><span class="line">        <span class="keyword">if</span> (x == t || dist[x] &gt; (<span class="number">1</span> &lt;&lt; <span class="number">30</span>))&#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : edge[x])&#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[x] + p.sec &lt; dist[p.fir])&#123;</span><br><span class="line">                q.<span class="built_in">erase</span>(&#123;dist[p.fir], p.fir&#125;);</span><br><span class="line">                dist[p.fir] = dist[x] + p.sec;</span><br><span class="line">                q.<span class="built_in">insert</span>(&#123;dist[p.fir], p.fir&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[t];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h2><p>适用情况：多源最短路 + 可有负权</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空间优化Version 时间复杂度：O(n^3) 空间复杂度：O(n^2) </span></span><br><span class="line"><span class="comment">// 邻接矩阵写法</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="type">int</span> v[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Floyd</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(v, <span class="number">127</span>, <span class="built_in">sizeof</span>(v));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            v[i][j] = a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (v[i][k] &lt; (<span class="number">1</span> &lt;&lt; <span class="number">30</span>) &amp;&amp; v[k][j] &lt; (<span class="number">1</span> &lt;&lt; <span class="number">30</span>))&#123;</span><br><span class="line">                    v[i][j] = <span class="built_in">min</span>(v[i][j], v[i][k] + v[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h2><p>适用场景：稠密图</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆优化Version 时间复杂度：O((n+m)logn)</span></span><br><span class="line">set &lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">vector &lt;PII&gt; edge[N];   <span class="comment">// 边集</span></span><br><span class="line"><span class="type">int</span> n, m, dist[N];      <span class="comment">// dist集</span></span><br><span class="line"><span class="type">bool</span> b[N];              <span class="comment">// 存在性集</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(b, <span class="literal">false</span>, <span class="built_in">sizeof</span>(b));</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">127</span>, <span class="built_in">sizeof</span>(dist));</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">        q.<span class="built_in">insert</span>(&#123;dist[i], i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x = q.<span class="built_in">begin</span>()-&gt;sec;</span><br><span class="line">        q.<span class="built_in">erase</span>(q.<span class="built_in">begin</span>());</span><br><span class="line">        <span class="keyword">if</span> (dist[x] &gt; (<span class="number">1</span> &lt;&lt; <span class="number">30</span>))&#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">        ++tot; ans += dist[x]; b[x] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : edge[x])&#123;</span><br><span class="line">            <span class="keyword">if</span> (!b[i.fir] &amp;&amp; i.sec &lt; dist[i.fir])&#123;</span><br><span class="line">                q.<span class="built_in">erase</span>(&#123;dist[i.fir], i.fir&#125;);</span><br><span class="line">                dist[i.fir] = i.sec;</span><br><span class="line">                q.<span class="built_in">insert</span>(&#123;dist[i.fir], i.fir&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tot != n)&#123; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123; <span class="keyword">return</span> ans; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h2><p>适用场景：稀疏图</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度：O(mlogn)</span></span><br><span class="line"><span class="type">int</span> n, m, fa[N];    <span class="comment">// fa是并查集的代表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y, v;    <span class="comment">// x, y代表这条边连接的两个点，v代表这条边的边权</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Node &amp;A) <span class="type">const</span>&#123;  <span class="comment">// 重构 &lt; 运算符</span></span><br><span class="line">        <span class="keyword">return</span> v &lt; A.v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; a[M];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FindSet</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == fa[i])&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[i] = <span class="built_in">FindSet</span>(fa[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        fa[i] = i;  <span class="comment">// 并查集初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + m + <span class="number">1</span>); <span class="comment">// 按边权排序</span></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>; <span class="type">int</span> cnt = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">FindSet</span>(a[i].x);</span><br><span class="line">        <span class="type">int</span> y = <span class="built_in">FindSet</span>(a[i].y);</span><br><span class="line">        <span class="keyword">if</span> (x != y)&#123;</span><br><span class="line">            fa[x] = y;</span><br><span class="line">            ans += a[i].v;</span><br><span class="line">            --cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">1</span>)&#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt != <span class="number">1</span>)&#123; <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">/*多于一个连通块*/</span> &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123; <span class="keyword">return</span> ans; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TopoSort"><a href="#TopoSort" class="headerlink" title="TopoSort"></a>TopoSort</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// STL写法 时间复杂度：O(n + m)</span></span><br><span class="line"><span class="comment">// 在进行TopoSort之前要先算好每个点的d，也就是入度</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">TopoSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 队列S</span></span><br><span class="line">    queue &lt;<span class="type">int</span>&gt; s, l;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!d[i])&#123;</span><br><span class="line">            <span class="comment">// 入度为0，加到S里面去</span></span><br><span class="line">            s.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当队列非空的时候</span></span><br><span class="line">    <span class="keyword">while</span> (s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="comment">// 将x加入到L的队尾，并把x从S中删去</span></span><br><span class="line">        <span class="type">int</span> x = s.<span class="built_in">front</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        l.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="comment">// 遍历x的所有边，令y的入度--，再判断如果此时y的入度为0，加进队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> y : edge[x])&#123;</span><br><span class="line">            <span class="keyword">if</span> (--d[y] == <span class="number">0</span>)&#123;</span><br><span class="line">                s.<span class="built_in">push</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断L里面有多少个点</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">int</span>(l.<span class="built_in">size</span>()) == n)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;  </span><br><span class="line">        <span class="comment">// q中记录了一个合法的拓扑序列</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 有环</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字典序最小/最大的拓扑序 时间复杂度：O(nlogn + m)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">TopoSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 优先队列S</span></span><br><span class="line">    queue &lt;<span class="type">int</span>&gt; l;</span><br><span class="line">    priority_queue &lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!d[i])&#123;</span><br><span class="line">            <span class="comment">// 入度为0，加到S里面去</span></span><br><span class="line">            s.<span class="built_in">push</span>(-i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当队列非空的时候</span></span><br><span class="line">    <span class="keyword">while</span> (s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x = -s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        l.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="comment">// 遍历x的所有边，令y的入度--，再判断如果此时y的入度为0，加进队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> y : edge[x])&#123;</span><br><span class="line">            <span class="keyword">if</span> (--d[y] == <span class="number">0</span>)&#123;</span><br><span class="line">                s.<span class="built_in">push</span>(-y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (l.<span class="built_in">size</span>())&#123;</span><br><span class="line">        cout &lt;&lt; l.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        l.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Euler-Road"><a href="#Euler-Road" class="headerlink" title="Euler Road"></a>Euler Road</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有向图的欧拉路</span></span><br><span class="line"><span class="comment">// 此代码的假设是将图中所有的有向边改为无向边后，图中所有度非零的点是联通的</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>, M = <span class="number">10010</span>;</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; edge[N]; <span class="comment">// 存边</span></span><br><span class="line"><span class="comment">// f[i]表示i里面0到f[i - 1]那些边已经走过了 下次要走f[i]了 防止重复枚举</span></span><br><span class="line"><span class="comment">// ind入度 outd出度 c用来记路径</span></span><br><span class="line"><span class="type">int</span> n, m, l, f[N], ind[N], outd[N], c[M];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (f[x] &lt; outd[x])&#123;</span><br><span class="line"><span class="comment">// 这条边要存在</span></span><br><span class="line"><span class="type">int</span> y = edge[x][f[x]];</span><br><span class="line">f[x]++;</span><br><span class="line"><span class="built_in">dfs</span>(y);</span><br><span class="line">c[++l] = y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Euler</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// x是起点</span></span><br><span class="line"><span class="comment">// y表示有多少个点的出度比入度大1</span></span><br><span class="line"><span class="comment">// z是有多少点的出度不等于入度</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, z = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 枚举每个点</span></span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, n)&#123;</span><br><span class="line"><span class="comment">// y的情况</span></span><br><span class="line"><span class="keyword">if</span> (ind[i] + <span class="number">1</span> == outd[i])&#123;</span><br><span class="line"><span class="comment">// 可能是起点</span></span><br><span class="line">x = i, ++y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// z的情况</span></span><br><span class="line"><span class="keyword">if</span> (ind[i] != outd[i])&#123;</span><br><span class="line">++z;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!((y == <span class="number">1</span> &amp;&amp; z == <span class="number">2</span>) || !z))&#123;</span><br><span class="line"><span class="comment">// 没有欧拉路</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 起点还没找到 写!z也可以</span></span><br><span class="line"><span class="keyword">if</span> (!x)&#123;</span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, n)&#123;</span><br><span class="line"><span class="keyword">if</span> (ind[i])&#123;</span><br><span class="line">x = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">l = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">dfs</span>(x);</span><br><span class="line">c[++l] = x;</span><br><span class="line"><span class="keyword">if</span> (l == m + <span class="number">1</span>)&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// per(i, l, 1)&#123;</span></span><br><span class="line"><span class="comment">// cout &lt;&lt; c[i] &lt;&lt; &quot; \n&quot;[i == 1];</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// -------------------------------</span></span><br><span class="line"><span class="comment">// 以下是main函数的一部分 记得更改d数组</span></span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, m)&#123;</span><br><span class="line"><span class="type">char</span> str[<span class="number">101</span>];</span><br><span class="line">cin &gt;&gt; str;</span><br><span class="line"><span class="type">int</span> x = str[<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>, y = str[<span class="built_in">strlen</span>(str) - <span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">edge[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">++outd[x];</span><br><span class="line">++ind[y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Euler</span>();</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无向图的欧拉路</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>, M = <span class="number">10010</span>;</span><br><span class="line"><span class="comment">// 存边 fir为去向 sec为idx</span></span><br><span class="line">vector &lt;PII&gt; edge[N];</span><br><span class="line"><span class="type">int</span> n, m, l, cnt = <span class="number">1</span>, f[N], d[N], v[N], c[M];</span><br><span class="line"><span class="type">bool</span> b[<span class="number">2</span> * M];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (f[x] &lt; v[x])&#123;</span><br><span class="line"><span class="comment">// 这条边要存在</span></span><br><span class="line"><span class="type">int</span> y = edge[x][f[x]].fir, idx = edge[x][f[x]].sec;</span><br><span class="line"><span class="keyword">if</span> (!b[idx])&#123;</span><br><span class="line">f[x]++;</span><br><span class="line">b[idx] = b[idx ^ <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">dfs</span>(y);</span><br><span class="line">c[++l] = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">f[x]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Euler</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 枚举每个点</span></span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, n)&#123;</span><br><span class="line"><span class="keyword">if</span> (d[i] &amp; <span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">// 可能是起点</span></span><br><span class="line">x = i, ++y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (y &amp;&amp; y != <span class="number">2</span>)&#123;</span><br><span class="line"><span class="comment">// 没有欧拉路</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!x)&#123;</span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, n)&#123;</span><br><span class="line"><span class="keyword">if</span> (d[i])&#123;</span><br><span class="line">x = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line"><span class="built_in">memset</span>(b, <span class="literal">false</span>, <span class="built_in">sizeof</span>(b));</span><br><span class="line">l = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">dfs</span>(x);</span><br><span class="line">c[++l] = x;</span><br><span class="line"><span class="keyword">if</span> (l != m + <span class="number">1</span>)&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">per</span>(i, l, <span class="number">1</span>)&#123;</span><br><span class="line">cout &lt;&lt; c[i] &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ------------------------------</span></span><br><span class="line"><span class="comment">// 以下是main函数的一部分 记得更改d数组</span></span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, m)&#123;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">edge[x].<span class="built_in">push_back</span>(&#123;y, ++cnt&#125;);</span><br><span class="line">edge[y].<span class="built_in">push_back</span>(&#123;x, ++cnt&#125;);</span><br><span class="line">++d[x];</span><br><span class="line">++d[y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, n)&#123;</span><br><span class="line">v[i] = edge[i].<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Euler</span>();</span><br></pre></td></tr></table></figure><h2 id="Bipartite-Graph"><a href="#Bipartite-Graph" class="headerlink" title="Bipartite Graph"></a>Bipartite Graph</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 染色法判别二分图 时间复杂度：O(n + m)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>;</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; edge[N];</span><br><span class="line"><span class="comment">// c数组存颜色 即color 1和2是不同的颜色 0代表还没染过色</span></span><br><span class="line"><span class="type">int</span> n, m, c[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">// 遍历x的边 然后递归下去就是遍历x的连通块</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> y : edge[x])&#123;</span><br><span class="line"><span class="keyword">if</span> (!c[y])&#123;</span><br><span class="line"><span class="comment">// 还没染过色 染之</span></span><br><span class="line">c[y] = <span class="number">3</span> - c[x];</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">dfs</span>(y))&#123;</span><br><span class="line"><span class="comment">// 染不动了</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (c[x] == c[y])&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="built_in">sizeof</span>(c))</span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, n)&#123;</span><br><span class="line"><span class="keyword">if</span> (!c[i])&#123;</span><br><span class="line">c[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">dfs</span>(i))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求二分图最大匹配 时间复杂度：O(nm)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="comment">// edge只记左边的点</span></span><br><span class="line">vector &lt;<span class="type">int</span>&gt; edge[N];</span><br><span class="line"><span class="comment">// v[i]表示有右边的第i个点 如果有匹配 匹配的是左边的哪个点 没有就为0</span></span><br><span class="line"><span class="type">int</span> n, m, n1, n2, v[N];</span><br><span class="line"><span class="type">bool</span> b[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">b[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> y : edge[x])&#123;</span><br><span class="line"><span class="keyword">if</span> (!v[y] || (!b[v[y]] &amp;&amp; <span class="built_in">Find</span>(v[y])))&#123;</span><br><span class="line">v[y] = x;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">match</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="built_in">sizeof</span>(v));</span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, n1)&#123;</span><br><span class="line"><span class="built_in">memset</span>(b, <span class="literal">false</span>, <span class="built_in">sizeof</span>(b));</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Find</span>(i))&#123;</span><br><span class="line"><span class="comment">// dfs</span></span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">最大独立集</span><br><span class="line">在图中选出最多的点，满足他们两两之间没有边相连。</span><br><span class="line"></span><br><span class="line">最大独立集.size = n - 最大匹配数</span><br><span class="line"></span><br><span class="line">最小点覆盖</span><br><span class="line">在图中选出最少的点，使得每条边的两个端点中至少有一个在集合里</span><br><span class="line"></span><br><span class="line">最小点覆盖.size = 最大匹配数</span><br></pre></td></tr></table></figure><hr><h1 id="Data-Structure"><a href="#Data-Structure" class="headerlink" title="Data - Structure"></a>Data - Structure</h1><p><em>Chain - Table：Skipped, I don’t like it.</em></p><hr><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组实现队列的简单操作</span></span><br><span class="line"><span class="type">int</span> q[<span class="number">100010</span>];</span><br><span class="line"><span class="type">int</span> front = <span class="number">1</span>, rear = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    q[++rear] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ++front;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;  <span class="comment">// 询问第k个元素</span></span><br><span class="line">    <span class="comment">// 如何判断队列里有几个元素？ rear - front + 1即可</span></span><br><span class="line">    <span class="keyword">return</span> q[front + k - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Top</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> q[front];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组实现循环队列</span></span><br><span class="line"><span class="comment">// 有些时候 入队出队次数 远远大于 队伍的元素个数，那么开很大的数组就浪费空间了</span></span><br><span class="line"><span class="comment">// 于是我们就让 当队尾指针移动到数组末端时，再将其移动到数组头即可，反之亦然</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> size = <span class="number">1010</span>;            <span class="comment">// size要严格大于队列最长的时候的长度</span></span><br><span class="line"><span class="type">int</span> q[size];</span><br><span class="line"><span class="type">int</span> front = <span class="number">1</span>, rear = size;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    rear = rear % size + <span class="number">1</span>;</span><br><span class="line">    q[rear] = x;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    front = front % size + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rear % size + <span class="number">1</span> == front;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (front + x - <span class="number">1</span> &lt;= size)&#123;</span><br><span class="line">        <span class="keyword">return</span> q[front + x - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q[front + x - <span class="number">1</span> - size];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈的数组实现</span></span><br><span class="line"><span class="type">int</span> s[<span class="number">100010</span>];  <span class="comment">// 创建栈</span></span><br><span class="line"><span class="type">int</span> top = <span class="number">0</span>;  <span class="comment">// 创建头指针，一开始在底部</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    s[++top] = x;        <span class="comment">//先移动top 再赋值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        --top;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Top</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s[top];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;  <span class="comment">// 查询从栈顶往下数第k个元素是多少</span></span><br><span class="line">    <span class="keyword">return</span> s[top+<span class="number">1</span>-k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Binary-Tree"><a href="#Binary-Tree" class="headerlink" title="Binary - Tree"></a>Binary - Tree</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 指针建立二叉树</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *l, *r, *fa;</span><br><span class="line">&#125; a[<span class="number">100010</span>];</span><br><span class="line"><span class="comment">// 插入子节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(TreeNode *fa, TreeNode *p, <span class="type">int</span> flag)</span></span>&#123;</span><br><span class="line">    <span class="comment">// flag = 0 插入到左边 flag = 1 插入到右边</span></span><br><span class="line">    <span class="keyword">if</span> (!flag)&#123; fa-&gt;l = p; &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123; fa-&gt;r = p; &#125;</span><br><span class="line">    p-&gt;fa = fa;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(TreeNode *p)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; p-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;l) <span class="built_in">PreOrder</span>(p-&gt;l);</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;r) <span class="built_in">PreOrder</span>(p-&gt;r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(TreeNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;l) <span class="built_in">InOrder</span>(p-&gt;l);</span><br><span class="line">    cout &lt;&lt; p-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;r) <span class="built_in">InOrder</span>(p-&gt;r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(TreeNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;l) <span class="built_in">PostOrder</span>(p-&gt;l);</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;r) <span class="built_in">PostOrder</span>(p-&gt;r);</span><br><span class="line">    cout &lt;&lt; p-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> l, r; cin &gt;&gt; l &gt;&gt; r; a[i].val = i;</span><br><span class="line">        <span class="keyword">if</span> (l != <span class="number">0</span>)&#123; a[i].l = &amp;a[l]; a[l].fa = &amp;a[i]; &#125;</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="number">0</span>)&#123; a[i].r = &amp;a[r]; a[r].fa = &amp;a[i]; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">PreOrder</span>(&amp;a[<span class="number">1</span>]); cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">InOrder</span>(&amp;a[<span class="number">1</span>]); cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">PostOrder</span>(&amp;a[<span class="number">1</span>]); cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">0 0</span></span><br><span class="line"><span class="comment">4 0</span></span><br><span class="line"><span class="comment">0 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h2 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆的数组实现</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Maxsize = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>;    <span class="comment">// 记录当前size</span></span><br><span class="line"><span class="comment">// int heap[Maxsize]; 这是数组实现 我们选择vector</span></span><br><span class="line">vector &lt;<span class="type">int</span>&gt; heap;</span><br><span class="line"><span class="comment">// 每一次插入新的数据，都要和它的父节点比一比（判别依据是根据本来是大根堆||小根堆）</span></span><br><span class="line"><span class="comment">// 以小根堆举例，插入的复杂度为O(logn)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Up</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(k &gt; <span class="number">1</span> &amp;&amp; heap[k] &lt; heap[k / <span class="number">2</span>])&#123;</span><br><span class="line">        <span class="built_in">swap</span>(heap[k], heap[k / <span class="number">2</span>]);</span><br><span class="line">        k /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    heap[++len] = x;</span><br><span class="line">    <span class="built_in">Up</span>(len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 堆最常用的功能就是维护min||max</span></span><br><span class="line"><span class="comment">// 以小根堆为例，我们常常会求得最小的数字，然后让它出堆；</span></span><br><span class="line"><span class="comment">// 这时候我们就要从堆中删除堆顶元素。</span></span><br><span class="line"><span class="comment">// 由于这时除了堆顶为空，它的左右子树堆仍然满足堆结构。</span></span><br><span class="line"><span class="comment">// 为了操作简单，我们将堆尾元素放到堆顶，然后再将其&quot;逐 步 下 移&quot;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Down</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(k + k &lt;= len)&#123;</span><br><span class="line">        <span class="type">int</span> j = k + k;</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= len &amp;&amp; heap[j + <span class="number">1</span>] &lt; heap[j])&#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (heap[k] &lt;= heap[j])&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(heap[k], heap[j]);</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(heap[<span class="number">1</span>], heap[len]);</span><br><span class="line">    len--;</span><br><span class="line">    <span class="built_in">Down</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除堆中任意一个元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == len)&#123;</span><br><span class="line">        heap[len] = <span class="number">0</span>;</span><br><span class="line">        len--;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x = heap[p];</span><br><span class="line">    <span class="type">int</span> y = heap[len];</span><br><span class="line">    <span class="built_in">swap</span>(heap[p],heap[len]);</span><br><span class="line">    len--;</span><br><span class="line">    <span class="keyword">if</span> (y &lt; x)&#123;</span><br><span class="line">        <span class="built_in">Up</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">Down</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// STL - Heap</span></span><br><span class="line"><span class="comment">// 大根堆：</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line"><span class="comment">// 小根堆：</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line"><span class="comment">// 基本操作：empty size top push pop...(没有clear)</span></span><br></pre></td></tr></table></figure><hr><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般的情况就用unordered_map来做就可以了，如果被卡了就换成map</span></span><br><span class="line"><span class="comment">// 如果需要解决值冲突，需要二次哈希甚至三次哈希，那么就需要用正经的哈希函数来搞了，我暂时用不到，故暂略之</span></span><br></pre></td></tr></table></figure><hr><h2 id="Monotone-Stack-and-Queue"><a href="#Monotone-Stack-and-Queue" class="headerlink" title="Monotone - Stack and Queue"></a>Monotone - Stack and Queue</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PS: 用的不是很好</span></span><br><span class="line"><span class="comment">// 单调栈模板</span></span><br><span class="line"><span class="comment">// 从下往上元素单调递减</span></span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, n)&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="comment">/* 栈非空 &amp;&amp; 栈顶元素 &lt; a[i] */</span>)&#123;</span><br><span class="line"><span class="comment">// 栈顶元素所在位置答案为i</span></span><br><span class="line"><span class="comment">// 弹出栈顶元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将a[i]入栈 并记录其位置</span></span><br><span class="line">&#125;<span class="comment">// 清空栈 栈中元素所在位置答案为0</span></span><br><span class="line"><span class="comment">// ---------------------------------------</span></span><br><span class="line"><span class="comment">// 单调队列模板</span></span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, n)&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="comment">/*队列非空 &amp;&amp; 队尾元素 &lt;= a[i]*/</span>)&#123;</span><br><span class="line"><span class="comment">// 弹出队尾元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将a[i]加入队尾</span></span><br><span class="line"><span class="comment">// 如果队首元素已经&quot;过气&quot;，将其出队</span></span><br><span class="line"><span class="comment">// 队首为当前区间的答案</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PS：用的不是很好</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line">VI edges[N];</span><br><span class="line"><span class="comment">// 数组里面的每一个元素都是一个vector，就是用vector来存树，当然也可以用链表来存</span></span><br><span class="line"><span class="comment">// edges[i]（这是个vector）就代表第i个点的所有子节点的下标</span></span><br><span class="line"><span class="type">int</span> n, fa[N];<span class="comment">// n代表树里面有多少个节点，fa[]代表节点的父节点编号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    edges[x].<span class="built_in">pb</span>(y);<span class="comment">// 给x节点添加一个儿子y</span></span><br><span class="line">    fa[y] = x;<span class="comment">// 更新y的父节点信息（对于有根树而言）</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintSon</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 遍历x的所有儿子</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : edges[x])&#123;</span><br><span class="line">        cout &lt;&lt; edges[x][i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">VI dfn;<span class="comment">// 有根树的DFS序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    dfn.<span class="built_in">pb</span>(x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="comment">/*x的所有儿子y*/</span>)&#123;</span><br><span class="line">        <span class="built_in">DFS</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有根树的BFS序 q中出现的元素顺序即BFS序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 将root加入队列q</span></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="comment">// x = q队首元素;</span></span><br><span class="line">        <span class="comment">// x出队;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="comment">/*x的所有儿子y*/</span>)&#123;</span><br><span class="line">            <span class="comment">// y入队;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Trie-Tree"><a href="#Trie-Tree" class="headerlink" title="Trie Tree"></a>Trie Tree</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> charsize = <span class="number">26</span>;    <span class="comment">// 字符集大小</span></span><br><span class="line"><span class="type">int</span> nxt[N][charsize];   <span class="comment">// 记录此节点的子节点编号（默认全是小写字母）</span></span><br><span class="line"><span class="type">bool</span> isEnd[N];  <span class="comment">// 表示此编号节点是否为终止节点</span></span><br><span class="line"><span class="type">int</span> root = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;    <span class="comment">// 表示当前的节点编号数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(string s, <span class="type">int</span> len)</span></span>&#123;  <span class="comment">// s为等待插入的字符串，0_base，len为字符串长度</span></span><br><span class="line">    <span class="type">int</span> now = <span class="number">0</span>;    <span class="comment">// 当前在哪个节点上</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;   <span class="comment">// 遍历</span></span><br><span class="line">        <span class="type">int</span> x = s[i] - <span class="string">&#x27;a&#x27;</span>;     <span class="comment">// 转成数字</span></span><br><span class="line">        <span class="keyword">if</span> (!nxt[now][x])&#123;     <span class="comment">// 如果当前节点没有子节点x，则创建之，并且给予编号</span></span><br><span class="line">            nxt[now][x] = ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        now = nxt[now][x];     <span class="comment">// 无论创建了新节点与否，都更新当前节点的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    isEnd[now] = <span class="literal">true</span>;          <span class="comment">// 最后的最后，把该字符串的最后一个字符的isEnd标记为true</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// s为等待插入的字符串，0_base，len为字符串长度</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">search</span><span class="params">(string s, <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> now = <span class="number">0</span>;    <span class="comment">//和上面一样，记录当前在看的节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;  <span class="comment">//遍历之</span></span><br><span class="line">        <span class="type">int</span> x = s[i] - <span class="string">&#x27;a&#x27;</span>;     <span class="comment">//转成数字</span></span><br><span class="line">        <span class="keyword">if</span> (!nxt[now][x])&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;<span class="comment">//如果当前节点没有子节点x，则直接返回false</span></span><br><span class="line">        now = nxt[now][x];     <span class="comment">//如果没有return则更新当前节点位置，继续循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isEnd[now];          <span class="comment">//最后进行判断最后一个字符是否是结束位置，返回即可</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 字典树的删除比较罕见 暂略</span></span><br><span class="line"><span class="comment">/*字符集较大的时候请使用哈希</span></span><br><span class="line"><span class="comment">struct TreeNode&#123;</span></span><br><span class="line"><span class="comment">    unordered_map &lt;char, int&gt; nxt;</span></span><br><span class="line"><span class="comment">    bool isEnd;</span></span><br><span class="line"><span class="comment">&#125; tree[N];*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 例题描述：n个字符串s1~sn和m组询问，每次询问一个字符串是否在s1~sn中出现过，有1，无0</span></span><br><span class="line">    ios;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">insert</span>(s, len);</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        cout &lt;&lt; <span class="built_in">search</span>(s, len) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Union-Find-Set"><a href="#Union-Find-Set" class="headerlink" title="Union - Find - Set"></a>Union - Find - Set</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一开始有n个元素，互相独立，则构成了n个集合，每个集合的代表元素就是它本身</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> fa[maxn + <span class="number">1</span>];   <span class="comment">// fa数组记录每个元素由谁代表</span></span><br><span class="line"><span class="type">int</span> sz[maxn + <span class="number">1</span>];   <span class="comment">// sz数组记录每个集合的元素个数</span></span><br><span class="line"><span class="type">int</span> dep[maxn + <span class="number">1</span>];  <span class="comment">// dep数组记录每个集合的树深度</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Initialize</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123; <span class="comment">// 一共有n个点</span></span><br><span class="line">        fa[i] = i;              <span class="comment">// 把代表元素设置为自己</span></span><br><span class="line">        sz[i] = dep[i] = <span class="number">1</span>;     <span class="comment">// 一开始的深度就是1，子树大小也是1，因为只有自己孤零零的一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Findset</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == fa[x])&#123;    <span class="comment">//如果就是代表元素就直接返回咯</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    fa[x] = <span class="built_in">Findset</span>(fa[x]);      <span class="comment">//在不是的情况下每一次都设置一遍</span></span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;<span class="comment">// 启发式合并O(logn)</span></span><br><span class="line">    <span class="type">int</span> fx = <span class="built_in">Findset</span>(x);</span><br><span class="line">    <span class="type">int</span> fy = <span class="built_in">Findset</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (fx == fy)&#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (sz[fx] &gt; sz[fy])&#123; <span class="built_in">swap</span>(fx, fy); &#125; <span class="comment">// 确定谁是骡子谁是马</span></span><br><span class="line">    fa[fx] = fy; sz[fy] += sz[fx];   <span class="comment">//子树的大小也要加起来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Segment-Tree"><a href="#Segment-Tree" class="headerlink" title="Segment Tree"></a>Segment Tree</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*线段树和树状数组在复杂度上同级, 但是树状数组的常数明显优于线段树, 其编程复杂度也远小于线段树. 树状数组的作用被线段树完全涵盖, 凡是可以使用树状数组解决的问题, 使用线段树一定可以解决, 但是线段树能够解决的问题树状数组未必能够解决。于是我们这里暂时就学线段树就可以了。*/</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500010</span>;</span><br><span class="line"><span class="comment">// f[i]记录的是编号为i的节点 记录的区间和</span></span><br><span class="line"><span class="comment">// v[i]记录的是编号为i的节点 整体要加上v[i]</span></span><br><span class="line"><span class="type">int</span> n, m, f[<span class="number">4</span> * N], a[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuildTree</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">//k是编号 l r是左端点和右端点</span></span><br><span class="line"><span class="keyword">if</span> (l == r)&#123;</span><br><span class="line"><span class="comment">//走到叶子节点了，走不动了</span></span><br><span class="line">f[k] = a[l];<span class="comment">//f[k] = a[r]当然也可以，无所谓</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = (l + r) / <span class="number">2</span>;<span class="comment">//这里可以用(l + r) &gt;&gt; 1，也是除以2的意思</span></span><br><span class="line"><span class="comment">//获得了当前区间的中点，开始分割递归</span></span><br><span class="line"><span class="built_in">BuildTree</span>(k + k, l, mid);</span><br><span class="line"><span class="built_in">BuildTree</span>(k + k + <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">f[k] = f[k + k] + f[k + k + <span class="number">1</span>];</span><br><span class="line"><span class="comment">//这里是用到了完全二叉树的节点编号的性质，父节点为k，则两个子节点分别为k + k和k + k + 1</span></span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//整棵树就建好了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="comment">//k是编号</span></span><br><span class="line"><span class="comment">//递归的去从根节点开始加val，一直加到点x上</span></span><br><span class="line">f[k] += val;</span><br><span class="line"><span class="keyword">if</span> (l == r)&#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (x &lt;= mid)&#123;</span><br><span class="line"><span class="comment">//如果x在mid的左边，也就是说要往左子树递归</span></span><br><span class="line"><span class="built_in">Add</span>(k + k, l, mid, x, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//如果x在mid的右边，也就是说要往右子树递归</span></span><br><span class="line"><span class="built_in">Add</span>(k + k + <span class="number">1</span>, mid + <span class="number">1</span>, r, x, val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line"><span class="comment">//编号为k的点对应的区间是l~r，s~t是其子区间</span></span><br><span class="line"><span class="keyword">if</span> (l == s &amp;&amp; r == t)&#123; <span class="keyword">return</span> f[k]; &#125;</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (t &lt;= mid)&#123;</span><br><span class="line"><span class="comment">//如果s~t完全位于左区间</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">calc</span>(k + k, l, mid, s, t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s &gt; mid)&#123;</span><br><span class="line"><span class="comment">//如果s~t完全位于右区间</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">calc</span>(k + k + <span class="number">1</span>, mid + <span class="number">1</span>, r, s, t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//如果s~t横跨两边，加起来即可</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">calc</span>(k + k, l, mid, s, mid) + <span class="built_in">calc</span>(k + k + <span class="number">1</span>, mid + <span class="number">1</span>, r, mid + <span class="number">1</span>, t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios;</span><br><span class="line"><span class="comment">// m次操作</span></span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归建树</span></span><br><span class="line"><span class="built_in">BuildTree</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line"><span class="type">int</span> op, x, y;</span><br><span class="line">cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;</span><br><span class="line"><span class="keyword">if</span> (op == <span class="number">1</span>)&#123;<span class="comment">// 操作1：第x个数加上y</span></span><br><span class="line"><span class="built_in">Add</span>(<span class="number">1</span>, <span class="number">1</span>, n, x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="comment">// 操作2：查询区间x~y的区间和</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">calc</span>(<span class="number">1</span>, <span class="number">1</span>, n, x, y) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带标记的线段树</span></span><br><span class="line"><span class="comment">// 上面一部分 + 下面一部分</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500010</span>;</span><br><span class="line">ll n, m, a[N], f[<span class="number">4</span> * N], v[N]; <span class="comment">//f[i]记录的是编号为i的节点记录的区间和</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">BuildTree</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">//k是编号 l r是左端点和右端点</span></span><br><span class="line"><span class="keyword">if</span> (l == r)&#123;</span><br><span class="line"><span class="comment">//走到叶子节点了，走不动了</span></span><br><span class="line">f[k] = a[l];<span class="comment">//f[k] = a[r]当然也可以，无所谓</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;<span class="comment">//这里可以用(l + r) &gt;&gt; 1，也是除以2的意思</span></span><br><span class="line"><span class="comment">//获得了当前区间的中点，开始分割递归</span></span><br><span class="line"><span class="built_in">BuildTree</span>(k + k, l, mid);</span><br><span class="line"><span class="built_in">BuildTree</span>(k + k + <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">f[k] = f[k + k] + f[k + k + <span class="number">1</span>];</span><br><span class="line"><span class="comment">//这里是用到了完全二叉树的节点编号的性质，父节点为k，则两个子节点分别为k + k和k + k + 1</span></span><br><span class="line"><span class="comment">//整棵树就建好了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, ll z)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == x &amp;&amp; r == y)&#123;</span><br><span class="line">v[k] += z;<span class="comment">// 这里的f不用改，因为只考虑其子树下面的和</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">f[k] += (y - x + <span class="number">1</span>) * z;</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (y &lt;= mid)&#123;</span><br><span class="line"><span class="built_in">Insert</span>(k + k, l, mid, x, y, z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt; mid)&#123;</span><br><span class="line"><span class="built_in">Insert</span>(k + k + <span class="number">1</span>, mid + <span class="number">1</span>, r, x, y, z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">Insert</span>(k + k, l, mid, x, mid, z);</span><br><span class="line"><span class="built_in">Insert</span>(k + k + <span class="number">1</span>, mid + <span class="number">1</span>, r, mid + <span class="number">1</span>, y, z);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, ll p)</span></span>&#123;</span><br><span class="line"><span class="comment">//编号为k的点对应的区间是l~r x~y是其子区间 p是根到当前的点的v的和</span></span><br><span class="line">p += v[k];</span><br><span class="line"><span class="keyword">if</span> (l == x &amp;&amp; r == y)&#123;</span><br><span class="line"><span class="keyword">return</span> p * (r - l + <span class="number">1</span>) + f[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (y &lt;= mid)&#123;</span><br><span class="line"><span class="comment">//如果完全位于左区间</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">calc</span>(k + k, l, mid, x, y, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &gt; mid)&#123;</span><br><span class="line"><span class="comment">//如果完全位于右区间</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">calc</span>(k + k + <span class="number">1</span>, mid + <span class="number">1</span>, r, x, y, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//如果横跨两边，加起来即可</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">calc</span>(k + k, l, mid, x, mid, p) + <span class="built_in">calc</span>(k + k + <span class="number">1</span>, mid + <span class="number">1</span>, r, mid + <span class="number">1</span>, y, p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归建树</span></span><br><span class="line"><span class="built_in">BuildTree</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line"><span class="type">int</span> op, x, y; ll k;</span><br><span class="line">cin &gt;&gt; op;</span><br><span class="line"><span class="keyword">if</span> (op == <span class="number">1</span>)&#123;<span class="comment">//操作1：x~y的区间都加上k</span></span><br><span class="line">cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line"><span class="built_in">Insert</span>(<span class="number">1</span>, <span class="number">1</span>, n, x, y, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="comment">//操作2：查询区间x~y的区间和</span></span><br><span class="line">cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">cout &lt;&lt; <span class="built_in">calc</span>(<span class="number">1</span>, <span class="number">1</span>, n, x, y, <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="Number-Theory"><a href="#Number-Theory" class="headerlink" title="Number - Theory"></a>Number - Theory</h1><h2 id="Exact-Division-amp-gcd-amp-lcm"><a href="#Exact-Division-amp-gcd-amp-lcm" class="headerlink" title="Exact - Division &amp; gcd &amp; lcm"></a>Exact - Division &amp; gcd &amp; lcm</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123; <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123; <span class="keyword">return</span> (a / <span class="built_in">gcd</span>(a, b)) * b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)&#123; x = <span class="number">1</span>, y = <span class="number">0</span>; <span class="keyword">return</span> a; &#125;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= (a / b) * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Prime-Sieve-amp-Block-By-Block"><a href="#Prime-Sieve-amp-Block-By-Block" class="headerlink" title="Prime Sieve &amp; Block - By - Block"></a>Prime Sieve &amp; Block - By - Block</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 试除法分解质因数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Divide</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i, s ++ ;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 试除法求所有约数</span></span><br><span class="line">vector &lt;<span class="type">int</span>&gt; <span class="built_in">get_divisors</span>(<span class="type">int</span> x)&#123;</span><br><span class="line">    vector &lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (i != x / i) res.<span class="built_in">push_back</span>(x / i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线性筛</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数 0_base</span></span><br><span class="line"><span class="type">bool</span> st[N];             <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++ )&#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++ )&#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Coresidual-amp-Euler-Func-amp-Inverse"><a href="#Coresidual-amp-Euler-Func-amp-Inverse" class="headerlink" title="Coresidual &amp; Euler Func &amp; Inverse"></a>Coresidual &amp; Euler Func &amp; Inverse</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给一个素数p 求1∼n关于p的逆元 (有四种求逆元的方法)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10100000</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> inv[N];</span><br><span class="line"><span class="type">int</span> n, p, ans = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; p &gt;&gt; n; inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        inv[i] = (p - p / i) * inv[p % i] % p;</span><br><span class="line">        ans ^= inv[i];  <span class="comment">// 由于输出可能很大 只需要求这些逆元的异或和即可</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 求欧拉函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">phi</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )&#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)&#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) res = res / x * (x - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Qmi-amp-Conbinatorial-Number"><a href="#Qmi-amp-Conbinatorial-Number" class="headerlink" title="Qmi &amp; Conbinatorial Number"></a>Qmi &amp; Conbinatorial Number</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速幂：求a^k%mod 时间复杂度O(logk)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    a %= mod; <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k)&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) &#123; res = res * a % mod; &#125;</span><br><span class="line">        a = a * a % mod; k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 快速乘</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function">ll <span class="title">quickmul</span><span class="params">(ll a, ll b, ll mod)</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>; a %= mod;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)&#123; ans += a; ans %= mod; &#125;</span><br><span class="line">        a += a; a %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 矩阵乘法</span></span><br><span class="line"><span class="comment">//优化的 O(n^3 log k) 但是常数小了很多</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">aa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll w[N][N];</span><br><span class="line">    <span class="built_in">memset</span>(w, <span class="number">0</span>, <span class="built_in">sizeof</span>(w));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i][k])&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (a[k][j])&#123;</span><br><span class="line">                        w[i][j] += a[i][k] * a[k][j]; w[i][j] %= P;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(a, w, <span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 排列数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">A</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = m; i &gt;= <span class="number">1</span>; i--) &#123; res *= n; n--; &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>四种求组合数的方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通组合数 N^2：</span></span><br><span class="line"><span class="comment">// c[a][b] 表示从a个中选b个的方案数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j ++ )</span><br><span class="line">        <span class="keyword">if</span> (!j) c[i][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> c[i][j] = (c[i - <span class="number">1</span>][j] + c[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过预处理逆元的方式求组合数：</span></span><br><span class="line"><span class="comment">// 首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N]</span></span><br><span class="line"><span class="comment">// 如果取模的数是质数，可以用费马小定理求逆元</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k, <span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k)&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 预处理阶乘的余数和阶乘逆元的余数</span></span><br><span class="line">fact[<span class="number">0</span>] = infact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i ++ )&#123;</span><br><span class="line">    fact[i] = (LL)fact[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    infact[i] = (LL)infact[i - <span class="number">1</span>] * <span class="built_in">qmi</span>(i, mod - <span class="number">2</span>, mod) % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lucas定理：</span></span><br><span class="line"><span class="comment">// 若p是质数，则对于任意整数 1 &lt;= m &lt;= n，有：</span></span><br><span class="line"><span class="comment">// C(n, m) = C(n % p, m % p) * C(n / p, m / p) (mod p)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k, <span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">while</span> (k)&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span> <span class="comment">/* 通过定理求组合数C(a, b)*/</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    LL x = <span class="number">1</span>, y = <span class="number">1</span>;  <span class="comment">// x是分子，y是分母</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a, j = <span class="number">1</span>; j &lt;= b; i --, j ++ )&#123;</span><br><span class="line">        x = (LL)x * i % p;</span><br><span class="line">        y = (LL) y * j % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * (LL)<span class="built_in">qmi</span>(y, p - <span class="number">2</span>, p) % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lucas</span><span class="params">(LL a, LL b, <span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; p &amp;&amp; b &lt; p) <span class="keyword">return</span> <span class="built_in">C</span>(a, b, p);</span><br><span class="line">    <span class="keyword">return</span> (LL)<span class="built_in">C</span>(a % p, b % p, p) * <span class="built_in">lucas</span>(a / p, b / p, p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分解质因数法求组合数：</span></span><br><span class="line"><span class="comment">/* 当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用：</span></span><br><span class="line"><span class="comment">    1. 筛法求出范围内的所有质数</span></span><br><span class="line"><span class="comment">    2. 通过 C(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n! 中p的次数是 n / p + n / p^2 + n / p^3 + ...</span></span><br><span class="line"><span class="comment">    3. 用高精度乘法将所有质因子相乘 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> primes[N], cnt;     <span class="comment">// 存储所有质数</span></span><br><span class="line"><span class="type">int</span> sum[N];     <span class="comment">// 存储每个质数的次数</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个数是否已被筛掉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )&#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> p)</span><span class="comment">/*求n！中的次数*/</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)&#123;</span><br><span class="line">        res += n / p;</span><br><span class="line">        n /= p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a, <span class="type">int</span> b)</span><span class="comment">/*高精度乘低精度模板*/</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; c;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i ++ )&#123;</span><br><span class="line">        t += a[i] * b;</span><br><span class="line">        c.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (t)&#123;</span><br><span class="line">        c.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">get_primes</span>(a);  <span class="comment">// 预处理范围内的所有质数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i ++ )<span class="comment">/*求每个质因数的次数*/</span>&#123;</span><br><span class="line">    <span class="type">int</span> p = primes[i];</span><br><span class="line">    sum[i] = <span class="built_in">get</span>(a, p) - <span class="built_in">get</span>(b, p) - <span class="built_in">get</span>(a - b, p);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">res.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i ++ )     <span class="comment">// 用高精度乘法将所有质因子相乘</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; sum[i]; j ++ )</span><br><span class="line">        res = <span class="built_in">mul</span>(res, primes[i]);</span><br></pre></td></tr></table></figure><hr><h2 id="Gaussian-Elimination"><a href="#Gaussian-Elimination" class="headerlink" title="Gaussian Elimination"></a>Gaussian Elimination</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a[N][N]是增广矩阵</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gauss</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> c, r;</span><br><span class="line">    <span class="keyword">for</span> (c = <span class="number">0</span>, r = <span class="number">0</span>; c &lt; n; c ++ )&#123;</span><br><span class="line">        <span class="type">int</span> t = r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i ++ )   <span class="comment">// 找到绝对值最大的行</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; <span class="built_in">fabs</span>(a[t][c]))</span><br><span class="line">                t = i;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[t][c]) &lt; eps) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = c; i &lt;= n; i ++ ) <span class="built_in">swap</span>(a[t][i], a[r][i]);      <span class="comment">// 将绝对值最大的行换到最顶端</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= c; i -- ) a[r][i] /= a[r][c];      <span class="comment">// 将当前行的首位变成1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r + <span class="number">1</span>; i &lt; n; i ++ )       <span class="comment">// 用当前行将下面所有的列消成0</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; eps)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= c; j -- )</span><br><span class="line">                    a[i][j] -= a[r][j] * a[i][c];</span><br><span class="line">        r ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; n)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][n]) &gt; eps)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// 无解</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 有无穷多组解</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j ++ )</span><br><span class="line">            a[i][n] -= a[i][j] * a[j][n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 有唯一解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Chinese-Remainder-Theorem"><a href="#Chinese-Remainder-Theorem" class="headerlink" title="Chinese Remainder Theorem"></a>Chinese Remainder Theorem</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中国剩余定理可求解一元线性同余方程组</span></span><br><span class="line"><span class="function">ll <span class="title">CRT</span><span class="params">(<span class="type">int</span> k, ll* a, ll* r)</span> </span>&#123;</span><br><span class="line">    ll n = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) n = n * r[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        ll m = n / r[i], b, y;</span><br><span class="line">        <span class="built_in">exgcd</span>(m, r[i], b, y);  <span class="comment">// b * m mod r[i] = 1</span></span><br><span class="line">        ans = (ans + a[i] * m * b % n) % n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ans % n + n) % n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="Other-Algorithm"><a href="#Other-Algorithm" class="headerlink" title="Other Algorithm"></a>Other Algorithm</h1><h2 id="BFS-amp-DFS"><a href="#BFS-amp-DFS" class="headerlink" title="BFS &amp; DFS"></a>BFS &amp; DFS</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BFS</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BFS</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 表示1号点已经被遍历过</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="comment">/*遍历所有当前点的相邻位置*/</span>)&#123;</span><br><span class="line">            <span class="comment">// 用变量xxx表示新的点</span></span><br><span class="line">            <span class="keyword">if</span> (!st[<span class="comment">/*xxx*/</span>])&#123;</span><br><span class="line">                st[<span class="comment">/*xxx*/</span>] = <span class="literal">true</span>; <span class="comment">// 表示点j已经被遍历过</span></span><br><span class="line">                q.<span class="built_in">push</span>(<span class="comment">/*xxx*/</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// DFS</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">// st[u] 表示点u已经被遍历过</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="comment">/*遍历所有当前点的相邻位置*/</span>)&#123;</span><br><span class="line">        <span class="comment">// 用变量xxx表示新的点</span></span><br><span class="line">        <span class="keyword">if</span> (!st[<span class="comment">/*xxx*/</span>]) &#123;</span><br><span class="line">            <span class="built_in">DFS</span>(<span class="comment">/*xxx*/</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整数二分：</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;    <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 浮点数二分：</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">bsearch_3</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;   <span class="comment">// eps 表示精度，取决于题目对精度的要求</span></span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)&#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>KMP：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度</span></span><br><span class="line"><span class="comment">// 求模式串的Next数组：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i ++ )&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">    ne[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 匹配</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">    <span class="keyword">if</span> (j == m)&#123;</span><br><span class="line">        j = ne[j];</span><br><span class="line">        <span class="comment">// 匹配成功后的逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字串Substr：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;HelloWorld&quot;</span>;</span><br><span class="line">    <span class="comment">// substr(l, len) = [l, len)</span></span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, <span class="number">9</span>)&#123;</span><br><span class="line">        cout &lt;&lt; str.<span class="built_in">substr</span>(<span class="number">0</span>, i) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, <span class="number">9</span>)&#123;</span><br><span class="line">    cout &lt;&lt; str.<span class="built_in">substr</span>(<span class="number">9</span> - i, i) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// substr(l) = [l, end]</span></span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, <span class="number">9</span>)&#123;</span><br><span class="line">        cout &lt;&lt; str.<span class="built_in">substr</span>(i) &lt;&lt; endl;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Discretization-amp-Prefix-sum-amp-Difference"><a href="#Discretization-amp-Prefix-sum-amp-Difference" class="headerlink" title="Discretization &amp; Prefix sum &amp; Difference"></a>Discretization &amp; Prefix sum &amp; Difference</h2><p>高维前缀和</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="comment">//先求数组a关于第一个维度的前缀和&#123;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">        a[i][j]=a[i][j]+a[i][j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">    <span class="comment">//在已经求完一个维度前缀和的基础上求数组a关于第二个维度的前缀和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">        a[i][j]=a[i][j]+a[i<span class="number">-1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这种方式可以理解成二维前缀和是数组在求完关于第一个维度的前缀和，</span></span><br><span class="line"><span class="comment">然后再for一遍求它关于第二个维度的前缀和。</span></span><br><span class="line"><span class="comment">然后它在求三维以上前缀和的时候，就体现出这种写法在高维前缀和上的优越性了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=p;++k)&#123;</span><br><span class="line">            a[i][j][k]+=a[i<span class="number">-1</span>][j][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=p;++k)&#123;</span><br><span class="line">            a[i][j][k]+=a[i][j<span class="number">-1</span>][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=p;++k)&#123;</span><br><span class="line">            a[i][j][k]+=a[i][j][k<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// 无需借助容斥原理，求高维前缀和的复杂度变为O(|高维空间容量|*k)，可以处理k稍大一些的情况。</span></span><br></pre></td></tr></table></figure><p>差分：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    b[l] += c; b[r+<span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 二维</span></span><br><span class="line">a[i][j] = s[i][j] - s[i - <span class="number">1</span>][j] - s[i][j - <span class="number">1</span>] + s[i - <span class="number">1</span>][j - <span class="number">1</span>];<span class="comment">//子矩形加</span></span><br></pre></td></tr></table></figure><hr><h2 id="Double-Pointer"><a href="#Double-Pointer" class="headerlink" title="Double Pointer"></a>Double Pointer</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ )&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; i &amp;&amp; <span class="built_in">check</span>(i, j)) j ++ ;</span><br><span class="line">    <span class="comment">// 具体问题的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 常见问题分类：</span></span><br><span class="line"><span class="comment">    (1) 对于一个序列，用两个指针维护一段区间</span></span><br><span class="line"><span class="comment">    (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作 */</span></span><br></pre></td></tr></table></figure><hr><h2 id="High-Precision"><a href="#High-Precision" class="headerlink" title="High Precision"></a>High Precision</h2><p>高精度加：（没搞懂怎么用）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">add</span>(B, A);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )&#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>高精度减：（也没搞懂）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; <span class="built_in">int</span>(A.<span class="built_in">size</span>()); i ++ )&#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="built_in">int</span>(B.<span class="built_in">size</span>())) t -= B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">int</span>(C.<span class="built_in">size</span>()) &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Bit-Operation"><a href="#Bit-Operation" class="headerlink" title="Bit Operation"></a>Bit Operation</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回x的最后一位1以及以后</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x &amp; -x; &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Quick-Readin"><a href="#Quick-Readin" class="headerlink" title="Quick Readin"></a>Quick Readin</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">rd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+ch-<span class="string">&#x27;0&#x27;</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Game-Theory"><a href="#Game-Theory" class="headerlink" title="Game Theory"></a>Game Theory</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">（更多是在平等博弈下讨论的）</span><br><span class="line">假设我们的游戏是**无环的**，即*不会存在能回到原来的状态从而无限进行下去的可能*；</span><br><span class="line">则该游戏存在的所有状态构成一个**有向无环图**；</span><br><span class="line">*注：以下都是基于Alice和Bob轮流进行游戏的情况下*</span><br><span class="line">**先手必胜态**和**先手必败态**都是指的当前局面下，下一步谁来走，而不是整局游戏的先手。</span><br><span class="line">必胜态触发的两种情况：（对必败态同理）</span><br><span class="line">1. 达到终止条件（胜利条件）</span><br><span class="line">2. 存在一个后继为必败态（随着后续的步骤会转变到必败态）</span><br><span class="line">如果存在平局的情况，那么我们可以采用：胜1平0负-1的状态表示方式，此时我们的dp方程就是min(后继)；</span><br><span class="line">不难想到，无论是平等博弈还是不平等博弈，我们都可以从**终点开始枚举**所有的状态，利用**动态规划**的思想。</span><br><span class="line">那么，什么情况下不能dp呢？</span><br><span class="line">就是当游戏局面很多的时候，没有办法把所有的状态都记下来的时候，就需要用到博弈论的手法了。</span><br></pre></td></tr></table></figure><hr><h2 id="Team-Mo"><a href="#Team-Mo" class="headerlink" title="Team Mo"></a>Team Mo</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> sign)</span> </span>&#123; <span class="comment">/*update nowAns*/</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">BLOCK_SIZE = <span class="built_in">int</span>(<span class="built_in">ceil</span>(<span class="built_in">pow</span>(n, <span class="number">0.5</span>)));</span><br><span class="line"><span class="built_in">sort</span>(querys, querys + m);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">    <span class="type">const</span> query &amp;q = querys[i];</span><br><span class="line">    <span class="keyword">while</span> (l &gt; q.l) <span class="built_in">move</span>(--l, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (r &lt; q.r) <span class="built_in">move</span>(r++, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (l &lt; q.l) <span class="built_in">move</span>(l++, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">while</span> (r &gt; q.r) <span class="built_in">move</span>(--r, <span class="number">-1</span>);</span><br><span class="line">    ans[q.id] = nowAns;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Computation-Geometry"><a href="#Computation-Geometry" class="headerlink" title="Computation Geometry"></a>Computation Geometry</h1><ul><li>精度：减少正反三角函数、除法、根号的使用次数。</li><li>简洁：多归纳，多模块化，少分类讨论。</li><li>除零： 所有除法都要考虑<code>0</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = b → abs(a − b) &lt; eps</span><br><span class="line">a &lt; b → a &lt; b − eps</span><br><span class="line">a &gt; b → a &gt; b + eps</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断两线段是否相交</span></span><br><span class="line"><span class="comment">// 注意：如果有#include &lt;math.h&gt;则需要注意y1, y2等变量需要放进局部变量而非全局变量，因为math.h中有同名函数。</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span> &#123;</span><br><span class="line">    <span class="type">double</span> x1;</span><br><span class="line">    <span class="type">double</span> y1;</span><br><span class="line">    <span class="type">double</span> x2;</span><br><span class="line">    <span class="type">double</span> y2;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">intersection</span><span class="params">(<span class="type">const</span> Line &amp;l1, <span class="type">const</span> Line &amp;l2)</span></span>&#123;</span><br><span class="line">    <span class="comment">//快速排斥实验</span></span><br><span class="line">    <span class="keyword">if</span> ((l1.x1 &gt; l1.x2 ? l1.x1 : l1.x2) &lt; (l2.x1 &lt; l2.x2 ? l2.x1 : l2.x2) ||</span><br><span class="line">        (l1.y1 &gt; l1.y2 ? l1.y1 : l1.y2) &lt; (l2.y1 &lt; l2.y2 ? l2.y1 : l2.y2) ||</span><br><span class="line">        (l2.x1 &gt; l2.x2 ? l2.x1 : l2.x2) &lt; (l1.x1 &lt; l1.x2 ? l1.x1 : l1.x2) ||</span><br><span class="line">        (l2.y1 &gt; l2.y2 ? l2.y1 : l2.y2) &lt; (l1.y1 &lt; l1.y2 ? l1.y1 : l1.y2))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//跨立实验</span></span><br><span class="line">    <span class="keyword">if</span> ((((l1.x1 - l2.x1)*(l2.y2 - l2.y1) - (l1.y1 - l2.y1)*(l2.x2 - l2.x1))*</span><br><span class="line">        ((l1.x2 - l2.x1)*(l2.y2 - l2.y1) - (l1.y2 - l2.y1)*(l2.x2 - l2.x1))) &gt; <span class="number">0</span> ||</span><br><span class="line">        (((l2.x1 - l1.x1)*(l1.y2 - l1.y1) - (l2.y1 - l1.y1)*(l1.x2 - l1.x1))*</span><br><span class="line">        ((l2.x2 - l1.x1)*(l1.y2 - l1.y1) - (l2.y2 - l1.y1)*(l1.x2 - l1.x1))) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>偷的板子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);  <span class="comment">//π</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-8</span>;       <span class="comment">//精度控制</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> inf = <span class="number">1e100</span>;      <span class="comment">//无穷大</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sgn</span><span class="params">(<span class="type">double</span> s)</span>              <span class="comment">//判断浮点数的符号</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(s) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span>  <span class="comment">//判断x和y的大小关系,-1表示x&lt;y</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(x - y) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; y) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">r2d</span><span class="params">(<span class="type">double</span> rad)</span>  <span class="comment">//弧度转角度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rad / pi * <span class="number">180.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">d2r</span><span class="params">(<span class="type">double</span> degree)</span>  <span class="comment">//角度转弧度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> degree / <span class="number">180.0</span> * pi;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>  <span class="comment">//点与向量</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">double</span> a = <span class="number">0</span>, <span class="type">double</span> b = <span class="number">0</span>)</span><br><span class="line">        : <span class="built_in">x</span>(a), <span class="built_in">y</span>(b) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">()</span>  <span class="comment">//输入</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">debug</span><span class="params">()</span>  <span class="comment">//输出</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(%lf,%lf)\n&quot;</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>+(Point b)  <span class="comment">//向量相加</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Point</span>(x + b.x, y + b.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>-(Point b)  <span class="comment">//向量相减</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Point</span>(x - b.x, y - b.y);</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>*(<span class="type">double</span> b)  <span class="comment">//向量数乘</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Point</span>(x * b, y * b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> <span class="keyword">operator</span>*(Point b)  <span class="comment">//向量内积</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x * b.x + y * b.y;</span><br><span class="line">    &#125;</span><br><span class="line">    Point <span class="keyword">operator</span>/(<span class="type">double</span> b)  <span class="comment">//除法</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Point</span>(x / b, y / b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Point&amp; b)  <span class="comment">//大小比较</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">cmp</span>(x, b.x) == <span class="number">0</span>) <span class="keyword">return</span> y &lt; b.y;</span><br><span class="line">        <span class="keyword">return</span> x &lt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Point&amp; b)  <span class="comment">//判等</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">cmp</span>(x, b.x) == <span class="number">0</span> &amp;&amp; <span class="built_in">cmp</span>(y, b.y) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">cross</span><span class="params">(Point b)</span> <span class="type">const</span>  <span class="comment">//向量叉乘</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * b.y - y * b.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">angle</span><span class="params">()</span>  <span class="comment">//极角,弧度(-pi, pi]</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">atan2</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">length</span><span class="params">()</span>  <span class="comment">//模</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>((*<span class="keyword">this</span>) * (*<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">length2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (*<span class="keyword">this</span>) * (*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">angleTo</span><span class="params">(Point b)</span>  <span class="comment">//向量角度,弧度</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">acos</span>(((*<span class="keyword">this</span>) * b) / <span class="built_in">length</span>() / b.<span class="built_in">length</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">angleTo</span><span class="params">(Point a, Point b)</span>  <span class="comment">//从该点看其它两点的角度,弧度</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Point</span>(a - *<span class="keyword">this</span>).<span class="built_in">angleTo</span>(b - *<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">(Point a, Point b)</span>  <span class="comment">//求三点组成平行四边形有向面积</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (a - *<span class="keyword">this</span>).<span class="built_in">cross</span>(b - *<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">dist</span><span class="params">(Point b)</span>  <span class="comment">//求两点间欧式距离</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (*<span class="keyword">this</span> - b).<span class="built_in">length</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">dist2</span><span class="params">(Point b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (*<span class="keyword">this</span> - b).<span class="built_in">length2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">manhattanDis</span><span class="params">(Point b)</span>  <span class="comment">//求两点间曼哈顿距离</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">fabs</span>(x - b.x) + <span class="built_in">fabs</span>(y - b.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">rotate</span><span class="params">(Point p, <span class="type">double</span> ang)</span>  <span class="comment">//绕点p逆时针旋转ang弧度,不修改本身的值</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Point v = (*<span class="keyword">this</span>) - p;</span><br><span class="line">        <span class="type">double</span> c = <span class="built_in">cos</span>(ang), s = <span class="built_in">sin</span>(ang);</span><br><span class="line">        <span class="keyword">return</span> p + <span class="built_in">Point</span>(v.x * c - v.y * s, v.x * s + v.y * c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">rotate</span><span class="params">(<span class="type">double</span> ang)</span>  <span class="comment">//直接逆时针旋转ang弧度</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rotate</span>(<span class="built_in">Point</span>(<span class="number">0</span>, <span class="number">0</span>), ang);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">rotLeft</span><span class="params">()</span>  <span class="comment">//左转90</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Point</span>(-y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">rotRight</span><span class="params">()</span>  <span class="comment">//右转90</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Point</span>(y, -x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">regular</span><span class="params">()</span>  <span class="comment">//化为单位向量</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> / <span class="built_in">length</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">normal</span><span class="params">()</span>  <span class="comment">//左转90的单位法向量</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rotLeft</span>().<span class="built_in">regular</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">trunc</span><span class="params">(<span class="type">double</span> r)</span>  <span class="comment">//化为长度为r的向量</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">regular</span>() * r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">parrelTo</span><span class="params">(Point b)</span>  <span class="comment">//向量平行</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sgn</span>(<span class="built_in">cross</span>(b)) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">verticalTo</span><span class="params">(Point b)</span>  <span class="comment">//向量垂直</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sgn</span>((*<span class="keyword">this</span>) * b) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">toLeftTest</span><span class="params">(Point from, Point to, Point test)</span>  <span class="comment">//测试test在不在from-&gt;to的左边,1在左边,-1在右边,0共线</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sgn</span>((to - from).<span class="built_in">cross</span>(test - to));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Circle</span>  <span class="comment">//圆</span></span><br><span class="line">&#123;</span><br><span class="line">    Point o;   <span class="comment">//圆心</span></span><br><span class="line">    <span class="type">double</span> r;  <span class="comment">//半径</span></span><br><span class="line">    <span class="built_in">Circle</span>(Point o = <span class="built_in">Point</span>(), <span class="type">double</span> r = <span class="number">0.0</span>)</span><br><span class="line">        : <span class="built_in">o</span>(o), <span class="built_in">r</span>(r) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf%lf&quot;</span>, &amp;o.x, &amp;o.y, &amp;r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">debug</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(%lf,%lf,%lf)\n&quot;</span>, o.x, o.y, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Circle <span class="title">invertToCicle</span><span class="params">(Point P, <span class="type">double</span> R)</span>  <span class="comment">//外部反演点反演,反演为圆; p为反演中心,r为反演半径</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Circle ans;</span><br><span class="line">        <span class="type">double</span> d1 = P.<span class="built_in">dist</span>(o);</span><br><span class="line">        ans.r = r / (d1 * d1 - r * r) * R * R;</span><br><span class="line">        <span class="type">double</span> d2 = R * R / (d1 - r) - ans.r;</span><br><span class="line">        ans.o = P + (o - P) * (d2 / d1);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span></span><br><span class="line">&#123;</span><br><span class="line">    Point pos;</span><br><span class="line">    Vector to;</span><br><span class="line">    <span class="built_in">Line</span>(Point p = <span class="built_in">Point</span>(), Vector t = <span class="built_in">Point</span>())  <span class="comment">//顶点和方向向量</span></span><br><span class="line">        : <span class="built_in">pos</span>(p), <span class="built_in">to</span>(t)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> Line <span class="title">tp</span><span class="params">(Point a, Point b)</span>  <span class="comment">//两点构造</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Line</span>(a, b - a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Line</span>(<span class="type">double</span> x1, <span class="type">double</span> y1, <span class="type">double</span> x2, <span class="type">double</span> y2)  <span class="comment">//两点构造</span></span><br><span class="line">    &#123;</span><br><span class="line">        pos = <span class="built_in">Point</span>(x1, y1), to = <span class="built_in">Point</span>(x2, y2) - <span class="built_in">Point</span>(x1, y1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">point</span><span class="params">(<span class="type">double</span> s)</span>  <span class="comment">//获取某处的一个点</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pos + to * s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">angle</span><span class="params">()</span>  <span class="comment">//获得直线倾角,[0,pi)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">acos</span>(to.<span class="built_in">regular</span>().x * <span class="built_in">sgn</span>(to.<span class="built_in">regular</span>().y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">onLine</span><span class="params">(Point s)</span>  <span class="comment">//判断点与直线的位置关系0在直线外;1在直线上</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sgn</span>(to.<span class="built_in">cross</span>(s - pos)) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(Line l)  <span class="comment">//两条直线是否是同一条(重合)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> l.<span class="built_in">onLine</span>(<span class="built_in">point</span>(<span class="number">0</span>)) &amp;&amp; l.<span class="built_in">onLine</span>(<span class="built_in">point</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(Line l)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> !((*<span class="keyword">this</span>) == l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">parrelTo</span><span class="params">(Line l)</span>  <span class="comment">//直线平行</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> to.<span class="built_in">parrelTo</span>(l.to);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">verticalTo</span><span class="params">(Line l)</span>  <span class="comment">//直线垂直</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> to.<span class="built_in">verticalTo</span>(l.to);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">insWithLine</span><span class="params">(Line l)</span>  <span class="comment">//与另一条直线的交点</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">point</span>(l.to.<span class="built_in">cross</span>(pos - l.pos) / to.<span class="built_in">cross</span>(l.to));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">disToPoint</span><span class="params">(Point s)</span>  <span class="comment">//点到直线的距离</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">fabs</span>(to.<span class="built_in">cross</span>(s - pos) / to.<span class="built_in">length</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">projection</span><span class="params">(Point s)</span>  <span class="comment">//点在直线上的投影</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">point</span>((to * (s - pos)) / (to * to));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Circle <span class="title">invertToCircle</span><span class="params">(Point P, <span class="type">double</span> R)</span>  <span class="comment">//直线外一点反演为圆</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">Line <span class="title">lp</span><span class="params">(P, to.rotLeft())</span></span>;</span><br><span class="line">        Point ps = <span class="keyword">this</span>-&gt;<span class="built_in">insWithLine</span>(lp);</span><br><span class="line">        Circle c;</span><br><span class="line">        c.r = R * R / <span class="keyword">this</span>-&gt;<span class="built_in">disToPoint</span>(P) / <span class="number">2.0</span>;</span><br><span class="line">        c.o = P + (ps - P).<span class="built_in">regular</span>() * c.r;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">disToSegment</span><span class="params">(Point s, Point a, Point b)</span>  <span class="comment">//点到线段ab最短距离</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> (s - a).<span class="built_in">length</span>();</span><br><span class="line">    Vector v1 = b - a, v2 = s - a, v3 = s - b;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sgn</span>(v1 * v2) &lt; <span class="number">0</span>) <span class="keyword">return</span> v2.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sgn</span>(v1 * v3) &gt; <span class="number">0</span>) <span class="keyword">return</span> v3.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Line</span>(a, b - a).<span class="built_in">disToPoint</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">(Point a, Point b, Point c)</span>  <span class="comment">//三角形面积</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>((b - a).<span class="built_in">cross</span>(c - a) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">onSegment</span><span class="params">(Point p, Point a, Point b)</span>  <span class="comment">//点是否在线段上</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">sgn</span>((a - p).<span class="built_in">cross</span>(b - p)) == <span class="number">0</span> &amp;&amp; <span class="built_in">sgn</span>((a - p) * (b - p)) &lt; <span class="number">0</span>) || p == a || p == b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">insWithSegment</span><span class="params">(Line l, Point a, Point b, Point&amp; ans)</span>  <span class="comment">//直线与线段相交</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l.<span class="built_in">parrelTo</span>(<span class="built_in">Line</span>(a, b - a))) <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//不相交</span></span><br><span class="line">    ans = l.<span class="built_in">insWithLine</span>(<span class="built_in">Line</span>(a, b - a));</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">onSegment</span>(ans, a, b)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (ans == a || ans == b) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//与端点相交</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;                            <span class="comment">//相交</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">segmentIns</span><span class="params">(Point a1, Point a2, Point b1, Point b2)</span>  <span class="comment">//判断线段是否相交</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> c1 = (a2 - a1).<span class="built_in">cross</span>(b1 - a1), c2 = (a2 - a1).<span class="built_in">cross</span>(b2 - a1);</span><br><span class="line">    <span class="type">double</span> c3 = (b2 - b1).<span class="built_in">cross</span>(a1 - b1), c4 = (b2 - b1).<span class="built_in">cross</span>(a2 - b1);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">sgn</span>(c1) || !<span class="built_in">sgn</span>(c2) || !<span class="built_in">sgn</span>(c3) || !<span class="built_in">sgn</span>(c4)) &#123;  <span class="comment">//控制是否可以在顶点处相交</span></span><br><span class="line">        <span class="type">bool</span> f1 = <span class="built_in">onSegment</span>(b1, a1, a2);</span><br><span class="line">        <span class="type">bool</span> f2 = <span class="built_in">onSegment</span>(b2, a1, a2);</span><br><span class="line">        <span class="type">bool</span> f3 = <span class="built_in">onSegment</span>(a1, b1, b2);</span><br><span class="line">        <span class="type">bool</span> f4 = <span class="built_in">onSegment</span>(a2, b1, b2);</span><br><span class="line">        <span class="type">bool</span> f = (f1 | f2 | f3 | f4);</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sgn</span>(c1) * <span class="built_in">sgn</span>(c2) &lt; <span class="number">0</span> &amp;&amp; <span class="built_in">sgn</span>(c3) * <span class="built_in">sgn</span>(c4) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">polygonArea</span><span class="params">(Point* p, <span class="type">int</span> n)</span>  <span class="comment">//计算多边形有向面积,点需要按顺序排列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) s += (p[i] - p[<span class="number">0</span>]).<span class="built_in">cross</span>(p[i + <span class="number">1</span>] - p[<span class="number">0</span>]) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">polygonPerimeter</span><span class="params">(Point* p, <span class="type">int</span> n)</span>  <span class="comment">//计算多边形周长,点需要按顺序排列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> ans = <span class="number">0</span>;</span><br><span class="line">    p[n] = p[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) ans += p[i].<span class="built_in">dist</span>(p[i + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quad</span><span class="params">(Point a)</span>  <span class="comment">// 判断象限的函数，每个象限包括半个坐标轴</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">cmp</span>(a.x, <span class="number">0</span>) &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">cmp</span>(a.y, <span class="number">0</span>) &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">cmp</span>(a.x, <span class="number">0</span>) &lt;= <span class="number">0</span> &amp;&amp; <span class="built_in">cmp</span>(a.y, <span class="number">0</span>) &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">cmp</span>(a.x, <span class="number">0</span>) &lt; <span class="number">0</span> &amp;&amp; <span class="built_in">cmp</span>(a.y, <span class="number">0</span>) &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">cmp</span>(a.x, <span class="number">0</span>) &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">cmp</span>(a.y, <span class="number">0</span>) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sortByPolarAngle</span><span class="params">(Point at, Point* begin, Point* end)</span>  <span class="comment">//极角逆时针排序，以at为极点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(begin, end, [&amp;](Point a, Point b) &#123;</span><br><span class="line">        a = a - at, b = b - at;</span><br><span class="line">        <span class="type">int</span> l1 = <span class="built_in">quad</span>(a), l2 = <span class="built_in">quad</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (l1 == l2) &#123;</span><br><span class="line">            <span class="type">double</span> c = a.<span class="built_in">cross</span>(b);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">cmp</span>(c, <span class="number">0</span>) &gt; <span class="number">0</span> || (<span class="built_in">cmp</span>(c, <span class="number">0</span>) == <span class="number">0</span> &amp;&amp; a.<span class="built_in">length</span>() &lt; b.<span class="built_in">length</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l1 &lt; l2;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gramhamScan</span><span class="params">(Point* res, <span class="type">int</span> n, Point* ans)</span>  <span class="comment">//求凸包,O(nlogn),ans存放答案,返回凸包上点的数量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Point p = res[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, top = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (res[i] &lt; p) p = res[i], k = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(res[<span class="number">0</span>], res[k]), <span class="built_in">sortByPolarAngle</span>(res[<span class="number">0</span>], res + <span class="number">1</span>, res + n), ans[<span class="number">0</span>] = res[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &gt; <span class="number">2</span> &amp;&amp; <span class="built_in">sgn</span>((ans[top - <span class="number">1</span>] - ans[top - <span class="number">2</span>]).<span class="built_in">cross</span>(res[i] - ans[top - <span class="number">2</span>])) &lt;= <span class="number">0</span>) --top;</span><br><span class="line">        ans[top++] = res[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">rotatingCalipers</span><span class="params">(Point* poly, <span class="type">int</span> n)</span>  <span class="comment">//旋转卡壳,返回凸包直径</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">2</span>;</span><br><span class="line">    poly[n] = poly[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">area</span>(poly[i], poly[i + <span class="number">1</span>], poly[j]) &lt; <span class="built_in">area</span>(poly[i], poly[i + <span class="number">1</span>], poly[j + <span class="number">1</span>])) &#123;</span><br><span class="line">            ++j;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; n) j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, <span class="built_in">max</span>(poly[i].<span class="built_in">dist</span>(poly[j]), poly[i + <span class="number">1</span>].<span class="built_in">dist</span>(poly[j])));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isPointInPolygon</span><span class="params">(Point p, Point* poly, <span class="type">int</span> n)</span>  <span class="comment">//点在多边形内1;在外-1;在边界上0</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> wn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">onSegment</span>(p, poly[i], poly[(i + <span class="number">1</span>) % n])) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> k = <span class="built_in">sgn</span>((poly[(i + <span class="number">1</span>) % n] - poly[i]).<span class="built_in">cross</span>(p - poly[i]));</span><br><span class="line">        <span class="type">int</span> d1 = <span class="built_in">sgn</span>(poly[i].y - p.y);</span><br><span class="line">        <span class="type">int</span> d2 = <span class="built_in">sgn</span>(poly[(i + <span class="number">1</span>) % n].y - p.y);</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; d1 &lt;= <span class="number">0</span> &amp;&amp; d2 &gt; <span class="number">0</span>) wn++;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">0</span> &amp;&amp; d2 &lt;= <span class="number">0</span> &amp;&amp; d1 &gt; <span class="number">0</span>) wn--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wn != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前言：&lt;/p&gt;
&lt;p&gt;2023.03.18正式退役啦，特此来把之前杂乱无章且错误百出的，有关算法竞赛的博客整合起来，汇总成此篇博客。&lt;/p&gt;
&lt;p&gt;（其实是我自己的板子，如果大家有需要就拿去就好啦，能帮到各位的话也算是一种传承吧）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;个</summary>
      
    
    
    
    <category term="XCPC" scheme="https://conqueror712.github.io/categories/XCPC/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机网络 - 上丨学习记录</title>
    <link href="https://conqueror712.github.io/post/Computer-Network.html"/>
    <id>https://conqueror712.github.io/post/Computer-Network.html</id>
    <published>2023-02-09T12:03:22.000Z</published>
    <updated>2023-03-23T01:35:18.929Z</updated>
    
    <content type="html"><![CDATA[<p><em>Computer Networking A Top-Down Approach Learning Note Part 1</em></p><p><strong>前言的前言的前言</strong>：</p><blockquote><p>个人博客：<a href="https://conqueror712.github.io/">https://conqueror712.github.io/</a></p><p>知乎：<a href="https://www.zhihu.com/people/soeur712/posts">https://www.zhihu.com/people/soeur712/posts</a></p><p>Bilibili：<a href="https://space.bilibili.com/57089326">https://space.bilibili.com/57089326</a></p><p>掘金：<a href="https://juejin.cn/user/1297878069809725/posts">https://juejin.cn/user/1297878069809725/posts</a></p></blockquote><hr><p><strong>前言的前言</strong>：</p><p>本文是笔者初学计算机网络的笔记和一些心得，难免会有部分疏漏和错误，还请各位读者积极指出，不吝赐教。</p><p>有一些内容是笔者认为对自己暂时没那么重要的部分，就没有放上去，具体的内容可以查看相关的书籍。</p><p>还有要补充的就是，计算机网络的学习记录将会分为上中下三部分，这一部分，也就是上，主要是涵盖了《自顶向下计算机网络》的第一章部分，因为是初学，笔者对于很多概念还比较陌生，加之这一章节与其他章节的性质不同，是一个概览，所以单独把这一章节放在上这一部分。</p><p>事不宜迟，我们开始吧！</p><hr><h1 id="Unit-1-计算机网络概述"><a href="#Unit-1-计算机网络概述" class="headerlink" title="Unit 1 计算机网络概述"></a>Unit 1 计算机网络概述</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>该课程的总体教学目标需要掌握计网的什么？</p><ul><li>基本概念</li><li>工作原理</li><li>常用技术</li></ul><p>计算机网络为什么比较难学？</p><p>有很多的**”定性的、逻辑描述的推理”**；</p><p>与数学物理不同，倒是有点像政治，有着比较强的**”表述性”**；</p><p>在学习的过程中应当”取其精华”，尤其是面对一些晦涩难懂且冗长的概念。</p><p>这一章节作为导论，有什么”关键词”吗？</p><p><strong>框架、术语、原理、历史。</strong></p><p>此外，每一章大致分为两个部分：原理 + 实例；</p><p>其中，原理又有两个部分：功能 + 服务（一般是向上层提供接口的服务）</p><p><img src="https://s2.loli.net/2023/02/05/CmaRS2pUiZKVYP5.png" alt="avatar"></p><hr><h2 id="什么是Internet"><a href="#什么是Internet" class="headerlink" title="什么是Internet?"></a>什么是Internet?</h2><p><img src="https://s2.loli.net/2023/02/05/ejtp8fUq4HBGIRO.png" alt="avatar"></p><h3 id="从具体构成角度："><a href="#从具体构成角度：" class="headerlink" title="从具体构成角度："></a>从具体构成角度：</h3><p>互联网只是网络的一种，广义的网络就是<strong>节点 + 边</strong>，例如蜘蛛网、家族图谱等等。</p><p><img src="https://cdnjson.com/images/2023/03/23/image5d8db9ed618aaa1b.png" alt="avatar"></p><ul><li>主机节点：主机<code>host</code> &#x3D; 端系统<code>end system</code>，图例是<code>□</code>，还包括运行的网络应用程序；</li><li>数据交换节点：负责转发数据，图例是<code>○</code>；</li><li>通信链路：以<code>带宽bps，即bit/s</code>作为传输速率衡量标准，常见的有光纤、同轴电缆、卫星、无线电等；</li><li>接入链路：<code>□与○之间</code>；</li><li>骨干链路：<code>○与○之间</code>；</li><li>交换机：在链路层；</li><li>路由器：在网络层；</li></ul><h4 id="互联网："><a href="#互联网：" class="headerlink" title="互联网："></a>互联网：</h4><ul><li>由TCP和IP协议为主的一簇协议支撑工作的那个网，概括来说可以称为<strong>网络的网络</strong>；</li><li>松散的层次结构，互联的ISP (Internet Service Provider)因特网服务提供商；</li><li>公共Internet，专用intranet；</li><li>标准：RFC文档 → IETF；</li></ul><h4 id="协议："><a href="#协议：" class="headerlink" title="协议："></a>协议：</h4><ul><li>对等层的实体，在通信的过程中需要遵守的规范的集合。</li><li>协议控制发送</li><li>定义了在两个或多个通信实体之间交换的报文<strong>格式</strong>和<strong>次序</strong>，以及在报文传输、接收或其他事件方面所采取的<strong>动作</strong>。</li><li>PDU (Protocol Data Unit)协议数据单元，是指对等层次之间传递的数据单位。<ul><li>物理层的PDU是<code>bit</code></li><li>数据链路层的PDU是<code>数据帧frame</code></li><li>网络层的PDU是<code>数据包packet</code></li><li>传输层的PDU是<code>数据段segment</code></li><li>其他更高层次的PDU是数据<code>data</code></li></ul></li></ul><h3 id="从服务角度："><a href="#从服务角度：" class="headerlink" title="从服务角度："></a>从服务角度：</h3><p>包括分布式应用进程和为分布式应用进程提供通讯服务的基础设施。</p><h4 id="分布式应用进程："><a href="#分布式应用进程：" class="headerlink" title="分布式应用进程："></a>分布式应用进程：</h4><p>使用通信设施进行通信，包括Web、VoIP、Email、社交网络、电商等等；</p><h4 id="基础设施："><a href="#基础设施：" class="headerlink" title="基础设施："></a>基础设施：</h4><p>形式是API，将发送和接收数据的APPS与互联网连接起来，组成如下：</p><ul><li>主机</li><li>应用层以下的所有协议实体</li><li>网络的部分</li></ul><p>类型如下：区别就在于”打招呼与否”</p><ul><li>面向连接的可靠服务，用<code>TCP / IP()</code></li><li>无连接的不可靠服务，用<code>UDP</code></li></ul><blockquote><p>[缩写说明]：</p><ul><li>TCP Transmission Control Protocal是传输控制协议；</li><li>IP Internet Protocol是网际协议；</li><li>IETF Internet Engineering Task Force因特网工程任务组；</li><li>RFC Request for commets请求评论；</li><li>API Application Programming Interface应用程序编程接口；</li></ul></blockquote><h3 id="谁在运营互联网？"><a href="#谁在运营互联网？" class="headerlink" title="谁在运营互联网？"></a>谁在运营互联网？</h3><p>没有人经营互联网。它被组织为一个分散的网络网络。</p><p>数以千计的公司、大学、政府和其他实体运营自己的网络，并根据<strong>自愿互连协议</strong>相互交换流量。</p><ul><li><strong>IETF</strong>（互联网工程任务组）组织管理了<strong>使互联网工作的共享技术标准</strong>。</li><li><strong>ICANN</strong>（互联网名称与数字地址分配机构）负责分发域名和IP地址（计算机用来在互联网上相互识别的数字），但是并不控制谁可以连接到互联网。</li></ul><p><img src="http://web.stanford.edu/class/msande91si/www-spr04/readings/week1/InternetWhitepaper_files/ruswp_diag4.gif" alt="avatar"></p><h3 id="什么是IPv6？"><a href="#什么是IPv6？" class="headerlink" title="什么是IPv6？"></a>什么是IPv6？</h3><p>目前的互联网标准，称为IPv4，只允许大约4亿个IP地址。这在1970年代被认为是一个很大的数字，但今天，IPv4地址的供应几乎耗尽。</p><p>因此，互联网工程师开发了一种名为IPv6的新标准。IPv6允许数量惊人，确切的数字是<strong>39位数</strong>，确保几乎永远不会再耗尽。</p><p>具体的结构等细节这里不展开叙述。</p><h3 id="无线互联网如何工作？"><a href="#无线互联网如何工作？" class="headerlink" title="无线互联网如何工作？"></a>无线互联网如何工作？</h3><p>无线互联网有两种基本类型：</p><ul><li>WIFI：任何人都可以购买WIFI网络设备，为了防止互相干扰，WIFI网络的功率和范围有严格的限制；</li><li>蜂窝：更加集中，通过将服务区域分解为单元来工作，单元小到一个街区，大到数英里宽，每个单元的重心都有一个塔来提供服务，当设备从一个小区移动到另一个小区时，网络会自动将设备从一个塔转移到另一个塔，允许用户继续通信而不会中断。蜂窝网络使用许可用于其<strong>专用的频谱</strong>，由于该频谱稀缺，因此通常通过拍卖授予。</li></ul><p><img src="http://web.stanford.edu/class/msande91si/www-spr04/readings/week1/InternetWhitepaper_files/ruswp_diag3.gif" alt="avatar"></p><h3 id="什么是云？"><a href="#什么是云？" class="headerlink" title="什么是云？"></a>什么是云？</h3><p>云描述了一种在 2000 年代初流行的计算方法。通过将文件存储在服务器上并通过互联网交付软件，云计算为用户提供了更简单、更可靠的计算体验。</p><hr><h2 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h2><p><img src="https://s2.loli.net/2023/02/06/UByjCsFYKgawRHn.png" alt="avatar"></p><h3 id="何为网络边缘？"><a href="#何为网络边缘？" class="headerlink" title="何为网络边缘？"></a>何为网络边缘？</h3><p><strong>采用网络设施的面向连接的服务；</strong></p><p>说白了，就是上文提到过的那些”方的”，也就是主机节点和应用程序<code>□</code>，它们是edge；</p><p>网络边缘是计算机网络的部件，当然还有其他的部件，一起构成了网络结构：</p><p><img src="https://cdnjson.com/images/2023/03/23/image743f3bbf41c6554c.png" alt="avatar"></p><hr><h3 id="应用进程间的通讯方式："><a href="#应用进程间的通讯方式：" class="headerlink" title="应用进程间的通讯方式："></a>应用进程间的通讯方式：</h3><p>主要有两种模式</p><h4 id="CS模式"><a href="#CS模式" class="headerlink" title="CS模式"></a>CS模式</h4><p>即客户端-服务器模式，这种模式是<strong>主从的</strong>，资源在服务器，客户端来请求之；</p><p>客户端是主动的，而服务器是被动的；</p><p>会有什么问题呢？</p><p>就是当Client太多的时候，需要好多的Server构成Server Farm，</p><p>从而导致更大的扩容代价和宕机代价，</p><p>总体来说就是<strong>可扩展性差</strong>。</p><h4 id="P2P模式"><a href="#P2P模式" class="headerlink" title="P2P模式"></a>P2P模式</h4><p>即peer - peer模式，是对等的一种模式，而非主从；</p><p>每个节点既可以是Client，也可以是Server，构成分布式的系统，<strong>可扩展性好</strong>；</p><p>例如迅雷等文件分发软件，就是利用P2P模式来进行更好的工作，传统的话是使用FTP；</p><blockquote><p>举例来说，如果你要下载一个文件，它会给你分成三个片段，你将会从不同的三个节点获得一部分片段，最后拼接汇集在一起，这样就实现了带宽的提升，速率的提升。</p></blockquote><hr><h3 id="关于连接服务："><a href="#关于连接服务：" class="headerlink" title="关于连接服务："></a>关于连接服务：</h3><p>共同点：都是采用网络设施进行的。</p><p><img src="https://cdnjson.com/images/2023/03/23/image30aa3f256f40a3aa.png" alt="avatar"></p><h4 id="TCP服务"><a href="#TCP服务" class="headerlink" title="TCP服务"></a>TCP服务</h4><ul><li>可靠：不出错、不乱序、不重复、不丢失；</li><li>流量控制：维护一个Balance，协调发送方和接收方的速率；</li><li>拥塞控制：维护一个Balance，协调链路上的节点的通行能力，类似道路车流量控制；</li></ul><h4 id="UDP服务"><a href="#UDP服务" class="headerlink" title="UDP服务"></a>UDP服务</h4><ul><li>无连接：上来就发送，就是任性</li><li>不可靠：丢了一些也没关系</li><li>无流量控制</li><li>无拥塞控制</li></ul><p>对于无连接服务，这里有补充：</p><p><img src="https://s2.loli.net/2023/02/09/IFwhJQifvaKbPu3.png" alt="avatar"></p><hr><h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><p>网络分类：</p><p><img src="https://cdnjson.com/images/2023/03/23/image7eaaa24dbd1b5bb1.png" alt="avatar"></p><p>基本问题：<strong>数据怎样通过网络进行传输？</strong></p><p>网络核心包括分组交换机以及网络链路，它们一起构成了<strong>网状网络</strong>；</p><h3 id="分组交换："><a href="#分组交换：" class="headerlink" title="分组交换："></a>分组交换：</h3><p>关键功能：<strong>路由 + 转发</strong></p><ul><li>路由：决定分组采用的源到目标的路径，路由算法；</li><li>转发：将分组从路由器的输入链路转移到输出链路；</li></ul><p>特点：</p><ul><li>将要传送的数据分成一个个单位：分组packet；</li><li>将分组packet从一个路由器传到相邻路由器hop，一段段最终从源端传送到目标端；</li><li>每段：采用链路的最大传输能力，即带宽；</li></ul><p><img src="https://s2.loli.net/2023/02/08/i8aqtym1HWz3ATd.png" alt="avatar"></p><h4 id="存储转发传输"><a href="#存储转发传输" class="headerlink" title="存储转发传输"></a>存储转发传输</h4><ul><li>被传输到下一个链路之前，整个分组必须到达路由器；</li><li>在一个速率为<code>R</code> bps的链路 ，一个长度为<code>L</code> bits 的分组 的存储转发延时： <code>L/R</code> s；</li></ul><h4 id="排队延时和分组丢失"><a href="#排队延时和分组丢失" class="headerlink" title="排队延时和分组丢失"></a>排队延时和分组丢失</h4><p><img src="https://s2.loli.net/2023/02/08/hGF62ZPvNKTErOq.png" alt="avatar"></p><ul><li>如果到达速率 &gt; 链路的输出速率，则分组将会排队，形成queue；</li><li>但如果路由器的缓存用完了，分组将会被抛弃，俗称丢包；</li></ul><h4 id="统计多路复用"><a href="#统计多路复用" class="headerlink" title="统计多路复用"></a>统计多路复用</h4><p><img src="https://s2.loli.net/2023/02/08/kVEIqCre7obDHF1.png" alt="avatar"></p><h4 id="转发表和路由选择协议"><a href="#转发表和路由选择协议" class="headerlink" title="转发表和路由选择协议"></a>转发表和路由选择协议</h4><p>路由器怎样决定它应当向哪条链路进行转发呢？</p><p>在因特网中，每个端系统具有一个称为IP地址的地址，当源主机要向目标端系统发送一个packet时，源在该分组的首部包含了目的地的IP地址，方便路由器进行转发；</p><p>另外，每台路由器具有一个<strong>转发表</strong>，用于将目的地址（或者一部分）映射为输出链路。</p><p>但是，转发表示如何进行设置的？是人工的还是自动的？实际上是通过<strong>路由选择协议</strong>来实现自动设置转发表，在后面的章节会详细介绍（第四章）。</p><h4 id="分组交换的网络层"><a href="#分组交换的网络层" class="headerlink" title="分组交换的网络层"></a>分组交换的网络层</h4><blockquote><ol><li><p>数据报网络： </p><p> 分组的目标地址决定下一跳</p><p> 在不同的阶段，路由可以改变</p><p> 类似：问路</p><p> Internent</p></li><li><p>虚电路网络：</p><p> 每个分组都带标签（虚电路标识 VC ID），标签决定下一跳</p><p> 在呼叫建立时决定路径，在整个呼叫中路径保持不变</p><p> 路由器维持每个呼叫的状态信息</p><p> X.25 和ATM</p></li></ol></blockquote><p><em>其工作原理暂略</em></p><hr><h3 id="电路交换："><a href="#电路交换：" class="headerlink" title="电路交换："></a>电路交换：</h3><p>这是一种端到端 end-to-end 的连接</p><ul><li>为每个呼叫<strong>预留</strong>一条专有电路：如电话网；</li><li>专用资源：不共享，即每个呼叫一旦建立起来就能够保证性能；</li><li>如果呼叫没有数据发送，被分配的资源就会被浪费；</li><li>通常被传统电话网络采用，不适合计算机之间的通信；<ul><li>连接建立时间长；</li><li>计算机之间的通信有突发性，如果使用电路交换则浪费的片较多；</li></ul></li></ul><h4 id="电路交换-网络资源分片"><a href="#电路交换-网络资源分片" class="headerlink" title="电路交换-网络资源分片"></a>电路交换-网络资源分片</h4><p>网络资源，如带宽被分成片</p><ul><li>FDM 频分复用</li><li>TDM 时分复用</li><li>WDM 波分复用</li></ul><p><img src="https://s2.loli.net/2023/02/08/2eDUayYI1VsgCwX.png" alt="avatar"></p><h4 id="电路交换-计算"><a href="#电路交换-计算" class="headerlink" title="电路交换-计算"></a>电路交换-计算</h4><p><img src="https://s2.loli.net/2023/02/08/Ep6Xf7Lhr2ayGPH.png" alt="avatar"></p><hr><h3 id="分组交换网中的时延、丢包和吞吐量详解："><a href="#分组交换网中的时延、丢包和吞吐量详解：" class="headerlink" title="分组交换网中的时延、丢包和吞吐量详解："></a>分组交换网中的时延、丢包和吞吐量详解：</h3><h4 id="四种时延："><a href="#四种时延：" class="headerlink" title="四种时延："></a>四种时延：</h4><p><img src="https://cdnjson.com/images/2023/03/23/image238dd675d5273d52.png" alt="avatar"></p><ul><li>处理时延：检查分组首部和决定将该分组导向何处所需要的时间是处理时延的一部分；</li><li>排队时延：在队列中，当分组在链路上等待传输时，它经受排队时延；</li><li>传输时延：<code>L / R</code>，也就是路由器将分组从队列中推出去的时间；</li><li>传播时延：从链路起点到终点的物理传播需要的时间；</li></ul><h4 id="流量强度："><a href="#流量强度：" class="headerlink" title="流量强度："></a><strong>流量强度</strong>：</h4><p><code>L * a / R</code>，<code>a</code>是表示分组到达队列的平均速率，单位是<code>分组/秒</code>，即<code>pkt/s</code>；</p><p><img src="https://s2.loli.net/2023/02/08/pEzcJ6yqtaZl5A4.png" alt="avatar"></p><h4 id="丢包："><a href="#丢包：" class="headerlink" title="丢包："></a><strong>丢包</strong>：</h4><p>随着流量强度接近1，队列将满，路由器将丢弃后续分组。</p><h4 id="端到端时延："><a href="#端到端时延：" class="headerlink" title="端到端时延："></a>端到端时延：</h4><p><img src="https://s2.loli.net/2023/02/08/cGiBtFpqmgaOxYD.png" alt="avatar"></p><h5 id="1-Traceroute："><a href="#1-Traceroute：" class="headerlink" title="1. Traceroute："></a>1. Traceroute：</h5><p>Traceroute是一个简单的程序，它能够在任何因特网上运行。</p><p>当用户指定一个目的主机名字时，源主机中的该程序朝着该目的地发送多个特殊的分组。</p><p>更具体的内容暂略。</p><h5 id="2-端系统、应用程序和其他时延"><a href="#2-端系统、应用程序和其他时延" class="headerlink" title="2. 端系统、应用程序和其他时延"></a>2. 端系统、应用程序和其他时延</h5><p>这种填充一个分组的时间称为分组化时延，可能较大。</p><h4 id="计算机网络中的吞吐量"><a href="#计算机网络中的吞吐量" class="headerlink" title="计算机网络中的吞吐量"></a>计算机网络中的吞吐量</h4><p>吞吐量分为<strong>瞬时吞吐量</strong>和<strong>平均吞吐量</strong>；</p><ul><li>瞬时吞吐量：是主机接收到文件的速率，以bps计；</li><li>平均吞吐量：如果该文件由<code>F bit</code>，主机B接收到所有<code>F bit</code>用去了<code>T秒</code>，则文件传送的平均吞吐量是<code>F / T bps</code>；</li></ul><h5 id="瓶颈链路"><a href="#瓶颈链路" class="headerlink" title="瓶颈链路"></a>瓶颈链路</h5><p><img src="https://s2.loli.net/2023/02/08/gLapHFwhsI7WqyN.png" alt="avatar"></p><hr><h2 id="接入网与物理媒体"><a href="#接入网与物理媒体" class="headerlink" title="接入网与物理媒体"></a>接入网与物理媒体</h2><p>接入网是指host与edge router相连的这条物理链路；</p><p>三个方式：</p><ul><li>家庭接入网络</li><li>单位接入网络（学校、公司）</li><li>无线接入网络</li></ul><p>两个注意：</p><ul><li>接入网络的带宽？</li><li>共享 or 专用？</li></ul><h3 id="家庭接入："><a href="#家庭接入：" class="headerlink" title="家庭接入："></a>家庭接入：</h3><p><img src="https://s2.loli.net/2023/02/08/qMKP6JzvwNAlVmi.png" alt="avatar"></p><ul><li>DSL 数字用户线，即接入网<ul><li>采用现存的到交换局DSLAM的电话线；<ul><li>DSL线路上的数据被传到互联网；</li><li>DSL线路上的语音被传到电话网；</li></ul></li><li>&lt; 2.5 Mbps上行传输速率(typically &lt; 1 Mbps)；</li><li>&lt; 24 Mbps下行传输速率(typically &lt; 10 Mbps)；</li></ul></li></ul><p><img src="https://s2.loli.net/2023/02/08/dzcoI4xFt3kKDEW.png" alt="avatar"></p><hr><ul><li><p>电缆</p><p>  <img src="https://s2.loli.net/2023/02/08/AfL1I4be9KXhJtB.png" alt="avatar"></p></li></ul><hr><ul><li>FTTH 光纤到户<ul><li>又称线缆网络，有线电视信号线缆双向改造；</li><li>FDM: 在不同频段传输不同信道的数据，数字电视和上网数据（上下行）；</li><li>HFC: hybrid fiber coax<ul><li>非对称: 最高30Mbps的下行传输速率, 2 Mbps 上行传输速率；</li></ul></li><li><strong>线缆和光纤网络</strong>将家庭用户接入到ISP路由器；</li><li>各用户共享到线缆头端的接入网络；<ul><li>与DSL不同，DSL每个用户一个专用线路到CO (Central Office)；</li></ul></li></ul></li></ul><p><img src="https://s2.loli.net/2023/02/08/K3CfPj7cB6nm54F.png" alt="avatar"></p><hr><ul><li>拨号 + 卫星<ul><li>利用modem，将上网数据<strong>调制</strong>加载音频信号上，在电话线上传输，在局端将其中的数据<strong>解调</strong>出来，反之亦然；<ul><li>调频</li><li>调幅</li><li>调相位</li><li>综合调制</li></ul></li><li>56Kbps 的速率直接接入路由器 (通常更低)；</li><li>不能同时上网和打电话：不能总是在线；</li></ul></li></ul><hr><h3 id="企业接入网络："><a href="#企业接入网络：" class="headerlink" title="企业接入网络："></a>企业接入网络：</h3><p><img src="https://s2.loli.net/2023/02/08/OypJYFo6GZ1HmMc.png" alt="avatar"></p><ul><li>以太网</li><li>WiFi</li></ul><hr><h3 id="广域无线接入网络："><a href="#广域无线接入网络：" class="headerlink" title="广域无线接入网络："></a>广域无线接入网络：</h3><p>各无线端系统共享无线接入网络（端系统到无线路由器），通过基站（接入站）；</p><p><img src="https://s2.loli.net/2023/02/08/oVwYQ3TDIbL1vMJ.png" alt="avatar"></p><hr><h3 id="物理媒体："><a href="#物理媒体：" class="headerlink" title="物理媒体："></a>物理媒体：</h3><p><img src="https://cdnjson.com/images/2023/03/23/imagefdc98297cb8f7d9e.png" alt="avatar"></p><p><img src="https://s2.loli.net/2023/02/08/x85PnRkLuey3gmH.png" alt="avatar"></p><p><img src="https://s2.loli.net/2023/02/08/R6fuCnWYScw9Khy.png" alt="avatar"></p><hr><h2 id="Internet结构和ISP"><a href="#Internet结构和ISP" class="headerlink" title="Internet结构和ISP"></a>Internet结构和ISP</h2><h3 id="互联网络结构：网络的网络"><a href="#互联网络结构：网络的网络" class="headerlink" title="互联网络结构：网络的网络"></a>互联网络结构：网络的网络</h3><p>端系统通过<strong>接入ISP</strong>来连接到互联网；</p><p>若将每个接入ISP都连接到全局ISP，客户ISPs和提供者ISPs又经纪合约，这样一定会有竞争者有利可图，一定存在竞争，于是不能直接这么干；</p><p><img src="https://s2.loli.net/2023/02/09/jEsRQm896bUuTCF.png" alt="avatar"></p><ul><li>POP: 高层ISP面向客户网络的接入点，涉及费用结算<ul><li>如一个低层ISP接入多个高层ISP，多宿（multi home）</li></ul></li><li>对等接入：2个ISP对等互接，不涉及费用结算</li><li>IXP：多个对等ISP互联互通之处，通常不涉及费用结算<ul><li>对等接入</li></ul></li><li>ICP自己部署专用网络，同时和各级ISP连接</li></ul><hr><h2 id="协议层次及服务模型"><a href="#协议层次及服务模型" class="headerlink" title="协议层次及服务模型"></a>协议层次及服务模型</h2><p>网络有很多构成元素和设备：</p><ul><li>主机</li><li>路由器</li><li>各种媒体的链路</li><li>应用</li><li>协议</li><li>硬件，软件</li><li>…</li></ul><p>如何组织和实现这个复杂的网络功能呢？答案是<strong>分层</strong>！</p><h3 id="层次化方式实现复杂网络功能："><a href="#层次化方式实现复杂网络功能：" class="headerlink" title="层次化方式实现复杂网络功能："></a>层次化方式实现复杂网络功能：</h3><ul><li>将网络复杂的功能分层功能明确的<strong>层次</strong>，每一层实现了其中一个或一组<strong>功能</strong>，功能中有其上层可以使用的功能：<strong>服务</strong>；</li><li>本层协议实体相互交互执行本层的<strong>协议动作</strong>，<em>目的是实现本层功能，通过接口为上层提供更好的服务</em>；</li><li>在实现本层协议的时候，直接利用了下层所提供的服务；</li><li>本层的服务：借助下层服务实现的本层协议实体之间交互带来的新功能（上层可以利用的）+ 更下层所提供的服务；</li></ul><h3 id="服务与协议："><a href="#服务与协议：" class="headerlink" title="服务与协议："></a>服务与协议：</h3><h4 id="服务与协议的区别"><a href="#服务与协议的区别" class="headerlink" title="服务与协议的区别"></a>服务与协议的区别</h4><ul><li>服务(Service)：低层实体<strong>向上层</strong>实体提供它们之间的通信的能力，是通过原语(primitive)来操作的，垂直的</li><li>协议(protocol) ：<strong>对等层</strong>实体(peer entity)之间在相互通信的过程中，需要遵循的规则的集合，水平的</li></ul><h4 id="服务与协议的联系"><a href="#服务与协议的联系" class="headerlink" title="服务与协议的联系"></a>服务与协议的联系</h4><ul><li>本层协议的实现要靠下层提供的服务来实现</li><li>本层实体通过协议为上层提供更高级的服务</li></ul><h3 id="什么是数据包？"><a href="#什么是数据包？" class="headerlink" title="什么是数据包？"></a>什么是数据包？</h3><p>数据包是通过互联网传输的<strong>信息的基本单位</strong>。将信息拆分成小的、可消化的部分可以更有效地利用网络的容量。</p><p>数据包的组成：</p><ul><li>标头：包含帮助数据包到达其目标的信息，包括<strong>数据包的长度、源和目标</strong>，以及帮助接收方检测数据包在传输过程中是否损坏的<strong>校验和值</strong>。</li><li>实际数据：一个数据包最多可以包含 64 KB 的数据，大约是 20 页的纯文本。</li></ul><p>此外，如果互联网路由器遇到拥塞或其他技术问题，则可以通过简单地丢弃数据包来处理它。发送计算机负责检测数据包未到达其目标并发送另一个副本。这种方法似乎违反直觉，但它简化了互联网的核心基础设施，以更低的成本实现更高的性能。</p><h3 id="数据单元DU："><a href="#数据单元DU：" class="headerlink" title="数据单元DU："></a>数据单元DU：</h3><p><img src="https://s2.loli.net/2023/02/09/LAfnrGHpzymOXt1.png" alt="avatar"></p><p>上文提到过的：</p><p>PDU (Protocol Data Unit)协议数据单元，是指对等层次之间传递的数据单位。</p><ul><li>物理层的PDU是<code>bit</code></li><li>数据链路层的PDU是<code>数据帧frame</code></li><li>网络层的PDU是<code>数据包packet</code></li><li>传输层的PDU是<code>数据段segment</code></li><li>其他更高层次的PDU是数据<code>data</code></li></ul><p><strong>具体来说</strong>：</p><p><img src="https://cdnjson.com/images/2023/03/23/image94c1d7406046a3d4.png" alt="avatar"></p><h3 id="分层处理和实现复杂系统的好处？"><a href="#分层处理和实现复杂系统的好处？" class="headerlink" title="分层处理和实现复杂系统的好处？"></a>分层处理和实现复杂系统的好处？</h3><ul><li>概念化：结构清晰，便于标示网络组件，以及描述其相互关系<ul><li>分层参考模型</li></ul></li><li>结构化：模块化更易于维护和系统升级<ul><li>针对某一层的改变是独立的</li></ul></li></ul><h3 id="Internet协议栈："><a href="#Internet协议栈：" class="headerlink" title="Internet协议栈："></a>Internet协议栈：</h3><p>应用层: 网络应用</p><ul><li>为人类用户或者其他应用进程提供网络应用服务</li><li>FTP，SMTP，HTTP，DNS</li></ul><p>传输层: 主机之间的数据传输</p><ul><li>在网络层提供的端到端通信基础上，细分为进程 到进程，将不可靠的通信变成可靠地通信</li><li>TCP，UDP</li></ul><p>网络层: 为数据包从源到目的选择路由</p><ul><li>主机主机之间的通信，端到端通信，不可靠</li><li>IP，路由协议</li></ul><p>链路层: 相邻网络节点间的数据传输</p><ul><li>2个相邻2点的通信，点到点通信，可靠或不可靠</li><li>点对对协议PPP，802.11(wifi)，Ethernet</li></ul><p>物理层: 在线路上传送bit</p><p><img src="https://cdnjson.com/images/2023/03/23/image58791ea91b1bcfce.png" alt="avatar"></p><h3 id="ISO-x2F-OSI-参考模型："><a href="#ISO-x2F-OSI-参考模型：" class="headerlink" title="ISO &#x2F; OSI 参考模型："></a>ISO &#x2F; OSI 参考模型：</h3><p><img src="https://s2.loli.net/2023/02/09/sUY6iWKrzgXEuAk.png" alt="avatar"></p><h3 id="封装与解封装："><a href="#封装与解封装：" class="headerlink" title="封装与解封装："></a>封装与解封装：</h3><p><img src="https://s2.loli.net/2023/02/09/ujJOm6TViNrvBZw.png" alt="avatar"></p><hr><h2 id="面对攻击的网络"><a href="#面对攻击的网络" class="headerlink" title="面对攻击的网络"></a>面对攻击的网络</h2><p>网络安全领域主要探讨以下问题：</p><ul><li>坏家伙如何攻击计算机网络？</li><li>我们如何防御以免受他们的攻击？</li></ul><h3 id="坏家伙能够经因特网将有害程序放入你的计算机中："><a href="#坏家伙能够经因特网将有害程序放入你的计算机中：" class="headerlink" title="坏家伙能够经因特网将有害程序放入你的计算机中："></a>坏家伙能够经因特网将有害程序放入你的计算机中：</h3><p>一些<strong>恶意软件</strong>，会做各种不正当的事情，包括但不限于删除我们的文件，安装间谍软件来收集隐私信息。</p><p>受害的主机也会变成数以千计的受害设备网络中的一员，被统称为<strong>僵尸网络</strong>。</p><p>如今（当时是2013年），多数恶意软件是通过<strong>自我复制</strong>来操作的，通过病毒或蠕虫的方式扩散：</p><ul><li>病毒：是一种需要某种形式的用户交互来感染用户设备的恶意软件，典型的例子是包含恶意可执行代码的电子邮件附件。</li><li>蠕虫：是一种无需任何明显用户交互就能进入设备的恶意软件，那些应用程序可能从因特网接收恶意软件并运行它，生成了蠕虫。新近感染设备中的蠕虫则能扫描因特网，搜索其他运行相同易受感染的网络应用程序的主机，一经发现便发送一个自身副本。</li></ul><h3 id="坏家伙能够攻击服务器和网络基础设施："><a href="#坏家伙能够攻击服务器和网络基础设施：" class="headerlink" title="坏家伙能够攻击服务器和网络基础设施："></a>坏家伙能够攻击服务器和网络基础设施：</h3><p>另一种宽泛类型的安全性威胁称为<strong>拒绝服务攻击</strong>（Denial-of-Service (DoS) attack），顾名思义，DoS攻击使得网络、主机或其他基础设施部分不能由合法用户所使用。Web服务器、电子邮件服务器、DNS服务器等都可以作为DoS攻击的目标。一般有如下三种类型：</p><ul><li><strong>弱点攻击</strong>：这涉及向一台目标主机上运行的易受攻击的应用程序或操作系统发送制作精细的报文，如果适当顺序的多个分组发送给一个易受攻击的应用程序或操作系统，该服务器可能停止运行，或者更糟糕的是主机可能崩溃。</li><li><strong>带宽洪泛</strong>：攻击者向目标主机发送大量的分组，分组数量之多使得目标的接入链路变得拥塞，使得合法的分组无法到达服务器。</li><li><strong>连接洪泛</strong>：攻击者在目标主机中创建大量的半开或者全开TCP连接，该主机因为这些伪造的连接而陷入困境，并停止接受合法的连接。</li></ul><p>值得一提的是，<strong>分布式DoS</strong>(Distributed DoS)攻击就是大名鼎鼎的DDoS攻击，攻击者控制多个源并让每个源向目标猛烈发送流量，比起单一主机的DoS，DDoS更加难以检测和防范。</p><p><img src="https://s2.loli.net/2023/02/09/gaZ2Cz9KfmYvEIM.png" alt="avatar"></p><h3 id="坏家伙能够嗅探分组："><a href="#坏家伙能够嗅探分组：" class="headerlink" title="坏家伙能够嗅探分组："></a>坏家伙能够嗅探分组：</h3><p>当无处不在的因特网接入极为便利并使得令人惊奇的新应用程序为移动用户所用的同时，也产生了重大的安全弱点——在无线传输设备的附近放置一台被动的接收机，该接收机就能得到传输的每个分组的副本。记录每个流经的分组副本的被动接收机也被称为<strong>分组嗅探器</strong>(packet sniffer)。</p><p>当然，这也能够部署在有线环境中，这里先略过。</p><p>因为分组嗅探器是被动的，也就是说它们不向信道中注入分组，所以难以检测它们的存在，因此，我们向无线信道发送分组的时候，<strong>必须接受这样的可能性</strong>。</p><h3 id="坏家伙能够伪装成你信任的人："><a href="#坏家伙能够伪装成你信任的人：" class="headerlink" title="坏家伙能够伪装成你信任的人："></a>坏家伙能够伪装成你信任的人：</h3><p>这个大家还是挺熟悉的，后面再介绍更加细节的内容。</p><p>这里就介绍一个概念：</p><p>将具有虚假源地址的分组注入因特网的能力被称为<strong>IP哄骗</strong> (IP spoofing)；</p><hr><h2 id="8-计算机网络的历史"><a href="#8-计算机网络的历史" class="headerlink" title="8. 计算机网络的历史"></a>8. 计算机网络的历史</h2><p><img src="https://s2.loli.net/2023/02/09/lt87ge4ZbTCksoW.png" alt="avatar"></p><p>具体内容待补充，敬请期待！</p><p><em>“不闻不若闻之，闻之不若见之，见之不若知之，知之不若行之。”</em></p><hr><h1 id="Unit-1-5-待整理的网络知识"><a href="#Unit-1-5-待整理的网络知识" class="headerlink" title="Unit 1.5 待整理的网络知识"></a>Unit 1.5 待整理的网络知识</h1><h2 id="一、什么是域名系统？"><a href="#一、什么是域名系统？" class="headerlink" title="一、什么是域名系统？"></a>一、什么是域名系统？</h2><p>域名系统<code>DNS</code>是您可以通过在浏览器中键入<code>github.com</code>而不是难以记住的数字地址，如216.148.41.12来访问网页的原因。</p><blockquote><p>域名系统由位于加利福尼亚州的非营利组织ICANN 管理。ICANN成立于1998年。它被美国商务部授予对DNS的权力，尽管它越来越多地声称自己独立于美国政府。</p><p>有两种类型的域名。第一个是通用顶级域 （gTLD），例如 .com、.edu、.org 和 .gov。由于互联网起源于美国，因此这些域名往往在那里最受欢迎。这些域的权限通常委托给私人组织。</p><p>还有国家代码顶级域 （ccTLD）。世界上每个国家都有自己的 2 个字母代码。例如，美国的 ccTLD 是 .us，英国的 ccTLD 是 .uk，中国的 ccTLD 是 .cn。这些域名由每个国家&#x2F;地区的当局管理。一些 ccTLD，如 .tv（代表岛国图瓦卢）和 .io（英属印度洋领地），在本国以外的地方很受欢迎。</p></blockquote><p><img src="http://web.stanford.edu/class/msande91si/www-spr04/readings/week1/InternetWhitepaper_files/ruswp_diag6.gif" alt="avatar"></p><hr><h2 id="二、浏览器的工作原理简述"><a href="#二、浏览器的工作原理简述" class="headerlink" title="二、浏览器的工作原理简述"></a>二、浏览器的工作原理简述</h2><h3 id="0-概述Overview："><a href="#0-概述Overview：" class="headerlink" title="0. 概述Overview："></a>0. 概述Overview：</h3><p>Web性能的两个主要问题：</p><ol><li>与<strong>延迟</strong>有关的问题</li><li>与大多数情况下浏览器是<strong>单线程</strong>的事实有关的问题</li></ol><blockquote><p>延迟是影响我们确保快速加载页面的能力的最大威胁。</p><p>对于流畅的交互，开发人员的目标是确保高性能的网站交互，从平滑滚动到响应触摸。<strong>渲染时间是关键</strong>，要确保主线程能够完成我们投入的所有工作，并且仍然始终可用于处理用户交互。通过了解浏览器的单线程性质并在可能和适当的情况下最小化主线程的职责，可以提高 Web 性能，以确保呈现流畅和对交互的即时响应。</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2c2ce0c78bd4510825974bec7e046d0~tplv-k3u1fbpfcp-zoom-1.image" alt="avatar"></p><hr><h3 id="1-导航Navigation："><a href="#1-导航Navigation：" class="headerlink" title="1. 导航Navigation："></a>1. 导航Navigation：</h3><p>导航是加载网页的第一步；</p><p>每当用户通过在地址栏中输入 URL、单击链接、提交表单以及其他操作来请求页面时，就是导航。</p><p>Web 性能的目标之一是<strong>最大程度地减少完成导航所需的时间</strong>。</p><h4 id="域名解析查找DNS-Lookup："><a href="#域名解析查找DNS-Lookup：" class="headerlink" title="域名解析查找DNS Lookup："></a>域名解析查找DNS Lookup：</h4><p>那么怎么进行导航呢？</p><ol><li>浏览器缓存：首先检查浏览器的DNS缓存，看看是否有缓存的域名解析结果。</li><li>系统缓存：如果浏览器缓存没有结果，系统将检查操作系统的DNS缓存。</li><li>路由器缓存：如果系统缓存没有结果，路由器也会检查其DNS缓存。</li><li>本地DNS服务器：如果路由器缓存没有结果，系统将询问本地DNS服务器，看看它是否已经缓存了域名解析结果。</li><li>根DNS服务器：如果本地DNS服务器没有结果，它将询问根DNS服务器，试图获得域名的解析。</li><li>授权DNS服务器：根DNS服务器会向授权DNS服务器查询，以获取更详细的域名解析信息。</li><li>权威DNS服务器：最后，授权DNS服务器将询问权威DNS服务器，以确定该域名的IP地址。</li><li>缓存结果：找到的结果将被缓存，以便在将来不必再次查询。</li></ol><p><img src="https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work/latency.jpg" alt="avatar"></p><h4 id="TCP三次握手："><a href="#TCP三次握手：" class="headerlink" title="TCP三次握手："></a>TCP三次握手：</h4><p>一旦知道 IP 地址，浏览器就会通过 TCP 三向握手建立与服务器的连接。</p><p>TCP的三向握手技术通常被称为“SYN-SYN-ACK”（或更准确地说是SYN，SYN-ACK，ACK）。</p><p>TCP三次握手是一种网络协议中的握手过程，主要用于确保客户端与服务器之间的可靠通信。步骤如下：</p><ol><li>客户端发送一个SYN（Synchronize）请求报文到服务器，请求建立一个连接。</li><li>服务器收到SYN请求后，回应一个SYN-ACK（Synchronize-Acknowledge）报文，表示同意建立连接。</li><li>客户端收到SYN-ACK报文后，再发送一个ACK（Acknowledge）报文，确认连接建立完成。</li></ol><p>完成三次握手后，客户端与服务器间的连接就建立成功。这样可以确保两端在建立连接前，已经确认了对方的可用性，避免了网络中的垃圾数据或攻击行为。</p><h4 id="TLS协商："><a href="#TLS协商：" class="headerlink" title="TLS协商："></a>TLS协商：</h4><p>对于通过HTTPS建立的安全连接，需要再次“握手”。</p><p>这种握手，或者更确切地说是TLS协商，确定将使用哪种密码来加密通信，验证服务器，并在开始实际数据传输之前建立安全连接。这需要在实际发送内容请求之前再往返服务器三次。</p><p>虽然使连接安全会增加页面加载时间，但安全连接值得延迟费用，因为浏览器和 Web 服务器之间传输的数据无法被第三方解密。</p><p>TLS协商的过程一般包括以下步骤：</p><ol><li>客户端发送”Client Hello”报文给服务器，其中包含了客户端支持的加密协议、会话ID、随机数等信息。</li><li>服务器收到”Client Hello”报文后，会回复”Server Hello”报文给客户端，其中包含了服务器选择的加密协议、会话ID、随机数等信息。</li><li>客户端和服务器通过协商后确定的加密协议进行密钥交换，以确定本次通信的密钥。</li><li>双方确认协商结果后，通信开始加密传输数据。</li></ol><p>TLS协商的过程确保了客户端和服务器之间的通信是安全的，防止了数据在传输过程中的泄露和篡改。</p><p><img src="https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work/ssl.jpg" alt="avatar"></p><hr><h3 id="2-响应Response："><a href="#2-响应Response：" class="headerlink" title="2. 响应Response："></a>2. 响应Response：</h3><p>现在，导航已经结束了，来到了响应的阶段。</p><p>一旦我们与 Web 服务器建立了连接，浏览器就会<strong>代表用户发送初始 HTTP-GET 请求</strong>，</p><p>对于网站来说，该请求通常是 HTML 文件。一旦服务器收到请求，它将回复相关的响应标头和HTML的内容。</p><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en-US&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>My simple page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;styles.css&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;myscript.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;heading&quot;</span>&gt;</span>My Page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph with a <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://example.com/about&quot;</span>&gt;</span>link<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;myimage.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;image description&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;anotherscript.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="HTTP请求方法："><a href="#HTTP请求方法：" class="headerlink" title="HTTP请求方法："></a>HTTP请求方法：</h4><ul><li>GET 该方法请求指定资源的表示形式。使用的请求应仅检索数据。</li><li>HEAD 该方法请求与请求相同的响应，但没有响应正文。</li><li>POST 该方法将实体提交到指定的资源，这通常会导致服务器的状态更改或副作用。</li><li>PUT 该方法将目标资源的所有当前表示形式替换为请求有效负载。</li><li>DELETE 该方法删除指定的资源。</li><li>CONNECT 该方法建立到目标资源标识的服务器的隧道。</li><li>OPTIONS 该方法描述目标资源的通信选项。</li><li>TRACE 该方法沿目标资源的路径执行消息环回测试。</li><li>PATCH 该方法对资源应用部分修改。</li></ul><h4 id="TCP慢启动-x2F-14KB规则："><a href="#TCP慢启动-x2F-14KB规则：" class="headerlink" title="TCP慢启动 &#x2F; 14KB规则："></a>TCP慢启动 &#x2F; 14KB规则：</h4><p>TCP 慢启动有助于<strong>提高网络能力的传输速度</strong>。</p><p>TCP 慢启动是一种算法，<strong>用于检测数据包传输的可用带宽，并平衡网络连接的速度</strong>。</p><p>它可以防止出现最初功能未知的网络拥塞，并缓慢增加扩散的信息量，直到找到网络的最大容量。</p><p>第一个响应数据包将为 14KB。这是TCP慢启动的一部分，这是一种平衡网络连接速度的算法。</p><p>慢启动会<strong>逐渐增加传输的数据量，直到确定网络的最大带宽</strong>。</p><p>在TCP慢启动中，在收到初始数据包后，服务器将下一个数据包的大小<strong>加倍至28KB</strong>左右。后续数据包的大小会增加，<strong>直到达到预定阈值或遇到拥塞</strong>。</p><p>大概可以理解为逐步试探的倍增过程。</p><h4 id="拥塞控制："><a href="#拥塞控制：" class="headerlink" title="拥塞控制："></a>拥塞控制：</h4><p>当<strong>服务器</strong>以 <strong>TCP 数据包</strong>的形式发送数据时，用户的<strong>客户端</strong>通过<strong>返回确认或 ACK</strong> 来确认传递。</p><p>连接的容量有限，具体取决于硬件和网络条件。如果服务器发送太多数据包太快，它们将<strong>被丢弃</strong>。</p><p>服务器将其注册为缺少的 ACK。拥塞控制算法使用已发送数据包和 ACK 的此流来确定发送速率。</p><hr><h4 id="解析Parsing："><a href="#解析Parsing：" class="headerlink" title="解析Parsing："></a>解析Parsing：</h4><p>一旦浏览器收到第一个数据块，它就可以开始解析收到的信息。</p><p>解析意味着分析程序并将其转换为运行时环境可以实际运行的内部格式，例如浏览器中的 JavaScript 引擎。</p><p>解析是浏览器将它通过网络接收的数据转换为 <strong>DOM</strong> 和 <strong>CSSOM</strong> 的步骤，<strong>渲染器</strong>使用它来将页面绘制到屏幕上。</p><blockquote><p><strong>具体来说</strong>：</p><p>浏览器将 HTML 解析为 DOM 树。HTML 解析涉及标记化和树构造。HTML 标记包括开始和结束标记，以及属性名称和值。如果文档格式正确，则解析它既简单又快速。解析器将标记化的输入解析到文档中，从而构建文档树。</p><p>当 HTML 解析器找到非阻塞资源（如图像）时，浏览器将请求这些资源并继续解析。遇到 CSS 文件时，解析可以继续，但标记（尤其是那些没有异步或属性的标记）会阻止呈现，并暂停 HTML 解析。<code>&lt;script&gt;defer</code></p><p>当浏览器遇到 CSS 样式时，它会将文本解析为 CSS 对象模型（或 CSSOM），这是一种数据结构，然后用于样式布局和绘画。然后，浏览器从这两种结构创建一个呈现树，以便能够将内容绘制到屏幕上。JavaScript 也会被下载、解析，然后执行。</p></blockquote><h4 id="构建DOM树："><a href="#构建DOM树：" class="headerlink" title="构建DOM树："></a>构建DOM树：</h4><p>DOM 树描述文档的内容。<html> 元素是文档树的第一个标记和根节点。</p><p>树反映了不同标签之间的关系和层次结构。嵌套在其他标签中的标签是子节点。</p><p>DOM 节点的数量越多，构建 DOM 树所需的时间就越长。</p><p><img src="https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work/dom.gif" alt="avatar"></p><h4 id="预加载扫描仪Preload-Scanner："><a href="#预加载扫描仪Preload-Scanner：" class="headerlink" title="预加载扫描仪Preload Scanner："></a>预加载扫描仪Preload Scanner：</h4><blockquote><p>当浏览器构建 DOM 树时，此过程占用主线程。</p><p>发生这种情况时，预加载扫描程序将解析可用内容并请求高优先级资源，如 CSS、JavaScript 和 Web 字体。</p><p>多亏了预加载扫描程序，我们不必等到解析器找到对外部资源的引用来请求它。</p><p>它将在后台检索资源，以便在主 HTML 解析器到达请求的资产时，它们可能已经在运行中，或者已被下载。预加载扫查器提供的优化可减少阻塞。</p></blockquote><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;styles.css&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;myscript.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;myimage.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;image description&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;anotherscript.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在此示例中，当主线程解析 HTML 和 CSS 时，预加载扫描程序将找到脚本和图像，并开始下载它们。若要确保脚本不会阻止进程，请添加属性，或者如果 JavaScript 解析和执行顺序很重要，请添加属性。</p><h4 id="构建CSSOM树："><a href="#构建CSSOM树：" class="headerlink" title="构建CSSOM树："></a>构建CSSOM树：</h4><p>关键呈现路径中的第二步是处理 CSS 并构建 CSSOM 树。</p><p>CSS 对象模型类似于 DOM。DOM 和 CSSOM 都是树。它们是独立的数据结构。</p><p>浏览器将 CSS 规则转换为它可以理解和使用的样式映射。浏览器遍历 CSS 中的每个规则集，根据 CSS 选择器创建具有父、子和同级关系的节点树。</p><p><img src="https://s2.loli.net/2023/01/30/wzGjACSikPZ6rWp.png" alt="avatar"></p><p>除此之外，还有一些内容例如JavaScript编译和构建辅助功能树等等，这里不展开叙述。</p><hr><h3 id="3-渲染Render"><a href="#3-渲染Render" class="headerlink" title="3. 渲染Render"></a>3. 渲染Render</h3><p>接下来是渲染部分，以下是四个比较重要的内容：</p><h4 id="Style"><a href="#Style" class="headerlink" title="Style"></a>Style</h4><p>关键渲染路径中的第三步是将 DOM 和 CSSOM 组合到渲染树中。计算样式树或渲染树的构造从 DOM 树的根开始，遍历每个可见节点。</p><h4 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h4><p>关键渲染路径中的第四步是在渲染树上运行布局，以计算每个节点的几何体。<em>布局</em>是确定呈现树中所有节点的宽度、高度和位置的过程，也是确定页面上每个对象的大小和位置的过程。<em>重排</em>是页面任何部分或整个文档的任何后续大小和位置确定。</p><h4 id="Paint"><a href="#Paint" class="headerlink" title="Paint"></a>Paint</h4><p>关键渲染路径的最后一步是将各个节点绘制到屏幕上，第一次出现称为第一次有意义的绘制。在绘画或光栅化阶段，浏览器将布局阶段计算的每个框转换为屏幕上的实际像素。绘画涉及将元素的每个视觉部分绘制到屏幕上，包括文本、颜色、边框、阴影以及按钮和图像等替换元素。浏览器需要非常快速地完成此操作。</p><h4 id="Compositing"><a href="#Compositing" class="headerlink" title="Compositing"></a>Compositing</h4><p>一旦主线程完成页面绘制，你会认为我们会“一切就绪”。事实未必如此。如果加载包含 JavaScript，该 JavaScript 已正确延迟，并且仅在 onload 事件触发后执行，则主线程可能繁忙，并且不可用于滚动、触摸和其他交互。</p><p>到这一步，浏览器的工作基本上就算是完成了。</p><hr><h2 id="三、Hosting"><a href="#三、Hosting" class="headerlink" title="三、Hosting"></a>三、Hosting</h2><h3 id="0-概述Overview：-1"><a href="#0-概述Overview：-1" class="headerlink" title="0. 概述Overview："></a>0. 概述Overview：</h3><p>Hosting是指<strong>将网站存储在服务器上</strong>，以便全球用户<strong>通过互联网访问该网站</strong>的服务。它包括：</p><ol><li>服务器租赁：为网站提供存储空间和带宽</li><li>网络架构：确保网站可以连接到互联网</li><li>技术支持：协助解决网站运行问题</li><li>网站维护：保证服务器性能和安全性</li></ol><p>有多种不同的Hosting服务，如共享Hosting，虚拟专用服务器（VPS）和独立专用服务器（Dedicated Server）。</p><p>根据网站的需求，个人或企业可以选择合适的Hosting服务。</p><h3 id="1-Hosting细节："><a href="#1-Hosting细节：" class="headerlink" title="1. Hosting细节："></a>1. Hosting细节：</h3><ol><li>备份：一些Hosting提供商提供定期备份功能，以确保数据安全</li><li>安全：保护网站免受黑客攻击，提供SSL证书等安全功能是一项重要的任务</li><li>可扩展性：随着网站的发展，需要更多的存储空间和带宽，因此要选择可扩展的Hosting服务</li><li>性能：网站速度和可用性对用户体验有很大影响，因此要选择高性能的Hosting服务</li><li>技术支持：良好的技术支持是网站运行的重要保证，选择提供全天候技术支持的Hosting提供商是一个好选择。</li></ol><hr><h2 id="四、DNS-互联网的电话簿"><a href="#四、DNS-互联网的电话簿" class="headerlink" title="四、DNS-互联网的电话簿"></a>四、DNS-互联网的电话簿</h2><h3 id="0-简介："><a href="#0-简介：" class="headerlink" title="0. 简介："></a>0. 简介：</h3><p>DNS（域名系统 Domain Name System ）是互联网连接资源的分层和分散命名系统；</p><p>DNS维护域名列表以及与其关联的资源（如 IP 地址）；</p><p>DNS最突出的功能是将人性化域名转换为数字IP地址；</p><p>将域名映射到相应 IP 地址的过程称为 DNS 查找，相比之下，反向 DNS 查找 （rDNS） 用于确定与 IP 地址关联的域名。</p><h3 id="1-额外的安全层？"><a href="#1-额外的安全层？" class="headerlink" title="1. 额外的安全层？"></a>1. 额外的安全层？</h3><p>默认情况下，DNS查询Request和响应Response以<strong>明文形式</strong>，通过UDP发送，也就是说网络、ISP 或任何能够监控传输的人都可以读取它们。即使网站使用 HTTPS，也会公开导航到该网站所需的 DNS 查询。</p><p>如何解决呢？事实上有两种办法：TLS上的DNS和HTTPS上的DNS，他们都是为加密明文DNS流量而开发的标准。</p><p><img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/7qcyOJwWyOt4EVJykiIRTn/30e34453409eb42fa1ec36680609ad8d/dns-traffic-over-tls-https.svg" alt="avatar"></p><h3 id="2-DNS-x2F-HTTPS-over-DNS"><a href="#2-DNS-x2F-HTTPS-over-DNS" class="headerlink" title="2. DNS &#x2F; HTTPS-over-DNS?"></a>2. DNS &#x2F; HTTPS-over-DNS?</h3><p>TLS 上的 DNS 或 DoT 是加密 DNS 查询以保持其安全和私密性的标准。</p><p>DoT 使用与 HTTPS 网站相同的安全协议 TLS 来加密和验证通信（TLS也称为”SSL”）。</p><p>DoT 在用户数据报协议 UDP 之上添加了 TLS 加密，该协议用于 DNS 查询。</p><p>此外，它还确保 DNS 请求和响应不会因中间人攻击而被篡改或伪造。</p><p>DNS over HTTPS，或DoH，是DoT的替代方案。</p><p>使用 DoH，DNS 查询和响应是加密的，但它们是通过 HTTP 或 HTTP&#x2F;2 协议发送的，而不是直接通过 UDP 发送的。</p><h4 id="有何不同？"><a href="#有何不同？" class="headerlink" title="有何不同？"></a><strong>有何不同</strong>？</h4><p>每个标准都是单独开发的，都有自己的 RFC（征求意见） 文档，</p><p>但 DoT 和 DoH 之间最重要的<strong>区别在于它们使用的端口</strong>。</p><p>DoT 仅使用端口 853，而 DoH 使用端口 443，这是<strong>所有其他 HTTPS 流量使用的端口</strong>。</p><p>由于 DoT 具有专用端口，因此任何具有网络可见性的人都可以看到 DoT 流量的来来去去，即使请求和响应本身是加密的。相比之下，在DoH中，DNS查询和响应伪装在其他HTTPS流量中，因为它们都来自同一端口。</p><h4 id="哪个更好？"><a href="#哪个更好？" class="headerlink" title="哪个更好？"></a>哪个更好？</h4><p>从网络安全的角度来看，DoT可以说更好。它使网络管理员能够监视和阻止 DNS 查询，这对于识别和阻止恶意流量非常重要。同时，DoH查询隐藏在常规HTTPS流量中，这意味着如果不阻止所有其他HTTPS流量，就无法轻松阻止它们。</p><p>但是，从隐私的角度来看，DoH可以说是可取的。使用 DoH，DNS 查询隐藏在较大的 HTTPS 流量中。这降低了网络管理员的可见性，但为用户提供了更多的隐私。</p><hr><h3 id="3-涉及-DNS-的常见攻击有哪些？"><a href="#3-涉及-DNS-的常见攻击有哪些？" class="headerlink" title="3. 涉及 DNS 的常见攻击有哪些？"></a>3. 涉及 DNS 的常见攻击有哪些？</h3><ul><li><strong>DNS 欺骗&#x2F;缓存中毒</strong>：这是一种将伪造的 DNS 数据引入 DNS 解析程序缓存的攻击，导致解析器返回域的错误 IP 地址。流量可以转移到恶意机器或攻击者想要的任何地方，而不是转到正确的网站;通常，这将是用于恶意目的（例如分发恶意软件或收集登录信息）的原始站点的副本。</li><li><strong>DNS 隧道</strong>：此攻击使用其他协议通过 DNS 查询和响应进行隧道传输。攻击者可以使用 SSH、TCP 或 HTTP 将恶意软件或被盗信息传递到 DNS 查询中，而大多数防火墙都不会检测到。</li><li><strong>DNS 劫持</strong>：在 DNS 劫持中，攻击者将查询重定向到其他域名服务器。这可以通过恶意软件或未经授权修改 DNS 服务器来完成。尽管结果与DNS欺骗的结果相似，但这是一种根本不同的攻击，因为它针对的是名称服务器上网站的DNS记录，而不是解析器的缓存。</li><li><strong>NXDOMAIN 攻击</strong>：这是一种 DNS 洪水攻击，攻击者用请求淹没 DNS 服务器，请求不存在的记录，试图导致合法流量的拒绝服务。这可以使用复杂的攻击工具来实现，这些工具可以为每个请求自动生成唯一的子域。NXDOMAIN 攻击还可以针对递归解析器，目的是用垃圾请求填充解析器的缓存。</li><li><strong>幻域攻击</strong>：幻像域攻击的结果与 DNS 解析器上的 NXDOMAIN 攻击类似。攻击者设置了一堆“幻像”域服务器，这些服务器要么响应请求非常慢，要么根本不响应。然后，解析器受到对这些域的大量请求的打击，解析器被占用等待响应，导致性能降低和拒绝服务。</li><li><strong>随机子域攻击</strong>：在这种情况下，攻击者会针对一个合法站点的多个随机、不存在的子域发送 DNS 查询。目标是为域的权威名称服务器创建拒绝服务，从而无法从名称服务器查找网站。作为副作用，为攻击者提供服务的ISP也可能受到影响，因为他们的递归解析器的缓存将加载错误请求。</li><li><strong>域锁定攻击</strong>：攻击者通过设置特殊域和解析器来与其他合法解析器创建 TCP 连接，从而策划这种形式的攻击。当目标解析器发送请求时，这些域会发回缓慢的随机数据包流，从而占用解析器的资源。</li><li><strong>基于僵尸网络的 CPE 攻击</strong>：这些攻击是使用 CPE 设备（客户端设备;这是服务提供商提供的供其客户使用的硬件，例如调制解调器、路由器、电缆盒等）进行的。攻击者破坏CPE，设备成为僵尸网络的一部分，用于对一个站点或域执行随机子域攻击。</li></ul><p><del>（怎么名字都这么帅的）</del></p><p><img src="https://www.cloudflare.com/img/learning/dns/dns-security/dns-hijacking.png" alt="avatar"></p><hr><h3 id="4-域名安全"><a href="#4-域名安全" class="headerlink" title="4. 域名安全"></a>4. 域名安全</h3><p>DNS 安全扩展 （DNSSEC） 是为缓解此问题而创建的安全协议。</p><p>DNSSEC 通过对数据进行数字签名来帮助确保其有效性，从而防止攻击。</p><p>为了确保安全查找，必须在 DNS 查找过程中的<strong>每个级别进行签名</strong>。</p><p>有关 DNSSEC 的更多内容请参考：<a href="https://blog.cloudflare.com/dnssec-an-introduction/?_gl=1*1k44464*_ga*MzE2OTQ0NzY1LjE2NzUxNDM3NzI.*_gid*NjAzODc2NjAyLjE2NzUxNDM3NzI.">DNSSEC: An Introduction (cloudflare.com)</a></p><hr><h3 id="5-其他内容："><a href="#5-其他内容：" class="headerlink" title="5. 其他内容："></a>5. 其他内容：</h3><h4 id="DNS防火墙："><a href="#DNS防火墙：" class="headerlink" title="DNS防火墙："></a>DNS防火墙：</h4><p>DNS firewall 是一种可为 DNS 服务器提供众多安全和性能服务的工具。</p><p>DNS firewall 位于用户的递归解析器与他们正尝试访问的网站或服务的权威性域名服务器之间。</p><p>防火墙可提供速率限制服务，以关闭试图淹没服务器的攻击者。如果服务器确实由于攻击或其他任何原因而停机，则 DNS firewall 可通过提供来自高速缓存的 DNS 响应来使运营商的站点或服务保持正常运行。</p><h4 id="用户隐私："><a href="#用户隐私：" class="headerlink" title="用户隐私："></a>用户隐私：</h4><p>DNS 查询未加密。即使用户使用像 1.1.1.1 这样不跟踪他们活动的 DNS 解析器，DNS 查询也会以明文形式在互联网上传输。这意味着拦截查询的任何人都可以看到用户正在访问哪些网站。</p><p><em>还有诸如DNS高速缓存中毒等内容我们暂且略过。</em></p><hr><h2 id="五、DomainName-域名"><a href="#五、DomainName-域名" class="headerlink" title="五、DomainName-域名"></a>五、DomainName-域名</h2><h3 id="0-简介：-1"><a href="#0-简介：-1" class="headerlink" title="0. 简介："></a>0. 简介：</h3><p>域名是一个文本字符串，映射到一个数字 IP 地址，可用于从客户端软件访问网站。</p><p>简单来说，域名是用户在浏览器窗口中键入以访问特定网站的文本。</p><p>网站的实际地址是一个复杂的数字 IP 地址（例如 103.21.244.0），但由于 DNS 的存在，用户可以输入人类友好的域名并将其路由到他们要查找的网站。此过程称为 DNS 查找。</p><p>域名全部由域名注册管理机构管理。</p><p><img src="https://developer.mozilla.org/en-US/docs/Learn/Common_questions/What_is_a_domain_name/2014-10-dns-request2.png" alt="avatar"></p><h3 id="1-与URL的区别？"><a href="#1-与URL的区别？" class="headerlink" title="1. 与URL的区别？"></a>1. 与URL的区别？</h3><p>统一资源定位符（URL）有时也称为网址，包含站点的域名以及其他信息，如传输协议和路径等。</p><p>例如，在 URL<code>https://www.bilibili.com/anime/</code>中，<code>www.bilibili.com</code>是域名，而<code>https</code>是协议，<code>/anime/</code>是指向网站上特定页面的路径。</p><h3 id="2-域名的组成部分？"><a href="#2-域名的组成部分？" class="headerlink" title="2. 域名的组成部分？"></a>2. 域名的组成部分？</h3><p>域名通常分为两个或三个部分，各个部分用一个点分隔。</p><p>从右到左阅读时，域名中的<strong>标识符从最广泛到最具体</strong>。</p><p>域名中最后一个点右边的部分是顶级域 (TLD)。</p><p>其中包括<code>.com、.net和.org </code>等通用TLD，以及<code>.uk</code>和<code>.cn</code>等特定国家&#x2F;地区的 TLD。</p><p>TLD 的左侧是第二级域（2LD），如果 2LD 的左侧有任何内容，则称为第三级域（3LD）。</p><h3 id="3-查找可用域名："><a href="#3-查找可用域名：" class="headerlink" title="3. 查找可用域名："></a>3. 查找可用域名：</h3><p>法一：转到域名注册商的网站。他们中的大多数都提供<code>whois</code>服务，告诉您域名是否可用。</p><p>法二：如果使用具有内置 shell 的系统，请在其中键入命令，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ whois mozilla.org</span><br><span class="line">Domain Name:MOZILLA.ORG</span><br><span class="line">Domain ID: D1409563-LROR</span><br><span class="line">Creation Date: 1998-01-24T05:00:00Z</span><br><span class="line">Updated Date: 2013-12-08T01:16:57Z</span><br><span class="line">Registry Expiry Date: 2015-01-23T05:00:00Z</span><br><span class="line">Sponsoring Registrar:MarkMonitor Inc. (R37-LROR)</span><br><span class="line">Sponsoring Registrar IANA ID: 292</span><br><span class="line">WHOIS Server:</span><br><span class="line">Referral URL:</span><br><span class="line">Domain Status: clientDeleteProhibited</span><br><span class="line">Domain Status: clientTransferProhibited</span><br><span class="line">Domain Status: clientUpdateProhibited</span><br><span class="line">Registrant ID:mmr-33684</span><br><span class="line">Registrant Name:DNS Admin</span><br><span class="line">Registrant Organization:Mozilla Foundation</span><br><span class="line">Registrant Street: 650 Castro St Ste 300</span><br><span class="line">Registrant City:Mountain View</span><br><span class="line">Registrant State/Province:CA</span><br><span class="line">Registrant Postal Code:94041</span><br><span class="line">Registrant Country:US</span><br><span class="line">Registrant Phone:+1.6509030800</span><br></pre></td></tr></table></figure><h3 id="4-其他内容"><a href="#4-其他内容" class="headerlink" title="4. 其他内容"></a>4. 其他内容</h3><p>域名的最长保留期是十年。用户可以持有域名超过十年，因为注册商通常让他们无限期地续订域名。但是，用户从来没有真正拥有过这个域名，他们只是租用了它。</p><p><img src="https://www.cloudflare-cn.com/img/learning/dns/glossary/expired-domains/expired-domain-timeline.svg" alt="avatar"></p><p>如果没有人购买过期的域名，它可能会在一定时间后退回到原来的注册机构。它将不再可用，直到注册表决定释放它。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;em&gt;Computer Networking A Top-Down Approach Learning Note Part 1&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前言的前言的前言&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;个人博客：&lt;a href=</summary>
      
    
    
    
    <category term="408" scheme="https://conqueror712.github.io/categories/408/"/>
    
    
  </entry>
  
  <entry>
    <title>RabbitMQ丨学习记录</title>
    <link href="https://conqueror712.github.io/post/RabbitMQ.html"/>
    <id>https://conqueror712.github.io/post/RabbitMQ.html</id>
    <published>2023-02-01T02:42:42.000Z</published>
    <updated>2023-03-23T01:23:35.115Z</updated>
    
    <content type="html"><![CDATA[<h1 id="零、前言"><a href="#零、前言" class="headerlink" title="零、前言"></a>零、前言</h1><p>本文记录了笔者在学习消息队列和RabbitMQ的基础知识的过程，</p><p>若笔者有任何疏忽纰漏之处，烦请不吝赐教。</p><p>本文会不断的补充、修改和完善，期待您的宝贵意见。</p><blockquote><p>个人博客：<a href="https://conqueror712.github.io/">https://conqueror712.github.io/</a></p><p>知乎：<a href="https://www.zhihu.com/people/soeur712/posts">https://www.zhihu.com/people/soeur712/posts</a></p><p>Bilibili：<a href="https://space.bilibili.com/57089326">https://space.bilibili.com/57089326</a></p><p>掘金：<a href="https://juejin.cn/user/1297878069809725/posts">https://juejin.cn/user/1297878069809725/posts</a></p></blockquote><h2 id="什么是中间件？为什么要使用它？"><a href="#什么是中间件？为什么要使用它？" class="headerlink" title="什么是中间件？为什么要使用它？"></a>什么是中间件？为什么要使用它？</h2><p>中间件 Middleware 是<strong>处于操作系统和应用程序之间的软件</strong>。</p><p>人们在使用中间件时，往往是一组中间件<strong>集成在一起</strong>，构成一个平台（包括开发平台和运行平台），</p><p>但在这组中间件中必须要有一个<strong>通信中间件</strong>，即<code>中间件 = 平台 + 通信</code>，</p><p>这个定义也限定了只有<strong>用于分布式系统</strong>中才能称为中间件，同时还可以把它与支撑软件和实用软件区分开来。</p><p>中间件<strong>屏蔽了底层操作系统的复杂性</strong>，使程序开发人员面对一个简单而统一的开发环境，减少程序设计的复杂性，将注意力集中在自己的业务上，不必再为程序在不同系统软件上的移植而重复工作，从而大大减少了技术上的负担。</p><p>中间件带给应用系统的，不只是开发的简便、开发周期的缩短，也减少了系统的维护、运行和管理的工作量，还减少了计算机总体费用的投入。</p><p>中间件应该具有以下的<strong>特点</strong>：</p><ul><li>满足大量应用的需要</li><li>运行于多种硬件和OS平台</li><li>支持分布计算，提供跨网络、硬件和OS平台的透明性的应用或服务的交互</li><li>支持标准的协议</li><li>支持标准的接口</li></ul><p>另外，中间件的技术一般现在一些互联网公司或者项目中使用比较多，如果仅仅还只是一个初创公司建议还是使用单体架构，最多加个缓存中间件即可，不要盲目追求新或者所谓的高性能，而<strong>追求的背后一定是业务的驱动和项目的驱动</strong>。</p><h2 id="MindMap："><a href="#MindMap：" class="headerlink" title="MindMap："></a><strong>MindMap</strong>：</h2><p><img src="https://s2.loli.net/2023/02/01/bB8HDJIs2tlKSXw.png" alt="avatar"></p><h2 id="学习目标与技巧"><a href="#学习目标与技巧" class="headerlink" title="学习目标与技巧"></a>学习目标与技巧</h2><p><strong>我们需要理解和掌握</strong>：</p><ul><li>什么是消息中间件</li><li>什么是协议</li><li>什么是持久化</li><li>消息分发</li><li>消息的高可用</li><li>消息的集群</li><li>消息的容错</li><li>消息的冗余</li></ul><p><strong>一些可供参考的方法</strong>：</p><ul><li>理解中间件在项目架构中的作用，以及各中间件的底层实现；</li><li>可以使用一些类比的生活概念去理解中间件；</li><li>使用一些流程图或者脑图的方式去梳理各个中间件在架构中的作用；</li><li>思考中间件在项目中设计的和使用的原因；</li><li>学会查看中间件的源码以及开开源项目和博客。</li></ul><hr><h1 id="一、分布式架构与消息中间件"><a href="#一、分布式架构与消息中间件" class="headerlink" title="一、分布式架构与消息中间件"></a>一、分布式架构与消息中间件</h1><h2 id="0-分布式架构"><a href="#0-分布式架构" class="headerlink" title="0. 分布式架构"></a>0. 分布式架构</h2><p>通俗解释分布式系统：<strong>一个请求由服务器端的多个服务协同处理完成</strong>。</p><p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/02/28/kuangstudyd40834ed-a15f-4606-bb36-ce475b05a949.png" alt="avatar"></p><blockquote><p><strong>存在问题</strong><br>1：学习成本高，技术栈过多；<br>2：运维成本和服务器成本增高；<br>3：人员的成本也会增高；<br>4：项目的负载度也会上升；<br>5：面临的错误和容错性也会成倍增加；<br>6：占用的服务器端口和通讯的选择的成本高；<br>7：安全性的考虑和因素逼迫可能选择RMI&#x2F;MQ相关的服务器端通讯。</p><p><strong>好处</strong><br>1：服务系统的独立，占用的服务器资源减少和占用的硬件成本减少；<br>确切的说是：可以合理的分配服务资源，不造成服务器资源的浪费；<br>2：系统的独立维护和部署，耦合度降低，可插拔性；<br>3：系统的架构和技术栈的选择可以变的灵活；<br>4：弹性的部署，不会造成平台因部署造成的瘫痪和停服的状态。</p></blockquote><hr><h2 id="1-消息中间件"><a href="#1-消息中间件" class="headerlink" title="1. 消息中间件"></a>1. 消息中间件</h2><h3 id="消息中间件的主要作用："><a href="#消息中间件的主要作用：" class="headerlink" title="消息中间件的主要作用："></a>消息中间件的<strong>主要作用</strong>：</h3><ul><li>利用可靠的消息传递机制进行<strong>系统和系统直接的通讯</strong>；</li><li>通过提供消息传递和消息的排队机制，它可以在分布式系统环境下<strong>扩展进程间的通讯</strong>。</li></ul><h3 id="消息中间件的应用场景："><a href="#消息中间件的应用场景：" class="headerlink" title="消息中间件的应用场景："></a>消息中间件的应用场景：</h3><ul><li>跨系统数据传递；</li><li>高并发的流量削峰；</li><li>数据的分发和异步处理；</li><li>大数据分析与传递；</li><li>分布式事务；</li></ul><p>很常见的一个例子就是电商的并发订单。</p><h3 id="消息中间件的本质及设计："><a href="#消息中间件的本质及设计：" class="headerlink" title="消息中间件的本质及设计："></a>消息中间件的本质及设计：</h3><p>它是一种接受数据，接受请求、存储数据、发送数据等功能的技术服务。</p><p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/02/28/kuangstudy7c171d88-687a-4c6c-8a97-2b257467172e.png" alt="avatar"></p><h3 id="消息中间件的核心组成部分："><a href="#消息中间件的核心组成部分：" class="headerlink" title="消息中间件的核心组成部分："></a>消息中间件的核心组成部分：</h3><ul><li>消息的协议</li><li>消息的持久化机制</li><li>消息的分发策略</li><li>消息的高可用，高可靠</li><li>消息的容错机制</li></ul><hr><h1 id="二、消息与消息队列"><a href="#二、消息与消息队列" class="headerlink" title="二、消息与消息队列"></a>二、消息与消息队列</h1><h2 id="0-网络协议简介"><a href="#0-网络协议简介" class="headerlink" title="0. 网络协议简介"></a>0. 网络协议简介</h2><p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/03/02/kuangstudy9e91d500-e775-45f3-92fa-78a6278efc51.png" alt="avatar"></p><p>协议：</p><ol><li>计算机底层操作系统和应用程序通讯时共同遵守的一组约定，只有遵循共同的约定和规范，系统和底层操作系统之间才能相互交流。</li><li>和一般的网络应用程序的不同它主要负责数据的接受和传递，所以性能比较的高。</li><li>协议对数据格式和计算机之间交换数据都必须严格遵守规范。</li></ol><p>协议的<strong>三要素</strong>：</p><ol><li>语法：语法是用户数据与控制信息的结构与格式，以及数据出现的顺序。</li><li>语义：语义是解释控制信息每个部分的意义。它规定了需要发出何种控制信息，以及完成的动作与做出什么样的响应。</li><li>时序：时序是对事件发生顺序的详细说明。</li></ol><blockquote><p>以HTTP请求协议举例：</p><p>语法：http规定了请求报文和响应报文的格式。<br>语义：客户端主动发起请求称之为请求。<br>时序：一个请求对应一个响应，注意是先有请求再有响应。</p></blockquote><blockquote><p>Q：为什么消息中间件不直接使用HTTP协议呢？</p><p>A：首先因为http请求报文头和响应报文头是比较复杂的，包含了cookie，数据的加密解密，状态码，响应码等附加的功能，但是对于一个消息而言，我们并不需要这么复杂，也没有这个必要性，它其实就是负责数据传递，存储，分发就行，一定要追求的是高性能。尽量简洁，快速。其次大部分情况下http大部分都是短链接，在实际的交互过程中，一个请求到响应很有可能会中断，中断以后就不会就行持久化，就会造成请求的丢失。这样就不利于消息中间件的业务场景，因为消息中间件可能是一个长期的获取消息的过程，出现问题和故障要对数据或消息就行持久化等，目的是为了保证消息和数据的高可靠和稳健的运行。</p></blockquote><hr><h3 id="AMQP协议"><a href="#AMQP协议" class="headerlink" title="AMQP协议"></a>AMQP协议</h3><p>Advanced Message Queuing Protocol 高级消息队列协议</p><p>它是一种面向消息中间件的开放标准，支持应用程序之间安全可靠的通信。</p><p>它提供了一个灵活和可扩展的消息体系结构，具有事务、路由和消息持久性等特性。</p><p>特点：</p><ul><li>分布式事务支持。</li><li>消息的持久化支持。</li><li>高性能和高可靠的消息处理优势。</li></ul><h3 id="MQTT协议"><a href="#MQTT协议" class="headerlink" title="MQTT协议"></a>MQTT协议</h3><p>Message Queueing Telemetry Transport </p><p>它是一种轻量级的发布-订阅消息传递协议，专为资源受限的设备和低带宽的网络设计。</p><p>它被广泛应用于物联网(Internet of Things)和M2M (Machine-to-Machine)通信，为设备之间的数据传输和接收提供了一种简单高效的机制。</p><p>特点：</p><ul><li>轻量</li><li>结构简单</li><li>传输快，不支持事务</li><li>没有持久化设计。</li></ul><p>应用场景：</p><ul><li>适用于计算能力有限</li><li>低带宽</li><li>网络不稳定的场景。</li></ul><h3 id="OpenMessage协议"><a href="#OpenMessage协议" class="headerlink" title="OpenMessage协议"></a>OpenMessage协议</h3><p>它是阿里巴巴集团为其中间件产品RocketMQ开发的专有消息协议。</p><p>它提供高性能和可靠的消息传递，具有消息排序、容错和发布-订阅消息等特性。</p><p>特点：</p><ul><li>结构简单</li><li>解析速度快</li><li>支持事务和持久化设计。</li></ul><h3 id="Kafka协议"><a href="#Kafka协议" class="headerlink" title="Kafka协议"></a>Kafka协议</h3><p>Kafka协议是基于TCP&#x2F;IP的二进制协议。</p><p>其消息内部是通过长度来分割，由一些基本数据类型组成。</p><p>特点：</p><ul><li>结构简单</li><li>解析速度快</li><li>无事务支持</li><li>有持久化设计</li></ul><hr><h2 id="1-MQ持久化"><a href="#1-MQ持久化" class="headerlink" title="1. MQ持久化"></a>1. MQ持久化</h2><p>持久化就是将数据存入磁盘，而不是存在内存中随服务器重启断开而消失，使数据能够永久保存。</p><p><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/02/28/kuangstudyf908e193-4ca3-44b7-87d0-cbb17b55a107.png" alt="avatar"></p><hr><h2 id="2-消息的分发策略"><a href="#2-消息的分发策略" class="headerlink" title="2. 消息的分发策略"></a>2. 消息的分发策略</h2><p>由于MQ有<strong>生产者、存储信息和消费者</strong>这三个角色，</p><p>那么当生产者生成消息之后，MQ进行存储，消费者通过<code>push</code>和<code>pull</code>来进行获取消息。</p><p>MQ就是一种推送的过程。</p><p>具体来说：</p><p>消息分发策略是指<strong>用于确定哪些消费者从消息传递系统哪里接收什么特定消息的技术</strong>。</p><p>以下是常见的消息分发策略。</p><ul><li><p>Fan-Out：这种策略包括同时向所有订阅者或消费者发送消息。</p></li><li><p>Fan-In：这种策略涉及一次将消息发送给一个consumer，通常采用轮询方式。</p></li><li><p>负载平衡：此策略涉及基于消费者的处理能力和当前工作负载等因素以平衡的方式将消息分发给消费者。</p></li><li><p>分片Sharding：这种策略涉及将消息分成更小的块，称为分片(shard)，并将它们分发给不同的消费者进行并行处理。</p></li><li><p>过滤Filtering：此策略涉及根据预定义的过滤器(如消息内容或消费者类型)将消息发送给消费者的子集。</p></li><li><p>路由Routing：此策略涉及根据其路由键(由消息发布者确定)将消息发送给特定的消费者。</p></li></ul><hr><h2 id="3-MQ高可用和高可靠"><a href="#3-MQ高可用和高可靠" class="headerlink" title="3. MQ高可用和高可靠"></a>3. MQ高可用和高可靠</h2><h3 id="高可用？"><a href="#高可用？" class="headerlink" title="高可用？"></a>高可用？</h3><p>指产品在规定的条件和规定的时间内处于<strong>可执行规定功能状态的能力</strong>。</p><p>高可用有以下几种<strong>集群模式</strong>，都是为了保证消息服务器不会寄，就算寄了依然可以很快的修复或者维持基本功能。</p><ul><li>Master-slave主从共享数据的部署方式</li><li>Master- slave主从同步部署方式</li><li>多主集群同步部署模式</li><li>多主集群转发部署模式</li><li>Master-slave与Breoker-cluster组合的方案</li></ul><h3 id="高可靠？"><a href="#高可靠？" class="headerlink" title="高可靠？"></a>高可靠？</h3><p>指系统可以<strong>无故障地持续运行</strong>，若一个系统突然崩溃、报错、异常，能不影响线上业务的正常运行，且出错的几率极低。</p><p>若想达到高可靠性，需要考虑以下两点：</p><ul><li>消息的传输：通过协议来保证系统间数据解析的正确性。</li><li>消息的存储可靠：通过持久化来保证消息的可靠性。</li></ul><hr><h1 id="三、RabbitMQ入门"><a href="#三、RabbitMQ入门" class="headerlink" title="三、RabbitMQ入门"></a>三、RabbitMQ入门</h1><blockquote><p>环境：</p><ul><li>Windows 10</li><li>Docker</li><li>VSCode</li><li>勤劳的双手</li></ul></blockquote><p><em>笔者致力于创作上至老奶奶，下至小狗狗都能看懂的教程！</em></p><h2 id="0-Docker下安装RabbitMQ"><a href="#0-Docker下安装RabbitMQ" class="headerlink" title="0. Docker下安装RabbitMQ"></a>0. Docker下安装RabbitMQ</h2><h3 id="拉取镜像："><a href="#拉取镜像：" class="headerlink" title="拉取镜像："></a>拉取镜像：</h3><p>在cmd中直接输入以下即可，实测不需要打开管理员权限，也不需要切换目录；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker search rabbitMq</span><br><span class="line"></span><br><span class="line">docker pull docker.io/rabbitmq:3.8-management</span><br></pre></td></tr></table></figure><h3 id="创建容器："><a href="#创建容器：" class="headerlink" title="创建容器："></a>创建容器：</h3><p>进入 Docker Desktop 查看镜像ID，当然你也可以<code>docker images</code></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/829e35d4eaca409789a9b316e6a30334~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>将其复制并在cmd中输入以下指令来创建rabbitMq容器：</p><p><code>docker run --name rabbitmq -d -p 15672:15672 -p 5672:5672 818bf18535d7</code></p><p>参数说明：</p><ul><li><code>--name</code>是容器名称，这里我们使用的是<code>rabbitmq</code></li><li><code>-d</code>是令容器后台运行</li><li><code>-p</code>是设置容器内部端口号与主机的映射，web端口默认值为<code>15672</code>，数据通信端口默认值为<code>5672</code></li></ul><p>如果返回一大串容器ID那就说明创建成功啦！</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c90c89a804c04178aa9e10d9bc453eeb~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h3 id="查看状态："><a href="#查看状态：" class="headerlink" title="查看状态："></a>查看状态：</h3><p>这个时候我们可以查看容器是否在运行，当然你也可以使用<code>docker ps</code>来查看</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d09b86a5bfa54900af5361ed1c366de2~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>同样的，我们在这里把容器ID复制下来之后使用<code>docker logs -f &lt;ID&gt;</code>可以查看容器的日志；</p><p>特别地，容器的ID可以简写，前提是保证前缀不与其他容器的相同。</p><p>就像这样：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87bba41248a7409992a835504cd6b1cc~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><hr><h2 id="1-Web端的简单测试"><a href="#1-Web端的简单测试" class="headerlink" title="1. Web端的简单测试"></a>1. Web端的简单测试</h2><h3 id="进入Web端："><a href="#进入Web端：" class="headerlink" title="进入Web端："></a>进入Web端：</h3><p>首先进入cmd输入<code>ipconfig</code>获取本机IP：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7380674c5874444bfa3eab1de3de6c3~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>随后输入<code>&lt;IP&gt;:15672</code>进入RabbitMQ的Web端，</p><p>例如笔者就是<code>192.168.1.4:15672</code>，随后出现如下界面：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1dcada7a7e04ee980a0be35a7d2df24~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>这个时候我们还没有创建任何账户，默认使用<code>guest</code>进行登录（账密都是）：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a42acef3e2544458b6394896a74faef2~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>Oh非常好，我们看到了想要的界面！</p><hr><h3 id="创建新的账户："><a href="#创建新的账户：" class="headerlink" title="创建新的账户："></a>创建新的账户：</h3><p>人活一世，总不能连个名字都没有，接下来我们就来创建一个新的账户，</p><p>毕竟guest有各种访问限制；</p><p>我们首先<strong>进入容器</strong>：<code>docker exec -i -t &lt;容器ID&gt; bin/bash</code></p><p>当然你也可以使用点击即送的方法进入，不过这次并不推荐：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c5f7f91484e429b9c526d4fe7a6de7e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>随后<strong>添加用户</strong>：<code>rabbitmqctl add_user &lt;username&gt; &lt;password&gt;</code></p><p>方便起见，我们就用root了，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@638f5fe7d784:/# rabbitmqctl add_user root 13243546</span><br><span class="line">Adding user &quot;root&quot; ...</span><br><span class="line">Done. Don&#x27;t forget to grant the user permissions to some virtual hosts! See &#x27;rabbitmqctl help set_permissions&#x27; to learn more.</span><br></pre></td></tr></table></figure><p>这个时候root还不是”root”呀，我们不能袖手旁观，需要<strong>赋予权限</strong>：</p><p><code>rabbitmqctl set_permissions -p / root &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</code></p><p>这样可能还不够，还需要给其赋予administrator的角色：</p><p><code>rabbitmqctl set_user_tags root administrator</code></p><h3 id="查看所用用户："><a href="#查看所用用户：" class="headerlink" title="查看所用用户："></a>查看所用用户：</h3><p><code>rabbitmqctl list_users</code></p><p>以上的cmd效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@638f5fe7d784:/# rabbitmqctl set_permissions -p / root &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br><span class="line">Setting permissions for user &quot;root&quot; in vhost &quot;/&quot; ...</span><br><span class="line">root@638f5fe7d784:/# rabbitmqctl set_user_tags root administrator</span><br><span class="line">Setting tags for user &quot;root&quot; to [administrator] ...</span><br><span class="line">root@638f5fe7d784:/# rabbitmqctl list_users</span><br><span class="line">Listing users ...</span><br><span class="line">user    tags</span><br><span class="line">guest   [administrator]</span><br><span class="line">root    [administrator]</span><br></pre></td></tr></table></figure><h3 id="回到Web端，再次登录："><a href="#回到Web端，再次登录：" class="headerlink" title="回到Web端，再次登录："></a>回到Web端，再次登录：</h3><p>这时可以关闭退出容器了，直接<code>exit + 右上角</code>关闭cmd即可；</p><p>然后Log Out一下guest账户，重新输入刚才的账户：</p><p>可以看到，我们卷土重来了！</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afb205703f6b488780a1ca70283d6e25~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><hr><h2 id="2-Go-RabbitMQ实现HelloWorld"><a href="#2-Go-RabbitMQ实现HelloWorld" class="headerlink" title="2. Go + RabbitMQ实现HelloWorld"></a>2. Go + RabbitMQ实现HelloWorld</h2><p>没错，你没有看错，又是<code>HelloWorld</code>，话不多说让我们进入正题：</p><p>打开cmd，进入你想要的项目文件夹，老规矩<code>go mod init &lt;...&gt;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go mod init go-rabbitmq-demo</span><br><span class="line">go: creating new go.mod: module go-rabbitmq-demo</span><br><span class="line">code .  // 打开我们亲爱的VSCode</span><br></pre></td></tr></table></figure><p>随后创建send.go</p><p>引入<code>github.com/streadway/amqp</code>并<code>go mod tidy</code></p><h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><p>定义一个辅助函数用于检查每个amqp调用的返回值；</p><p>发送方和接收方最好都要有；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义辅助函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">failOnError</span><span class="params">(err <span class="type">error</span>, msg <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatalf(<span class="string">&quot;%s: %s&quot;</span>, msg, err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="send-go主函数"><a href="#send-go主函数" class="headerlink" title="send.go主函数"></a>send.go主函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 建立与 RabbitMQ 的连接</span></span><br><span class="line">    <span class="comment">// 配置连接套接字，定义连接的协议与身份验证</span></span><br><span class="line">    conn, err := amqp.Dial(<span class="string">&quot;amqp://guest:guest@localhost:5672/&quot;</span>)</span><br><span class="line">    failOnError(err, <span class="string">&quot;Failed to connect to RabbitMQ&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建通道来传递消息</span></span><br><span class="line">    ch, err := conn.Channel()</span><br><span class="line">    failOnError(err, <span class="string">&quot;Failed to open a channel&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> ch.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明要发送到的队列</span></span><br><span class="line">    q, err := ch.QueueDeclare(</span><br><span class="line">        <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">        <span class="literal">false</span>,</span><br><span class="line">        <span class="literal">false</span>,</span><br><span class="line">        <span class="literal">false</span>,</span><br><span class="line">        <span class="literal">false</span>,</span><br><span class="line">        <span class="literal">nil</span>,</span><br><span class="line">    )</span><br><span class="line">    failOnError(err, <span class="string">&quot;Failed to declare a queue&quot;</span>)</span><br><span class="line">    <span class="comment">// ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)</span></span><br><span class="line">    <span class="comment">// defer cancel()</span></span><br><span class="line"></span><br><span class="line">    body := <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将消息发布到声明的队列</span></span><br><span class="line">    err = ch.Publish(</span><br><span class="line">        <span class="string">&quot;&quot;</span>,</span><br><span class="line">        q.Name,</span><br><span class="line">        <span class="literal">false</span>,</span><br><span class="line">        <span class="literal">false</span>,</span><br><span class="line">        amqp.Publishing&#123;</span><br><span class="line">            ContentType: <span class="string">&quot;text/plain&quot;</span>,</span><br><span class="line">            Body:        []<span class="type">byte</span>(body),</span><br><span class="line">        &#125;)</span><br><span class="line">    failOnError(err, <span class="string">&quot;Failed to publish a message&quot;</span>)</span><br><span class="line">    <span class="comment">// log.Printf(&quot; [x] Sent %s\n&quot;, body)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="receive-go主函数"><a href="#receive-go主函数" class="headerlink" title="receive.go主函数"></a>receive.go主函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 建立与 RabbitMQ 的连接</span></span><br><span class="line">    conn, err := amqp.Dial(<span class="string">&quot;amqp://guest:guest@localhost:5672/&quot;</span>)</span><br><span class="line">    failOnError(err, <span class="string">&quot;Failed to connect to RabbitMQ&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取通道</span></span><br><span class="line">    ch, err := conn.Channel()</span><br><span class="line">    failOnError(err, <span class="string">&quot;Failed to open a channel&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> ch.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明队列</span></span><br><span class="line">    q, err := ch.QueueDeclare(</span><br><span class="line">        <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">        <span class="literal">false</span>,</span><br><span class="line">        <span class="literal">false</span>,</span><br><span class="line">        <span class="literal">false</span>,</span><br><span class="line">        <span class="literal">false</span>,</span><br><span class="line">        <span class="literal">nil</span>,</span><br><span class="line">    )</span><br><span class="line">    failOnError(err, <span class="string">&quot;Failed to declare a queue&quot;</span>)</span><br><span class="line"></span><br><span class="line">    msgs, err := ch.Consume(</span><br><span class="line">        q.Name, <span class="comment">// queue</span></span><br><span class="line">        <span class="string">&quot;&quot;</span>,     <span class="comment">// consumer</span></span><br><span class="line">        <span class="literal">true</span>,   <span class="comment">// auto-ack</span></span><br><span class="line">        <span class="literal">false</span>,  <span class="comment">// exclusive</span></span><br><span class="line">        <span class="literal">false</span>,  <span class="comment">// no-local</span></span><br><span class="line">        <span class="literal">false</span>,  <span class="comment">// no-wait</span></span><br><span class="line">        <span class="literal">nil</span>,    <span class="comment">// args</span></span><br><span class="line">    )</span><br><span class="line">    failOnError(err, <span class="string">&quot;Failed to register a consumer&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> forever <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> d := <span class="keyword">range</span> msgs &#123;</span><br><span class="line">            log.Printf(<span class="string">&quot;Received a message: %s&quot;</span>, d.Body)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    log.Printf(<span class="string">&quot; [*] Waiting for messages. To exit press CTRL+C&quot;</span>)</span><br><span class="line">    &lt;-forever</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="运行！"><a href="#运行！" class="headerlink" title="运行！"></a>运行！</h3><p>分别在两个cmd里面执行<code>go run send.go</code>和<code>go run receive.go</code></p><p>注意，<code>send</code>可以执行多次之后再执行<code>receive</code>，也可以先开启<code>receive</code>，读者不妨自己尝试一下；</p><p>我们可以在Web端看到，Channel中有数据的情况：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9ecbca20ad34c709f77526162c1d41f~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>终端的情况是这样的：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/221f097bdec64106bc3ecc12fe65270a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h3 id="文件目录结构"><a href="#文件目录结构" class="headerlink" title="文件目录结构"></a>文件目录结构</h3><p>很简单，就这四个东西：</p><p align=center><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5368c5bc790d41a183dba9283c2b496c~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"  /></p><hr><p>THE END.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;零、前言&quot;&gt;&lt;a href=&quot;#零、前言&quot; class=&quot;headerlink&quot; title=&quot;零、前言&quot;&gt;&lt;/a&gt;零、前言&lt;/h1&gt;&lt;p&gt;本文记录了笔者在学习消息队列和RabbitMQ的基础知识的过程，&lt;/p&gt;
&lt;p&gt;若笔者有任何疏忽纰漏之处，烦请不吝赐教。&lt;/</summary>
      
    
    
    
    <category term="Devlopment-Tech" scheme="https://conqueror712.github.io/categories/Devlopment-Tech/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker + VSCode丨学习记录</title>
    <link href="https://conqueror712.github.io/post/Docker.html"/>
    <id>https://conqueror712.github.io/post/Docker.html</id>
    <published>2023-01-29T06:06:45.000Z</published>
    <updated>2023-03-23T01:30:57.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="零、前言："><a href="#零、前言：" class="headerlink" title="零、前言："></a>零、前言：</h1><p>本文是笔者从零开始学习Docker的学习记录。</p><p>若笔者有任何疏忽纰漏之处，烦请不吝赐教。</p><blockquote><p>个人博客：<a href="https://conqueror712.github.io/">https://conqueror712.github.io/</a></p><p>知乎：<a href="https://www.zhihu.com/people/soeur712/posts">https://www.zhihu.com/people/soeur712/posts</a></p><p>Bilibili：<a href="https://space.bilibili.com/57089326">https://space.bilibili.com/57089326</a></p><p>掘金：<a href="https://juejin.cn/user/1297878069809725/posts">https://juejin.cn/user/1297878069809725/posts</a></p></blockquote><h1 id="一、Docker简介："><a href="#一、Docker简介：" class="headerlink" title="一、Docker简介："></a>一、Docker简介：</h1><p>Docker 是一个应用打包、分发、部署的工具<br>你也可以把它理解为一个轻量的虚拟机，它只虚拟你软件需要的运行环境，多余的一点都不要，<br>而普通虚拟机则是一个完整而庞大的系统，包含各种不管你要不要的软件。</p><p>Docker 的入门知识还有以下几点需要了解：</p><ol><li><p>镜像 (image) 和容器 (container) 的关系：镜像是容器的模板，容器是镜像运行时的实例。</p></li><li><p>Docker Hub：Docker Hub 是一个公共镜像仓库，可以在这里搜索和下载镜像。</p></li><li><p>Dockerfile: 一个Dockerfile 文件是一个文本文件，包含了一条条指令，它告诉Docker如何构建一个镜像.</p></li><li><p>容器网络:Docker支持多种网络模式,包括host,bridge,overlay等.</p></li><li><p>数据管理:Docker支持将容器中的数据挂载到宿主机上,或者将容器间共享数据.</p></li><li><p>使用docker-compose:docker-compose是一个用来管理多个容器的工具,可以通过一个配置文件来管理多个容器,并且可以一键启动和停止.</p></li><li><p>注意事项：</p><ul><li><p>不要在root用户下运行Docker，需要使用sudo</p></li><li><p>在开发过程中，需要注意容器的版本管理，保证不同环境的稳定性</p></li><li><p>需要注意容器的网络配置，确保容器之间可以互相访问</p></li><li><p>容器中的数据需要及时备份</p></li></ul></li></ol><hr><h1 id="二、小试牛刀"><a href="#二、小试牛刀" class="headerlink" title="二、小试牛刀"></a>二、小试牛刀</h1><h2 id="快速开始："><a href="#快速开始：" class="headerlink" title="快速开始："></a>快速开始：</h2><p>一个非常简单的办法，结合vscode：</p><p>以一个Go项目举例：</p><p><code>docker run -dit -v /d/goenv:/root/goenv golang</code><br>注意：地址可以自己更换</p><p><code>docker run</code> 是用来启动一个新的 Docker 容器的命令。</p><ul><li><code>-d</code> : 后台运行容器，即在后台运行容器而不阻塞当前的终端。</li><li><code>-i</code> : 保留标准输入的活性，这样可以在容器中使用命令行</li><li><code>-t</code> : 分配一个伪终端（tty），这样可以在容器中使用命令行</li><li><code>-v /d/goenv:/root/goenv</code> : 使用 <code>-v</code> 选项将主机的 <code>/d/goenv</code> 目录挂载到容器的 <code>/root/goenv</code> 目录。这样就可以在容器中访问主机上的文件。</li><li><code>golang</code> : 指定要使用的 Docker 镜像的名称。</li></ul><p>然后使用VSCODE连接就行了<br>之后就是初始化等等的操作<br><code>go mod init goenv</code><br>编写<code>main.go</code>等等…</p><p><strong>重要概念</strong>：</p><p><strong>镜像</strong>：可以理解为软件安装包，可以方便的进行传播和安装。<br><strong>容器</strong>：软件安装后的状态，每个软件运行环境都是独立的、隔离的，称之为容器。</p><p><strong>常用相关命令</strong>：</p><p><code>docker ps</code> 查看当前运行中的容器<br><code>docker images</code> 查看镜像列表<br><code>docker rm container-id</code> 删除指定 id 的容器<br><code>docker stop/start container-id</code> 停止&#x2F;启动指定 id 的容器<br><code>docker rmi image-id</code> 删除指定 id 的镜像<br><code>docker volume ls</code> 查看 volume 列表<br><code>docker network ls</code> 查看网络列表</p><hr><h2 id="Docker-VS-普通虚拟机："><a href="#Docker-VS-普通虚拟机：" class="headerlink" title="Docker VS 普通虚拟机："></a>Docker VS 普通虚拟机：</h2><table><thead><tr><th>特性</th><th>普通虚拟机</th><th>Docker</th></tr></thead><tbody><tr><td>跨平台</td><td>通常只能在桌面级系统运行，例如 Windows&#x2F;Mac，无法在不带图形界面的服务器上运行</td><td>支持的系统非常多，各类 windows 和 Linux 都支持</td></tr><tr><td>性能</td><td>性能损耗大，内存占用高，因为是把整个完整系统都虚拟出来了</td><td>性能好，只虚拟软件所需运行环境，最大化减少没用的配置</td></tr><tr><td>自动化</td><td>需要手动安装所有东西</td><td>一个命令就可以自动部署好所需环境</td></tr><tr><td>稳定性</td><td>稳定性不高，不同系统差异大</td><td>稳定性好，不同系统都一样部署方式</td></tr></tbody></table><h3 id="开发方面与WSL2的对比："><a href="#开发方面与WSL2的对比：" class="headerlink" title="开发方面与WSL2的对比："></a>开发方面与WSL2的对比：</h3><p>Docker 和 WSL 2 两者都可以在 Windows 系统上提供 Linux 环境，但是它们的工作原理和用途是有区别的。</p><p>WSL 2 是 Windows Subsystem for Linux 的第二版，可以在 Windows 系统上运行 Linux 子系统，并且支持运行原生 Linux 应用程序。WSL 2 可以让开发者在 Windows 上使用 Linux 环境进行开发，并且可以直接访问 Windows 系统上的文件。</p><p>Docker 是一个容器化平台，可以在宿主机上运行多个独立的容器，每个容器都可以运行不同的应用程序。Docker 可以将应用程序和其所需的环境封装在一起，方便进行部署和移植。使用Docker，可以在不同的环境下,方便的部署和调试，并且可以隔离这些环境，不会相互影响.</p><p>总的来说，WSL 2 主要用于在 Windows 上使用 Linux 环境进行开发，而 Docker 则更多用于将应用程序和其所需的环境封装在容器中，方便进行部署和移植。</p><hr><h2 id="镜像加速源："><a href="#镜像加速源：" class="headerlink" title="镜像加速源："></a>镜像加速源：</h2><table><thead><tr><th>镜像加速器</th><th>镜像加速器地址</th></tr></thead><tbody><tr><td>Docker 中国官方镜像</td><td><a href="https://registry.docker-cn.com/">https://registry.docker-cn.com</a></td></tr><tr><td>DaoCloud 镜像站</td><td><a href="http://f1361db2.m.daocloud.io/">http://f1361db2.m.daocloud.io</a></td></tr><tr><td>Azure 中国镜像</td><td><a href="https://dockerhub.azk8s.cn/">https://dockerhub.azk8s.cn</a></td></tr><tr><td>科大镜像站</td><td><a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn</a></td></tr><tr><td>阿里云</td><td>https:&#x2F;&#x2F;<your_code>.mirror.aliyuncs.com</td></tr><tr><td>七牛云</td><td><a href="https://reg-mirror.qiniu.com/">https://reg-mirror.qiniu.com</a></td></tr><tr><td>网易云</td><td><a href="https://hub-mirror.c.163.com/">https://hub-mirror.c.163.com</a></td></tr><tr><td>腾讯云</td><td><a href="https://mirror.ccs.tencentyun.com/">https://mirror.ccs.tencentyun.com</a></td></tr></tbody></table><hr><h2 id="Docker安装软件："><a href="#Docker安装软件：" class="headerlink" title="Docker安装软件："></a>Docker安装软件：</h2><blockquote><h3 id="直接安装的缺点"><a href="#直接安装的缺点" class="headerlink" title="直接安装的缺点"></a>直接安装的缺点</h3><ul><li>安装麻烦，可能有各种依赖，运行报错。例如：WordPress，ElasticSearch，Redis，ELK</li><li>可能对 Windows 并不友好，运行有各种兼容问题，软件只支持 Linux 上跑</li><li>不方便安装多版本软件，不能共存。</li><li>电脑安装了一堆软件，拖慢电脑速度。</li><li>不同系统和硬件，安装方式不一样</li></ul><h3 id="Docker-安装的优点"><a href="#Docker-安装的优点" class="headerlink" title="Docker 安装的优点"></a>Docker 安装的优点</h3><ul><li>一个命令就可以安装好，快速方便</li><li>有大量的镜像，可直接使用</li><li>没有系统兼容问题，Linux 专享软件也照样跑</li><li>支持软件多版本共存</li><li>用完就丢，不拖慢电脑速度</li><li>不同系统和硬件，只要安装好 Docker 其他都一样了，一个命令搞定所有</li></ul></blockquote><hr><h2 id="VSCode-Docker"><a href="#VSCode-Docker" class="headerlink" title="VSCode + Docker"></a>VSCode + Docker</h2><h3 id="使用VSCode打开Docker中已开启的镜像："><a href="#使用VSCode打开Docker中已开启的镜像：" class="headerlink" title="使用VSCode打开Docker中已开启的镜像："></a>使用VSCode打开Docker中已开启的镜像：</h3><p>在VSCode中安装Docker插件之后，直接点击，会看到很多已创建好的镜像，</p><p>右键然后在VSCode里打开就好了（具体的名字可能不是这个，翻译问题）</p><h3 id="code-workspace文件说明："><a href="#code-workspace文件说明：" class="headerlink" title=".code-workspace文件说明："></a>.code-workspace文件说明：</h3><p><code>.code-workspace</code> 文件是 Visual Studio Code 的工作区文件，它用于记录打开的文件夹和已安装的插件等配置信息。</p><p>在 Visual Studio Code 中，你可以通过以下方式生成 <code>.code-workspace</code> 文件：</p><ol><li>在文件资源管理器中，右键单击文件夹并选择 “Save Workspace As…” 来保存当前工作区。</li><li>选择 “File” 菜单中的 “Save Workspace As…” 来保存当前工作区。</li><li>在命令面板中输入 “Save Workspace As…” 并回车来保存当前工作区。</li></ol><p>保存后的工作区文件将会以 <code>.code-workspace</code> 为扩展名保存在你指定的位置.</p><hr><h1 id="三、继续向前"><a href="#三、继续向前" class="headerlink" title="三、继续向前"></a>三、继续向前</h1><h2 id="DockerFile相关："><a href="#DockerFile相关：" class="headerlink" title="DockerFile相关："></a>DockerFile相关：</h2><p>先看一个例子：</p><blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">11</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> easydoc.net</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制代码</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> . /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置容器启动后的默认运行目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行命令，安装依赖</span></span><br><span class="line"><span class="comment"># RUN 命令可以有多个，但是可以用 &amp;&amp; 连接多个命令来减少层级。</span></span><br><span class="line"><span class="comment"># 例如 RUN npm install &amp;&amp; cd /app &amp;&amp; mkdir logs</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm install --registry=https://registry.npm.taobao.org</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CMD 指令只能一个，是容器启动后执行的命令，算是程序的入口。</span></span><br><span class="line"><span class="comment"># 如果还需要运行其他命令可以用 &amp;&amp; 连接，也可以写成一个shell脚本去执行。</span></span><br><span class="line"><span class="comment"># 例如 CMD cd /app &amp;&amp; ./start.sh</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> node app.js</span></span><br></pre></td></tr></table></figure></blockquote><p>Dockerfile 是用来构建 Docker 镜像的配置文件。其中，<code>RUN</code> 指令是用来在镜像构建过程中执行命令的。</p><p>在这个例子中，<code>RUN npm install --registry=https://registry.npm.taobao.org</code> 的作用是安装 npm 包，并将 npm 的镜像源设置为淘宝镜像，为了加速npm 的安装速度。</p><p>这个命令会在Docker容器中执行，会在容器中安装npm的包，在这个命令执行完成后，npm包已经安装在容器中了。</p><p>注意：使用 npm install 命令前需要先使用COPY或者ADD指令将项目文件复制到容器中。</p><p>参考：<a href="https://docs.docker.com/engine/reference/builder/#run">Dockerfile reference | Docker Documentation</a></p><hr><h2 id="目录挂载："><a href="#目录挂载：" class="headerlink" title="目录挂载："></a>目录挂载：</h2><p>目录挂载可以解决的问题：</p><ul><li>使用 Docker 运行后，倘若修改项目代码不会立刻生效，需要重新<code>build</code>和<code>run</code>，很麻烦。</li><li>容器里面产生的数据，例如 log 文件，数据库备份文件，容器删除后就丢失了。</li></ul><p><strong>目录挂载的方式</strong>：</p><ul><li><code>bind mount</code> 直接把宿主机目录映射到容器内，适合挂代码目录和配置文件。可挂到多个容器上</li><li><code>volume</code> 由容器创建和管理，创建在宿主机，所以删除容器不会丢失，官方推荐，更高效，Linux 文件系统，适合存储数据库数据。可挂到多个容器上</li><li><code>tmpfs mount</code> 适合存储临时文件，存宿主机内存中。不可多容器共享。</li></ul><p><code>bind mount</code> 方式用绝对路径 <code>-v D:/code:/app</code></p><p><code>volume</code> 方式，只需要一个名字 <code>-v db-data:/app</code>，注意，这里的<code>db-data</code>就是名字，这块区域由容器自己来创建。</p><p>bind mount例：<code>docker run -p 9090:8080 --name test-hello -v D:/code:/app -d golang:v1</code></p><ul><li>这里是把项目的代码目录挂载到容器里面的<code>/app</code>目录</li><li>把容器的8080暴露到伺服器的9090端口</li><li>容器名字命名为test-hello</li><li>挂载绝对目录</li><li><code>-d</code>表示在后台运行</li><li><code>golang:v1</code>指定镜像的名字和版本</li></ul><p>于是我们的代码就愉快的跑起来了；</p><hr><p>余下内容未完待续…</p><p>谢谢大家的阅读，欢迎互动，也欢迎访问我的博客！</p><p><a href="https://conqueror712.gitee.io/conqueror712.gitee.io/">落雨乄天珀夜 (gitee.io)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;零、前言：&quot;&gt;&lt;a href=&quot;#零、前言：&quot; class=&quot;headerlink&quot; title=&quot;零、前言：&quot;&gt;&lt;/a&gt;零、前言：&lt;/h1&gt;&lt;p&gt;本文是笔者从零开始学习Docker的学习记录。&lt;/p&gt;
&lt;p&gt;若笔者有任何疏忽纰漏之处，烦请不吝赐教。&lt;/p&gt;
&lt;b</summary>
      
    
    
    
    <category term="Devlopment-Tech" scheme="https://conqueror712.github.io/categories/Devlopment-Tech/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis丨学习记录</title>
    <link href="https://conqueror712.github.io/post/Redis.html"/>
    <id>https://conqueror712.github.io/post/Redis.html</id>
    <published>2023-01-29T06:00:41.000Z</published>
    <updated>2023-03-23T01:21:38.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="零、前言"><a href="#零、前言" class="headerlink" title="零、前言"></a>零、前言</h1><p>本文是笔者从零开始学习Redis的学习记录。</p><p>若笔者有任何疏忽纰漏之处，烦请不吝赐教。</p><blockquote><p>个人博客：<a href="https://conqueror712.github.io/">https://conqueror712.github.io/</a></p><p>知乎：<a href="https://www.zhihu.com/people/soeur712/posts">https://www.zhihu.com/people/soeur712/posts</a></p><p>Bilibili：<a href="https://space.bilibili.com/57089326">https://space.bilibili.com/57089326</a></p><p>掘金：<a href="https://juejin.cn/user/1297878069809725/posts">https://juejin.cn/user/1297878069809725/posts</a></p></blockquote><hr><h1 id="一、开门见山"><a href="#一、开门见山" class="headerlink" title="一、开门见山"></a>一、开门见山</h1><p>源码：<a href="https://github.com/redis/redis">https://github.com/redis/redis</a></p><h2 id="Redis是什么？"><a href="#Redis是什么？" class="headerlink" title="Redis是什么？"></a><strong>Redis</strong>是什么？</h2><ul><li><p><strong>基于内存的多模型数据库，毫秒级的延迟</strong></p></li><li><p>Remote Dictionary Server</p></li><li><p>是一个由<code>Salvatore Sanfilippo</code>写的<code>key-value</code>存储系统；</p></li><li><p>是<strong>跨平台的非关系型数据库</strong>；</p></li><li><p>是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的 API。</p></li></ul><h2 id="Redis有什么特点？"><a href="#Redis有什么特点？" class="headerlink" title="Redis有什么特点？"></a>Redis有什么特点？</h2><ul><li>Redis 通常被称为<strong>数据结构服务器</strong>，因为值可以是字符串、哈希、列表、集合和有序集合等类型。</li><li>Redis支持<strong>数据的持久化</strong>，可以将<strong>内存中的数据保存在磁盘中</strong>，重启的时候可以再次加载进行使用。</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47f76ed6d91f496ab5279e68a691b317~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h2 id="Redis的优势有哪些？"><a href="#Redis的优势有哪些？" class="headerlink" title="Redis的优势有哪些？"></a>Redis的优势有哪些？</h2><ul><li>性能极高</li><li>丰富的数据类型，因此你不需要把它塞进一堆表或者JSON文档里</li><li>原子 – Redis的所有操作都是原子性的，意思就是<strong>要么成功执行要么失败完全不执行</strong>。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</li><li>丰富的特性 – Redis还支持 publish&#x2F;subscribe, 通知, key 过期等等特性。</li></ul><h2 id="Redis的其他补充？"><a href="#Redis的其他补充？" class="headerlink" title="Redis的其他补充？"></a>Redis的其他补充？</h2><ul><li>缓存也可以用于存储持久化数据</li><li>传统的关系型数据库没办法做到快速把数据传递给终端用户</li><li>数据总是会在内存上进行修改和读取，而不是在慢得多的硬盘上，但与此同时，它会把数据存储在硬盘上，这样就可以按需对数据进行重建，因此数据库是完全持久化的</li><li>Redis完全可以作为主数据库，并且可以显著地降低复杂度</li><li>多模型——可以通过扩展模块来支持多种数据库范式，可以按需引用，如下图所示：</li></ul><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/111409e98b124e52a3229eb9a02f433b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><hr><h2 id="Redis如何安装？"><a href="#Redis如何安装？" class="headerlink" title="Redis如何安装？"></a>Redis如何安装？</h2><ol><li>在<a href="https://github.com/tporadowski/redis/releases%E4%B8%AD%E9%80%89%E6%8B%A9%60.zip%60%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E5%B9%B6%E8%A7%A3%E5%8E%8B%EF%BC%88%E5%BD%93%E7%84%B6%E4%B9%9F%E5%8F%AF%E4%BB%A5%E9%80%89%E5%88%AB%E7%9A%84%EF%BC%89%EF%BC%8C%E7%84%B6%E5%90%8Erename%E4%B8%BAredis">https://github.com/tporadowski/redis/releases中选择`.zip`格式的文件下载并解压（当然也可以选别的），然后rename为redis</a></li><li>在解压路径下打开<code>cmd</code>并输入<code>redis-server.exe redis.windows.conf</code>，你会看到如下图所示的样子：</li></ol><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/721cdc037d934682b7c19999cd6fde1c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><ol start="3"><li>添加环境变量，地址就是解压地址</li><li>保持上面这个<code>cmd</code>窗口不要关闭的情况下再开启一个<code>cmd</code>，运行<code>redis-cli.exe -h 127.0.0.1 -p &lt;your port num&gt;</code>（好像都是6379？），这里如果报错，你可能需要WIN+R开启cmd而不是用其他的方法</li></ol><p>（Redis的配置暂略，有需要更改的话会再补充相关内容）</p><hr><h1 id="二、继续向前"><a href="#二、继续向前" class="headerlink" title="二、继续向前"></a>二、继续向前</h1><h2 id="Redis命令"><a href="#Redis命令" class="headerlink" title="Redis命令"></a>Redis命令</h2><p>可参考网站：</p><p><a href="http://doc.redisfans.com/">Redis 命令参考 — Redis 命令参考 (redisfans.com)</a></p><p><a href="https://redis.io/commands/">Commands | Redis</a></p><p>在端口启动的情况下，输入<code>redis-cli</code>即可进入redis客户端，输入<code>PING</code>输出<code>PONG</code>即证明成功启动。</p><h2 id="Redis键"><a href="#Redis键" class="headerlink" title="Redis键"></a>Redis键</h2><h4 id="Redis键的基本命令："><a href="#Redis键的基本命令：" class="headerlink" title="Redis键的基本命令："></a>Redis键的基本命令：</h4><ul><li><a href="http://doc.redisfans.com/key/del.html">DEL</a></li><li><a href="http://doc.redisfans.com/key/dump.html">DUMP</a></li><li><a href="http://doc.redisfans.com/key/exists.html">EXISTS</a></li><li><a href="http://doc.redisfans.com/key/expire.html">EXPIRE</a></li><li><a href="http://doc.redisfans.com/key/expireat.html">EXPIREAT</a></li><li><a href="http://doc.redisfans.com/key/keys.html">KEYS</a></li><li><a href="http://doc.redisfans.com/key/migrate.html">MIGRATE</a></li><li><a href="http://doc.redisfans.com/key/move.html">MOVE</a></li><li><a href="http://doc.redisfans.com/key/object.html">OBJECT</a></li><li><a href="http://doc.redisfans.com/key/persist.html">PERSIST</a></li><li><a href="http://doc.redisfans.com/key/pexpire.html">PEXPIRE</a></li><li><a href="http://doc.redisfans.com/key/pexpireat.html">PEXPIREAT</a></li><li><a href="http://doc.redisfans.com/key/pttl.html">PTTL</a></li><li><a href="http://doc.redisfans.com/key/randomkey.html">RANDOMKEY</a></li><li><a href="http://doc.redisfans.com/key/rename.html">RENAME</a></li><li><a href="http://doc.redisfans.com/key/renamenx.html">RENAMENX</a></li><li><a href="http://doc.redisfans.com/key/restore.html">RESTORE</a></li><li><a href="http://doc.redisfans.com/key/sort.html">SORT</a></li><li><a href="http://doc.redisfans.com/key/ttl.html">TTL</a></li><li><a href="http://doc.redisfans.com/key/type.html">TYPE</a></li><li><a href="http://doc.redisfans.com/key/scan.html">SCAN</a></li></ul><h2 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h2><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>特点：</p><ul><li>一个key对应一个value</li><li>string类型是<strong>二进制安全的</strong>，意思是 redis 的 string 可以包含任何数据例如jpg图片或者序列化的对象</li><li>string类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB</li></ul><p>demo：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afbaaffa219b4132a784d18b6e4fb886~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h4 id="string的基本命令："><a href="#string的基本命令：" class="headerlink" title="string的基本命令："></a>string的基本命令：</h4><ul><li><a href="http://doc.redisfans.com/string/append.html">APPEND</a></li><li><a href="http://doc.redisfans.com/string/bitcount.html">BITCOUNT</a></li><li><a href="http://doc.redisfans.com/string/bitop.html">BITOP</a></li><li><a href="http://doc.redisfans.com/string/decr.html">DECR</a></li><li><a href="http://doc.redisfans.com/string/decrby.html">DECRBY</a></li><li><a href="http://doc.redisfans.com/string/get.html">GET</a></li><li><a href="http://doc.redisfans.com/string/getbit.html">GETBIT</a></li><li><a href="http://doc.redisfans.com/string/getrange.html">GETRANGE</a></li><li><a href="http://doc.redisfans.com/string/getset.html">GETSET</a></li><li><a href="http://doc.redisfans.com/string/incr.html">INCR</a></li><li><a href="http://doc.redisfans.com/string/incrby.html">INCRBY</a></li><li><a href="http://doc.redisfans.com/string/incrbyfloat.html">INCRBYFLOAT</a></li><li><a href="http://doc.redisfans.com/string/mget.html">MGET</a></li><li><a href="http://doc.redisfans.com/string/mset.html">MSET</a></li><li><a href="http://doc.redisfans.com/string/msetnx.html">MSETNX</a></li><li><a href="http://doc.redisfans.com/string/psetex.html">PSETEX</a></li><li><a href="http://doc.redisfans.com/string/set.html">SET</a></li><li><a href="http://doc.redisfans.com/string/setbit.html">SETBIT</a></li><li><a href="http://doc.redisfans.com/string/setex.html">SETEX</a></li><li><a href="http://doc.redisfans.com/string/setnx.html">SETNX</a></li><li><a href="http://doc.redisfans.com/string/setrange.html">SETRANGE</a></li><li><a href="http://doc.redisfans.com/string/strlen.html">STRLEN</a></li></ul><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>特点：</p><ul><li>hash是一个键值对集合</li><li>hash是一个string类型的field和value的映射表，特别适合存储对象</li><li>每个 hash 可以存储 2^32 -1 键值对</li></ul><p>demo：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5fb120be05054b8c821f8fc3665fd5bf~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h4 id="hash的基本命令："><a href="#hash的基本命令：" class="headerlink" title="hash的基本命令："></a>hash的基本命令：</h4><ul><li><a href="http://doc.redisfans.com/hash/hdel.html">HDEL</a></li><li><a href="http://doc.redisfans.com/hash/hexists.html">HEXISTS</a></li><li><a href="http://doc.redisfans.com/hash/hget.html">HGET</a></li><li><a href="http://doc.redisfans.com/hash/hgetall.html">HGETALL</a></li><li><a href="http://doc.redisfans.com/hash/hincrby.html">HINCRBY</a></li><li><a href="http://doc.redisfans.com/hash/hincrbyfloat.html">HINCRBYFLOAT</a></li><li><a href="http://doc.redisfans.com/hash/hkeys.html">HKEYS</a></li><li><a href="http://doc.redisfans.com/hash/hlen.html">HLEN</a></li><li><a href="http://doc.redisfans.com/hash/hmget.html">HMGET</a></li><li><a href="http://doc.redisfans.com/hash/hmset.html">HMSET</a></li><li><a href="http://doc.redisfans.com/hash/hset.html">HSET</a></li><li><a href="http://doc.redisfans.com/hash/hsetnx.html">HSETNX</a></li><li><a href="http://doc.redisfans.com/hash/hvals.html">HVALS</a></li><li><a href="http://doc.redisfans.com/hash/hscan.html">HSCAN</a></li></ul><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>特点：</p><ul><li>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部L或者尾部R</li><li>列表最多也可存储 2^32 - 1 元素</li></ul><p>demo：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b062f37a3774659a04f8014bcbe5e69~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h4 id="list的基本命令："><a href="#list的基本命令：" class="headerlink" title="list的基本命令："></a>list的基本命令：</h4><ul><li><a href="http://doc.redisfans.com/list/blpop.html">BLPOP</a></li><li><a href="http://doc.redisfans.com/list/brpop.html">BRPOP</a></li><li><a href="http://doc.redisfans.com/list/brpoplpush.html">BRPOPLPUSH</a></li><li><a href="http://doc.redisfans.com/list/lindex.html">LINDEX</a></li><li><a href="http://doc.redisfans.com/list/linsert.html">LINSERT</a></li><li><a href="http://doc.redisfans.com/list/llen.html">LLEN</a></li><li><a href="http://doc.redisfans.com/list/lpop.html">LPOP</a></li><li><a href="http://doc.redisfans.com/list/lpush.html">LPUSH</a></li><li><a href="http://doc.redisfans.com/list/lpushx.html">LPUSHX</a></li><li><a href="http://doc.redisfans.com/list/lrange.html">LRANGE</a></li><li><a href="http://doc.redisfans.com/list/lrem.html">LREM</a></li><li><a href="http://doc.redisfans.com/list/lset.html">LSET</a></li><li><a href="http://doc.redisfans.com/list/ltrim.html">LTRIM</a></li><li><a href="http://doc.redisfans.com/list/rpop.html">RPOP</a></li><li><a href="http://doc.redisfans.com/list/rpoplpush.html">RPOPLPUSH</a></li><li><a href="http://doc.redisfans.com/list/rpush.html">RPUSH</a></li><li><a href="http://doc.redisfans.com/list/rpushx.html">RPUSHX</a></li></ul><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>特点：</p><ul><li>Redis 的 Set 是 string 类型的无序集合</li><li>set是通过哈希表实现的，所以R U D的复杂度都是 O(1)</li><li>集合的唯一性</li><li>集合中最大的成员数为 2^32 - 1</li></ul><p>demo：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5c0d8e077e548089a934fe1bd9aa35f~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>可以看到是唯一的且无序的</p><h4 id="set的基本命令："><a href="#set的基本命令：" class="headerlink" title="set的基本命令："></a>set的基本命令：</h4><ul><li><a href="http://doc.redisfans.com/set/sadd.html">SADD</a></li><li><a href="http://doc.redisfans.com/set/scard.html">SCARD</a></li><li><a href="http://doc.redisfans.com/set/sdiff.html">SDIFF</a></li><li><a href="http://doc.redisfans.com/set/sdiffstore.html">SDIFFSTORE</a></li><li><a href="http://doc.redisfans.com/set/sinter.html">SINTER</a></li><li><a href="http://doc.redisfans.com/set/sinterstore.html">SINTERSTORE</a></li><li><a href="http://doc.redisfans.com/set/sismember.html">SISMEMBER</a></li><li><a href="http://doc.redisfans.com/set/smembers.html">SMEMBERS</a></li><li><a href="http://doc.redisfans.com/set/smove.html">SMOVE</a></li><li><a href="http://doc.redisfans.com/set/spop.html">SPOP</a></li><li><a href="http://doc.redisfans.com/set/srandmember.html">SRANDMEMBER</a></li><li><a href="http://doc.redisfans.com/set/srem.html">SREM</a></li><li><a href="http://doc.redisfans.com/set/sunion.html">SUNION</a></li><li><a href="http://doc.redisfans.com/set/sunionstore.html">SUNIONSTORE</a></li><li><a href="http://doc.redisfans.com/set/sscan.html">SSCAN</a></li></ul><h3 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h3><p>特点：</p><ul><li>集合的唯一性</li><li>有序集合</li><li>每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</li><li>zset的成员是唯一的,但分数(score)却可以重复。</li></ul><p>demo：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c9b3c2b3f174bc4b890ba562cb7aaba~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>可以看到是唯一的且有序的，但是score可以重复</p><h4 id="zset的基本命令："><a href="#zset的基本命令：" class="headerlink" title="zset的基本命令："></a>zset的基本命令：</h4><ul><li><a href="http://doc.redisfans.com/sorted_set/zadd.html">ZADD</a></li><li><a href="http://doc.redisfans.com/sorted_set/zcard.html">ZCARD</a></li><li><a href="http://doc.redisfans.com/sorted_set/zcount.html">ZCOUNT</a></li><li><a href="http://doc.redisfans.com/sorted_set/zincrby.html">ZINCRBY</a></li><li><a href="http://doc.redisfans.com/sorted_set/zrange.html">ZRANGE</a></li><li><a href="http://doc.redisfans.com/sorted_set/zrangebyscore.html">ZRANGEBYSCORE</a></li><li><a href="http://doc.redisfans.com/sorted_set/zrank.html">ZRANK</a></li><li><a href="http://doc.redisfans.com/sorted_set/zrem.html">ZREM</a></li><li><a href="http://doc.redisfans.com/sorted_set/zremrangebyrank.html">ZREMRANGEBYRANK</a></li><li><a href="http://doc.redisfans.com/sorted_set/zremrangebyscore.html">ZREMRANGEBYSCORE</a></li><li><a href="http://doc.redisfans.com/sorted_set/zrevrange.html">ZREVRANGE</a></li><li><a href="http://doc.redisfans.com/sorted_set/zrevrangebyscore.html">ZREVRANGEBYSCORE</a></li><li><a href="http://doc.redisfans.com/sorted_set/zrevrank.html">ZREVRANK</a></li><li><a href="http://doc.redisfans.com/sorted_set/zscore.html">ZSCORE</a></li><li><a href="http://doc.redisfans.com/sorted_set/zunionstore.html">ZUNIONSTORE</a></li><li><a href="http://doc.redisfans.com/sorted_set/zinterstore.html">ZINTERSTORE</a></li><li><a href="http://doc.redisfans.com/sorted_set/zscan.html">ZSCAN</a></li></ul><hr><h2 id="Redis-HyperLogLog"><a href="#Redis-HyperLogLog" class="headerlink" title="Redis-HyperLogLog"></a>Redis-HyperLogLog</h2><p><strong>简介</strong>：</p><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p><p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p><p>Q：什么是基数？</p><p>A：基数就是集合内去重后元素的个数</p><p>Q：什么是基数估计？</p><p>A：基数估计就是在误差可接受的范围内，快速计算基数。</p><p>demo：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f889cd76071f4c89bed355b3d02d9495~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h3 id="HyperLogLog的基本命令："><a href="#HyperLogLog的基本命令：" class="headerlink" title="HyperLogLog的基本命令："></a>HyperLogLog的基本命令：</h3><table><thead><tr><th align="left">Num</th><th align="left">命令及描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">[PFADD key element <a href="https://www.runoob.com/redis/hyperloglog-pfadd.html">element …]</a> ——添加指定元素到 HyperLogLog 中。</td></tr><tr><td align="left">2</td><td align="left">[PFCOUNT key <a href="https://www.runoob.com/redis/hyperloglog-pfcount.html">key …]</a> ——返回给定 HyperLogLog 的基数估算值。</td></tr><tr><td align="left">3</td><td align="left">[PFMERGE destkey sourcekey <a href="https://www.runoob.com/redis/hyperloglog-pfmerge.html">sourcekey …]</a> ——将多个 HyperLogLog 合并为一个 HyperLogLog</td></tr></tbody></table><hr><h2 id="Redis-Pub-x2F-Sub-发布订阅"><a href="#Redis-Pub-x2F-Sub-发布订阅" class="headerlink" title="Redis-Pub&#x2F;Sub-发布订阅"></a>Redis-Pub&#x2F;Sub-发布订阅</h2><p>Redis 发布订阅 (pub&#x2F;sub) 是一种<strong>消息通信模式</strong>：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p><p><strong>图解</strong>：（图源Runoob）</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81c27914648d43f7bfef07cd16b845c6~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>注意：如果需要测试，可能会需要开启多个<code>redis-cli</code>客户端</p><p>demo：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fae085ad25ce4f6b99411775dae75811~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>其中msg的命令是<code>PUBLISH FallenChat &quot;something&quot;</code></p><h3 id="发布订阅的基本命令："><a href="#发布订阅的基本命令：" class="headerlink" title="发布订阅的基本命令："></a>发布订阅的基本命令：</h3><ul><li><a href="http://doc.redisfans.com/pub_sub/psubscribe.html">PSUBSCRIBE</a></li><li><a href="http://doc.redisfans.com/pub_sub/publish.html">PUBLISH</a></li><li><a href="http://doc.redisfans.com/pub_sub/pubsub.html">PUBSUB</a></li><li><a href="http://doc.redisfans.com/pub_sub/punsubscribe.html">PUNSUBSCRIBE</a></li><li><a href="http://doc.redisfans.com/pub_sub/subscribe.html">SUBSCRIBE</a></li><li><a href="http://doc.redisfans.com/pub_sub/unsubscribe.html">UNSUBSCRIBE</a></li></ul><hr><h2 id="Redis-Transaction-事务"><a href="#Redis-Transaction-事务" class="headerlink" title="Redis-Transaction-事务"></a>Redis-Transaction-事务</h2><p>Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：</p><ul><li>批量操作在发送 EXEC 命令前被放入<strong>队列缓存</strong></li><li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。</li><li>在事务执行过程，其他客户端提交的命令请求<strong>不会</strong>插入到事务执行命令序列中</li></ul><p>一个事务从开始到执行会经历以下<strong>三个阶段</strong>：</p><ul><li>开始事务</li><li>命令入队</li><li>执行事务</li></ul><p>demo：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0839a16a7a5547f8a243058a72665233~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>特别地：单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</p><h3 id="事务的基本命令："><a href="#事务的基本命令：" class="headerlink" title="事务的基本命令："></a>事务的基本命令：</h3><ul><li><a href="http://doc.redisfans.com/transaction/discard.html">DISCARD</a></li><li><a href="http://doc.redisfans.com/transaction/exec.html">EXEC</a></li><li><a href="http://doc.redisfans.com/transaction/multi.html">MULTI</a></li><li><a href="http://doc.redisfans.com/transaction/unwatch.html">UNWATCH</a></li><li><a href="http://doc.redisfans.com/transaction/watch.html">WATCH</a></li></ul><hr><h2 id="Redis-Script-脚本"><a href="#Redis-Script-脚本" class="headerlink" title="Redis-Script-脚本"></a>Redis-Script-脚本</h2><p>Redis 脚本使用<code>Lua</code>解释器来执行脚本。 Redis 2.6 版本通过内嵌支持 Lua 环境。</p><p>执行脚本的常用命令为 <strong>EVAL</strong></p><h3 id="Lua简介："><a href="#Lua简介：" class="headerlink" title="Lua简介："></a>Lua简介：</h3><p>Q：Lua？</p><p>A：Lua 是一种轻量小巧的<strong>脚本语言</strong>，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。</p><p>A：其<strong>设计目的</strong>是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。</p><p><strong>Lua特性</strong>：</p><ul><li><strong>轻量级</strong>: 它用标准C语言编写并以源代码形式开放，编译后仅仅一百余K，可以很方便的嵌入别的程序里。</li><li><strong>可扩展</strong>: Lua提供了非常易于使用的扩展接口和机制：由宿主语言(通常是C或C++)提供这些功能，Lua可以使用它们，就像是本来就内置的功能一样。</li><li>其它特性：<ul><li>支持面向过程(procedure-oriented)编程和函数式编程(functional programming)；</li><li>自动内存管理；只提供了一种通用类型的表（table），用它可以实现数组，哈希表，集合，对象；</li><li>语言内置模式匹配；闭包(closure)；函数也可以看做一个值；提供多线程（协同进程，并非操作系统所支持的线程）支持；</li><li>通过闭包和table可以很方便地支持面向对象编程所需要的一些关键机制，比如数据抽象，虚函数，继承和重载等。</li></ul></li></ul><p><strong>Lua应用场景</strong>：</p><ul><li>游戏开发</li><li>独立应用脚本</li><li>Web 应用脚本</li><li>扩展和数据库插件如：MySQL Proxy 和 MySQL WorkBench</li><li>安全系统，如入侵检测系统</li></ul><hr><p>回到Redis</p><p>demo：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb7417415d474aea96ca488dcaa75d37~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h3 id="脚本的基本命令："><a href="#脚本的基本命令：" class="headerlink" title="脚本的基本命令："></a>脚本的基本命令：</h3><ul><li><a href="http://doc.redisfans.com/script/eval.html">EVAL</a></li><li><a href="http://doc.redisfans.com/script/evalsha.html">EVALSHA</a></li><li><a href="http://doc.redisfans.com/script/script_exists.html">SCRIPT EXISTS</a></li><li><a href="http://doc.redisfans.com/script/script_flush.html">SCRIPT FLUSH</a></li><li><a href="http://doc.redisfans.com/script/script_kill.html">SCRIPT KILL</a></li><li><a href="http://doc.redisfans.com/script/script_load.html">SCRIPT LOAD</a></li></ul><hr><h2 id="Redis-Connection-连接"><a href="#Redis-Connection-连接" class="headerlink" title="Redis-Connection-连接"></a>Redis-Connection-连接</h2><p>Redis 连接命令主要是用于连接 redis 服务</p><h3 id="连接的基本命令："><a href="#连接的基本命令：" class="headerlink" title="连接的基本命令："></a>连接的基本命令：</h3><ul><li><a href="http://doc.redisfans.com/connection/auth.html">AUTH</a></li><li><a href="http://doc.redisfans.com/connection/echo.html">ECHO</a></li><li><a href="http://doc.redisfans.com/connection/ping.html">PING</a></li><li><a href="http://doc.redisfans.com/connection/quit.html">QUIT</a></li><li><a href="http://doc.redisfans.com/connection/select.html">SELECT</a></li></ul><hr><h2 id="Redis-Server-服务器"><a href="#Redis-Server-服务器" class="headerlink" title="Redis-Server-服务器"></a>Redis-Server-服务器</h2><p>Redis 服务器命令主要是用于管理 redis 服务</p><p>输入<code>INFO</code>就可以查看，由于内容过多就不一一展示了，下面是一部分</p><p>demo：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3722d8245af4e72aa1b2d6134747903~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h3 id="服务器的基本命令："><a href="#服务器的基本命令：" class="headerlink" title="服务器的基本命令："></a>服务器的基本命令：</h3><ul><li><a href="http://doc.redisfans.com/server/bgrewriteaof.html">BGREWRITEAOF</a></li><li><a href="http://doc.redisfans.com/server/bgsave.html">BGSAVE</a></li><li><a href="http://doc.redisfans.com/server/client_getname.html">CLIENT GETNAME</a></li><li><a href="http://doc.redisfans.com/server/client_kill.html">CLIENT KILL</a></li><li><a href="http://doc.redisfans.com/server/client_list.html">CLIENT LIST</a></li><li><a href="http://doc.redisfans.com/server/client_setname.html">CLIENT SETNAME</a></li><li><a href="http://doc.redisfans.com/server/config_get.html">CONFIG GET</a></li><li><a href="http://doc.redisfans.com/server/config_resetstat.html">CONFIG RESETSTAT</a></li><li><a href="http://doc.redisfans.com/server/config_rewrite.html">CONFIG REWRITE</a></li><li><a href="http://doc.redisfans.com/server/config_set.html">CONFIG SET</a></li><li><a href="http://doc.redisfans.com/server/dbsize.html">DBSIZE</a></li><li><a href="http://doc.redisfans.com/server/debug_object.html">DEBUG OBJECT</a></li><li><a href="http://doc.redisfans.com/server/debug_segfault.html">DEBUG SEGFAULT</a></li><li><a href="http://doc.redisfans.com/server/flushall.html">FLUSHALL</a></li><li><a href="http://doc.redisfans.com/server/flushdb.html">FLUSHDB</a></li><li><a href="http://doc.redisfans.com/server/info.html">INFO</a></li><li><a href="http://doc.redisfans.com/server/lastsave.html">LASTSAVE</a></li><li><a href="http://doc.redisfans.com/server/monitor.html">MONITOR</a></li><li><a href="http://doc.redisfans.com/server/psync.html">PSYNC</a></li><li><a href="http://doc.redisfans.com/server/save.html">SAVE</a></li><li><a href="http://doc.redisfans.com/server/shutdown.html">SHUTDOWN</a></li><li><a href="http://doc.redisfans.com/server/slaveof.html">SLAVEOF</a></li><li><a href="http://doc.redisfans.com/server/slowlog.html">SLOWLOG</a></li><li><a href="http://doc.redisfans.com/server/sync.html">SYNC</a></li><li><a href="http://doc.redisfans.com/server/time.html">TIME</a></li></ul><hr><h2 id="Redis-GEO"><a href="#Redis-GEO" class="headerlink" title="Redis-GEO"></a>Redis-GEO</h2><p>Redis GEO 主要用于存储地理位置信息，并对存储的信息进行操作。（After V3.2）</p><p>Redis GEO 常用的操作方法：</p><ul><li>geoadd：添加地理位置的坐标。</li><li>geopos：获取地理位置的坐标。</li><li>geodist：计算两个位置之间的距离。</li><li>georadius：根据用户给定的经纬度坐标来获取指定范围内的地理位置集合。</li><li>georadiusbymember：根据储存在位置集合里面的某个地点获取指定范围内的地理位置集合。</li><li>geohash：返回一个或多个位置对象的 geohash 值。</li></ul><p>demo待补充</p><hr><h2 id="Redis-Stream"><a href="#Redis-Stream" class="headerlink" title="Redis-Stream"></a>Redis-Stream</h2><p>（After V5.0）</p><blockquote><p>Redis Stream 主要用于消息队列（MQ，Message Queue），Redis 本身是有一个 Redis 发布订阅 (pub&#x2F;sub) 来实现消息队列的功能，但它有个缺点就是<strong>消息无法持久化</strong>，如果出现网络断开、Redis 宕机等，消息就会被丢弃。</p><p>而 Redis Stream 提供了<strong>消息的持久化</strong>和<strong>主备复制</strong>功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。</p></blockquote><p>结构示意图：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a73c211f11bd45f389b5565ef98b12ee~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><ul><li>有一个消息链表</li><li>每个Stream都有唯一的名称，就是key，在首次使用 xadd 指令追加消息时自动创建。</li></ul><blockquote><ul><li><strong>Consumer Group</strong> ：消费组，使用 XGROUP CREATE 命令创建，一个消费组有多个消费者(Consumer)。</li><li><strong>last_delivered_id</strong> ：游标，每个消费组会有个游标 last_delivered_id，任意一个消费者读取了消息都会使游标 last_delivered_id 往前移动。</li><li><strong>pending_ids</strong> ：消费者(Consumer)的状态变量，作用是维护消费者的未确认的 id。 pending_ids 记录了当前已经被客户端读取的消息，但是还没有 ack (Acknowledge character：确认字符）。</li></ul></blockquote><h3 id="消息队列相关命令："><a href="#消息队列相关命令：" class="headerlink" title="消息队列相关命令："></a><strong>消息队列相关命令：</strong></h3><ul><li><strong>XADD</strong> - 添加消息到末尾</li><li><strong>XTRIM</strong> - 对流进行修剪，限制长度</li><li><strong>XDEL</strong> - 删除消息</li><li><strong>XLEN</strong> - 获取流包含的元素数量，即消息长度</li><li><strong>XRANGE</strong> - 获取消息列表，会自动过滤已经删除的消息</li><li><strong>XREVRANGE</strong> - 反向获取消息列表，ID 从大到小</li><li><strong>XREAD</strong> - 以阻塞或非阻塞方式获取消息列表</li></ul><h3 id="消费者组相关命令："><a href="#消费者组相关命令：" class="headerlink" title="消费者组相关命令："></a><strong>消费者组相关命令：</strong></h3><ul><li><strong>XGROUP CREATE</strong> - 创建消费者组</li><li><strong>XREADGROUP GROUP</strong> - 读取消费者组中的消息</li><li><strong>XACK</strong> - 将消息标记为”已处理”</li><li><strong>XGROUP SETID</strong> - 为消费者组设置新的最后递送消息ID</li><li><strong>XGROUP DELCONSUMER</strong> - 删除消费者</li><li><strong>XGROUP DESTROY</strong> - 删除消费者组</li><li><strong>XPENDING</strong> - 显示待处理消息的相关信息</li><li><strong>XCLAIM</strong> - 转移消息的归属权</li><li><strong>XINFO</strong> - 查看流和消费者组的相关信息；</li><li><strong>XINFO GROUPS</strong> - 打印消费者组的信息；</li><li><strong>XINFO STREAM</strong> - 打印流信息</li></ul><p>demo待补充</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;零、前言&quot;&gt;&lt;a href=&quot;#零、前言&quot; class=&quot;headerlink&quot; title=&quot;零、前言&quot;&gt;&lt;/a&gt;零、前言&lt;/h1&gt;&lt;p&gt;本文是笔者从零开始学习Redis的学习记录。&lt;/p&gt;
&lt;p&gt;若笔者有任何疏忽纰漏之处，烦请不吝赐教。&lt;/p&gt;
&lt;blockq</summary>
      
    
    
    
    <category term="Devlopment-Tech" scheme="https://conqueror712.github.io/categories/Devlopment-Tech/"/>
    
    
  </entry>
  
  <entry>
    <title>深度学习 - Ep0 - 引言与前置知识丨学习记录</title>
    <link href="https://conqueror712.github.io/post/DeepLearningNote.html"/>
    <id>https://conqueror712.github.io/post/DeepLearningNote.html</id>
    <published>2023-01-01T13:32:11.000Z</published>
    <updated>2023-03-27T02:24:11.917Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h3><p>本篇内容目前用于记录自己一开始学习深度学习的学习过程，方便自己查阅，或许正在看本文的你对其中的一些内容有所疑惑，这大概是本人为了方便自己阅读和理解所以写的不够清楚的原因所致，如果你有任何想询问的问题，欢迎在以下任何平台提问！</p><blockquote><p>个人博客：<a href="https://conqueror712.github.io/">https://conqueror712.github.io/</a></p><p>知乎：<a href="https://www.zhihu.com/people/soeur712/posts">https://www.zhihu.com/people/soeur712/posts</a></p><p>Bilibili：<a href="https://space.bilibili.com/57089326">https://space.bilibili.com/57089326</a></p><p>掘金：<a href="https://juejin.cn/user/1297878069809725/posts">https://juejin.cn/user/1297878069809725/posts</a></p></blockquote><h3 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h3><p>本篇不会发表在知乎和掘金平台，仅作为个人的一个记录。</p><p>本篇内容较为杂乱，请<strong>谨慎阅读</strong>！</p><hr><h1 id="00-Pytorch入门"><a href="#00-Pytorch入门" class="headerlink" title="00 - Pytorch入门"></a><strong>00 - Pytorch入门</strong></h1><p>Anaconda Prompt的一些操作：</p><h2 id="创建环境与加载数据："><a href="#创建环境与加载数据：" class="headerlink" title="创建环境与加载数据："></a><strong>创建环境与加载数据：</strong></h2><p><code>conda create -n name1 python=3.9</code></p><p>这里 -n 后面的内容是你创建的环境的名字，</p><p>随后如果出现 <code>The following NEW packages will be INSTALLED:</code>，yes即可。</p><p><strong>激活and取消激活这些包的指令：</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda activate &lt;环境名&gt;</span><br><span class="line">conda deactivate</span><br></pre></td></tr></table></figure><p><code>pip list</code>可以知道这个环境中有哪些工具包</p><p><code>nvidia-smi</code>可以知道自己的英伟达显卡的具体信息，CUDA9.2版本需要396.26版本</p><p>复制安装指令，安装即可。</p><p>安装过程中出现如下信息同上操作：</p><p><code>The following NEW packages will be INSTALLED:</code></p><p>随后再次使用pip list查看是否有Pytorch即可（过程太慢请使用镜像）。</p><p>另一种检查方法是键入<code>python</code>进入python，然后<code>import torch</code></p><p>随后再输入<code>torch.cuda.is_available()</code>，如果返回True则成功。</p><p>在Pytorch中安装Jupyter</p><p><code>conda install nb_conda</code></p><p>随后键入jupyter notebook即可</p><hr><p> 下面是一些调用数据的实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyData</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="comment"># 初始化，根据这个类来创建特定的实例时需要</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root_dir, label_dir</span>):</span><br><span class="line">        self.root_dir = root_dir</span><br><span class="line">        self.label_dir = label_dir</span><br><span class="line">        self.path = os.path.join(self.root_dir, self.label_dir)</span><br><span class="line">        self.img_path = os.listdir(self.path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">        img_name = self.img_path[idx]</span><br><span class="line">        img_item_path = os.path.join(self.root_dir, self.label_dir, img_name)</span><br><span class="line">        img = Image.<span class="built_in">open</span>(img_item_path)</span><br><span class="line">        label = self.label_dir</span><br><span class="line">        <span class="keyword">return</span> img, label</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.img_path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root_dir = <span class="string">&quot;dataset/train&quot;</span></span><br><span class="line">ants_label_dir = <span class="string">&quot;ants&quot;</span></span><br><span class="line">bees_label_dir = <span class="string">&quot;bees&quot;</span></span><br><span class="line">ants_dataset = MyData(root_dir, ants_label_dir)</span><br><span class="line">bees_dataset = MyData(root_dir, bees_label_dir)</span><br><span class="line"></span><br><span class="line">train_dataset = ants_dataset + bees_dataset</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然，也可以通过修改文件夹名字来进行如上操作，这里就不给出了。</span></span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/07/20/Qyeo9GJg4FjxEc8.png" alt="avatar"></p><p><img src="https://s2.loli.net/2022/07/20/jzoCbfUGEZOQsJq.png" alt="avatar"></p><hr><h2 id="MMCV配置环境"><a href="#MMCV配置环境" class="headerlink" title="MMCV配置环境"></a><strong>MMCV配置环境</strong></h2><ul><li>Linux &#x2F; Windows</li><li>Python</li><li>Pytorch</li><li>CUDA</li><li>gcc &amp;&amp; g++ (5.4+)</li><li>mmcv-full</li></ul><hr><h3 id="Windows环境-or-Linux环境："><a href="#Windows环境-or-Linux环境：" class="headerlink" title="Windows环境 or Linux环境："></a>Windows环境 or Linux环境：</h3><p>我们先来看mmcv，安装mmcv的前提是环境中需要有Pytorch。</p><p>Pytorch我选择在conda中进行安装，并且采用了国内的镜像。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">conda config <span class="literal">--add</span> channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/ </span><br><span class="line">conda config <span class="literal">--add</span> channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda<span class="literal">-forge</span>/ </span><br><span class="line">conda config <span class="literal">--add</span> channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config <span class="literal">--add</span> channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ </span><br><span class="line">conda config <span class="literal">--add</span> channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/peterjc123/</span><br><span class="line">conda config <span class="literal">--add</span> channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/</span><br><span class="line">conda config <span class="literal">--set</span> show_channel_urls yes</span><br></pre></td></tr></table></figure><ol><li>创建并激活conda虚拟环境：</li></ol><p><code>conda create -n mmcv python=3.8 -y</code></p><p><code>conda activate mmcv</code></p><ol start="2"><li>安装Pytorch和Torchvision：</li></ol><p><code>conda install pytorch==1.10.0 torchvision cudatoolkit=11.3 -c pytorch</code></p><p>注意，这里版本号之间不仅需要更改成自己需要的版本，还需要注意对应关系。</p><p>值得一提的是，如果采用国内的镜像，则需要去掉<code>-c</code>，否则还是会很慢。</p><ol start="3"><li>安装最新版mmcv-full（注意，这是使用预编译包，如果要从源码编译，则直接跳转至下文！）：</li></ol><p><code>pip install mmcv-full -f https://download.openmmlab.com/mmcv/dist/&#123;cu_version&#125;/&#123;torch_version&#125;/index.html</code></p><p>注意，链接中的 <code>&#123;cu_version&#125;</code> 和 <code>&#123;torch_version&#125;</code> 根据自身需求替换成实际的版本号。</p><p>本人在安装的时候使用的指令是：</p><p><code>pip install mmcv-full -f https://download.openmmlab.com/mmcv/dist/cu113/torch1.10.0/index.html</code></p><p>值得一提的是，貌似还有一种安装方法是用MIM，但本人在Linux下试了一次没有成功。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip3 install openmim</span><br><span class="line">mim install mmcv<span class="literal">-full</span>==<span class="number">1.5</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure><hr><h3 id="查看环境版本指令："><a href="#查看环境版本指令：" class="headerlink" title="查看环境版本指令："></a>查看环境版本指令：</h3><p><code>python --version</code>Python</p><p><code>print(torch.__version__)</code>Pytorch（python环境下，并且导入torch）</p><p><code>nvcc -V</code>CUDA</p><p><code>gcc -v</code>gcc</p><p><code>print(mmedit.__version__)</code> mmedit（python环境下，并且导入mmedit）</p><hr><p>直到这里，都属于安装MMCV的阶段，以上步骤在Windows和Linux下几乎都一样，接下来到了从源码上编译MMCV，Windows就要复杂一些了，具体如下：</p><h3 id="Windows环境编译MMCV："><a href="#Windows环境编译MMCV：" class="headerlink" title="Windows环境编译MMCV："></a>Windows环境编译MMCV：</h3><p>依赖：</p><ul><li>Git</li><li>Visual Studio</li><li>Anaconda（推荐） | Miniconda</li><li>CUDA</li></ul><p>注意需要启用的是Anaconda命令行而非一般的命令行。</p><p>这里防止出错，直接部分<em>引用官方文档</em>：</p><p>创建一个新的 Conda 环境</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create <span class="literal">--name</span> mmcv python=<span class="number">3.8</span>  <span class="comment"># 经测试，3.6, 3.7, 3.8 也能通过</span></span><br><span class="line">conda activate mmcv  <span class="comment"># 确保做任何操作前先激活环境</span></span><br></pre></td></tr></table></figure><p>安装 PyTorch 时，可以根据需要安装支持 CUDA 或不支持 CUDA 的版本</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CUDA version</span></span><br><span class="line">conda install pytorch==<span class="number">1.10</span>.<span class="number">0</span> torchvision cudatoolkit=<span class="number">11.3</span> <span class="literal">-c</span> pytorch</span><br><span class="line"><span class="comment"># 注意，这里的版本一定要对应，否则会报错！</span></span><br></pre></td></tr></table></figure><p>准备 MMCV 源代码</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/<span class="built_in">open-mmlab</span>/mmcv.git</span><br><span class="line"><span class="built_in">cd</span> mmcv</span><br></pre></td></tr></table></figure><p>安装所需 Python 依赖包</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install <span class="literal">-r</span> requirements/runtime.txt</span><br></pre></td></tr></table></figure><p><strong>建议安装 <code>ninja</code> 以加快编译速度</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install <span class="literal">-r</span> requirements/optional.txt</span><br></pre></td></tr></table></figure><p>接下来就要开始编译过程了：</p><p>设置 MSVC 编译器</p><p>设置环境变量。添加 <code>C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.27.29110\bin\Hostx86\x64</code> 到 <code>PATH</code>，则 <code>cl.exe</code> 可以在命令行中运行，如下所示，以下是测试部分：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(base) <span class="built_in">PS</span> C:\Users\xxx&gt; cl</span><br><span class="line">Microsoft (<span class="built_in">R</span>) C/C++ Optimizing  Compiler Version <span class="number">19.27</span>.<span class="number">29111</span> <span class="keyword">for</span> x64</span><br><span class="line">Copyright (C) Microsoft Corporation.   All rights reserved.</span><br><span class="line"></span><br><span class="line">usage: cl [ <span class="type">option...</span> ] filename... [ / <span class="type">link</span> <span class="type">linkoption...</span> ]</span><br></pre></td></tr></table></figure><p>为了兼容性，我们使用 x86-hosted 以及 x64-targeted 版本，即路径中的 <code>Hostx86\x64</code> （注意先后顺序）。</p><p>因为 PyTorch 将解析 <code>cl.exe</code> 的输出以检查其版本，只有 utf-8 将会被识别，你可能需要将系统语言更改为英语。</p><p>控制面板 -&gt; 地区-&gt; 管理-&gt; 非 Unicode 来进行语言转换。</p><p>设置环境变量（注意这里是PS终端）：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$env:MMCV_WITH_OPS</span> = <span class="number">1</span></span><br><span class="line"><span class="variable">$env:MAX_JOBS</span> = <span class="number">8</span>  <span class="comment"># 根据你可用CPU以及内存量进行设置</span></span><br></pre></td></tr></table></figure><p>检查 <code>CUDA_PATH</code> 或者 <code>CUDA_HOME</code> 环境变量已经存在在 <code>envs</code> 之中</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(base) <span class="built_in">PS</span> C:\Users\WRH&gt; <span class="built_in">ls</span> env:</span><br><span class="line"></span><br><span class="line">Name                           Value</span><br><span class="line"><span class="literal">----</span>                           <span class="literal">-----</span></span><br><span class="line">CUDA_PATH                      C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.<span class="number">3</span></span><br><span class="line">CUDA_PATH_V11_3                C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.<span class="number">3</span></span><br><span class="line">CUDA_PATH_V11_7                C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.<span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>如 果 没 有</strong>，你可以按照下面的步骤设置</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$env:CUDA_HOME</span> = <span class="string">&quot;C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.3&quot;</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="variable">$env:CUDA_HOME</span> = <span class="variable">$env:CUDA_PATH_V11_3</span>  <span class="comment"># CUDA_PATH_V11_3 已经在环境变量中</span></span><br></pre></td></tr></table></figure><h3 id="设置-CUDA-的目标架构"><a href="#设置-CUDA-的目标架构" class="headerlink" title="设置 CUDA 的目标架构"></a>设置 CUDA 的目标架构</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$env:TORCH_CUDA_ARCH_LIST</span>=<span class="string">&quot;6.1&quot;</span> <span class="comment"># 支持 GTX 1080（本人是1050qwq）</span></span><br><span class="line"><span class="comment"># 或者用所有支持的版本，但可能会变得很慢</span></span><br><span class="line"><span class="variable">$env:TORCH_CUDA_ARCH_LIST</span>=<span class="string">&quot;3.5 3.7 5.0 5.2 6.0 6.1 7.0 7.5&quot;</span></span><br></pre></td></tr></table></figure><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$env:MMCV_WITH_OPS</span> = <span class="number">1</span></span><br><span class="line"><span class="variable">$env:MAX_JOBS</span> = <span class="number">8</span> <span class="comment"># 根据你可用CPU以及内存量进行设置（保守点可以输4）</span></span><br><span class="line">conda activate mmcv <span class="comment"># 激活环境</span></span><br><span class="line"><span class="built_in">cd</span> mmcv  <span class="comment"># 改变路径</span></span><br><span class="line">python setup.py build_ext  <span class="comment"># 如果成功, cl 将被启动用于编译算子</span></span><br><span class="line">python setup.py develop <span class="comment"># 安装</span></span><br><span class="line">pip list <span class="comment"># 检查是否安装成功</span></span><br></pre></td></tr></table></figure><p>与此同时，我们可以进行MMEditing的安装：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/<span class="built_in">open-mmlab</span>/mmediting.git</span><br><span class="line"><span class="built_in">cd</span> mmediting</span><br><span class="line">pip3 install <span class="literal">-e</span> .</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">python <span class="literal">-c</span> <span class="string">&quot;import mmedit; print(mmedit.__version__)&quot;</span></span><br><span class="line"><span class="comment"># Example output: 0.14.0</span></span><br></pre></td></tr></table></figure><hr><h1 id="01-Abstract"><a href="#01-Abstract" class="headerlink" title="01-Abstract"></a>01-Abstract</h1><p>本文介绍了笔者在学习《动手学深度学习》课程中的笔记。</p><p>这一Part的内容是深度学习基础。</p><p>后续将会补充更多的公式推导和原理部分。</p><p>敬请期待！</p><hr><h1 id="02-Guide-Topic"><a href="#02-Guide-Topic" class="headerlink" title="02-Guide Topic"></a>02-Guide Topic</h1><p>The most import thing of deep learning is <strong>Neural Network</strong>.</p><p>The Neural Network is a <strong>language</strong>, it is very <strong>flexible</strong>.</p><p>AutoGluon⭐</p><p>Book Version 1: <a href="https://zh/d2.ai/">https://zh/d2.ai/</a></p><p>Book Version 2: <a href="https://zh-v2.d2l.ai/">https://zh-v2.d2l.ai/</a></p><p>Source Code: <a href="https://github.com./d2l-ai/d2l-zh">https://github.com./d2l-ai/d2l-zh</a></p><p>Course Web: <a href="https://courses.d2l.ai/zh-v2">https://courses.d2l.ai/zh-v2</a></p><p>Discuss: <a href="https://discuss.pytorch.org/">https://discuss.pytorch.org/</a> <a href="https://discuss.d2l.ai/c/16">https://discuss.d2l.ai/c/16</a></p><h2 id="Introduce-DeepLearning"><a href="#Introduce-DeepLearning" class="headerlink" title="Introduce DeepLearning"></a>Introduce DeepLearning</h2><p>The target of this course: </p><ul><li>introduce the classic and new model like LeNet, ResNet, LSTM, BERT,…</li><li>Basic Machine Learning</li><li>Practice</li></ul><h2 id="The-Application-of-DL"><a href="#The-Application-of-DL" class="headerlink" title="The  Application of DL"></a>The  Application of DL</h2><p>图片分类：2012年深度学习开始之后错误率迅速降低，目前大约5%</p><p><a href="https://qz.com/1034972/the-data-that-changed-thedirection-of-ai-research-and-possibly-the-world/">https://qz.com/1034972/the-data-that-changed-thedirection-of-ai-research-and-possibly-the-world/</a></p><p>物体检测和分割</p><p>样式迁移：可以初步理解为，加滤镜</p><p>人脸合成</p><p>文字生成图片<a href="https://openai.com/blog/dall-e/">DALL·E: Creating Images from Text (openai.com)</a></p><p>文字生成</p><p>无人驾驶</p><p><em>广告推荐的预测与训练步骤：</em>特征提取→模型→点击率预测→训练数据→特征和用户点击→模型</p><p>模型的可解释性：XAI，DL上做的还不太好，ML上还行</p><h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><p>流程如下：</p><ol><li><p><code>ssh ubuntu@&lt;IP&gt;</code>连接云服务器，如果直接能在服务器的terminal上操作也可以</p></li><li><p><code>sudo apt update</code>更新一下机器，因为一开始就是一个裸的ubuntu啥也没有</p></li><li><p><code>sudo apt install build-essential</code>装一些开发环境，例如gcc</p></li><li><p><code>sudo apt install python3.8</code>安装python</p></li><li><p>miniconda安装，去官网复制对应版本和需求的链接，下载：<code>wget &lt;link&gt;</code> → 安装：<code>bash Miniconda3-latest-Linux-x64_64.sh（根据自己的文件进行替换）</code>默认装在根目录下面就可以</p></li><li><p>进入conda环境：<code>bash</code>（直接在terminal里打bash）之后可以直接在base环境里来用，也可以新创建一个环境。 </p></li><li><p>内部环境的安装：<code>pip install jupyter d2l torch torchvision</code>（本地记得换源）</p></li><li><p>课程记事本的下载：<code>http://zh-v2.d2l.ai</code>→<code>在Jupyter记事本文件这里复制链接</code>→<code>wget &lt;link&gt;</code></p></li><li><p>如果服务器里没有zip，则需要安装一个zip<code>sudo spt install zip</code>，之后<code>ls</code>可以显示一下名称，然后再进行解压即可<code>unzip d2l-zh.zip</code></p><p>之后再<code>ls</code>可以看到解压出来了三个文件夹<code>mxnet pytorch tensorflow</code></p><p>进入pytorch的文件夹查看有什么东西<code>cd pytorch/``ls</code></p></li><li><p>PPT的下载可以直接<code>git clone &lt;link&gt;</code>（链接在github里，是仓库）</p></li><li><p>运行jupyter<code>jupyter notebook</code>（会出现一个链接，需要将远端的<code>link</code>map到本地<code>ssh -L8888:localhost:8888 ubuntu@&lt;IP&gt;</code>）（这里的8888是远程的端口）</p><p>值得一提的是，打开jupyter之后笔记有幻灯片格式，还有非幻灯片格式，若想打开幻灯片格式则需要安装一个插件<code>pip install rise</code></p></li></ol><hr><h1 id="03-Pre-Knowledge"><a href="#03-Pre-Knowledge" class="headerlink" title="03-Pre Knowledge"></a>03-Pre Knowledge</h1><h2 id="Data-Operation"><a href="#Data-Operation" class="headerlink" title="Data Operation"></a>Data Operation</h2><p>机器学习中用到的最多的数据结构：N维数组</p><p>访问元素的几种常用方法：</p><ul><li>一个元素<code>[1, 2]</code></li><li>一行<code>[1, :]</code></li><li>子区域<code>[1:3, 1:]</code></li><li>子区域<code>[::3, ::2]</code></li></ul><p>除此之外，还可以通过<code>-1</code>来访问最后一个元素</p><h3 id="Tensor张量"><a href="#Tensor张量" class="headerlink" title="Tensor张量"></a>Tensor张量</h3><p>张量表示一个数值组成的数组，这个数组可能有多个维度。</p><p><code>x = torch.arange(12)</code></p><p>我们可以通过张量的<code>shape</code>属性来访问张量的形状和<strong>张量</strong>中<strong>元素的总数</strong><br><code>x.shape</code></p><p><code>x.numel</code></p><p>要改变一个张量的形状而不改变元素的数量和数值，我们可以调用<code>reshape</code>函数</p><p><code>X = x.reshape(3, 4)</code></p><p>使用全0，全1或其他常量或者从特定分布中随机采样的数字</p><p><code>torch.zeros((2, 3, 4))</code></p><p><code>torch.ones((2, 3, 4))</code></p><p>也可以直接在定义的时候就赋好初始值，这里不过多赘述；</p><p>常见的四则运算等都可以被升级为按元素运算；</p><p>把多个张量连接在一起</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X = torch.arange(<span class="number">12</span>, dtype=torch.float32).reshape((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">Y = torch.tensor([[<span class="number">2.0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line">torch.cat((X, Y), dim=<span class="number">0</span>), torch.cat((X, Y), dim=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>通过逻辑运算符构建二元张量；</p><p>对张量中所有元素求和会获得一个只有一个元素的张量<code>X.sum()</code>；</p><p>即使形状不同，我们仍然可以通过调用<strong>广播机制</strong>来执行按元素操作； </p><p>还有一些赋值的方法：<code>X[0:2, :]  = 12</code>；</p><p>运行一些操作可能会导致为新结果分配内存：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">before = <span class="built_in">id</span>(Y) <span class="comment"># 在Python中，id()类似于指针的意思</span></span><br><span class="line">Y = Y + X</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(Y) == before)</span><br><span class="line"><span class="comment"># output = False</span></span><br></pre></td></tr></table></figure><p>执行原地内存操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new_Y = torch.zeros_like(Y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;id(new_Y):&quot;</span>, <span class="built_in">id</span>(new_Y))</span><br><span class="line">new_Y[:] = X + Y</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;id(new_Y):&quot;</span>, <span class="built_in">id</span>(new_Y))</span><br></pre></td></tr></table></figure><p>转换为NumPy张量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A = X.numpy()</span><br><span class="line">B = torch.tensor(A)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(A), <span class="built_in">type</span>(B)) <span class="comment"># 查看数据类型</span></span><br><span class="line"><span class="comment"># 将大小为1的张量转换为Python标量：</span></span><br><span class="line">a = torch.tensor([<span class="number">3.5</span>])</span><br><span class="line">a, a.item(), <span class="built_in">float</span>(a), <span class="built_in">int</span>(a)</span><br><span class="line"><span class="comment"># output = (tensor([3.5000]), 3.5, 3.5, 3)</span></span><br></pre></td></tr></table></figure><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>作用：读取csv文件→做一定的特征预处理→变成pytorch能用的一个tenser(张量)</p><p>创建一个人工数据集，并存储在csv（逗号分隔值）文件；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.makedirs(os.path.join(<span class="string">&#x27;..&#x27;</span>, <span class="string">&#x27;data&#x27;</span>), exist_ok=<span class="literal">True</span>)</span><br><span class="line">data_file = os.path.join(<span class="string">&#x27;..&#x27;</span>, <span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;house_tiny.csv&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(data_file, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&#x27;NumRooms,Alley,Price\n&#x27;</span>)  <span class="comment"># 列名</span></span><br><span class="line">    f.write(<span class="string">&#x27;NA,Pave,127500\n&#x27;</span>)  <span class="comment"># 每行表示一个数据样本</span></span><br><span class="line">    f.write(<span class="string">&#x27;2,NA,106000\n&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;4,NA,178100\n&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;NA,NA,140000\n&#x27;</span>)</span><br></pre></td></tr></table></figure><p>从创建的csv文件中加载原始数据集；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = pd.read_csv(data_file)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"><span class="comment"># 事实上这里也可直接写成data，不使用print，会保留HTML格式</span></span><br></pre></td></tr></table></figure><p>处理缺失的数据，典型的方法是<strong>插值</strong>和<strong>删除</strong>，代码就不放了，可以直接看<a href="https://zh-v2.d2l.ai/chapter_preliminaries/pandas.html">2.2. 数据预处理 — 动手学深度学习 2.0.0-beta1 documentation (d2l.ai)</a></p><hr><h2 id="Linear-Algebra"><a href="#Linear-Algebra" class="headerlink" title="Linear Algebra"></a>Linear Algebra</h2><h3 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h3><p>c &#x3D; A * b  hence  ||c|| &lt;&#x3D; ||A|| * ||b||</p><p>取决于如何衡量b和c的长度</p><p>常见范数：</p><ul><li>矩阵范数：最小的满足上面公式的值</li><li>Frobenius范数（具体公式不给出了）</li></ul><p>正定矩阵：如果一个矩阵是正定的，那么它乘上任何一个行向量或者列向量之后值都是大于等于0的；</p><h3 id="哈达玛积"><a href="#哈达玛积" class="headerlink" title="哈达玛积"></a>哈达玛积</h3><p>两个矩阵按元素乘法</p><h3 id="亚导数"><a href="#亚导数" class="headerlink" title="亚导数"></a>亚导数</h3><p>将导数拓展到不可微的函数</p><h3 id="向量链式法则"><a href="#向量链式法则" class="headerlink" title="向量链式法则"></a>向量链式法则</h3><p>略</p><h3 id="自动求导"><a href="#自动求导" class="headerlink" title="自动求导"></a>自动求导</h3><p>自动求导计算一个函数在指定值上的导数</p><p>有别于符号求导和数值求导</p><h3 id="计算图"><a href="#计算图" class="headerlink" title="计算图"></a>计算图</h3><p>将代码分解成操作子</p><p>将计算表示成一个无环图</p><p>（显式构造、隐式构造）</p><hr><h2 id="Matrix-Calculation"><a href="#Matrix-Calculation" class="headerlink" title="Matrix Calculation"></a>Matrix Calculation</h2><h3 id="导数"><a href="#导数" class="headerlink" title="导数"></a>导数</h3><ul><li><p>标量导数（回忆一下即可）</p></li><li><p>亚导数（将导数拓展到不可微的函数）</p></li><li><p>向量的导数（注意方向是如何变化的）<strong>（梯度与等高线正交，指向值变化最大的方向）</strong></p><img src="https://s2.loli.net/2023/01/01/tp45niawvJU9qlo.png" alt="avatar" style="zoom:50%;" /></li><li><p>拓展到矩阵以及更高维度的张量</p><p><img src="https://s2.loli.net/2023/01/01/ZqCuXydNbRKawoQ.png" alt="avatar"></p></li></ul><p>机器学习不关心P问题，只关心NP问题，所以一般不会处理凸函数问题，因为凸函数问题显然可以很容易得到最优解。（下面补充一下P与NP的内容好了）</p><h3 id="P与NP问题"><a href="#P与NP问题" class="headerlink" title="P与NP问题"></a>P与NP问题</h3><blockquote><p>**<em>P类问题*<strong>：所有可以在<a href="https://baike.baidu.com/item/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%97%B6%E9%97%B4?fromModule=lemma_inlink">多项式时间</a>内求解的判定问题构成P类问题。</strong></em>判定问题***<em>：</em>判断是否有一种能够解决某一类问题的能行算法的研究课题。</p><p>**<em>NP类问题*<strong>：所有的非确定性多项式时间可解的判定问题构成NP类问题。</strong></em>非确定性算法***：非确定性算法将问题分解成猜测和验证两个阶段。算法的猜测阶段是非确定性的，算法的验证阶段是确定性的，它验证猜测阶段给出解的正确性。设算法A是解一个判定问题Q的非确定性算法，如果A的验证阶段能在多项式时间内完成，则称A是一个多项式时间非确定性算法。有些计算问题是确定性的，例如加减乘除，只要按照公式推导，按部就班一步步来，就可以得到结果。但是，有些问题是无法按部就班直接地计算出来。比如，找大<a href="https://baike.baidu.com/item/%E8%B4%A8%E6%95%B0?fromModule=lemma_inlink">质数</a>的问题。有没有一个公式能推出下一个<a href="https://baike.baidu.com/item/%E8%B4%A8%E6%95%B0?fromModule=lemma_inlink">质数</a>是多少呢？这种问题的答案，是无法直接计算得到的，只能通过间接的“猜算”来得到结果。这也就是非确定性问题。而这些问题的通常有个算法，它不能直接告诉你答案是什么，但可以告诉你，某个可能的结果是正确的答案还是错误的。这个可以告诉你“猜算”的答案正确与否的算法，假如可以在多项式（polynomial）时间内算出来，就叫做多项式非确定性问题。</p><p>***NPC问题***<strong>：</strong>NP中的某些问题的复杂性与整个类的复杂性相关联.这些问题中任何一个如果存在多项式时间的算法,那么所有NP问题都是多项式时间可解的.这些问题被称为NP-完全问题(NPC问题)。</p></blockquote><hr><h2 id="自动求导-1"><a href="#自动求导-1" class="headerlink" title="自动求导"></a>自动求导</h2><h3 id="向量链式法则-1"><a href="#向量链式法则-1" class="headerlink" title="向量链式法则"></a>向量链式法则</h3><p><img src="https://s2.loli.net/2023/01/01/g5DQzkZC49jmqlF.png" alt="avatar"></p><p>接下来我们看一个例子：</p><p><img src="https://s2.loli.net/2023/01/01/4aYqp7nE9HCgDW6.png" alt="avatar"></p><h3 id="不同的求导："><a href="#不同的求导：" class="headerlink" title="不同的求导："></a>不同的求导：</h3><ul><li>自动求导：计算一个函数在指定值上的导数</li><li>符号求导：显式的一个求导</li><li>数值求导：用数值来拟合，不需要知道具体的表达式</li></ul><h3 id="计算图："><a href="#计算图：" class="headerlink" title="计算图："></a>计算图：</h3><p>计算图是Pytorch内部自动计算导数的一个方式；</p><p>其实等同于用链式法则求导的一个过程，有点像同路相乘异路相加；</p><ul><li>将代码分解成操作子</li><li>将计算表示成一个有向无环图DAG</li></ul><p>构造计算图有显式构造和隐式构造两种方式，数学上一般是显示，Pytorch是隐式；</p><h3 id="自动求导的模式："><a href="#自动求导的模式：" class="headerlink" title="自动求导的模式："></a>自动求导的模式：</h3><p><img src="https://s2.loli.net/2023/01/01/QfPDEl9yCiHLMVt.png" alt="avatar"></p><p><img src="https://s2.loli.net/2023/01/01/FS3pXUNqrdWjEBO.png" alt="avatar"></p><p><strong>其实，反向传播就是人们用手来算复合函数求导的过程，是一样的。</strong></p><p>demo代码如下<a href="https://zh-v2.d2l.ai/chapter_preliminaries/autograd.html#id2">2.5. 自动微分 — 动手学深度学习 2.0.0 documentation (d2l.ai)</a></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;写在前面：&quot;&gt;&lt;a href=&quot;#写在前面：&quot; class=&quot;headerlink&quot; title=&quot;写在前面：&quot;&gt;&lt;/a&gt;写在前面：&lt;/h3&gt;&lt;p&gt;本篇内容目前用于记录自己一开始学习深度学习的学习过程，方便自己查阅，或许正在看本文的你对其中的一些内容有所疑惑，这大</summary>
      
    
    
    
    <category term="AI" scheme="https://conqueror712.github.io/categories/AI/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL入门丨学习记录</title>
    <link href="https://conqueror712.github.io/post/MySQL.html"/>
    <id>https://conqueror712.github.io/post/MySQL.html</id>
    <published>2022-09-27T05:46:28.000Z</published>
    <updated>2023-03-23T01:27:58.127Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>个人博客：<a href="https://conqueror712.github.io/">https://conqueror712.github.io/</a></p><p>知乎：<a href="https://www.zhihu.com/people/soeur712/posts">https://www.zhihu.com/people/soeur712/posts</a></p><p>Bilibili：<a href="https://space.bilibili.com/57089326">https://space.bilibili.com/57089326</a></p><p>掘金：<a href="https://juejin.cn/user/1297878069809725/posts">https://juejin.cn/user/1297878069809725/posts</a></p></blockquote><h1 id="零、MySQL安装与启动"><a href="#零、MySQL安装与启动" class="headerlink" title="零、MySQL安装与启动"></a><strong>零、MySQL安装与启动</strong></h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>直接官网下<code>.msi</code>后安装，一路<code>next</code>即可…</p><p>之后在安装路径处加一个<code>my.ini</code>内容和细节参考<a href="https://www.runoob.com/mysql/mysql-install.html">MySQL 安装 | 菜鸟教程 (runoob.com)</a></p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>首先cd进MySQL的bin目录</p><p><code>net start mysql</code></p><p><code>mysql -u root -p</code> 键入密码即可</p><p>当然，可以选择在<code>my.ini</code>内设置跳过密码输入…</p><p>可以使用<code>exit</code>或<code>quit</code>来退出mysql</p><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>直接启动<code>MySQL Command Line Client</code></p><hr><h1 id="一、MySQL管理"><a href="#一、MySQL管理" class="headerlink" title="一、MySQL管理"></a><strong>一、MySQL管理</strong></h1><h3 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h3><p><code>CREATE USER &#39;用户名&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;用户密码&#39;;</code></p><h3 id="查看用户"><a href="#查看用户" class="headerlink" title="查看用户"></a>查看用户</h3><p><code>select user,host from mysql.user;</code></p><h3 id="查看所有数据库"><a href="#查看所有数据库" class="headerlink" title="查看所有数据库"></a>查看所有数据库</h3><p><code>show DATABASES;</code></p><h3 id="锁定操作数据库"><a href="#锁定操作数据库" class="headerlink" title="锁定操作数据库"></a>锁定操作数据库</h3><p><code>use &lt;数据库名&gt;</code></p><p>在此之后可进行</p><ul><li><strong>显示指定数据库的所有表</strong>操作：<code>SHOW TABLES;</code></li><li><strong>显示数据表的属性</strong>：<code>SHOW COLUMNS FROM &lt;数据表名&gt;</code>;</li><li><strong>显示数据表的详细索引信息</strong>：<code>SHOW INDEX FROM &lt;数据表名&gt;;</code></li></ul><h3 id="授权用户"><a href="#授权用户" class="headerlink" title="授权用户"></a>授权用户</h3><p><em>（暂未成功，也暂未用到）</em></p><p><code>GRANT privileges ON databasename.tablename TO &#39;FALLEN&#39;@&#39;host&#39;;</code></p><ul><li><p>privileges – 用户的操作权限,如SELECT , INSERT , UPDATE  等(详细列表见该文最后面).如果要授予所 的权限则使用ALL说明: </p></li><li><p>databasename –  数据库名</p></li><li><p>tablename-表名,如果要授予该用户对所有数据库和表的相应操作权限则可用* 表示, 如*.*</p></li></ul><h3 id="显示数据表的属性"><a href="#显示数据表的属性" class="headerlink" title="显示数据表的属性"></a>显示数据表的属性</h3><p><code>SHOW COLUMNS FROM &lt;数据表名&gt;</code></p><h3 id="输出数据库管理系统的性能和统计信息"><a href="#输出数据库管理系统的性能和统计信息" class="headerlink" title="输出数据库管理系统的性能和统计信息"></a>输出数据库管理系统的性能和统计信息</h3><p><em>（暂未成功，也暂未用到）</em></p><p><code>SHOW TABLE STATUS [FROM db_name] [LIKE &#39;pattern&#39;] \G;</code></p><hr><h1 id="二、MySQL的基本操作"><a href="#二、MySQL的基本操作" class="headerlink" title="二、MySQL的基本操作"></a><strong>二、MySQL的基本操作</strong></h1><h2 id="MySQL连接"><a href="#MySQL连接" class="headerlink" title="MySQL连接"></a>MySQL连接</h2><p>实际上就是登录，可以直接命令行登录也可以用PHP登录（暂略）。</p><hr><h2 id="MySQL数据库的操作"><a href="#MySQL数据库的操作" class="headerlink" title="MySQL数据库的操作"></a>MySQL数据库的操作</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p><code>CREATE DATABASE &lt;数据库名&gt;;</code></p><p>也可以使用admin直接创建，还可以用PHP创建（暂略）。</p><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><p><code>drop database &lt;数据库名&gt;;</code></p><p>也可以使用admin直接删除，还可以用PHP删除（暂略）。</p><h3 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h3><p><code>use &lt;数据库名&gt;</code></p><p>还可以用PHP删除（暂略）。</p><hr><h2 id="MySQL数据类型"><a href="#MySQL数据类型" class="headerlink" title="MySQL数据类型"></a>MySQL数据类型</h2><ul><li>数值</li><li>日期&#x2F;时间</li><li>字符&#x2F;字符串</li></ul><p>这里就不一一列举了，可以参考：<a href="https://www.runoob.com/mysql/mysql-data-types.html">MySQL 数据类型 | 菜鸟教程 (runoob.com)</a></p><hr><h2 id="MySQL数据表的操作"><a href="#MySQL数据表的操作" class="headerlink" title="MySQL数据表的操作"></a>MySQL数据表的操作</h2><h3 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h3><p><code>CREATE TABLE table_name (colunm_name colunm_type)</code></p><p>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE fallen_tbl(</span><br><span class="line">   -&gt; fallen_id INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">   -&gt; fallen_title VARCHAR(100) NOT NULL,</span><br><span class="line">   -&gt; fallen_author VARCHAR(40) NOT NULL,</span><br><span class="line">   -&gt; submission_date DATE,</span><br><span class="line">   -&gt; PRIMARY KEY ( fallen_id )</span><br><span class="line">   -&gt; )ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><ul><li>如果你不想字段为 <strong>NULL</strong> 可以设置字段的属性为 <strong>NOT NULL</strong>， 在操作数据库时如果输入该字段的数据为<strong>NULL</strong> ，就会报错。</li><li>AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1。</li><li>PRIMARY KEY关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔。</li><li>ENGINE 设置存储引擎，CHARSET 设置编码。</li></ul><p><em>同样可以使用PHP，后文不做提示，一并略之。</em></p><h3 id="删除数据表"><a href="#删除数据表" class="headerlink" title="删除数据表"></a>删除数据表</h3><p><code>DROP TABLE table_name;</code></p><hr><h2 id="MySQL数据操作"><a href="#MySQL数据操作" class="headerlink" title="MySQL数据操作"></a>MySQL数据操作</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO &lt;数据表名&gt; (field1, field2, ..., fieldN)</span><br><span class="line">VALUES</span><br><span class="line">(value1, value2, ..., valueN);</span><br></pre></td></tr></table></figure><p>特别地，如果数据是字符型，必须使用单引号或者双引号，如”value”；</p><p>值得一提的是，命令不区分大小写。</p><h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><p>最基本的：<code>SELECT * FROM &lt;数据表名&gt;</code></p><h3 id="WHERE子句"><a href="#WHERE子句" class="headerlink" title="WHERE子句"></a>WHERE子句</h3><p><code>select * from fallen_tbl where fallen_title=&#39;学习MySQL使我快乐&#39;;</code></p><h3 id="UPDATE更新"><a href="#UPDATE更新" class="headerlink" title="UPDATE更新"></a>UPDATE更新</h3><p>用于修改MySQL中的数据</p><p><code>UPDATE fallen_tbl SET fallen_title=&#39;今天中午吃豌豆小面但是有怪东西&#39; WHERE fallen_id=2;</code></p><h3 id="DELETE删除"><a href="#DELETE删除" class="headerlink" title="DELETE删除"></a>DELETE删除</h3><p><code>DELETE FROM fallen_tbl WHERE fallen_id=3;</code></p><h3 id="LIKE子句"><a href="#LIKE子句" class="headerlink" title="LIKE子句"></a>LIKE子句</h3><p><code>SELECT * from fallen_tbl WHERE fallen_title LIKE &#39;%快乐&#39;;</code></p><h3 id="UNION操作符"><a href="#UNION操作符" class="headerlink" title="UNION操作符"></a>UNION操作符</h3><p>UNION 操作符用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中。多个 SELECT 语句会删除重复的数据，即<strong>去重</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT fallen_author FROM fallen_tbl</span><br><span class="line">    -&gt; UNION</span><br><span class="line">    -&gt; SELECT rain_author FROM rain_tbl</span><br><span class="line">    -&gt; ORDER BY fallen_author;</span><br></pre></td></tr></table></figure><p>特别地，如果在UNION后面加一个ALL，则没有去重功能，将会合并所有值。</p><p>更加特别的，带有WHERE的UNION ALL如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT country, name FROM Websites</span><br><span class="line">WHERE country=&#x27;CN&#x27;</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT country, app_name FROM apps</span><br><span class="line">WHERE country=&#x27;CN&#x27;</span><br><span class="line">ORDER BY country;</span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p><code>select * from fallen_tbl order by submission_date ASC;</code></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;个人博客：&lt;a href=&quot;https://conqueror712.github.io/&quot;&gt;https://conqueror712.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;知乎：&lt;a href=&quot;https://www.zhihu.com/</summary>
      
    
    
    
    <category term="Devlopment-Tech" scheme="https://conqueror712.github.io/categories/Devlopment-Tech/"/>
    
    
  </entry>
  
  <entry>
    <title>Git丨学习记录</title>
    <link href="https://conqueror712.github.io/post/Git.html"/>
    <id>https://conqueror712.github.io/post/Git.html</id>
    <published>2022-09-26T08:43:04.000Z</published>
    <updated>2023-03-23T01:30:39.717Z</updated>
    
    <content type="html"><![CDATA[<p>前言：</p><p>鉴于本人比较愚蠢，每次使用Git都会遇到不少的问题，<br>又因为本人比较懒，不愿意每次都上网查资料来debug，<br>故开此记录文档来便于查阅。</p><blockquote><p>个人博客：<a href="https://conqueror712.github.io/">https://conqueror712.github.io/</a></p><p>知乎：<a href="https://www.zhihu.com/people/soeur712/posts">https://www.zhihu.com/people/soeur712/posts</a></p><p>Bilibili：<a href="https://space.bilibili.com/57089326">https://space.bilibili.com/57089326</a></p><p>掘金：<a href="https://juejin.cn/user/1297878069809725/posts">https://juejin.cn/user/1297878069809725/posts</a></p></blockquote><hr><h1 id="0-debug记录"><a href="#0-debug记录" class="headerlink" title="0. debug记录"></a>0. debug记录</h1><p>如果在<code>git commit</code>之后出现：<br><code>Please enter the commit message for your changes. Lines starting...</code><br>那是因为没写<code>-m &quot;xxxx&quot;</code>，自动给跳转到<code>VIM</code>来让你手动输入参数了，<br>解决方法：</p><pre><code> 1. 按`i`或者`insert`键，进入&quot;插入模式&quot; 2. 修改最上面那行的黄色合并信息，也可以不改 1. 按下: `wq+ENTER`提交更新 所以还是推荐写上`-m &quot;xxxx&quot;`参数</code></pre><p>关于长城墙：请使用VPN</p><hr><h1 id="1-版本控制"><a href="#1-版本控制" class="headerlink" title="1. 版本控制"></a>1. 版本控制</h1><p>简而言之就是，在项目的版本迭代过程中，要保留老版本。</p><p>定义：版本控制（Revision Control）是一种在开发过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。</p><p>本地版本控制 -&gt;<br>集中版本控制(例如SVN，逻辑简单方便使用但是若服务器崩了就寄了) -&gt;<br>分布式版本控制(例如Git，每个人都拥有全部的代码，可以离线地在本地提交，联网了再扔到服务器上)</p><hr><h1 id="2-Git的配置"><a href="#2-Git的配置" class="headerlink" title="2. Git的配置"></a>2. Git的配置</h1><p>Windows: 官网下载，速度慢就配镜像；<br>Linux: <code>apt -get install git 或 sudo apt install git</code></p><p>当需要卸载的时候，记得回去清一下环境变量，然后在控制面板卸载就可以了；</p><p>鉴于<code>Git Bash</code>是<code>Linux</code>风格的窗口，故下面贴一些常用且基本的<code>Linux</code>命令，以便查阅：</p><p><img src="https://s2.loli.net/2023/01/13/9DInFLTamokZG3g.png" alt="avatar"></p><p>查看当前目录下的Git配置:<br><code>git config -l</code></p><p>查看系统给我们自动配置的配置（什么话啊）：<br><code>git config --system --list</code></p><p>查看用户自己配的配置：<br><code>git config --global --list</code><br>会出现<code>user.name &amp; user.email</code>，这是必须要配置的<br>如何配置？很简单：<br><code>git config --global user.name &quot;你的名字&quot;</code><br><code>git config --global user.email &quot;你的邮箱&quot;</code><br>如何删除？很简单，因为保存在本地了<br><code>Git\etc\gitconfig （安装目录） --system系统级</code><br><code>C:\Users\Administrator\.gitconfig   --global全局</code></p><hr><h1 id="3-Git基本理论（核心）"><a href="#3-Git基本理论（核心）" class="headerlink" title="3. Git基本理论（核心）"></a>3. Git基本理论（核心）</h1><p>Git本地有三个工作区域：</p><ol><li>工作目录(Working Directory):就是平时存放项目代码的地方</li><li>暂存区(Stage&#x2F;Index):用于临时存放你的改动，事实上只是一个文件，保存即将提交到文件列表信息</li><li>资源库(Repository或Git Directory):安全存放数据的位置，这里有提交到所有版本的数据，HEAD指向最新放入仓库的版本<br>Git远程有一个工作区域：</li><li>远程Git仓库(Remote Directory)：托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</li></ol><p>一个重要的原理图：</p><p><img src="https://s2.loli.net/2023/01/13/WwsykcjUFqv9TQb.png" alt="avatar"></p><p>在工作目录里面的隐藏的git文件夹里面有一个HEAD文件，里面大概是这样的内容：<br>ref: refs&#x2F;heads&#x2F;master<br>这个master是主分支的意思<br>当然，现在版本(2020.10.01之后)大概是变成了&#x2F;main 意思是一样的</p><p>Git的工作流程：</p><ol><li>在工作目录中添加、修改文件 -&gt; 有一个UserMapper.xml文件</li><li>将需要进行版本管理的文件放入暂存区域 -&gt; git add .</li><li>将暂存区域的文件提交到Git仓库 -&gt; git commit<br>因此，Git管理的文件有三种状态</li><li>已修改(modified)</li><li>已暂存(staged)</li><li>已提交(committed)</li></ol><hr><h1 id="4-Git项目搭建"><a href="#4-Git项目搭建" class="headerlink" title="4. Git项目搭建"></a>4. Git项目搭建</h1><p><img src="https://s2.loli.net/2023/01/13/w8THEhXqWjRfUQp.png" alt="avatar"></p><p>xxxxxxxxxx 上面的部分和之前的一张图片有一点差别，暂时先不去管；​查看当前暂存区状态：git status​创建本地仓库的两种方式：1. 创建全新的仓库，需要用Git管理的项目的根目录执行    在当前目录新建一个Git代码库，在Git Bash中    git init    执行之后就可以看到多了一个.git目录    2. 另一种方式是克隆远程目录    克隆一个项目和它的整个代码历史版本（版本信息）    git clone [url]</p><p>查看当前暂存区状态：git status</p><p>创建本地仓库的两种方式：</p><p>创建仓库的时候，许可证推荐选择GPL-3.0，具体的细则可以点进去自己看。</p><p>SSH的获取ssh-keygen<br>如果需要加密算法那就是ssh-keygen -t rsa</p><p>在C盘的&#x2F;user&#x2F;administrator&#x2F;.ssh&#x2F;id_rsa.pub找到，复制之后扔到Github的对应位置</p><p>克隆远程仓库到本地，复制地址之后git clone [url]就好了</p><hr><h1 id="5-Git文件操作"><a href="#5-Git文件操作" class="headerlink" title="5. Git文件操作"></a>5. Git文件操作</h1><p>文件的4种状态：</p><ol><li>Untracked:未跟踪，此文件在文件夹中，但并没有加入到Git库，不参与版本控制，通过git add状态变为Staged</li><li>Unmodify:文件已经入库，未修改，即版本库中的文件快照内容与文件夹中完全一致。这种类型的文件有两种去处：<ol><li>如果它被修改，而变为Modified；</li><li>如果使用git rm移除版本库，则变为Untracked文件</li></ol></li><li>Modified:文件已修改，仅仅是修改，并没有进行其他的操作，这个文件也有两个去处：<ol><li>通过git add可进入暂存Staged状态</li><li>使用git checkout则丢弃修改过，返回到Unmodify状态。git checkout即从库中取出文件，覆盖当前修改。</li></ol></li><li>Staged:暂存状态，执行git commit则将修改同步到库中，这时库中的文件和本地文件又变为一致，文件为Unmodify状态，执行git reset HEAD filename取消暂存，文件状态为Modified</li></ol><p>查看文件状态：</p><ol><li>查看指定文件状态git status [filename]</li><li>查看所有文件状态git status</li></ol><p>git add . # 添加所有文件到暂存区<br>git commit -m “我是信息我是信息” # 提交暂存区中的内容到本地仓库 -m的意思是提交信息</p><p>忽略文件：<br>有些时候我们并不想把所有的文件都纳入版本控制中，比如数据库文件、临时文件、设计文件等</p><p>应当在主目录下建立.gitignore文件，并且有以下规则：</p><ol><li>忽略文件中的空行或以#开始的行将会被忽略</li><li>可以使用Linux通配符，这里不过多展开</li><li>如果名称的最前面有一个！表示例外规则，将不被忽略</li><li>如果名称的最前面是一个路径分隔符&#x2F;，表示要忽略的文件在此目录下，而子目录中的文件不忽略</li><li>如果名称的最后面是一个路径分隔符&#x2F;，表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）</li></ol><blockquote><p><em>.txt# 忽略所有.txt结尾的文件<br>!lib.txt# 但lib.txt除外<br>&#x2F;temp# 仅忽略项目根目录下的TODO文件，不包括其他目录temp<br>build&#x2F;# 忽略build&#x2F;目录下的所有文件<br>doc&#x2F;</em>.txt# 会忽略doc&#x2F;notes.txt但不包括doc&#x2F;server&#x2F;arch.txt</p></blockquote><hr><h1 id="6-Git分支说明"><a href="#6-Git分支说明" class="headerlink" title="6. Git分支说明"></a>6. Git分支说明</h1><p>Git分支中常用的命令：</p><p>列出所有本地分支<code>git branch</code></p><p>列出所有远程分支<code>git branch -r</code></p><p>新建一个分支，但依然停留在当前分支<code>git branch [branch-name]</code></p><p>新建一个分支，并切换到该分支<code>git checkout -b [branch]</code></p><p>合并指定分支到当前分支<code>git merge [branch]</code></p><p>删除分支<code>git branch -d [branch-name]</code></p><p>删除远程分支<br><code>git push origin --delete [branch-name]</code><br><code>git branch -dr [remote/branch]</code></p><p>特别的，如果多个分支并行执行，就会导致我们代码不冲突，也就是同时存在多个版本<br>这里暂时不特别管这部分…</p><hr><h1 id="7-其他"><a href="#7-其他" class="headerlink" title="7. 其他"></a>7. 其他</h1><h2 id="Fork-与上游仓库同步"><a href="#Fork-与上游仓库同步" class="headerlink" title="Fork 与上游仓库同步"></a>Fork 与上游仓库同步</h2><p>要将您的 Fork 与上游仓库同步，您需要执行以下步骤：</p><p>首先，将上游仓库的 URL 添加为远程仓库。在终端或命令行中，进入您的本地仓库并运行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add upstream &lt;upstream_repository_url&gt;</span><br></pre></td></tr></table></figure><p>这将把上游仓库的 URL 添加为一个名为“upstream”的远程仓库。</p><p>接下来，获取上游仓库的更新。运行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch upstream</span><br></pre></td></tr></table></figure><p>这将获取上游仓库的更新，但并不会自动将其合并到您的本地分支中。</p><p>现在，将您的本地分支切换到主分支（通常是 <code>master</code>）。运行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><p>接下来，将上游仓库的更改合并到您的本地分支中。运行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge upstream/master</span><br></pre></td></tr></table></figure><p>这将在您的本地分支中合并上游仓库的更改。</p><p>最后，将更新后的本地分支推送到您的 Fork 上。运行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>这将将更新后的本地分支推送到您的 Fork 上。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前言：&lt;/p&gt;
&lt;p&gt;鉴于本人比较愚蠢，每次使用Git都会遇到不少的问题，&lt;br&gt;又因为本人比较懒，不愿意每次都上网查资料来debug，&lt;br&gt;故开此记录文档来便于查阅。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;个人博客：&lt;a href=&quot;https://conqueror</summary>
      
    
    
    
    <category term="Devlopment-Tech" scheme="https://conqueror712.github.io/categories/Devlopment-Tech/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机组成原理丨学习记录</title>
    <link href="https://conqueror712.github.io/post/Principles-Of-Computer-Composition.html"/>
    <id>https://conqueror712.github.io/post/Principles-Of-Computer-Composition.html</id>
    <published>2022-08-21T02:51:33.000Z</published>
    <updated>2023-03-23T01:27:13.109Z</updated>
    
    <content type="html"><![CDATA[<h1 id="零、前言"><a href="#零、前言" class="headerlink" title="零、前言"></a>零、前言</h1><blockquote><p>个人博客：<a href="https://conqueror712.github.io/">https://conqueror712.github.io/</a></p><p>知乎：<a href="https://www.zhihu.com/people/soeur712/posts">https://www.zhihu.com/people/soeur712/posts</a></p><p>Bilibili：<a href="https://space.bilibili.com/57089326">https://space.bilibili.com/57089326</a></p><p>掘金：<a href="https://juejin.cn/user/1297878069809725/posts">https://juejin.cn/user/1297878069809725/posts</a></p></blockquote><p>注：本文会不断的修改更新，如有任何错误欢迎指出！</p><h2 id="课程内容："><a href="#课程内容：" class="headerlink" title="课程内容："></a>课程内容：</h2><ul><li>计算机概述<ul><li>性能指标、层次结构</li></ul></li><li>数据表示与运算器<ul><li>数据的表示、运算器</li><li>浮点运算方法</li></ul></li><li>存储器<ul><li>存储器系统、存储器控制器</li><li>Cache、虚拟存储器</li></ul></li><li>指令系统<ul><li>指令集架构、寻址方式</li><li>典型指令</li></ul></li><li>中央处理器<ul><li>CPU模型机、指令执行过程、微程序控制器</li><li>硬布线控制器</li></ul></li><li>总线<ul><li>总线分类、总线仲裁</li><li>总线定时</li></ul></li><li>外围设备<ul><li>磁盘、显示</li></ul></li><li>输入输出系统<ul><li>程序查询、中断、DMA</li><li>通道方式</li></ul></li></ul><hr><h1 id="一、计算机系统体系结构"><a href="#一、计算机系统体系结构" class="headerlink" title="一、计算机系统体系结构"></a><strong>一、计算机系统体系结构</strong></h1><img src="https://s2.loli.net/2022/08/21/7eFLWu3gxnmpIzb.png" alt="avatar" style="zoom:50%;" /><p>一般来说，组成一词比体系结构要更加偏向底层；</p><p><img src="https://s2.loli.net/2022/09/02/SUavEFcVu3eZb6T.png" alt="avatar"></p><p><img src="https://s2.loli.net/2022/08/21/kxOe4jfuYpyrHWD.png" alt="avatar"></p><hr><h2 id="计算机的发展历史："><a href="#计算机的发展历史：" class="headerlink" title="计算机的发展历史："></a>计算机的发展历史：</h2><p><img src="https://s2.loli.net/2022/09/02/WZYy7ACMLgoskPQ.png" alt="avatar"></p><p>第一台<strong>电子数字</strong>计算机：ENIAC(1946)（电子管）</p><p><img src="https://s2.loli.net/2022/09/02/RX62aQxklEtvYfz.png" alt="avatar"></p><h3 id="冯诺依曼结构"><a href="#冯诺依曼结构" class="headerlink" title="冯诺依曼结构"></a>冯诺依曼结构</h3><p>以<strong>运算器</strong>为核心</p><p>“存储程序”的概念是指<strong>将指令以二进制代码的形式事先输入计算机的主存储器</strong>，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。</p><p>第一台采用冯诺依曼结构的计算机：EDVAC</p><p><img src="https://s2.loli.net/2022/09/02/Qp5Ini9DBsJT1Oq.png" alt="avatar"></p><h3 id="现代计算机结构"><a href="#现代计算机结构" class="headerlink" title="现代计算机结构"></a>现代计算机结构</h3><p>以<strong>存储器</strong>为核心</p><p>CPU &#x3D; 运算器 + 控制器（合二为一）</p><p><img src="https://s2.loli.net/2022/09/02/YLcFVW13xfkjuln.png" alt="avatar"></p><p><img src="https://s2.loli.net/2022/09/02/OoiWevhbEfjqwYc.png" alt="avatar"></p><p>注意，这里的主机和很大的那个主机箱子不是一个概念，这里的主机只包括CPU和主存。</p><p><img src="https://s2.loli.net/2022/09/02/vNOQWzVqiMHY8jP.png" alt="avatar"></p><hr><h2 id="主要硬件结构的简要介绍"><a href="#主要硬件结构的简要介绍" class="headerlink" title="主要硬件结构的简要介绍"></a>主要硬件结构的简要介绍</h2><h3 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h3><p>包括存储体、MAR（存储地址寄存器Memory Address Register）、MDR（存储数据寄存器Memory Data Register）</p><p>读取一个位于存储体内的信息的时候，顺序是<code>-&gt;MAR-&gt;存储体-&gt;MDR-&gt;</code></p><p>存储体内部的大致结构如下：</p><img src="https://s2.loli.net/2022/09/02/bON3eZLIr8kmvjB.png" alt="avatar" style="zoom:50%;" /><p>存储字长的例子 以及 字和字节的区别：B与b是不一样的，字与字节是不一样的，字节是<strong>死的</strong>，字是<strong>活的</strong>。</p><img src="https://s2.loli.net/2022/09/02/oWqHd6FfPRjS2Z8.png" alt="avatar" style="zoom:50%;" /><h3 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h3><p><img src="https://s2.loli.net/2022/09/02/2T8HZgBKGeRrwzE.png" alt="avatar"></p><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><p><img src="https://s2.loli.net/2022/09/02/sZpBEF4LICHXl6m.png" alt="avatar"></p><p>完成一条指令：<code>PC取指令-&gt;IR分析指令-&gt;CU执行指令</code>。其中前两步也被称为<strong>取指</strong>操作，最后一步也被称为<strong>执行</strong>操作。</p><p>除此之外，还有条件码寄存器(Status Register)，用里面的一个一个标记位，存放CPU进行算术或者逻辑运算的结果。</p><h3 id="计算机的工作过程示例："><a href="#计算机的工作过程示例：" class="headerlink" title="计算机的工作过程示例："></a>计算机的工作过程示例：</h3><p><img src="https://s2.loli.net/2022/09/02/NaCXPqoTULfI7OR.png" alt="avatar"></p><p><img src="https://s2.loli.net/2022/09/02/8NFmjOYRDgT9G1U.png" alt="avatar"></p><p>指令的执行分为必经步骤和有选择性的步骤。</p><img src="https://s2.loli.net/2022/09/02/7KkIeyd2YJgoG8Q.png" alt="avatar" style="zoom:50%;" /><p>需要特别说明的是，现代的计算机往往会把MAR和MDR集成到CPU里面去，所以有可能有的题目会画在一起。</p><p>还有一点：在高级语言中的<code>if</code> <code>else</code> <code>for</code>实际上会被编译成<code>cmp(compare)</code>和<code>jne(jump if not equal)</code>，所以本质上是<code>goto</code>；</p><p>函数调用的原理：Stack LIFO</p><p><strong>总结：</strong></p><p><img src="https://s2.loli.net/2022/09/02/623vjFNMypiCquH.png" alt="avatar"></p><h2 id="计算机系统的多级层次结构"><a href="#计算机系统的多级层次结构" class="headerlink" title="计算机系统的多级层次结构"></a>计算机系统的多级层次结构</h2><p><img src="https://s2.loli.net/2022/09/02/JqHkDbm5TatPBjl.png" alt="avatar"></p><p><img src="https://s2.loli.net/2022/09/02/p7Xc4k8FaxotjrE.png" alt="avatar"></p><h3 id="编译程序："><a href="#编译程序：" class="headerlink" title="编译程序："></a>编译程序：</h3><p>将高级语言编写的源程序全部语句一次全部翻译成机器语言程序，而后再执行机器语言程序（只需翻译一次)解释程序:将源程序的一条语句翻译成对应于机器语言的语句，并立即执行。紧接着再翻译下一句(每次执行都要翻译)。</p><p><img src="https://s2.loli.net/2022/09/02/bx4EdoM7CpPzBhL.png" alt="avatar"></p><h2 id="计算机的性能指标"><a href="#计算机的性能指标" class="headerlink" title="计算机的性能指标"></a>计算机的性能指标</h2><h3 id="储存器的性能指标"><a href="#储存器的性能指标" class="headerlink" title="储存器的性能指标"></a>储存器的性能指标</h3><p>需要注意的一点是：在实际情况中MAR的位数不一定能计算出存储器的真正大小。理论值是峰值。</p><p>MAR位数反应<strong>存储单元的个数</strong>（最多支持的个数），例如32位MAR，<strong>最多</strong>存储单元个数：<code>2^32</code></p><p>MDR位数 &#x3D; <strong>存储字长</strong> &#x3D; 每个存储单元的大小</p><p>故<code>总容量 = 存储单元个数 * 存储字长</code>，单位是<code>bit</code>，若转换成字节则<code>/8</code>；</p><p><code>K: 2^10</code>  <code>M: 2^20</code>  <code>G: 2^30</code>  <code>T: 2^40</code></p><p><strong>CPI</strong> (Clock cycle Per Instruction)：执行一条指令所需的<strong>时钟周期数</strong>；</p><p>​不同的指令，CPI不同。甚至相同的指令，CPI也有可能发生变化；</p><p>​所以通常提到CPI的时候都是指的<strong>平均值</strong>；</p><p><strong>执行一条指令的耗时</strong>： <code>指令数 * CPI * CPU时钟周期(ClockCycleTime)</code></p><p><strong>IPS</strong> (Instructions Per Second)：每秒执行多少条指令；</p><p>​<code>IPS = 主频 / 平均CPI</code></p><p>​有时，也会在IPS FLOPS前面加上K M G T，有别于刚才的存储大小；</p><p>​<code>K = Kilo = 1e3</code></p><p>​<code>M = Million = 1e6</code></p><p>​<code>G = Giga = 1e9</code></p><p>​<code>T = Tera = 1e12</code></p><p><strong>FLOPS</strong> (Floating-point Operations Per Second)：每秒执行多少次浮点运算</p><p><strong>数据通路带宽</strong>：</p><p>数据总线一次所能并行传送信息的位数；（各硬件部件通过数据总线传输数据）</p><p><strong>吞吐量（率）</strong>：指系统在单位时间内处理请求的数量</p><p>它取决于信息能多快地存入内存，CPU能多快地取指令，数据能多快地从内存取出或存入，以及所得结果能多快地从内存送给一台外部设备。这些步骤中的每一步都关系到主存，因此，系统吞吐量主要取决于主存的存取周期。</p><p><strong>响应时间</strong>：指从用户向计算机发送一个请求，到系统对该请求做出相应并获得他所需要的结果的等待时间。</p><p>通常包括<strong>CPU时间</strong>（运行一个程序所花费的时间）与<strong>等待时间</strong>（用于磁盘访问、存储器访问、I&#x2F;O操作、操作系统开销等时间）。</p><p>值得一提的是，一般来说，我们会定义<code>性能 = 1 / 响应时间</code></p><p><strong>功耗问题</strong>：</p><p><code>功耗 ≈ 1/2 × 负载电容 × 电压的平方 × 开关频率 × 晶体管数量</code></p><p>所以有了<em>通过并行提高性能</em>的方式。</p><p>综上所述，我们可以用一个<em>基准程序</em>来测量计算机处理速度，也就是所谓的<em>跑分软件</em>。</p><hr><h2 id="计算机的一些基础名词："><a href="#计算机的一些基础名词：" class="headerlink" title="计算机的一些基础名词："></a>计算机的一些基础名词：</h2><h3 id="机器字长"><a href="#机器字长" class="headerlink" title="机器字长"></a>机器字长</h3><p>计算机<strong>一次</strong>整数运算所能处理的二进制位数</p><h3 id="微处理器"><a href="#微处理器" class="headerlink" title="微处理器"></a><strong>微处理器</strong></h3><p>​微处理器是在单个硅片上实现的CPU，围绕其构建的计算机被称为<strong>微机</strong>。</p><h3 id="硬盘与储存系统"><a href="#硬盘与储存系统" class="headerlink" title="硬盘与储存系统"></a><strong>硬盘与储存系统</strong></h3><p>​如今，半导体硬盘 即固态SSD开始取代传统的机械硬盘，这有助于硬盘的性能（主要是访问时间）。</p><p>​如果不能将程序储存在合适的储存器中，CPU的速度再快也<strong>毫无用处</strong>。</p><p>​<strong>便宜的Flash储存器（俗称闪存）</strong>使得MP3、数码相机、电子书和ipad等数码产品获得了巨大成功。</p><p><img src="https://s2.loli.net/2022/08/21/AvTiyVapcUtFqle.png" alt="avatar"></p><h3 id="图灵完备"><a href="#图灵完备" class="headerlink" title="图灵完备"></a><strong>图灵完备</strong></h3><p>如果一台计算机能够模拟图灵机，那么它就是图灵完备的。</p><p>如今的计算机都是如此了。</p><p><img src="https://s2.loli.net/2022/08/21/SZyOibjwTtWRXEp.png" alt="avatar"><img src="https://s2.loli.net/2022/08/21/RTPLsmdaNVeti2c.png" alt="avatar"></p><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a><strong>总线</strong></h3><p>一些计算机系统使用总线扩展接口或桥接技术，以此来在不同类型的总线之间交换数据。（USB Type-C转接就是如此）</p><h3 id="信息"><a href="#信息" class="headerlink" title="信息"></a><strong>信息</strong></h3><p>信息这一词表示计算机中的指令和数据</p><p>如右图，双向箭头代表这条通路商的信息是双向的；</p><p>分为<strong>读周期</strong>和<strong>写周期</strong>，会让信息流的方向不同。</p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a><strong>寄存器</strong></h3><p>寄存器是CPU内部用来存放一个单位的数据的存储单元。</p><p>由多个**触发器(Flip-Flop)<strong>和</strong>锁存器(Latches)**组成的简单电路。</p><p>寄存器通常用它所保存的数据的位数来描述（8位 16位 32位 64位）。</p><p>寄存器和<strong>存储器</strong>中的<strong>字存储单元</strong>没有本质区别；</p><p>实际差别在于，寄存器位于CPU内，它的访问速度<strong>远远快于</strong>访问CPU外的存储器。</p><img src="https://s2.loli.net/2022/08/21/dXS5uDTgCA4Lo3x.png" alt="avatar" style="zoom:33%;" /><h3 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a><strong>时钟</strong></h3><p>绝大多数数字电子电路都带有一个时钟，用以生成<strong>连续的间隔固定的</strong>电脉冲流。</p><p>之所以被称作时钟，是因为可用这些电脉冲来<strong>计时</strong>或确定计算机内所有事件的<strong>顺序</strong>。</p><p>时钟提供了脉冲流，所有的内部操作都是在时钟脉冲的触发下进行的；</p><p>时钟的频率是决定计算机速度的一个因素，目前一般为3.2GHz（32亿）。</p><p>事件由时钟信号触发的数字电路被称作<strong>同步的</strong>，因为它们由时钟信号来同步。</p><p>有些事件则是<strong>异步的</strong>，因为它们可以在任何时间发生。</p><p>​<em>例如，如果移动一下鼠标，它会向计算机发送一个信号，这是一个异步事件（先动，后发）；</em></p><p><em>然而，计算机可以在每个时钟脉冲检测鼠标的状态，这是一个异步事件。</em></p><p><img src="https://s2.loli.net/2022/08/21/8t4qJypExLHXYFR.png" alt="avatar"></p><p>后续还会学到真正的计算机如何在完成一条指令之前就开始执行一条新的指令（我觉得它叫并行）。</p><p>计算机会将数据和指令放在不同的存储器中（或使用不同的总线传输数据和指令）；</p><p>这样的结构叫做 <em>哈佛体系机构</em>。</p><p><img src="https://s2.loli.net/2022/08/21/EODCfNRylZ9pXWx.png" alt="avatar"></p><h3 id="光刻机"><a href="#光刻机" class="headerlink" title="光刻机"></a>光刻机</h3><p>原理简要示意图：</p><p><img src="https://s2.loli.net/2022/08/21/PDIoUCpTB6XubHr.png" alt="avatar"></p><p>一层一层更改顶部的化学覆盖层，然后用光来照射…</p><p><img src="https://s2.loli.net/2022/08/21/MpCysI7u3gY4SGN.png" alt="avatar"></p><h3 id="普适计算"><a href="#普适计算" class="headerlink" title="普适计算"></a><strong>普适计算</strong></h3><p>简单释义：计算是无处不在的</p><p>​也被称为功耗感知的计算(power-aware)——低功耗计算</p><p>特征：趋同性</p><p>实例：eBook中的E-ink，即电子墨水</p><hr><h2 id="存储程序计算机的概念"><a href="#存储程序计算机的概念" class="headerlink" title="存储程序计算机的概念"></a>存储程序计算机的概念</h2><p>计算机的存储器应当视为一个存放信息的表格或目录（<strong>有序的</strong>）。</p><p>人类的记忆往往不是有序的，是神经元之间的复杂连接构成的非线性结构，这种结构并不利于计算机检索，故计算机采用连续的储存方式。</p><p><img src="https://s2.loli.net/2022/08/25/xMVFeJp4z3DdR7X.png" alt="avatar"></p><h3 id="寄存器传输语言RTL"><a href="#寄存器传输语言RTL" class="headerlink" title="寄存器传输语言RTL"></a>寄存器传输语言RTL</h3><p>由于使用文字描述计算机的操作很不方便，故有了RTL，这样可以更加容易地定义计算机内发生的操作。</p><p>注意：RTL并不是一种计算机语言，它只是一种用来<strong>定义计算机操作的符号</strong>。</p><p>RTL可以很方便地<strong>区分</strong>存储单元的地址和它的内容，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[15] = Max_Run</span><br><span class="line">含义是：地址为15的存储单元保存了变量Max_Run的值</span><br><span class="line"></span><br><span class="line">[15] ← [15] + 1</span><br><span class="line">含义是将地址为15的存储单元的值+1，并将结果写回地址为15的存储单元</span><br><span class="line">其中 ← 符号的含义是数据传送</span><br></pre></td></tr></table></figure><p>自计算机诞生，直至20世纪70年代，计算机采用的运行过程都是<strong>单线程顺序</strong>的，而今天的计算机已经可以做到<strong>并行</strong>和<strong>乱序</strong>地完成内部操作了。</p><p>在当时，机器上执行一条指令需要至少两次访存：</p><ol><li>读取指令</li><li>从存储器中读出指令需要的数据  ||  将它之前的指令产生的或修改过的数据写回存储器</li></ol><p>这一过程也被称为<strong>读取&#x2F;执行</strong>周期的两阶段模式。</p><p>这一情况当时人们用<strong>冯 · 诺依曼平瓶颈</strong>来表明CPU与存储器之间的通路是存储程序计算机的制约因素之一，下面是一个可视化的例子：</p><p><img src="https://s2.loli.net/2022/08/25/xDsjSgO6A58FKMC.png" alt="avatar"></p><h4 id="两地址指令："><a href="#两地址指令：" class="headerlink" title="两地址指令："></a>两地址指令：</h4><p>采用两地址指令来进行两数之和操作会破坏其中一个地址所存储的数的原始值，不难理解。</p><h4 id="单地址指令："><a href="#单地址指令：" class="headerlink" title="单地址指令："></a>单地址指令：</h4><p>由于指令中只提供了一个操作数地址而指令至少需要两个地址，处理器不得不使用一个<strong>不需要显式地址</strong>的第二操作数。第二个操作数来自于CPU内一个叫<strong>累加器</strong>的<strong>寄存器</strong>，由于所有的操作数都要流过它累加器，导致现在很少用了。</p><h3 id="计算机的分类"><a href="#计算机的分类" class="headerlink" title="计算机的分类"></a>计算机的分类</h3><ul><li>存储器 - 存储器型</li><li>寄存器 - 存储器型</li><li>寄存器 - 寄存器型</li></ul><h2 id="计算机系统概览"><a href="#计算机系统概览" class="headerlink" title="计算机系统概览"></a>计算机系统概览</h2><p>计算机科学家们将存储器是做一个巨大的通过地址访问的数组。</p><p><strong>存储墙</strong>一词，用来说明如今存储性能远落后于处理器性能，最终会制约处理器的性能。</p><h3 id="存储层次："><a href="#存储层次：" class="headerlink" title="存储层次："></a>存储层次：</h3><p><img src="https://s2.loli.net/2022/08/25/T2QvK4uIdwzVxHp.png" alt="avatat"></p><ul><li>寄存器存放处理器的工作数据；</li><li>Cache是缓存常用数据的快速存储器，是决定计算机性能的关键模块；<ul><li>Cache系统与计算机的地址总线和数据总线相连，监听着CPU与存储器之间的事务；</li><li>有些Cache分多级，查找顺序为一级 → 二级 → … → 主存；</li></ul></li><li>DRAM存放工作数据块（动态随机访问存储器Dynamic Random Access Memory）；<ul><li>易失性半导体：掉电的时候其中的数据都会丢失；</li></ul></li><li>硬盘用来保存程序和数据；</li></ul><p>值得一提的是，虽然硬盘的容量是寄存器的4000万倍，但是速度却比寄存器慢2000万倍。</p><p><img src="https://s2.loli.net/2022/08/25/xPkvifM4eugYaAH.png" alt="avatar"></p><h3 id="总线-1"><a href="#总线-1" class="headerlink" title="总线"></a>总线</h3><p>总线将计算机或外部设备的两个或多个功能单元连接在一起并允许他们相互交换数据，例如CPU与显卡之间的总线。</p><p><img src="https://s2.loli.net/2022/08/25/4YZclWAF7m5H3sk.png" alt="avatar"></p><h4 id="仲裁器"><a href="#仲裁器" class="headerlink" title="仲裁器"></a>仲裁器</h4><p>一些系统使用仲裁器来决定允许在总线冲突的时候哪个设备继续工作，其余设备等待之。</p><h4 id="宽度"><a href="#宽度" class="headerlink" title="宽度"></a>宽度</h4><p>一般用<strong>并行数据通路的数量</strong>来定义总线的宽度；</p><p>​例如一条64位宽的总线一次能够传送64（8byte）bit的信息；</p><h4 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h4><p>总线带宽是衡量<strong>信息在总线上的传输速率</strong>的一项指标；</p><p>​单位一般是b&#x2F;s或者B&#x2F;s；</p><p>​在保持<strong>数据传输率</strong>不变的情况下增加总线的宽度，可以提高带宽；</p><h4 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h4><p>延迟是从发出数据传输请求到实际数据传输的时间间隔；</p><p>​总线延迟通常包括传输开始之前进行总线仲裁的时间；</p><hr><h1 id="二、数据的表示与运算"><a href="#二、数据的表示与运算" class="headerlink" title="二、数据的表示与运算"></a><strong>二、数据的表示与运算</strong></h1><hr><h3 id="BCD码"><a href="#BCD码" class="headerlink" title="BCD码"></a>BCD码</h3><p>Binary-Coded Decimal 用二进制编码的十进制<em>数字电路梦幻联动</em></p><ul><li>8421码  （需要掌握加法运算）</li><li>余3码</li><li>2421码</li></ul><p>首先我们来看<strong>8421</strong>码，用4位二进制来表示0~9十个数，显然是有冗余，因为2^4 &#x3D; 16，多了6种状态，不过这不重要。</p><p>假设我们要表示985，那么用8421码来存储就是：1001 1000 0101，8421码是一种<strong>有权码</strong>，每一位的权值固定。</p><p>8421码进行相加，实际上也是对应位相加，不过在实际做题中可以投机取巧，转化成十进制算完了再转回来（）。</p><p>很重要的一点是，当加法得到的结果超出了8421码的表示范围时，也就是落在了<code>[1010, 1111]</code>内，</p><p>那么计算机会自动把结果<code>+6</code>以<strong>进位</strong>，最后得到的位于原位的四位二进制数就是原本的数的<strong>个位</strong>（很神奇吧）</p><p>对映射的方式稍作修改就会得到别的编码方式</p><p>例如<strong>余3码</strong>就是在8421码的基础上再<code>+3</code>，即<code>+0011</code>，在余3码中，每一位并没有一个固定的权值，称为<strong>无权码</strong>。</p><hr><h3 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h3><p>在数据的传输过程中，有可能会发生错误，例如把<code>01</code>传输成了<code>00</code>，这种错误被称为<strong>位错误</strong>；</p><p>为了避免这种错误，或者说想要知道错误发生了，我们需要用多一些bit位来存储信息；</p><p>例如3bit映射到4个合法状态，就有了4种冗余的非法状态，当接收方获得非法状态的信息时，就能知道发生了错误。</p><table><thead><tr><th align="center">信息</th><th align="center">A</th><th align="center">B</th><th align="center">C</th><th align="center">D</th></tr></thead><tbody><tr><td align="center"><strong>编码</strong></td><td align="center"><strong>100</strong></td><td align="center"><strong>001</strong></td><td align="center"><strong>010</strong></td><td align="center"><strong>111</strong></td></tr></tbody></table><p>由若干位代码组成的一个字叫<strong>码字</strong>，比如上表中的100, 001都是；</p><p>将两个码字逐位进行对比，具有不同的位的个数称为<strong>两个码字间的距离</strong>；</p><p>一种编码方案可能有若干个合法码字，<strong>各</strong>合法码字间的最小距离称为**”码距”**，用<code>d</code>表示；</p><ul><li>当<code>d=1</code>时，无检错能力；</li><li>当<code>d=2</code>时，有检错能力；</li><li>当<code>d&gt;3</code>时，若设计合理，可能具有检错、纠错能力；</li></ul><p>偶校验的硬件实现：</p><p>各信息进行异或（模2加）运算，得到的结果即为偶校验位。</p><p>只因校验的硬件实现类似，不过是反过来了。</p><hr><h3 id="海明校验码"><a href="#海明校验码" class="headerlink" title="海明校验码"></a>海明校验码</h3><p>设计思路：将信息位分组进行<strong>偶校验</strong>，有多个校验位，校验位能<strong>携带多种状态信息</strong>（对与错，错在哪）；</p><p>校验位的个数：<code>2^k &gt;= n + k + 1</code>，信息位n，校验位k，n+k位中任何一位都可能出错，1种正确状态；</p><p>海明码<strong>求解步骤</strong>：（详细过程待补充）</p><ol><li>确定校验位数量</li><li>确定校验位的分布</li><li>求校验位的值</li><li>检错纠错</li></ol><p><em>海明码有1位纠错，2位检错能力</em></p><hr><h3 id="循环冗余校验码"><a href="#循环冗余校验码" class="headerlink" title="循环冗余校验码"></a>循环冗余校验码</h3><p>又称<strong>CRC码</strong></p><p><strong>主体思想</strong>：除法的余数</p><ol><li>数据发送、接收方约定一个“除数”</li><li>K个信息位和R和校验位作为“被除数”，添加校验位后需保证除法的余数 &#x3D;&#x3D; 0</li><li>收到数据后，进行二进制除法检验余数是否为0</li><li>若余数 !&#x3D; 0 则出错，进行纠错or重传</li></ol><p><strong>计算过程</strong>：</p><ol><li>确定K、R以及<strong>生成多项式</strong>对应的二进制码（生成多项式的系数就是除数）（R &#x3D; 生成多项式的最高次幂）</li><li>移位：信息码左移R位，低位补0，也就是在原本的信息码后面填上R个0即可</li><li>相除：对移位后的信息码，用生成多项式进行<strong>模2除法</strong>，产生余数</li><li>检错和纠错：如果最后得到的余数为000，则没有出错</li></ol><p><strong>检错</strong>：</p><p>模2除之后得到的余数的循环节为7，可以对应从1k~7k的出错位（K∈N+）（并不是二进制）；</p><p>一般来说，CRC码只用于计算机网络的检错，其纠错功能一般不用；</p><ol><li>可检测出所有奇数个错误；</li><li>可检测出所有双比特的错误；</li><li>可检测出所有小于等于校验位长度的连续错误；</li></ol><hr><h2 id="定点数与浮点数：如何用有限的Bit位表示尽可能多的信息"><a href="#定点数与浮点数：如何用有限的Bit位表示尽可能多的信息" class="headerlink" title="定点数与浮点数：如何用有限的Bit位表示尽可能多的信息"></a>定点数与浮点数：如何用有限的Bit位表示尽可能多的信息</h2><h3 id="对于定点数："><a href="#对于定点数：" class="headerlink" title="对于定点数："></a>对于<strong>定点数：</strong></h3><p>首先我们看看BCD码的缺陷：浪费位数，没法同时表示很大和很小的数</p><h3 id="对于浮点数："><a href="#对于浮点数：" class="headerlink" title="对于浮点数："></a>对于<strong>浮点数</strong>：</h3><p>我们有科学计数法，用来节省空间；</p><p><strong>IEEE标准</strong>：（定义了两个基本的格式）</p><ul><li>用32Bit表示单精度的浮点数<code>float || float32</code></li><li>用64Bit表示双精度的浮点数<code>double || float64</code></li></ul><p>用单精度类型举例（双精度类似）：</p><table><thead><tr><th align="center">s &#x3D; 符号位</th><th align="center">e &#x3D; 指数位</th><th align="center">f &#x3D; 有效数位</th></tr></thead><tbody><tr><td align="center">1 Bit</td><td align="center">8 Bit</td><td align="center">23 Bit</td></tr></tbody></table><p>特别地，对于指数位，我们用1<del>254映射到-126</del>127上，0和255另有用处；</p><p>于是，浮点数就可以表示成：<code>(-1)^s * 1.f * 2^e</code></p><h3 id="浮点数的二进制转化"><a href="#浮点数的二进制转化" class="headerlink" title="浮点数的二进制转化"></a>浮点数的二进制转化</h3><p><code>s + e + f</code></p><p>逐个转化成二进制然后拼接即可</p><h3 id="浮点数的加法和精度损失"><a href="#浮点数的加法和精度损失" class="headerlink" title="浮点数的加法和精度损失"></a>浮点数的加法和精度损失</h3><p>浮点数加法：（利用半加器和全加器就可以实现）</p><ul><li>先<strong>对齐</strong> 再运算</li><li>对齐指数位原则：<code>e = max(e1, e2)</code></li><li>对其指数位后，有效位应做相应左移右移</li></ul><p>在右移的过程中，最右侧的有效位被丢弃掉了，这一步是<strong>丢失精度</strong>的原因所在。</p><h3 id="Kahan-Summation算法解决精度丢失"><a href="#Kahan-Summation算法解决精度丢失" class="headerlink" title="Kahan Summation算法解决精度丢失"></a>Kahan Summation算法解决精度丢失</h3><p>解决”大数吃小数”的问题；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KahanSummation</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line"><span class="type">float</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0.0f</span>; <span class="type">float</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0.0f</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20000000</span>; i++) &#123; </span><br><span class="line"><span class="type">float</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1.0f</span>; </span><br><span class="line"><span class="type">float</span> <span class="variable">y</span> <span class="operator">=</span> x - c; </span><br><span class="line"><span class="type">float</span> <span class="variable">t</span> <span class="operator">=</span> sum + y;</span><br><span class="line">c = (t-sum)-y; </span><br><span class="line">sum = t;</span><br><span class="line">&#125; </span><br><span class="line">System.out.println(<span class="string">&quot;sum is &quot;</span> + sum); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其实这个算法的原理其实并不复杂，</span></span><br><span class="line"><span class="comment">就是在每次的计算过程中，都用一次减法，</span></span><br><span class="line"><span class="comment">把当前加法 计算中损失的精度记录下来，</span></span><br><span class="line"><span class="comment">然后在后面的循环中，把这个精度损失放在要加的小数上，再做一次运算。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h2 id="算术逻辑单元ALU"><a href="#算术逻辑单元ALU" class="headerlink" title="算术逻辑单元ALU"></a>算术逻辑单元ALU</h2><h3 id="加法器、乘法器与ALU的改进"><a href="#加法器、乘法器与ALU的改进" class="headerlink" title="加法器、乘法器与ALU的改进"></a>加法器、乘法器与ALU的改进</h3><p><strong>半加器：</strong></p><p>通过一个异或门计算出个位，通过一个与门计算出是否进位，我们就通过电路算出了 一个一位数的加法。</p><p>于是，<strong>我们把两个门电路打包，给它取一个名字，就叫作半加器</strong>（Half Adder）。</p><p><strong>全加器：</strong></p><p>由于半加器只能处理1位的加法问题，所以很容易想到，如果要进行多Bit的加法运算，则需要多个半加器组合工作。</p><p><strong>我们用两个半加器和一个或门，就能组合成一个全加器。</strong></p><p>有了全加器，我们要进行对应的两个 8 bit 数的加法就很容易了。我们只要把 8 个全加器串联起来就好了。</p><p>值得一提的是，实际CPU里面的加法器，会更复杂一些，被称为<strong>超前进位加法器</strong>，这里先不做过多介绍。</p><p>至于ALU，则是由加法器再进行组合设计封装的产物了。</p><p><em><strong>NOW, WE HAVE A NEW LEVEL OF ABSTRACTION!</strong></em></p><p><strong>乘法器：</strong></p><p>虽然我们可以多次使用加法器来达到乘法运算的效果，但是毕竟时间空间材料都很宝贵，于是乘法器就应运而生了。</p><p>首先需要了解的是：<strong>二进制乘法</strong></p><p>很简单，一张图就能解释：</p><p>操作只有2种：复制 or 置0，最后再全部加起来即可</p><p>实际上我们并不需要把每一位的运算结果都记录下来，那样的话实在是太浪费材料了，我们只需要维护一个动态的结果即可；</p><p>但是这样也有一个显著的缺点：<strong>慢！</strong></p><p>复杂度有O(N)，N为位数；</p><p><em><strong>所谓时间换空间，空间换时间…</strong></em></p><p><strong>电路设计改进——并行加速方法：</strong></p><p>实际上就是让多位同时计算，会获得O(logN)的时间复杂度，但相应的，<strong>代价</strong>是需要更多的晶体管开关来存放中间计算结果。</p><p>等待前面的步骤的等待时间，被称为**门延迟(Gate Delay)**。</p><blockquote><p>我们只要把进位部分的电路完全展开就好了。</p><p>我们的半加器到全加器，再到加法器，都是用最基础的门电路组合而成的。</p><p>门电路的计算逻辑，可以像我们做数学里面的多项式乘法一样 完全展开。</p><p>在展开之后呢，我们可以把原来需要较少的，但是有较多层前后计算依赖关系的门电路，</p><p>展开成需要较多的，但是依赖关系更少的门电路。</p></blockquote><hr><h1 id="三、存储系统"><a href="#三、存储系统" class="headerlink" title="三、存储系统"></a><strong>三、存储系统</strong></h1><h2 id="存储器的基本概念"><a href="#存储器的基本概念" class="headerlink" title="存储器的基本概念"></a>存储器的基本概念</h2><p><strong>存储介质：</strong>磁芯、磁表面、半导体、光…</p><p><strong>存取方式：</strong></p><ul><li>随机存取——RAM ROM</li><li>串行访问：<ul><li>顺序存取：磁带</li><li>直接存取：磁盘</li></ul></li></ul><p><strong>性能指标：</strong></p><ul><li>存储容量——存储字数 * 字长</li><li>单位成本——每位价格 &#x3D; 总成本 &#x2F; 总容量</li><li>存储速度——数据传输率（主存带宽） &#x3D; 数据宽度 &#x2F; 存储周期</li></ul><h3 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h3><ul><li>Cache - 主存层次：硬件实现，解决速度不匹配的问题</li><li>主存 - 辅存层次：硬件 + 操作系统实现，解决容量问题，逐渐形成虚拟存储系统</li></ul><p><strong>寄存器</strong>非常快，但也非常小；</p><p>CPU Cache使用<strong>SRAM(Static Random Access Memory静态随机存取存储器)</strong></p><p><strong>静态：</strong>通电状态数据保持存在，断电丢失</p><p>SRAM内1Bit数据需要6~8个晶体管，导致存储密度不高，空间有限，但是因为电路简单，故访问速度很快。</p><p>L1 L2 L3三层高速缓存，L1分为指令缓存和数据缓存</p><p>L1往往嵌在CPU核心内部，很快</p><p>L2不在核心内部，慢一些</p><p>L3是多个CPU核心公用的，尺寸更大，访问速度更慢</p><p>内存的芯片<strong>DRAM(Dynamic Random Access Memory动态随机存取存储器)</strong></p><p>相比SARM，密度↑，容量↑，价格↓，数据访问电路复杂度↑，刷新电路复杂度↑，访问延时↑</p><p>DARM需要不断**”刷新”**才能保持数据被存储起来。</p><p>1Bit只需要一个晶体管和一个电容，数据存在电容里，电容会不断漏电，所以需要定时刷新充电才能保护数据。</p><p><strong>SSD(Solid State Drive固态硬盘)</strong>HDD(Hard Disk Drive硬盘)：最大最慢</p><p>各个存储器只和相邻的一层存储器打交道，并且随着一层层往外，容量↑，速度↓，价格↓；</p><p><strong>局部性原理：</strong>（时间局部性 空间局部性）</p><p><em>高速度 大容量 低价格兼得</em></p><p>时间局部性：如果一个数据被访问了，那么它在短时间内还会被再次访问；</p><p>空间局部性：如果一个数据被访问了，那么和它相邻的数据也很快会被访问；</p><p>这样根据访问频率来决定将数据存储到速度快的存储器还是慢的就可以了。</p><p><strong>LRU(Least Recently Used)缓存算法</strong></p><p>​缓存命中率(Hit Rate)：访问的数据中 可以在我们设置的内存缓存中找到的占有多大的比例；</p><hr><p>未完待续…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;零、前言&quot;&gt;&lt;a href=&quot;#零、前言&quot; class=&quot;headerlink&quot; title=&quot;零、前言&quot;&gt;&lt;/a&gt;零、前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;个人博客：&lt;a href=&quot;https://conqueror712.github.io/&quot;&gt;ht</summary>
      
    
    
    
    <category term="408" scheme="https://conqueror712.github.io/categories/408/"/>
    
    
  </entry>
  
  <entry>
    <title>GoLang丨学习记录</title>
    <link href="https://conqueror712.github.io/post/GoLang.html"/>
    <id>https://conqueror712.github.io/post/GoLang.html</id>
    <published>2022-07-23T13:45:05.000Z</published>
    <updated>2023-03-23T01:30:27.227Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a><strong>前言：</strong></h1><blockquote><p>个人博客：<a href="https://conqueror712.github.io/">https://conqueror712.github.io/</a></p><p>知乎：<a href="https://www.zhihu.com/people/soeur712/posts">https://www.zhihu.com/people/soeur712/posts</a></p><p>Bilibili：<a href="https://space.bilibili.com/57089326">https://space.bilibili.com/57089326</a></p><p>掘金：<a href="https://juejin.cn/user/1297878069809725/posts">https://juejin.cn/user/1297878069809725/posts</a></p></blockquote><p>关于Go：</p><p>​它没有隐式的数值转换，没有构造函数和析构函数，没有运算符重载，没有默认参数，也没有继承，没有泛型，没有异常，没有宏，没有函数修饰，更没有线程局部存储。但是，语言本身是成熟和稳定的，而且承诺保证向后兼容：用之前的Go语言编写程序可以用新版本的Go语言编译器和标准库直接构建而不需要修改代码。</p><p>​Go语言有足够的类型系统以避免动态语言中那些粗心的类型错误，但是，Go语言的类型系统相比传统的强类型语言又要简洁很多。</p><hr><h1 id="引言-·-让我们从Helloworld开始："><a href="#引言-·-让我们从Helloworld开始：" class="headerlink" title="引言 · 让我们从Helloworld开始："></a><strong>引言 · 让我们从Helloworld开始：</strong></h1><p>首先需要下载GoLang的安装包，解压后配置环境变量：</p><p><code>GOPATH</code>由于是<strong>旧版适用</strong>，所以我们这里不装。</p><p><code>GOROOT</code>是直接在系统变量里新建，路径分别是项目地址和安装地址；</p><p>以及<code>GOPROXY = &quot;https://proxy.golang.com.cn,direct&quot;</code> &amp; <code>GO111MODULE = on</code></p><p>（GOPROXY的地址可能会随时间变化，具体请看<a href="https://goproxy.io/zh/">GOPROXY.IO - 一个全球代理 为 Go 模块而生</a>）</p><p>还有一个需要在Path里添加bin的地址；</p><p>完成了这些之后我们需要明确一个项目的<strong>路径规范</strong>，（适合自己就好）；</p><p>到这里，我们已经基本完成了上述流程。</p><p>不妨运行下面的代码试试看吧？（Terminal）</p><p>（需要在VSC里安装插件：go &amp; run）</p><p>然后要在你的项目路径下打开终端，对于1.11以后的版本需要这样做：</p><p><code>go mod init &lt;filename&gt;</code></p><p>例如我写的就是<code>go mod init test</code></p><p>之后就会生成一个<code>go.mod</code>文件，然后就不需要旧版本的<code>GOPATH</code>来运行了（记得让<code>GO111MODULE = on</code>）。</p><p>（PS：如果是off的话，还是需要配置GOPATH环境变量）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main<span class="comment">//每一个程序文件都要归属于一个包</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span><span class="comment">//引入一个叫fmt为了使用这个包的函数 例如Println()</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Helloworld!&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;落雨乄天珀夜&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过go build命令对该go文件进行编译，生成.exe文件</span></span><br><span class="line"><span class="comment">//例子：go build Helloworld.go</span></span><br><span class="line"><span class="comment">//通过go run命令可以直接运行.go程序，类似于一个脚本文件（速度慢）</span></span><br></pre></td></tr></table></figure><p>如果，我是说如果，环境安装完了以后右下角频频报错说install什么什么，那就开科学上网然后Install ALL然后重启VSC就可以了。</p><p>值得一提的是，我们可以用自动代码补全<code>pkgm</code>&amp;<code>fp</code>等等…</p><p>可以使用终端+<code>code .</code>的方式打开go项目文件夹，这样不会报go.mod的错误。</p><hr><h1 id="初识-·-基础语法篇"><a href="#初识-·-基础语法篇" class="headerlink" title="初识 · 基础语法篇"></a><strong>初识 · 基础语法篇</strong></h1><h2 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x, y <span class="type">int</span> = <span class="number">5</span>, <span class="number">15</span> <span class="comment">//声明全局变量</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">aa <span class="type">int</span>       = <span class="number">10</span></span><br><span class="line">bb <span class="type">complex64</span> = <span class="number">100</span> <span class="comment">//全局变量实际上是允许只声明不使用的</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Helloworld!&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;你好！我的昵称是：&quot;</span> + <span class="string">&quot;落雨乄天珀夜&quot;</span>) <span class="comment">//字符串的拼接</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> id = <span class="number">5201314</span></span><br><span class="line"><span class="keyword">var</span> bir = <span class="string">&quot;1900-01-01&quot;</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="string">&quot;我的学号是:%d， 我的生日是:%s&quot;</span></span><br><span class="line"><span class="keyword">var</span> target_url = fmt.Sprintf(url, id, bir) <span class="comment">//格式化字符串</span></span><br><span class="line">fmt.Println(target_url)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a, b, c <span class="type">int64</span> = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">fmt.Print(<span class="string">&quot;a + b + c = &quot;</span>)</span><br><span class="line">fmt.Println(a + b + c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d <span class="type">int8</span></span><br><span class="line">fmt.Print(<span class="string">&quot;如果不对变量进行初始化，默认为零  d = &quot;</span>)</span><br><span class="line">fmt.Println(d)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ok <span class="type">bool</span> = <span class="literal">true</span></span><br><span class="line">fmt.Print(<span class="string">&quot;ok = &quot;</span>)</span><br><span class="line">fmt.Println(ok)</span><br><span class="line"></span><br><span class="line">tmp_val := <span class="number">114514</span> <span class="comment">//一种简便的变量声明方式</span></span><br><span class="line">fmt.Println(tmp_val)</span><br><span class="line">fmt.Println(&amp;tmp_val) <span class="comment">//引用 可以显示地址</span></span><br><span class="line"></span><br><span class="line">_ = aa <span class="comment">//_实际上是一个只写变量 你不能得到它的值</span></span><br><span class="line">_ = bb</span><br><span class="line">_ = x</span><br><span class="line">_ = y <span class="comment">//把声明但未使用的变量使用掉</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在包一级声明语句声明的名字可在整个包对应的每个源文件中访问，而不是仅仅在其声明语句所在的源文件中访问。相比之下，局部声明的名字就只能在函数内部很小的范围被访问。</p><h2 id="常量-运算符-条件语句与循环"><a href="#常量-运算符-条件语句与循环" class="headerlink" title="常量  运算符  条件语句与循环"></a><strong>常量  运算符  条件语句与循环</strong></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> N <span class="type">int</span> = <span class="number">100010</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;常量N = %d&quot;</span>, N)</span><br><span class="line">fmt.Println()</span><br><span class="line">fmt.Println(<span class="string">&quot;iota是一种特殊的常量，可以认为是一个可以被编译器修改的常量。&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，</span></span><br><span class="line"><span class="comment">//const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">a = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">b        <span class="comment">//1</span></span><br><span class="line">c        <span class="comment">//2</span></span><br><span class="line">d = <span class="string">&quot;ha&quot;</span> <span class="comment">//独立值，iota += 1</span></span><br><span class="line">e        <span class="comment">//&quot;ha&quot;   iota += 1</span></span><br><span class="line">f = <span class="number">100</span>  <span class="comment">//iota +=1</span></span><br><span class="line">g        <span class="comment">//100  iota +=1</span></span><br><span class="line">h = <span class="literal">iota</span> <span class="comment">//7,恢复计数</span></span><br><span class="line">i        <span class="comment">//8</span></span><br><span class="line">)</span><br><span class="line">fmt.Println(a, b, c, d, e, f, g, h, i) <span class="comment">//虽然目前我并不知道这个东西有什么用</span></span><br><span class="line"><span class="comment">//运算符没什么好说的</span></span><br><span class="line"><span class="comment">//+ - * / % ++ -- == != &gt; &lt; &gt;= &lt;= &amp;&amp; || ! &amp; | ^ &lt;&lt; &gt;&gt; = += -= *= /= %= &lt;&lt;= &gt;&gt;= &amp;= ^= |= &amp;p *p</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;条件语句：&quot;</span>)</span><br><span class="line"><span class="comment">//select比较特殊</span></span><br><span class="line"><span class="comment">//select 语句类似于 switch 语句，但是select会随机执行一个可运行的case</span></span><br><span class="line"><span class="comment">//如果没有case可运行，它将阻塞，直到有case可运行。</span></span><br><span class="line">ok := <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;对的对的&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//必须这样写</span></span><br><span class="line">fmt.Println(<span class="string">&quot;不对不对&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;循环语句：&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Print(i, <span class="string">&quot; &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line">numbers := [<span class="number">6</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, x := <span class="keyword">range</span> numbers &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;第 %d 位 x 的值 = %d\n&quot;</span>, i, x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for 循环的 range 格式可以省略 key 和 value</span></span><br><span class="line"><span class="comment">//暂时没有接触到 不做展开</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i, j = j, i <span class="comment">// 交换 i 和 j 的值</span></span><br></pre></td></tr></table></figure><h2 id="函数-数组-指针与结构体"><a href="#函数-数组-指针与结构体" class="headerlink" title="函数  数组  指针与结构体"></a><strong>函数  数组  指针与结构体</strong></h2><h3 id="函数定义："><a href="#函数定义：" class="headerlink" title="函数定义："></a>函数定义：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function_name</span><span class="params">( [parameter list] )</span></span> [return_types] &#123;</span><br><span class="line">   函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数调用："><a href="#函数调用：" class="headerlink" title="函数调用："></a>函数调用：</h3><p>和C一样，略；</p><h3 id="函数返回多个值："><a href="#函数返回多个值：" class="headerlink" title="函数返回多个值："></a>函数返回多个值：</h3><p> Go的特性；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">string</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a, b := swap(<span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Runoob&quot;</span>)</span><br><span class="line">   fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数参数："><a href="#函数参数：" class="headerlink" title="函数参数："></a>函数参数：</h3><p>基本概念：函数如果使用参数，该变量可称为函数的形参；形参就像定义在函数体内的局部变量。</p><p>也分为值传递和引用传递两种，但其实默认使用和使用更多的是值传递（貌似）；</p><h3 id="函数用法："><a href="#函数用法：" class="headerlink" title="函数用法："></a>函数用法：</h3><p>有闭包等神奇的用法，等到用到的时候再写；</p><hr><h3 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h3><p>数组的声明如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> variable_name [SIZE] variable_type</span><br></pre></td></tr></table></figure><p>实例1：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>]<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; i++ &#123;</span><br><span class="line">a[i] = i</span><br><span class="line">fmt.Println(a[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例2：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr := [...]<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>&#125;</span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; i++ &#123;</span><br><span class="line">fmt.Println(arr[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多维数组："><a href="#多维数组：" class="headerlink" title="多维数组："></a>多维数组：</h3><p>其实和其他语言很类似…</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> variable_name [SIZE1][SIZE2]...[SIZEN] variable_type</span><br></pre></td></tr></table></figure><hr><h3 id="Go指针："><a href="#Go指针：" class="headerlink" title="Go指针："></a>Go指针：</h3><p>变量的地址：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="number">1</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;The address of &#x27;a&#x27; is: %x\n&quot;</span>, &amp;a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个指针变量指向了一个值的内存地址；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> var_name *<span class="keyword">var</span>-<span class="keyword">type</span></span><br></pre></td></tr></table></figure><p>指针使用实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> it *<span class="type">int</span></span><br><span class="line">it = &amp;a</span><br><span class="line">fmt.Println(it)</span><br><span class="line">fmt.Println(*it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺带一提，如果不给指针变量赋值，其值为<code>nil</code>，大小为0；</p><p>可以通过语句来判断一个指针是值为0还是是空指针：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ptr != <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><hr><h3 id="Go语言结构体："><a href="#Go语言结构体：" class="headerlink" title="Go语言结构体："></a>Go语言结构体：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> struct_variable_type <span class="keyword">struct</span> &#123;</span><br><span class="line">   member definition</span><br><span class="line">   member definition</span><br><span class="line">   ...</span><br><span class="line">   member definition</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个简单的实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">name  <span class="type">string</span></span><br><span class="line">ID    <span class="type">string</span></span><br><span class="line">score <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新的结构体</span></span><br><span class="line">fmt.Println(Student&#123;<span class="string">&quot;Lihua&quot;</span>, <span class="string">&quot;110&quot;</span>, <span class="string">&quot;59&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以使用 key =&gt; value 格式</span></span><br><span class="line">fmt.Println(Student&#123;name: <span class="string">&quot;XiaoLihua&quot;</span>, ID: <span class="string">&quot;250&quot;</span>, score: <span class="string">&quot;99&quot;</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="切片Slice"><a href="#切片Slice" class="headerlink" title="切片Slice"></a><strong>切片Slice</strong></h2><h3 id="定义切片："><a href="#定义切片：" class="headerlink" title="定义切片："></a>定义切片：</h3><p>切片实质上就是一个变长数组；</p><p>声明一个未指定大小的数组来定义切片：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> identifier []<span class="keyword">type</span></span><br></pre></td></tr></table></figure><p>或者使用make()函数来创建切片：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice1 []<span class="keyword">type</span> = <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br><span class="line"><span class="comment">//也可以简写为</span></span><br><span class="line">slice1 := <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br></pre></td></tr></table></figure><p>当然，必要时也可以指定容量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T, length, capacity)</span><br></pre></td></tr></table></figure><h3 id="len-和cap-函数："><a href="#len-和cap-函数：" class="headerlink" title="len()和cap()函数："></a>len()和cap()函数：</h3><p>应用实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> numbers = <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">   printSlice(numbers)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="空-nil-切片："><a href="#空-nil-切片：" class="headerlink" title="空(nil)切片："></a>空(nil)切片：</h3><p>一个切片在未初始化之前默认为 nil，长度为 0，实例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> numbers []<span class="type">int</span></span><br><span class="line"></span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(numbers == <span class="literal">nil</span>)&#123;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;切片是空的&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="切片截取："><a href="#切片截取：" class="headerlink" title="切片截取："></a>切片截取：</h3><p>demo：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;len = %d cap = %d slice = %v\n&quot;</span>, <span class="built_in">len</span>(x), <span class="built_in">cap</span>(x), x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//Create the slice</span></span><br><span class="line">num := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line">printSlice(num)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Print the original slice</span></span><br><span class="line">fmt.Println(<span class="string">&quot;num = &quot;</span>, num)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Print sub_slice from idx1(include) to idx4(not include)</span></span><br><span class="line">fmt.Println(<span class="string">&quot;num[1:4] == &quot;</span>, num[<span class="number">1</span>:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">//If the r_index is not defined, it will be 0 and len(s), just like:</span></span><br><span class="line">fmt.Println(<span class="string">&quot;num[:3] == &quot;</span>, num[:<span class="number">3</span>])</span><br><span class="line">fmt.Println(<span class="string">&quot;num[4:] == &quot;</span>, num[<span class="number">4</span>:])</span><br><span class="line"></span><br><span class="line">num1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">printSlice(num1)</span><br><span class="line"></span><br><span class="line">num2 := num[:<span class="number">2</span>]</span><br><span class="line">printSlice(num2)</span><br><span class="line"></span><br><span class="line">num3 := num[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">printSlice(num3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="append-和copy-函数："><a href="#append-和copy-函数：" class="headerlink" title="append()和copy()函数："></a>append()和copy()函数：</h3><p>demo：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;len = %d cap = %d slice = %v\n&quot;</span>, <span class="built_in">len</span>(x), <span class="built_in">cap</span>(x), x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> num []<span class="type">int</span></span><br><span class="line">printSlice(num)</span><br><span class="line"></span><br><span class="line">num = <span class="built_in">append</span>(num, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">printSlice(num)</span><br><span class="line"></span><br><span class="line">num1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(num), (<span class="built_in">cap</span>(num))*<span class="number">2</span>)</span><br><span class="line"><span class="built_in">copy</span>(num1, num)</span><br><span class="line">printSlice(num1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="范围Range"><a href="#范围Range" class="headerlink" title="范围Range"></a><strong>范围Range</strong></h2><p>range 关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。在数组和切片中它返回元素的索引和索引对应的值，在集合中返回 key-value 对。</p><p>实际上也可以省略，这里先不省略；</p><p>demo：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num1 = [...]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//num2 := [9]int&#123;9, 8, 7, 6, 5, 4, 3, 2, 1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i, val := <span class="keyword">range</span> num1 &#123;</span><br><span class="line">fmt.Println(i, <span class="string">&quot; &quot;</span>, val)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">8</span>; i++ &#123;</span><br><span class="line">fmt.Print(num1[i], <span class="string">&quot; &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="集合Map"><a href="#集合Map" class="headerlink" title="集合Map"></a><strong>集合Map</strong></h2><p>Map 是一种<strong>无序</strong>的键值对的集合。Map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。</p><p>Map 是一种集合，所以我们可以像迭代数组和切片那样迭代它。不过，Map 是无序的，我们无法决定它的返回顺序，这是因为 Map 是使用 hash 表来实现的。</p><h3 id="定义Map："><a href="#定义Map：" class="headerlink" title="定义Map："></a>定义Map：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map_variable := <span class="built_in">make</span>(<span class="keyword">map</span>[key_data_type]value_data_type)<span class="comment">//init</span></span><br></pre></td></tr></table></figure><p>demo：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> StudentNumber <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span></span><br><span class="line">StudentNumber = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">StudentNumber[<span class="number">1</span>] = <span class="string">&quot;小明&quot;</span></span><br><span class="line">StudentNumber[<span class="number">2</span>] = <span class="string">&quot;草泥马&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> num := <span class="keyword">range</span> StudentNumber &#123;</span><br><span class="line">fmt.Println(StudentNumber[num], <span class="string">&quot;的学号是&quot;</span>, num)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="delete-函数："><a href="#delete-函数：" class="headerlink" title="delete()函数："></a>delete()函数：</h3><p>注意，删除的是key，而不是value（其实也很好理解）</p><p>demo：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//var StudentNumber map[int]string</span></span><br><span class="line">StudentNumber := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">StudentNumber[<span class="number">1</span>] = <span class="string">&quot;小明&quot;</span></span><br><span class="line">StudentNumber[<span class="number">2</span>] = <span class="string">&quot;草泥马&quot;</span></span><br><span class="line">StudentNumber[<span class="number">3</span>] = <span class="string">&quot;仙人&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> num := <span class="keyword">range</span> StudentNumber &#123;</span><br><span class="line">fmt.Println(StudentNumber[num], <span class="string">&quot;的学号是&quot;</span>, num)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;---------------------------------------&quot;</span>)</span><br><span class="line"><span class="built_in">delete</span>(StudentNumber, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> num := <span class="keyword">range</span> StudentNumber &#123;</span><br><span class="line">fmt.Println(StudentNumber[num], <span class="string">&quot;的学号是&quot;</span>, num)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="类型转换与接口"><a href="#类型转换与接口" class="headerlink" title="类型转换与接口"></a><strong>类型转换与接口</strong></h2><h3 id="类型转换："><a href="#类型转换：" class="headerlink" title="类型转换："></a>类型转换：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum <span class="type">int</span> = <span class="number">13</span></span><br><span class="line">    <span class="keyword">var</span> cnt <span class="type">int</span> = <span class="number">5</span></span><br><span class="line">    <span class="keyword">var</span> ans <span class="type">float32</span></span><br><span class="line">    </span><br><span class="line">    ans = <span class="type">float32</span>(sum) / <span class="type">float32</span>(cnt)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;ans = %f\n&quot;</span>, cnt)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口："><a href="#接口：" class="headerlink" title="接口："></a>接口：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">interface</span> &#123; <span class="comment">//定义接口</span></span><br><span class="line">call()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NokiaPhone <span class="keyword">struct</span> &#123; <span class="comment">//定义结构体</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IPhone <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nokia1 NokiaPhone)</span></span> call() &#123; <span class="comment">//实现接口方法</span></span><br><span class="line">fmt.Println(<span class="string">&quot;I am NOKIA god, I will punish you!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(iphone1 IPhone)</span></span> call() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;I am APPLE god, I will punish you!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> phone Phone</span><br><span class="line">phone = <span class="built_in">new</span>(NokiaPhone)</span><br><span class="line">phone.call()</span><br><span class="line"></span><br><span class="line">phone = <span class="built_in">new</span>(IPhone)</span><br><span class="line">phone.call()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="错误处理与大并发"><a href="#错误处理与大并发" class="headerlink" title="错误处理与大并发"></a><strong>错误处理与大并发</strong></h2><h3 id="错误处理："><a href="#错误处理：" class="headerlink" title="错误处理："></a>错误处理：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个 DivideError 结构</span></span><br><span class="line"><span class="keyword">type</span> DivideError <span class="keyword">struct</span> &#123;</span><br><span class="line">dividee <span class="type">int</span></span><br><span class="line">divider <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 `error` 接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(de *DivideError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">strFormat := <span class="string">`</span></span><br><span class="line"><span class="string">    Cannot proceed, the divider is zero.</span></span><br><span class="line"><span class="string">    dividee: %d</span></span><br><span class="line"><span class="string">    divider: 0</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(strFormat, de.dividee)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 `int` 类型除法运算的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Divide</span><span class="params">(varDividee <span class="type">int</span>, varDivider <span class="type">int</span>)</span></span> (result <span class="type">int</span>, errorMsg <span class="type">string</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> varDivider == <span class="number">0</span> &#123;</span><br><span class="line">dData := DivideError&#123;</span><br><span class="line">dividee: varDividee,</span><br><span class="line">divider: varDivider,</span><br><span class="line">&#125;</span><br><span class="line">errorMsg = dData.Error()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> varDividee / varDivider, <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常情况</span></span><br><span class="line"><span class="keyword">if</span> result, errorMsg := Divide(<span class="number">100</span>, <span class="number">10</span>); errorMsg == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;100/10 = &quot;</span>, result)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当除数为零的时候会返回错误信息</span></span><br><span class="line"><span class="keyword">if</span> _, errorMsg := Divide(<span class="number">100</span>, <span class="number">0</span>); errorMsg != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;errorMsg is: &quot;</span>, errorMsg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并发初步："><a href="#并发初步：" class="headerlink" title="并发初步："></a>并发初步：</h3><p>通过go关键字来开启goroutine;</p><p>goroutine是一个<strong>轻量级线程</strong>，其调度是由Golang运行时进行管理的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(str <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">fmt.Println(str)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> say(<span class="string">&quot;World&quot;</span>)</span><br><span class="line">say(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此，就会无序交替输出<code>World</code>以及 <code>Hello</code>；</p><h3 id="通道-channel-："><a href="#通道-channel-：" class="headerlink" title="通道(channel)："></a>通道(channel)：</h3><p>通道是用来传递数据的一个<strong>数据结构</strong>，可以用于两个goroutine之间，通过传递一个指定类型的值来同步运行和通讯。</p><p>操作符<code>&lt;-</code>用于指定通道的<strong>方向</strong>，实现发送or接收；</p><p>特别地，若未指定方向，则为<strong>双向通道</strong>；</p><p>通道在使用前必须先创建；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- v    <span class="comment">// 把 v 发送到通道 ch</span></span><br><span class="line">v := &lt;-ch  <span class="comment">// 从 ch 接收数据   并把值赋给 v</span></span><br></pre></td></tr></table></figure><p>通道使用实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(s []<span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">sum += v</span><br><span class="line">&#125;</span><br><span class="line">c &lt;- sum <span class="comment">//将sum发送到通道c</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) <span class="comment">//声明通道</span></span><br><span class="line"><span class="keyword">go</span> sum(s[:<span class="built_in">len</span>(s)/<span class="number">2</span>], c)</span><br><span class="line"><span class="keyword">go</span> sum(s[<span class="built_in">len</span>(s)/<span class="number">2</span>:], c)</span><br><span class="line">x, y := &lt;-c, &lt;-c <span class="comment">//从通道c中接收</span></span><br><span class="line">fmt.Println(x, y, x+y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通道缓冲区："><a href="#通道缓冲区：" class="headerlink" title="通道缓冲区："></a>通道缓冲区：</h3><p>在用make声明通道的时候可以通过添加第二个参数来指定<strong>缓冲区的大小</strong>；</p><p><em>如果通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。**——runoob</em></p><p>缓冲区应用实例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 这里我们定义了一个可以存储整数类型的带缓冲通道</span></span><br><span class="line"><span class="comment">// 缓冲区大小为2</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为 ch 是带缓冲的通道，我们可以同时发送两个数据</span></span><br><span class="line"><span class="comment">// 而不用立刻需要去同步读取数据</span></span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">ch &lt;- <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取这两个数据</span></span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Go-遍历通道与关闭通道"><a href="#Go-遍历通道与关闭通道" class="headerlink" title="Go 遍历通道与关闭通道"></a>Go 遍历通道与关闭通道</h3><p>通过 range 关键字来实现遍历读取到的数据；</p><p>样例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">c &lt;- x</span><br><span class="line">x, y = y, x+y</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line"><span class="comment">// range 函数遍历每个从通道接收到的数据，因为 c 在发送完 10 个</span></span><br><span class="line"><span class="comment">// 数据之后就关闭了通道，所以这里我们 range 函数在接收到 10 个数据</span></span><br><span class="line"><span class="comment">// 之后就结束了。如果上面的 c 通道不关闭，那么 range 函数就不</span></span><br><span class="line"><span class="comment">// 会结束，从而在接收第 11 个数据的时候就阻塞了。</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="前进-·-并发深入与内置函数："><a href="#前进-·-并发深入与内置函数：" class="headerlink" title="前进 · 并发深入与内置函数："></a><strong>前进 · 并发深入与内置函数：</strong></h1><h2 id="内置函数："><a href="#内置函数：" class="headerlink" title="内置函数："></a>内置函数：</h2><h3 id="计时器："><a href="#计时器：" class="headerlink" title="计时器："></a>计时器：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">startTime := time.Now()</span><br><span class="line">...</span><br><span class="line">elapsedTime := time.Since(startTime)</span><br><span class="line">fmt.Println(<span class="string">&quot;time pass: &quot;</span>, elapsedTime)</span><br></pre></td></tr></table></figure><p>另一种：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StartTime := time.Now().UnixNano()</span><br><span class="line">...</span><br><span class="line">EndTime := time.Now().UnixNano()</span><br><span class="line">NanoSecond := <span class="type">float64</span>(Endtime - Starttime)</span><br><span class="line">fmt.Println(NanoSecond)</span><br></pre></td></tr></table></figure><hr><h3 id="defer语句："><a href="#defer语句：" class="headerlink" title="defer语句："></a>defer语句：</h3><p>加上defer之后就会进入一个栈内，如下程序输出结果就是333 222 111</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;111&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;222&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;333&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="init函数："><a href="#init函数：" class="headerlink" title="init函数："></a>init函数：</h3><p>程序初始化顺序：<code>变量初始化</code> -&gt; <code>init()</code> -&gt; <code>main()</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v <span class="type">int</span> = VarInit()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;INITIALIZE!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">VarInit</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;The initialize of var is completed!&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">110</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;111&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;222&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;333&quot;</span>)</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="并发的深入："><a href="#并发的深入：" class="headerlink" title="并发的深入："></a>并发的深入：</h2><h3 id="再遇channel："><a href="#再遇channel：" class="headerlink" title="再遇channel："></a>再遇channel：</h3><h4 id="channel的遍历（多方法）"><a href="#channel的遍历（多方法）" class="headerlink" title="channel的遍历（多方法）"></a>channel的遍历（多方法）</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法1：for循环 + if判断</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">//通过go命令发起的轻量级线程的匿名函数</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">c &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> data, ok := &lt;-c; ok &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;data: %v\n&quot;</span>, data)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2：for + range</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">//通过go命令发起的轻量级线程的匿名函数</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">c &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> data := <span class="keyword">range</span> c &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;data: %v\n&quot;</span>, data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得一提的是，如果没有<code>close(c)</code>来关闭通道，则会出现死锁输出：</p><p><code>fatal error: all goroutines are asleep - deadlock!</code></p><hr><h3 id="WaitGroup实现同步："><a href="#WaitGroup实现同步：" class="headerlink" title="WaitGroup实现同步："></a>WaitGroup实现同步：</h3><p>同步的含义：两个或多个协程之间互相等待，而不是顺次执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ECHO</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">fmt.Println(<span class="string">&quot;VOICE_ECHO&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> ECHO(i)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="runtime包："><a href="#runtime包：" class="headerlink" title="runtime包："></a>runtime包：</h3><p>runtime包里面定义了一些携程管理相关的API</p><h3 id="runtime-Gosched"><a href="#runtime-Gosched" class="headerlink" title="runtime.Gosched()"></a>runtime.Gosched()</h3><p><strong>高风亮节</strong>地让出CPU时间片，重新等待安排任务；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i &gt;= <span class="number">5</span> &#123;</span><br><span class="line">runtime.Goexit()</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;i: %v\n&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;I am the function show()&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> show()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="runtime-Goexit"><a href="#runtime-Goexit" class="headerlink" title="runtime.Goexit()"></a>runtime.Goexit()</h4><p>可以退出当前协程，目前还不知道有什么特别好的用处…</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i &gt;= <span class="number">5</span> &#123;</span><br><span class="line">runtime.Goexit()</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;i: %v\n&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;I am the function show()&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> show()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="runtime-GOMAXPROCS"><a href="#runtime-GOMAXPROCS" class="headerlink" title="runtime.GOMAXPROCS"></a>runtime.GOMAXPROCS</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;a: %v  &quot;</span>, i)</span><br><span class="line"><span class="comment">//当然 如果在每一次输出之后都sleep一小会儿，即使使用单核也会交替输出</span></span><br><span class="line"><span class="comment">//time.Sleep(time.Millisecond * 100)</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;b: %v  &quot;</span>, i)</span><br><span class="line"><span class="comment">//time.Sleep(time.Millisecond * 100)</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;runtime.NumCPU() = &quot;</span>, runtime.NumCPU())</span><br><span class="line"><span class="comment">//runtime.GOMAXPROCS(1)</span></span><br><span class="line"><span class="keyword">go</span> a()</span><br><span class="line"><span class="keyword">go</span> b()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Mutex互斥锁实现同步："><a href="#Mutex互斥锁实现同步：" class="headerlink" title="Mutex互斥锁实现同步："></a>Mutex互斥锁实现同步：</h3><p>除了使用channel实现同步之外，还可以使用Mutex互斥锁来实现同步。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m <span class="type">int</span> = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lock sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wt sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Addfunc</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wt.Done()</span><br><span class="line">lock.Lock()</span><br><span class="line">m += <span class="number">1</span></span><br><span class="line">time.Sleep(time.Millisecond * <span class="number">10</span>)</span><br><span class="line">lock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Subfunc</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wt.Done()</span><br><span class="line">lock.Lock()</span><br><span class="line">time.Sleep(time.Millisecond * <span class="number">2</span>)</span><br><span class="line">m -= <span class="number">1</span></span><br><span class="line">lock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">wt.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> Addfunc()</span><br><span class="line">wt.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> Subfunc()</span><br><span class="line"><span class="keyword">if</span> i%<span class="number">1000</span> == <span class="number">0</span> &#123;</span><br><span class="line">fmt.Println(m)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//wt.Wait()</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;End val: &quot;</span>, m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到两个进程同时交替进行，输出结果有来有回。</p><hr><h3 id="select："><a href="#select：" class="headerlink" title="select："></a>select：</h3><p>select是Go中的一个控制结构，类似于switch的功能，用于处理<em>异步IO操作</em>；</p><p>select会监听case语句中channel的读写操作；</p><p>当case中channel读写操作为非阻塞状态时，则会触发相应动作。</p><p>特别说明：</p><p><code>select中的case语句必须是一个channel操作</code></p><p><code>select中的default子句总是可运行的</code></p><p><code>如果有多个case都可运行，select会随机公平地选出一个执行</code></p><p><code>如果没有可运行的case语句，但是有default语句，则会直接执行default语句</code></p><p><code>如果没有可运行的case语句，并且没有default语句，则select会阻塞直至某个case可以运行</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> chanInt = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">var</span> chanStr = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">chanInt &lt;- <span class="number">100</span></span><br><span class="line">chanStr &lt;- <span class="string">&quot;MAGA&quot;</span></span><br><span class="line"><span class="built_in">close</span>(chanInt)</span><br><span class="line"><span class="built_in">close</span>(chanStr)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> r := &lt;-chanInt:</span><br><span class="line">fmt.Printf(<span class="string">&quot;chanInt: %v\n&quot;</span>, r)</span><br><span class="line"><span class="keyword">case</span> r := &lt;-chanStr:</span><br><span class="line">fmt.Printf(<span class="string">&quot;chanStr: %v\n&quot;</span>, r)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;DEFAULT!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Timer："><a href="#Timer：" class="headerlink" title="Timer："></a>Timer：</h3><p>定时器，内部通过channel实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">timer1 := time.NewTimer(time.Second * <span class="number">2</span>)</span><br><span class="line">t1 := time.Now()</span><br><span class="line">fmt.Printf(<span class="string">&quot;t1: %v\n&quot;</span>, t1) <span class="comment">//看看当前的时间</span></span><br><span class="line"></span><br><span class="line">t2 := &lt;-timer1.C <span class="comment">//这个C是管道的意思</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;t2: %v\n&quot;</span>, t2)</span><br><span class="line"></span><br><span class="line">&lt;-time.After(time.Second * <span class="number">1</span>) <span class="comment">//time.After的返回值是chan Time</span></span><br><span class="line">fmt.Println(<span class="string">&quot;时间流逝了一会儿...&quot;</span>)</span><br><span class="line"></span><br><span class="line">timer2 := time.NewTimer(time.Second)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">&lt;-timer2.C</span><br><span class="line">fmt.Println(<span class="string">&quot;This is timer2&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">stop := timer2.Stop() <span class="comment">//停止定时器</span></span><br><span class="line"><span class="comment">//阻止timer事件发生，当该函数执行后，timer计时器停止，相应的事件不再执行</span></span><br><span class="line"><span class="keyword">if</span> stop &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Timer is stopped!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;&gt;&gt;&gt;BEFORE&quot;</span>)</span><br><span class="line">timer3 := time.NewTimer(time.Second * <span class="number">5</span>)</span><br><span class="line">timer3.Reset(time.Second * <span class="number">1</span>)</span><br><span class="line">&lt;-timer3.C</span><br><span class="line">fmt.Println(<span class="string">&quot;AFTER&lt;&lt;&lt;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Ticket："><a href="#Ticket：" class="headerlink" title="Ticket："></a>Ticket：</h3><p>Timer只执行一次，Ticker可以周期地执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ticker := time.NewTicker(time.Second)</span><br><span class="line">counter := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> _ = <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;ticker 1&quot;</span>)</span><br><span class="line">counter++</span><br><span class="line"><span class="keyword">if</span> counter &gt;= <span class="number">5</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ticker.Stop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">chanInt := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">ticker := time.NewTicker(time.Second)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _ = <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> chanInt &lt;- <span class="number">1</span>:</span><br><span class="line"><span class="keyword">case</span> chanInt &lt;- <span class="number">2</span>:</span><br><span class="line"><span class="keyword">case</span> chanInt &lt;- <span class="number">3</span>:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> chanInt &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Receive: %v\n&quot;</span>, v)</span><br><span class="line">sum += v</span><br><span class="line"><span class="keyword">if</span> sum &gt;= <span class="number">10</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;sum: %v\n&quot;</span>, sum)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="原子变量与原子操作："><a href="#原子变量与原子操作：" class="headerlink" title="原子变量与原子操作："></a>原子变量与原子操作：</h3><p>一个简单的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x <span class="type">int32</span> = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//atomic内部是一个compare ans swap, 简称cas, 会在加减操作之前先比较old new两个值再进行操作</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f_add</span><span class="params">()</span></span> &#123;</span><br><span class="line">atomic.AddInt32(&amp;x, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f_sub</span><span class="params">()</span></span> &#123;</span><br><span class="line">atomic.AddInt32(&amp;x, <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">f_add()</span><br><span class="line">f_sub()</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;x: %v\n&quot;</span>, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>atomic提供的原子操作能够确保任意时刻只有一个goroutine对变量进行操作，</p><p>善用atomic能够避免程序中出现大量的锁操作。</p><p>atomic的常见操作：</p><ul><li>增减</li><li>载入 read</li><li>cas</li><li>交换</li><li>存储 write</li></ul><hr><h1 id="探索-·-GoLang标准库"><a href="#探索-·-GoLang标准库" class="headerlink" title="探索 · GoLang标准库"></a><strong>探索 · GoLang标准库</strong></h1><p>可以参考：<a href="https://pkg.go.dev/std">https://pkg.go.dev/std</a></p><h2 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a>os模块</h2><p>os标准库实现了平台（操作系统）无关的编程接口。</p><h3 id="文件目录相关"><a href="#文件目录相关" class="headerlink" title="文件目录相关"></a>文件目录相关</h3><p>demo1：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateFile</span><span class="params">()</span></span> &#123;</span><br><span class="line">f, err0 := os.Create(<span class="string">&quot;CreateFileTest.txt&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err0 != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;err: &quot;</span>, err0)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;f: &quot;</span>, f)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//值得一提的是，如果同名文件已经存在，则此操作会进行覆盖</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeDir</span><span class="params">()</span></span> &#123;</span><br><span class="line">err1 := os.Mkdir(<span class="string">&quot;MakeDirTest&quot;</span>, os.ModePerm)</span><br><span class="line"><span class="keyword">if</span> err1 != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;err1: %v\n&quot;</span>, err1)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RemoveDir</span><span class="params">()</span></span> &#123;</span><br><span class="line">err2 := os.RemoveAll(<span class="string">&quot;MakeDirTest&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err2 != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;err2: %v\n&quot;</span>, err2)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetWorkDir</span><span class="params">()</span></span> &#123;</span><br><span class="line">dir, err3 := os.Getwd()</span><br><span class="line"><span class="keyword">if</span> err3 != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;err3: %v\n&quot;</span>, err3)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;dir: %v\n&quot;</span>, dir)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ChangeWorkDir</span><span class="params">()</span></span> &#123;</span><br><span class="line">err4 := os.Chdir(<span class="string">&quot;D:/Coding/Git&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err4 != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;err4: %v\n&quot;</span>, err4)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(os.Getwd())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetTempDir</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := os.TempDir()</span><br><span class="line">fmt.Printf(<span class="string">&quot;s: %v\n&quot;</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RenameFile</span><span class="params">()</span></span> &#123;</span><br><span class="line">err5 := os.Rename(<span class="string">&quot;CreateFileTest.txt&quot;</span>, <span class="string">&quot;RenameTest.txt&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err5 != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;err5: %v\n&quot;</span>, err5)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">()</span></span> &#123;</span><br><span class="line">str, err6 := os.ReadFile(<span class="string">&quot;IO.txt&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err6 != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;err6: %v\n&quot;</span>, err6)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;string(str[:]):\n%v\n&quot;</span>, <span class="type">string</span>(str[:])) <span class="comment">//获取了一个切片</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteFile</span><span class="params">()</span></span> &#123;</span><br><span class="line">str1 := <span class="string">&quot;YOUR MAMA BOOM!&quot;</span></span><br><span class="line">os.WriteFile(<span class="string">&quot;IO.txt&quot;</span>, []<span class="type">byte</span>(str1), os.ModePerm)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//CreateFile()</span></span><br><span class="line"><span class="comment">//MakeDir()</span></span><br><span class="line"><span class="comment">//RemoveDir()</span></span><br><span class="line"><span class="comment">//GetWorkDir()</span></span><br><span class="line"><span class="comment">//GetTempDir()</span></span><br><span class="line"><span class="comment">//RenameFile()</span></span><br><span class="line"><span class="comment">//ReadFile()</span></span><br><span class="line"><span class="comment">//WriteFile()</span></span><br><span class="line"><span class="comment">//ReadFile()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demo2：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenCloseFile</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//Only read</span></span><br><span class="line">f1, err1 := os.Open(<span class="string">&quot;IO.txt&quot;</span>) <span class="comment">//err如果写成_的意思是不做处理</span></span><br><span class="line"><span class="keyword">if</span> err1 != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;err1: %v\n&quot;</span>, err1)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;f1.Name(): %v\n&quot;</span>, f1.Name())</span><br><span class="line">f1.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//还有一种更加高级且更直接的打开文件的方式，并且根据第二个参数 可以读写or创建，权限设置与Linux相同</span></span><br><span class="line">f2, err2 := os.OpenFile(<span class="string">&quot;IO1.txt&quot;</span>, os.O_RDWR|os.O_CREATE, <span class="number">0755</span>) <span class="comment">//可读可写，没有就创建一个，0755的权限设置</span></span><br><span class="line"><span class="keyword">if</span> err2 != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;err2: %v\n&quot;</span>, err2)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;f2.Name(): %v\n&quot;</span>, f2.Name())</span><br><span class="line">f2.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateFile</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 等价于OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, 0666)</span></span><br><span class="line">f1, err1 := os.Create(<span class="string">&quot;CreateFileTest.txt&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err1 != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;err1: %v\n&quot;</span>, err1)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;f1.Name(): %v\n&quot;</span>, f1.Name())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第1个参数 目录默认：Temp 第2个参数 文件名前缀</span></span><br><span class="line">f2, err2 := os.CreateTemp(<span class="string">&quot;&quot;</span>, <span class="string">&quot;Temp&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err2 != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;err2: %v\n&quot;</span>, err2)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;f2.Name(): %v\n&quot;</span>, f2.Name())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadOps</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//由于我们多数情况下并不知道要读的文件有多大，所以防止读取不全的情况发生，采用循环读取的方法</span></span><br><span class="line">f, _ := os.Open(<span class="string">&quot;IO.txt&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">10</span>) <span class="comment">//缓冲区的创建</span></span><br><span class="line">n, err := f.Read(buf)</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;n: %v\n&quot;</span>, n)</span><br><span class="line">fmt.Printf(<span class="string">&quot;string(buf): %v\n&quot;</span>, <span class="type">string</span>(buf))</span><br><span class="line">&#125;</span><br><span class="line">f.Close()</span><br><span class="line"></span><br><span class="line">f1, _ := os.Open(<span class="string">&quot;IO.txt&quot;</span>)</span><br><span class="line">buf1 := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">5</span>)</span><br><span class="line">n1, _ := f1.ReadAt(buf1, <span class="number">2</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;\n--------------------------------&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;n1: %v\n&quot;</span>, n1)</span><br><span class="line">fmt.Printf(<span class="string">&quot;string(buf1): %v\n&quot;</span>, <span class="type">string</span>(buf1))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Read_Dir</span><span class="params">()</span></span> &#123;</span><br><span class="line">de, _ := os.ReadDir(<span class="string">&quot;pkg&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> de &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;v.IsDir(): %v\n&quot;</span>, v.IsDir())</span><br><span class="line">fmt.Printf(<span class="string">&quot;v.Name(): %v\n&quot;</span>, v.Name())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Locate</span><span class="params">()</span></span> &#123;</span><br><span class="line">f, _ := os.Open(<span class="string">&quot;IO.txt&quot;</span>)</span><br><span class="line">f.Seek(<span class="number">4</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">//Seek设置下一次读/写的位置。</span></span><br><span class="line"><span class="comment">//offset为相对偏移量，而whence决定相对位置：0为相对文件开头，1为相对当前位置，2为相对文件结尾。</span></span><br><span class="line"><span class="comment">//它返回新的偏移量（相对开头）和可能的错误。</span></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">10</span>)</span><br><span class="line">n, _ := f.Read(buf)</span><br><span class="line">fmt.Printf(<span class="string">&quot;n: %v\n&quot;</span>, n)</span><br><span class="line">fmt.Printf(<span class="string">&quot;string(buf): %v\n&quot;</span>, <span class="type">string</span>(buf))</span><br><span class="line">f.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//OpenCloseFile()</span></span><br><span class="line"><span class="comment">//CreateFile()</span></span><br><span class="line"><span class="comment">//ReadOps()</span></span><br><span class="line"><span class="comment">//Read_Dir()</span></span><br><span class="line">Locate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="io包"><a href="#io包" class="headerlink" title="io包"></a>io包</h2><hr><h2 id="ioutil包"><a href="#ioutil包" class="headerlink" title="ioutil包"></a>ioutil包</h2><hr><h2 id="bufio"><a href="#bufio" class="headerlink" title="bufio"></a>bufio</h2><hr><h2 id="log"><a href="#log" class="headerlink" title="log"></a>log</h2><hr><h2 id="builtin"><a href="#builtin" class="headerlink" title="builtin"></a>builtin</h2><hr><h2 id="bytes"><a href="#bytes" class="headerlink" title="bytes"></a>bytes</h2><hr><h2 id="errors"><a href="#errors" class="headerlink" title="errors"></a>errors</h2><hr><h2 id="sort包"><a href="#sort包" class="headerlink" title="sort包"></a>sort包</h2><hr><h2 id="time"><a href="#time" class="headerlink" title="time"></a>time</h2><hr><h2 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h2><hr><h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><hr><h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a><strong>HTTP协议</strong></h1><p>超文本传输协议(Hyper Text Transfer Protocol)是一种用于分布式、协作式和超媒体信息系统的<strong>应用层协议</strong>。HTTP是万维网的数据通信的基础。它是基于<strong>TCP协议</strong>的应用层传输协议，简单来说就是客户端和服务端进行<strong>数据传输</strong>的一种规则。</p><p>详细内容可以参考：<a href="https://zhuanlan.zhihu.com/p/45173862">深入理解HTTP协议 - 知乎 (zhihu.com)</a></p><h2 id="HTTP协议概述"><a href="#HTTP协议概述" class="headerlink" title="HTTP协议概述"></a>HTTP协议概述</h2><p><code>HTTP</code> 是一种<strong>无状态</strong> (stateless) 协议, <code>HTTP</code>协议本身<em>不会对发送过的请求和相应的通信状态进行持久化处理</em>。</p><p>这样做的目的是为了保持HTTP协议的<strong>简单性</strong>，从而能够快速处理大量的事务, 提高效率。</p><p>然而，在许多应用场景中，我们需要保持用户登录的状态或记录用户购物车中的商品。</p><p>由于<code>HTTP</code>是无状态协议，所以必须引入一些技术来记录管理状态，例如<code>Cookie</code>。</p><h2 id="HTTP工作原理"><a href="#HTTP工作原理" class="headerlink" title="HTTP工作原理"></a>HTTP工作原理</h2><p>请求request - 响应response</p><p>HTTP请求由<strong>请求行</strong>，<strong>消息报头</strong>，<strong>请求正文</strong>三部分构成。</p><p>​其中，<strong>请求行</strong>由请求<code>Method</code>, <code>URL</code> 字段和<code>HTTP Version</code>三部分构成, 总的来说请求行就是定义了本次请求的请求方式, 请求的地址, 以及所遵循的HTTP协议版本例如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /example.html HTTP/1.1 (CRLF)</span><br></pre></td></tr></table></figure><h3 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h3><h3 id="无连接"><a href="#无连接" class="headerlink" title="无连接"></a>无连接</h3><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><h2 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h2><p>HTTP协议的方法有： </p><ul><li><code>GET</code>： 请求<strong>获取</strong>Request-URI所标识的资源</li><li><code>POST</code>： 在Request-URI所标识的资源后<strong>增加</strong>新的数据 </li><li><code>HEAD</code>： 请求获取由Request-URI所标识的资源的<strong>响应消息报头</strong></li><li><code>PUT</code>： 请求服务器<strong>存储或修改</strong>一个资源，并用Request-URI作为其标识</li><li><code>DELETE</code>： 请求服务器<strong>删除</strong>Request-URI所标识的资源</li><li><code>TRACE</code>： 请求服务器回送收到的请求信息，主要用于<strong>测试或诊断</strong> </li><li><code>CONNECT</code>： 保留将来使用</li><li><code>OPTIONS</code>： 请求查询服务器的性能，或者查询与资源关的选项和需求</li></ul><h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><p>状态代码有三位数字组成，第一个数字定义了响应的<strong>类别</strong>，且有五种可能取值：</p><ul><li><code>1xx</code>：<strong>指示信息</strong> - 表示请求已接收，继续处理</li><li><code>2xx</code>：<strong>成功</strong> - 表示请求已被成功接收、理解、接受 </li><li><code>3xx</code>：<strong>重定向</strong> - 要完成请求必须进行更进一步的操作</li><li><code>4xx</code>：<strong>客户端错误</strong> - 请求有语法错误或请求无法实现</li><li><code>5xx</code>：<strong>服务器端错误</strong> - 服务器未能实现合法的请求</li></ul><p>常见状态代码、状态描述、说明：</p><ul><li><code>200</code>： <strong>OK</strong> - 客户端请求成功</li><li><code>400</code>： <strong>Bad Request</strong> - 客户端请求有语法错误，不能被服务器所理解</li><li><code>401</code>： <strong>Unauthorized</strong> - 请求未经授权，这个状态代码必须和<code>WWW-Authenticate</code>报头域一起使用</li><li><code>403</code>： <strong>Forbidden</strong> - 服务器收到请求，但是拒绝提供服务</li><li><code>404</code>： <strong>Not Found</strong> - 请求资源不存在，eg：输入了错误的URL</li><li><code>500</code>： <strong>Internal Server Error</strong> - 服务器发生不可预期的错误</li><li><code>503</code>： <strong>Server Unavailable</strong> - 服务器当前不能处理客户端的请求，一段时间后,可能恢复正常</li></ul><h2 id="Restful风格编程"><a href="#Restful风格编程" class="headerlink" title="Restful风格编程"></a>Restful<strong>风格编程</strong></h2><p>REST (Representational State Transfer)描述了一个架构样式的网络系统，例如web应用程序。</p><p>基本理念：合理并简洁的设计URL，并且能对资源进行<code>POST</code> <code>DELETE</code> <code>PUT</code> <code>GET</code>增删改查的操作。</p><hr><h1 id="GoLang-HTTP标准库"><a href="#GoLang-HTTP标准库" class="headerlink" title="GoLang HTTP标准库"></a><strong>GoLang HTTP标准库</strong></h1><p>市面上所有的GoLangWeb框架都是基于HTTP标准库实现的。</p><h2 id="HTTP标准库客户端功能"><a href="#HTTP标准库客户端功能" class="headerlink" title="HTTP标准库客户端功能"></a>HTTP标准库客户端功能</h2><h3 id="发出GET请求"><a href="#发出GET请求" class="headerlink" title="发出GET请求"></a>发出GET请求</h3><p>使用API，需要知道<code>请求key</code></p><p>新建一个Go_Project，用VSCode打开，在终端输入<code>go mod init 网址</code>就可以初始化go.mod；</p><p>紧接着<code>go mod tidy</code>进行清除操作</p><p>测试代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGet</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//https://www.juhe.cn/box/index/id/73</span></span><br><span class="line">url := <span class="string">&quot;https://conqueror712.gitee.io/conqueror712.gitee.io/&quot;</span> <span class="comment">//接口地址</span></span><br><span class="line">response, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> response.Body.Close()           <span class="comment">//函数结束后关闭响应</span></span><br><span class="line">b, _ := ioutil.ReadAll(response.Body) <span class="comment">//返回字节切片</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;b: %v\n&quot;</span>, <span class="type">string</span>(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，还有一种方法可以把GET请求的一些参数<strong>做成变量</strong>，而不是直接放到URL中；</p><p>需要用<code>params</code>中文内容需要<code>Encode</code>，返回结果和上面的方法是一样，这里就不贴代码了。</p><h3 id="解析JSON格式"><a href="#解析JSON格式" class="headerlink" title="解析JSON格式"></a>解析JSON格式</h3><p>以结构体形式输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestParseJSON</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">Args    <span class="type">string</span>            <span class="string">`json:&quot;args&quot;`</span></span><br><span class="line">Headers <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span> <span class="string">`json:&quot;headers&quot;`</span></span><br><span class="line">Origin  <span class="type">string</span>            <span class="string">`json:&quot;origin&quot;`</span></span><br><span class="line">Url     <span class="type">string</span>            <span class="string">`json:&quot;url&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line">resp, err := http.Get(<span class="string">&quot;http://httpbin.org/get&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">body, _ := ioutil.ReadAll(resp.Body)</span><br><span class="line">fmt.Println(<span class="type">string</span>(body))</span><br><span class="line"><span class="keyword">var</span> res result</span><br><span class="line">_ = json.Unmarshal(body, &amp;res)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v&quot;</span>, res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GET请求添加请求头"><a href="#GET请求添加请求头" class="headerlink" title="GET请求添加请求头"></a>GET请求添加请求头</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAddHeader</span><span class="params">()</span></span> &#123;</span><br><span class="line">client := &amp;http.Client&#123;&#125;</span><br><span class="line">req, _ := http.NewRequest(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://httpbin.org/get&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">req.Header.Add(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;落雨&quot;</span>)</span><br><span class="line">req.Header.Add(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;110&quot;</span>)</span><br><span class="line">resp, _ := client.Do(req)</span><br><span class="line">body, _ := ioutil.ReadAll(resp.Body)</span><br><span class="line">fmt.Printf(<span class="type">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发出POST请求"><a href="#发出POST请求" class="headerlink" title="发出POST请求"></a>发出POST请求</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestPost</span><span class="params">()</span></span> &#123;</span><br><span class="line">urlstr := <span class="string">&quot;http://v.juhe.cn/hisWeather/province&quot;</span></span><br><span class="line">values := url.Values&#123;&#125;</span><br><span class="line">values.Set(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;000&quot;</span>) <span class="comment">//这里的key是错的</span></span><br><span class="line">values.Set(<span class="string">&quot;city&quot;</span>, <span class="string">&quot;北京&quot;</span>)</span><br><span class="line">r, err := http.PostForm(urlstr, values)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> r.Body.Close()</span><br><span class="line">b, _ := ioutil.ReadAll(r.Body)</span><br><span class="line">fmt.Printf(<span class="string">&quot;b: %v\n&quot;</span>, <span class="type">string</span>(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，还有另一种用键值对的方法，不过可读性比较差，这里就不给出代码了。</p><h3 id="发送JSON数据的POST请求"><a href="#发送JSON数据的POST请求" class="headerlink" title="发送JSON数据的POST请求"></a>发送JSON数据的POST请求</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestPostJSON</span><span class="params">()</span></span> &#123;</span><br><span class="line">data := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">data[<span class="string">&quot;site&quot;</span>] = <span class="string">&quot;https://conqueror712.gitee.io/conqueror712.gitee.io/&quot;</span></span><br><span class="line">data[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;落雨的博客&quot;</span></span><br><span class="line">bytesData, _ := json.Marshal(data)</span><br><span class="line">resp, _ := http.Post(<span class="string">&quot;http://httpbin.org/post&quot;</span>, <span class="string">&quot;application/json&quot;</span>, bytes.NewReader(bytesData))</span><br><span class="line">body, _ := ioutil.ReadAll(resp.Body)</span><br><span class="line">fmt.Println(<span class="type">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用Client自定义请求"><a href="#使用Client自定义请求" class="headerlink" title="使用Client自定义请求"></a>使用Client自定义请求</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestClient</span><span class="params">()</span></span> &#123;</span><br><span class="line">client := http.Client&#123;</span><br><span class="line">Timeout: time.Second * <span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line">url := <span class="string">&quot;http://v.juhe.cn/hisWeather/weather?key=&amp;city_id=1157&amp;weather_date=2017-07-15&quot;</span></span><br><span class="line">req, err := http.NewRequest(http.MethodGet, url, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">req.Header.Add(<span class="string">&quot;referer&quot;</span>, <span class="string">&quot;http://apis.juhe.cn/&quot;</span>)</span><br><span class="line">res, err2 := client.Do(req)</span><br><span class="line"><span class="keyword">if</span> err2 != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> res.Body.Close()</span><br><span class="line">b, _ := ioutil.ReadAll(res.Body)</span><br><span class="line">fmt.Printf(<span class="string">&quot;b: %v\n&quot;</span>, <span class="type">string</span>(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HTTP-Server"><a href="#HTTP-Server" class="headerlink" title="HTTP Server"></a>HTTP Server</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHttpServer</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//实现一个http server</span></span><br><span class="line"><span class="comment">//请求处理函数</span></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">io.WriteString(resp, <span class="string">&quot;HelloWorld你好世界&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//响应路径（斜杠是必要的）</span></span><br><span class="line">http.HandleFunc(<span class="string">&quot;/Hello&quot;</span>, f)</span><br><span class="line"><span class="comment">//设置监听端口，并监听（冒号是必要的）</span></span><br><span class="line">err := http.ListenAndServe(<span class="string">&quot;:9999&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//随后在浏览器内输入 http://localhost:9999/Hello 即可查看运行结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用Handler实现并发处理"><a href="#使用Handler实现并发处理" class="headerlink" title="使用Handler实现并发处理"></a>使用Handler实现并发处理</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该代码存在问题，请谨慎参考</span></span><br><span class="line"><span class="keyword">type</span> CountHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">mu sync.Mutex <span class="comment">//guards n</span></span><br><span class="line">n  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *CountHandler)</span></span> ServerHTTP(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">h.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> h.mu.Unlock()</span><br><span class="line">h.n++</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;count is %d\n&quot;</span>, h.n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHttpServerHandler</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.Handle(<span class="string">&quot;/Count&quot;</span>, <span class="built_in">new</span>(CountHandler))</span><br><span class="line">log.Fatal(http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;html/template&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">name := <span class="string">&quot;Conqueror712&quot;</span></span><br><span class="line">templateStr := <span class="string">&quot;Hello, &#123;&#123;.&#125;&#125;&quot;</span> <span class="comment">//只有一个变量 用.即可</span></span><br><span class="line">t := template.New(<span class="string">&quot;Test&quot;</span>)</span><br><span class="line">t2, err := t.Parse(templateStr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">t2.Execute(os.Stdout, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="Gin-Gorm实战CRUD"><a href="#Gin-Gorm实战CRUD" class="headerlink" title="Gin + Gorm实战CRUD"></a>Gin + Gorm实战CRUD</h1><p>话不多说，先附上Github链接，欢迎star：<a href="https://github.com/Conqueror712/Go_CRUD_demo">Conqueror712&#x2F;Go_CRUD_demo: Gin + Gorm + MySQL + Navicat (github.com)</a></p><p>再附上我的掘金文章链接，欢迎访问：<a href="https://juejin.cn/post/7192053234620432441">Gin + Gorm实战CRUD丨学习记录 - 掘金 (juejin.cn)</a></p><h2 id="零、前言："><a href="#零、前言：" class="headerlink" title="零、前言："></a>零、前言：</h2><p>Q：Gin和Gorm都是干什么的？有什么区别？</p><p>A：Gin 和 Gorm 是 Go 编程语言中流行的开源库。但是，它们服务于不同的目的，通常在 web 开发项目中一起使用。</p><p>Gin 是一个用于构建 HTTP 服务器的 web 框架。它提供了一个简单易用的 API，用于处理 HTTP 请求和响应、路由、中间件和其他常见的 web 应用程序所需的功能。它以其高性能和简约为特点，提供了轻量级和灵活的解决方案来构建 web 服务器。</p><p>Gorm 是 Go 的一个 ORM（对象关系映射）库。它提供了一个简单易用的 API，用于与数据库交互、处理数据库迁移和执行常见的数据库操作，如查询、插入、更新和删除记录。它支持多种数据库后端，包括 MySQL、PostgreSQL、SQLite 等。</p><p>总而言之, Gin 是用于处理 HTTP 请求和响应、路由、中间件和其他与网络相关的东西的 web 框架，而 Gorm 则是用于与数据库交互并执行常见数据库操作的 ORM 库。它们通常一起使用，来处理 HTTP 请求&#x2F;响应并在 web 开发项目中存储或获取数据。</p><h3 id="开发环境："><a href="#开发环境：" class="headerlink" title="开发环境："></a>开发环境：</h3><ul><li>Windows 10</li><li>VSCode</li></ul><hr><h2 id="一、Gin"><a href="#一、Gin" class="headerlink" title="一、Gin"></a>一、Gin</h2><h3 id="0-快速入门："><a href="#0-快速入门：" class="headerlink" title="0. 快速入门："></a>0. 快速入门：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/thinkerou/favicon&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中间件（拦截器），功能：预处理，登录授权、验证、分页、耗时统计...</span></span><br><span class="line"><span class="comment">// func myHandler() gin.HandlerFunc &#123;</span></span><br><span class="line"><span class="comment">// return func(ctx *gin.Context) &#123;</span></span><br><span class="line"><span class="comment">// // 通过自定义中间件，设置的值，在后续处理只要调用了这个中间件的都可以拿到这里的参数</span></span><br><span class="line"><span class="comment">// ctx.Set(&quot;usersesion&quot;, &quot;userid-1&quot;)</span></span><br><span class="line"><span class="comment">// ctx.Next()  // 放行</span></span><br><span class="line"><span class="comment">// ctx.Abort() // 阻止</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个服务</span></span><br><span class="line">ginServer := gin.Default()</span><br><span class="line">ginServer.Use(favicon.New(<span class="string">&quot;./Arctime.ico&quot;</span>)) <span class="comment">// 这里如果添加了东西然后再运行没有变化，请重启浏览器，浏览器有缓存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载静态页面</span></span><br><span class="line">ginServer.LoadHTMLGlob(<span class="string">&quot;templates/*&quot;</span>) <span class="comment">// 一种是全局加载，一种是加载指定的文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载资源文件</span></span><br><span class="line">ginServer.Static(<span class="string">&quot;/static&quot;</span>, <span class="string">&quot;./static&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相应一个页面给前端</span></span><br><span class="line"></span><br><span class="line">ginServer.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">ctx.HTML(http.StatusOK, <span class="string">&quot;index.html&quot;</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;msg&quot;</span>: <span class="string">&quot;This data is come from Go background.&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 能加载静态页面也可以加载测试文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取请求中的参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统方式：usl?userid=xxx&amp;username=conqueror712</span></span><br><span class="line"><span class="comment">// Rustful方式：/user/info/1/conqueror712</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是传统方式的例子</span></span><br><span class="line">ginServer.GET(<span class="string">&quot;/user/info&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123; <span class="comment">// 这个格式是固定的</span></span><br><span class="line">userid := context.Query(<span class="string">&quot;userid&quot;</span>)</span><br><span class="line">username := context.Query(<span class="string">&quot;username&quot;</span>)</span><br><span class="line"><span class="comment">// 拿到之后返回给前端</span></span><br><span class="line">context.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">&quot;userid&quot;</span>:   userid,</span><br><span class="line"><span class="string">&quot;username&quot;</span>: username,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 此时执行代码之后，在浏览器中可以输入http://localhost:8081/user/info?userid=111&amp;username=666</span></span><br><span class="line"><span class="comment">// 就可以看到返回了JSON格式的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是Rustful方式的例子</span></span><br><span class="line">ginServer.GET(<span class="string">&quot;/user/info/:userid/:username&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line">userid := context.Param(<span class="string">&quot;userid&quot;</span>)</span><br><span class="line">username := context.Param(<span class="string">&quot;username&quot;</span>)</span><br><span class="line"><span class="comment">// 还是一样，返回给前端</span></span><br><span class="line">context.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">&quot;userid&quot;</span>:   userid,</span><br><span class="line"><span class="string">&quot;username&quot;</span>: username,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 指定代码后，只需要在浏览器中http://localhost:8081/user/info/111/555</span></span><br><span class="line"><span class="comment">// 就可以看到返回了JSON数据了，非常方便简洁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化</span></span><br><span class="line"><span class="comment">// 前端给后端传递JSON</span></span><br><span class="line">ginServer.POST(<span class="string">&quot;/json&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// request.body</span></span><br><span class="line">data, _ := ctx.GetRawData()</span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125; <span class="comment">// Go语言中object一般用空接口来表示，可以接收anything</span></span><br><span class="line"><span class="comment">// 顺带一提，1.18以上，interface可以直接改成any</span></span><br><span class="line">_ = json.Unmarshal(data, &amp;m)</span><br><span class="line">ctx.JSON(http.StatusOK, m)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 用apipost或者postman写一段json传到localhost:8081/json里就可以了</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">json示例：</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">&quot;name&quot;: &quot;Conqueror712&quot;,</span></span><br><span class="line"><span class="comment">&quot;age&quot;: 666,</span></span><br><span class="line"><span class="comment">&quot;address&quot;: &quot;Mars&quot;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 看到后端的实时响应里面接收到数据就可以了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理表单请求 这些都是支持函数式编程，Go语言特性，可以把函数作为参数传进来</span></span><br><span class="line">ginServer.POST(<span class="string">&quot;/user/add&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">username := ctx.PostForm(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">password := ctx.PostForm(<span class="string">&quot;password&quot;</span>)</span><br><span class="line">ctx.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line"><span class="string">&quot;msg&quot;</span>:      <span class="string">&quot;ok&quot;</span>,</span><br><span class="line"><span class="string">&quot;username&quot;</span>: username,</span><br><span class="line"><span class="string">&quot;password&quot;</span>: password,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路由</span></span><br><span class="line">ginServer.GET(<span class="string">&quot;/test&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 重定向 -&gt; 301</span></span><br><span class="line">ctx.Redirect(<span class="number">301</span>, <span class="string">&quot;https://conqueror712.gitee.io/conqueror712.gitee.io/&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// http://localhost:8081/test</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 404</span></span><br><span class="line">ginServer.NoRoute(<span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">ctx.HTML(<span class="number">404</span>, <span class="string">&quot;404.html&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路由组暂略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器端口，用服务器端口来访问地址</span></span><br><span class="line">ginServer.Run(<span class="string">&quot;:8081&quot;</span>) <span class="comment">// 不写的话默认是8080，也可以更改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>API用法示例</strong>：<code>https://gin-gonic.com/zh-cn/docs/examples/</code></p><hr><h3 id="1-基准测试"><a href="#1-基准测试" class="headerlink" title="1. 基准测试"></a>1. 基准测试</h3><p>Q：基准测试是什么？</p><p>A：基准测试，也称为性能测试或压力测试，是一种<strong>用于测量系统或组件性能的测试</strong>。基准测试的<strong>目的是了解系统或组件在特定条件下的性能，并将结果与其他类似系统或组件进行比较</strong>。基准测试可用于评估各种类型的系统和组件，包括硬件、软件、网络和整个系统。</p><p>Q：什么时候需要基准测试呀？</p><p>A：基准测试通常涉及在被测系统或组件上运行特定工作负载或任务，并测量<strong>吞吐量、延迟时间、CPU使用率、内存使用率</strong>等各种性能指标。基准测试的结果可用于识别瓶颈和性能问题，并做出有关如何优化系统或组件以提高性能的明智决策。</p><p>有许多不同类型的基准测试，每种类型都有自己的指标和工作负载。常见的基准测试类型包括：</p><ul><li>人工基准测试：使用人工工作负载来测量系统或组件的性能。</li><li>真实世界基准测试：使用真实世界的工作负载或场景来测量系统或组件的性能。</li><li>压力测试：旨在将系统或组件推到极限，以确定在正常使用条件下可能不明显的性能问题</li></ul><p>重要的是要知道基准测试不是一次性的活动，而是应该<strong>定期进行</strong>的活动，以评估系统的性能并检测随时间的消耗。</p><p>Q：什么样的基准测试结果是我们想要的呀？</p><p>A：</p><ul><li>在一定的时间内实现的总调用数，越高越好</li><li>单次操作耗时（ns&#x2F;op），越低越好</li><li>堆内存分配 （B&#x2F;op）, 越低越好</li><li>每次操作的平均内存分配次数（allocs&#x2F;op），越低越好</li></ul><hr><h3 id="2-Gin的特性与Jsoniter："><a href="#2-Gin的特性与Jsoniter：" class="headerlink" title="2. Gin的特性与Jsoniter："></a>2. Gin的特性与Jsoniter：</h3><p>Gin v1 稳定的特性:</p><ul><li>零分配路由。</li><li>仍然是最快的 http 路由器和框架。</li><li>完整的单元测试支持。</li><li>实战考验。</li><li>API 冻结，新版本的发布不会破坏你的代码。</li><li>Gin 项目可以轻松部署在任何云提供商上。</li></ul><p>Gin 使用 encoding&#x2F;json 作为默认的 json 包，但是你可以在编译中使用标签将其修改为 jsoniter。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go build -tags=jsoniter .</span><br></pre></td></tr></table></figure><p><strong>Jsoniter是什么？</strong></p><ul><li><code>json-iterator</code>是一款快且灵活的<code>JSON</code>解析器,同时提供<code>Java</code>和<code>Go</code>两个版本。</li><li><code>json-iterator</code>是最快的<code>JSON</code>解析器。它最多能比普通的解析器快10倍之多</li><li>独特的<code>iterator api</code>能够直接遍历<code>JSON</code> ，极致性能、零内存分配</li><li>从dsljson和jsonparser借鉴了大量代码。</li></ul><p>下载依赖：<code>go get github.com/json-iterator/go</code></p><hr><h2 id="二、GORM"><a href="#二、GORM" class="headerlink" title="二、GORM"></a>二、GORM</h2><h3 id="0-特性与安装："><a href="#0-特性与安装：" class="headerlink" title="0. 特性与安装："></a>0. 特性与安装：</h3><ul><li>全功能 ORM</li><li>关联 (Has One，Has Many，Belongs To，Many To Many，多态，单表继承)</li><li>Create，Save，Update，Delete，Find 中钩子方法</li><li>支持 <code>Preload</code>、<code>Joins</code> 的预加载</li><li>事务，嵌套事务，Save Point，Rollback To Saved Point</li><li>Context、预编译模式、DryRun 模式</li><li>批量插入，FindInBatches，Find&#x2F;Create with Map，使用 SQL 表达式、Context Valuer 进行 CRUD</li><li>SQL 构建器，Upsert，数据库锁，Optimizer&#x2F;Index&#x2F;Comment Hint，命名参数，子查询</li><li>复合主键，索引，约束</li><li>Auto Migration</li><li>自定义 Logger</li><li>灵活的可扩展插件 API：Database Resolver（多数据库，读写分离）、Prometheus…</li><li>每个特性都经过了测试的重重考验</li><li>开发者友好</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go get -u gorm.io/gorm</span><br><span class="line">go get -u gorm.io/driver/sqlite</span><br></pre></td></tr></table></figure><p>其他的补充内容：</p><ul><li>Gorm是软删除，为了保证数据库的完整性</li></ul><hr><h2 id="三、Navicat"><a href="#三、Navicat" class="headerlink" title="三、Navicat"></a>三、Navicat</h2><p>破解教程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.jianshu.com/p/9c4c499429da</span><br></pre></td></tr></table></figure><p>新建连接 -&gt; MySQL -&gt; 连接名随便 -&gt; 密码随便 -&gt; 双击左侧打开 -&gt; 右键information_schema -&gt; 新建数据库 -&gt; 名称crud-list -&gt; 字符集utf8mb4</p><p>这里如果打开的时候报错<code>navicat 1045 - access denied for user &#39;root&#39;@&#39;localhost&#39; (using password: &#39;YES&#39;)</code>，则需要查看自己的数据库本身的问题</p><hr><h2 id="四、Gin-Gorm的CRUD"><a href="#四、Gin-Gorm的CRUD" class="headerlink" title="四、Gin+Gorm的CRUD"></a>四、Gin+Gorm的CRUD</h2><h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><p>编写测试代码，成功运行即可，但是这个时候还不能查看数据库是否被创建，</p><p>如果要看我们需要定义结构体，然后定义表迁移，具体代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;gorm.io/driver/sqlite&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"><span class="string">&quot;gorm.io/driver/mysql&quot;</span></span><br><span class="line"><span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 如何连接数据库 ? MySQL + Navicat</span></span><br><span class="line"><span class="comment">// 需要更改的内容：用户名，密码，数据库名称</span></span><br><span class="line">dsn := <span class="string">&quot;root:BqV?eGcc_1o+@tcp(127.0.0.1:3306)/crud-list?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span></span><br><span class="line">db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;db = &quot;</span>, db)</span><br><span class="line">fmt.Println(<span class="string">&quot;err = &quot;</span>, err)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接池</span></span><br><span class="line">sqlDB, err := db.DB()</span><br><span class="line"><span class="comment">// SetMaxIdleConns 设置空闲连接池中连接的最大数量</span></span><br><span class="line">sqlDB.SetMaxIdleConns(<span class="number">10</span>)</span><br><span class="line"><span class="comment">// SetMaxOpenConns 设置打开数据库连接的最大数量。</span></span><br><span class="line">sqlDB.SetMaxOpenConns(<span class="number">100</span>)</span><br><span class="line"><span class="comment">// SetConnMaxLifetime 设置了连接可复用的最大时间。</span></span><br><span class="line">sqlDB.SetConnMaxLifetime(<span class="number">10</span> * time.Second) <span class="comment">// 10秒钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体</span></span><br><span class="line"><span class="keyword">type</span> List <span class="keyword">struct</span> &#123;</span><br><span class="line">Name    <span class="type">string</span></span><br><span class="line">State   <span class="type">string</span></span><br><span class="line">Phone   <span class="type">string</span></span><br><span class="line">Email   <span class="type">string</span></span><br><span class="line">Address <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迁移</span></span><br><span class="line">db.AutoMigrate(&amp;List&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口</span></span><br><span class="line">r := gin.Default()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 端口号</span></span><br><span class="line">PORT := <span class="string">&quot;3001&quot;</span></span><br><span class="line">r.Run(<span class="string">&quot;:&quot;</span> + PORT)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义好之后我们运行，没有报错并且在终端显示出来3001就是正确的，这个时候我们可以去Navicat里面查看crud-list下面的”表”，刷新后发现有一个lists产生，那就是对的了。</p><p>但是这个时候我们存在两个问题：</p><ol><li>没有主键：在struct里添加<code>gorm.Model</code>来解决，Ctrl+左键可以查看<code>model</code></li><li>表里面的名称变成了复数：详见文档的高级主题-GORM配置里，在<code>*db*, *err* *:=* gorm.Open(mysql.Open(dsn), *&amp;*gorm.Config&#123;&#125;)</code>里面添加一段话即可</li></ol><p>更改完成之后我们要先在Navicat里面把原来的表<code>lists</code>删掉才能重新创建，这个时候我们重新运行，就会发现表单里面多了很多东西</p><hr><h2 id="结构体定义与优化"><a href="#结构体定义与优化" class="headerlink" title="结构体定义与优化"></a>结构体定义与优化</h2><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`gorm:&quot;type:varchar(20); not null&quot; json:&quot;name&quot; binding:&quot;required&quot;`</span><br></pre></td></tr></table></figure><p>需要注意的是：</p><ol><li>结构体里面的变量(Name)必须首字母大写，否则创建不出列，会被自动忽略</li><li>gorm指定类型</li><li>json表示json接收的时候的名称</li><li>binding required表示必须传入</li></ol><hr><h2 id="CRUD接口"><a href="#CRUD接口" class="headerlink" title="CRUD接口"></a>CRUD接口</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试</span></span><br><span class="line">r.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;message&quot;</span>: <span class="string">&quot;请求成功&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>编写完这一段之后运行代码，然后去postman里面新建一个GET接口<code>127.0.0.1:3001</code>然后send一下，出现请求成功就请求成功了。</p><hr><p>增也是一样，写好之后直接用如下JSON来测试就可以：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;state&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;在职&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;phone&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;13900000000&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;email&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;6666@qq.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;address&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;二仙桥成华大道&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>返回：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;200&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;ID&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;CreatedAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2023-01-24T09:27:36.73+08:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;UpdatedAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2023-01-24T09:27:36.73+08:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;DeletedAt&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;state&quot;</span><span class="punctuation">:</span> <span class="string">&quot;在职&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;phone&quot;</span><span class="punctuation">:</span> <span class="string">&quot;13900000000&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;6666@qq.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;二仙桥成华大道&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;添加成功&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>这时候也可以在数据库里看到这条数据</p><hr><p>删除也是一样，编写完运行之后添加一个DELETE接口，然后输入<code>127.0.0.1:3001/user/delete/2</code>之后send就可以看到返回了（前提是有数据）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;删除成功&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果是删除了不存在的id，就会返回</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">400</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;id没有找到，删除失败&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>顺带一提，事实上这个代码还可以优化，这里的if else太多了，后面优化的时候有错误直接return</p><hr><p>修改也是一样，示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;state&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;离职&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;phone&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;13900000000&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;email&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;6666@qq.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;address&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;二仙桥成华大道&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>返回：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;修改成功&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><hr><p>查询分为两种：</p><ol><li>条件查询</li><li>分页查询</li></ol><p>条件查询的话，直接写好了请求<code>127.0.0.1:3001/user/list/王五</code></p><p>返回：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;200&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;ID&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;CreatedAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2023-01-24T10:06:25.305+08:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;UpdatedAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2023-01-24T10:06:25.305+08:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;DeletedAt&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;王五&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;state&quot;</span><span class="punctuation">:</span> <span class="string">&quot;在职&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;phone&quot;</span><span class="punctuation">:</span> <span class="string">&quot;13100000000&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;8888@qq.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;八仙桥成华大道&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;查询成功&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>全部 &#x2F; 分页查询的话</p><p>譬如说请求是：<code>127.0.0.1:3001/user/list?pageNum=1&amp;pageSize=2</code></p><p>意思就是查询第一页的两个</p><p>返回：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;list&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;ID&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;CreatedAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2023-01-24T10:06:25.305+08:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;UpdatedAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2023-01-24T10:06:25.305+08:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;DeletedAt&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;王五&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;state&quot;</span><span class="punctuation">:</span> <span class="string">&quot;在职&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;phone&quot;</span><span class="punctuation">:</span> <span class="string">&quot;13100000000&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;8888@qq.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;八仙桥成华大道&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;pageNum&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;pageSize&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;查询成功&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果请求是：<code>127.0.0.1:3001/user/list</code></p><p>返回：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;list&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;ID&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;CreatedAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2023-01-24T09:27:36.73+08:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;UpdatedAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2023-01-24T09:55:20.351+08:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;DeletedAt&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;state&quot;</span><span class="punctuation">:</span> <span class="string">&quot;离职&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;phone&quot;</span><span class="punctuation">:</span> <span class="string">&quot;13900000000&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;6666@qq.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;二仙桥成华大道&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;ID&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;CreatedAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2023-01-24T10:06:25.305+08:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;UpdatedAt&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2023-01-24T10:06:25.305+08:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;DeletedAt&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;王五&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;state&quot;</span><span class="punctuation">:</span> <span class="string">&quot;在职&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;phone&quot;</span><span class="punctuation">:</span> <span class="string">&quot;13100000000&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;8888@qq.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;八仙桥成华大道&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;pageNum&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;pageSize&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;total&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;查询成功&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><hr><p>完整代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;gorm.io/driver/sqlite&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"><span class="string">&quot;gorm.io/driver/mysql&quot;</span></span><br><span class="line"><span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line"><span class="string">&quot;gorm.io/gorm/schema&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 如何连接数据库 ? MySQL + Navicat</span></span><br><span class="line"><span class="comment">// 需要更改的内容：用户名，密码，数据库名称</span></span><br><span class="line">dsn := <span class="string">&quot;root:password@tcp(127.0.0.1:3306)/database?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span></span><br><span class="line">db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;</span><br><span class="line">NamingStrategy: schema.NamingStrategy&#123;</span><br><span class="line">SingularTable: <span class="literal">true</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;db = &quot;</span>, db)</span><br><span class="line">fmt.Println(<span class="string">&quot;err = &quot;</span>, err)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接池</span></span><br><span class="line">sqlDB, err := db.DB()</span><br><span class="line"><span class="comment">// SetMaxIdleConns 设置空闲连接池中连接的最大数量</span></span><br><span class="line">sqlDB.SetMaxIdleConns(<span class="number">10</span>)</span><br><span class="line"><span class="comment">// SetMaxOpenConns 设置打开数据库连接的最大数量。</span></span><br><span class="line">sqlDB.SetMaxOpenConns(<span class="number">100</span>)</span><br><span class="line"><span class="comment">// SetConnMaxLifetime 设置了连接可复用的最大时间。</span></span><br><span class="line">sqlDB.SetConnMaxLifetime(<span class="number">10</span> * time.Second) <span class="comment">// 10秒钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体</span></span><br><span class="line"><span class="keyword">type</span> List <span class="keyword">struct</span> &#123;</span><br><span class="line">gorm.Model        <span class="comment">// 主键</span></span><br><span class="line">Name       <span class="type">string</span> <span class="string">`gorm:&quot;type:varchar(20); not null&quot; json:&quot;name&quot; binding:&quot;required&quot;`</span></span><br><span class="line">State      <span class="type">string</span> <span class="string">`gorm:&quot;type:varchar(20); not null&quot; json:&quot;state&quot; binding:&quot;required&quot;`</span></span><br><span class="line">Phone      <span class="type">string</span> <span class="string">`gorm:&quot;type:varchar(20); not null&quot; json:&quot;phone&quot; binding:&quot;required&quot;`</span></span><br><span class="line">Email      <span class="type">string</span> <span class="string">`gorm:&quot;type:varchar(40); not null&quot; json:&quot;email&quot; binding:&quot;required&quot;`</span></span><br><span class="line">Address    <span class="type">string</span> <span class="string">`gorm:&quot;type:varchar(200); not null&quot; json:&quot;address&quot; binding:&quot;required&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迁移</span></span><br><span class="line">db.AutoMigrate(&amp;List&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口</span></span><br><span class="line">r := gin.Default()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="comment">// r.GET(&quot;/&quot;, func(c *gin.Context) &#123;</span></span><br><span class="line"><span class="comment">// c.JSON(200, gin.H&#123;</span></span><br><span class="line"><span class="comment">// &quot;message&quot;: &quot;请求成功&quot;,</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 业务码约定：正确200，错误400</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 增</span></span><br><span class="line">r.POST(<span class="string">&quot;/user/add&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 定义一个变量指向结构体</span></span><br><span class="line"><span class="keyword">var</span> data List</span><br><span class="line"><span class="comment">// 绑定方法</span></span><br><span class="line">err := ctx.ShouldBindJSON(&amp;data)</span><br><span class="line"><span class="comment">// 判断绑定是否有错误</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">ctx.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;msg&quot;</span>:  <span class="string">&quot;添加失败&quot;</span>,</span><br><span class="line"><span class="string">&quot;data&quot;</span>: gin.H&#123;&#125;,</span><br><span class="line"><span class="string">&quot;code&quot;</span>: <span class="string">&quot;400&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 数据库的操作</span></span><br><span class="line">db.Create(&amp;data) <span class="comment">// 创建一条数据</span></span><br><span class="line">ctx.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;msg&quot;</span>:  <span class="string">&quot;添加成功&quot;</span>,</span><br><span class="line"><span class="string">&quot;data&quot;</span>: data,</span><br><span class="line"><span class="string">&quot;code&quot;</span>: <span class="string">&quot;200&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删</span></span><br><span class="line"><span class="comment">// 1. 找到对应的id对应的条目</span></span><br><span class="line"><span class="comment">// 2. 判断id是否存在</span></span><br><span class="line"><span class="comment">// 3. 从数据库中删除 or 返回id没有找到</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Restful编码规范</span></span><br><span class="line">r.DELETE(<span class="string">&quot;/user/delete/:id&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> data []List</span><br><span class="line"><span class="comment">// 接收id</span></span><br><span class="line">id := ctx.Param(<span class="string">&quot;id&quot;</span>) <span class="comment">// 如果有键值对形式的话用Query()</span></span><br><span class="line"><span class="comment">// 判断id是否存在</span></span><br><span class="line">db.Where(<span class="string">&quot;id = ? &quot;</span>, id).Find(&amp;data)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">0</span> &#123;</span><br><span class="line">ctx.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;msg&quot;</span>:  <span class="string">&quot;id没有找到，删除失败&quot;</span>,</span><br><span class="line"><span class="string">&quot;code&quot;</span>: <span class="number">400</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 操作数据库删除（删除id所对应的那一条）</span></span><br><span class="line"><span class="comment">// db.Where(&quot;id = ? &quot;, id).Delete(&amp;data) &lt;- 其实不需要这样写，因为查到的data里面就是要删除的数据</span></span><br><span class="line">db.Delete(&amp;data)</span><br><span class="line"></span><br><span class="line">ctx.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;msg&quot;</span>:  <span class="string">&quot;删除成功&quot;</span>,</span><br><span class="line"><span class="string">&quot;code&quot;</span>: <span class="number">200</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改</span></span><br><span class="line">r.PUT(<span class="string">&quot;/user/update/:id&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 1. 找到对应的id所对应的条目</span></span><br><span class="line"><span class="comment">// 2. 判断id是否存在</span></span><br><span class="line"><span class="comment">// 3. 修改对应条目 or 返回id没有找到</span></span><br><span class="line"><span class="keyword">var</span> data List</span><br><span class="line">id := ctx.Param(<span class="string">&quot;id&quot;</span>)</span><br><span class="line"><span class="comment">// db.Where(&quot;id = ?&quot;, id).Find(&amp;data) 可以这样写，也可以写成下面那样</span></span><br><span class="line"><span class="comment">// 还可以再Where后面加上Count函数，可以查出来这个条件对应的条数</span></span><br><span class="line">db.Select(<span class="string">&quot;id&quot;</span>).Where(<span class="string">&quot;id = ? &quot;</span>, id).Find(&amp;data)</span><br><span class="line"><span class="keyword">if</span> data.ID == <span class="number">0</span> &#123;</span><br><span class="line">ctx.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;msg&quot;</span>:  <span class="string">&quot;用户id没有找到&quot;</span>,</span><br><span class="line"><span class="string">&quot;code&quot;</span>: <span class="number">400</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 绑定一下</span></span><br><span class="line">err := ctx.ShouldBindJSON(&amp;data)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">ctx.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;msg&quot;</span>:  <span class="string">&quot;修改失败&quot;</span>,</span><br><span class="line"><span class="string">&quot;code&quot;</span>: <span class="number">400</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// db修改数据库内容</span></span><br><span class="line">db.Where(<span class="string">&quot;id = ?&quot;</span>, id).Updates(&amp;data)</span><br><span class="line">ctx.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;msg&quot;</span>:  <span class="string">&quot;修改成功&quot;</span>,</span><br><span class="line"><span class="string">&quot;code&quot;</span>: <span class="number">200</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查</span></span><br><span class="line"><span class="comment">// 第一种：条件查询，</span></span><br><span class="line">r.GET(<span class="string">&quot;/user/list/:name&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 获取路径参数</span></span><br><span class="line">name := ctx.Param(<span class="string">&quot;name&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> dataList []List</span><br><span class="line"><span class="comment">// 查询数据库</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ? &quot;</span>, name).Find(&amp;dataList)</span><br><span class="line"><span class="comment">// 判断是否查询到数据</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(dataList) == <span class="number">0</span> &#123;</span><br><span class="line">ctx.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;msg&quot;</span>:  <span class="string">&quot;没有查询到数据&quot;</span>,</span><br><span class="line"><span class="string">&quot;code&quot;</span>: <span class="string">&quot;400&quot;</span>,</span><br><span class="line"><span class="string">&quot;data&quot;</span>: gin.H&#123;&#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ctx.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;msg&quot;</span>:  <span class="string">&quot;查询成功&quot;</span>,</span><br><span class="line"><span class="string">&quot;code&quot;</span>: <span class="string">&quot;200&quot;</span>,</span><br><span class="line"><span class="string">&quot;data&quot;</span>: dataList,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种：全部查询 / 分页查询</span></span><br><span class="line">r.GET(<span class="string">&quot;/user/list&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> dataList []List</span><br><span class="line"><span class="comment">// 查询全部数据 or 查询分页数据</span></span><br><span class="line">pageSize, _ := strconv.Atoi(ctx.Query(<span class="string">&quot;pageSize&quot;</span>))</span><br><span class="line">pageNum, _ := strconv.Atoi(ctx.Query(<span class="string">&quot;pageNum&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否需要分页</span></span><br><span class="line"><span class="keyword">if</span> pageSize == <span class="number">0</span> &#123;</span><br><span class="line">pageSize = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> pageNum == <span class="number">0</span> &#123;</span><br><span class="line">pageNum = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">offsetVal := (pageNum - <span class="number">1</span>) * pageSize <span class="comment">// 固定写法 记住就行</span></span><br><span class="line"><span class="keyword">if</span> pageNum == <span class="number">-1</span> &amp;&amp; pageSize == <span class="number">-1</span> &#123;</span><br><span class="line">offsetVal = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个总数</span></span><br><span class="line"><span class="keyword">var</span> total <span class="type">int64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询数据库</span></span><br><span class="line">db.Model(dataList).Count(&amp;total).Limit(pageSize).Offset(offsetVal).Find(&amp;dataList)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(dataList) == <span class="number">0</span> &#123;</span><br><span class="line">ctx.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;msg&quot;</span>:  <span class="string">&quot;没有查询到数据&quot;</span>,</span><br><span class="line"><span class="string">&quot;code&quot;</span>: <span class="number">400</span>,</span><br><span class="line"><span class="string">&quot;data&quot;</span>: gin.H&#123;&#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ctx.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;msg&quot;</span>:  <span class="string">&quot;查询成功&quot;</span>,</span><br><span class="line"><span class="string">&quot;code&quot;</span>: <span class="number">200</span>,</span><br><span class="line"><span class="string">&quot;data&quot;</span>: gin.H&#123;</span><br><span class="line"><span class="string">&quot;list&quot;</span>:     dataList,</span><br><span class="line"><span class="string">&quot;total&quot;</span>:    total,</span><br><span class="line"><span class="string">&quot;pageNum&quot;</span>:  pageNum,</span><br><span class="line"><span class="string">&quot;pageSize&quot;</span>: pageSize,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 端口号</span></span><br><span class="line">PORT := <span class="string">&quot;3001&quot;</span></span><br><span class="line">r.Run(<span class="string">&quot;:&quot;</span> + PORT)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>THE END</p><hr><h1 id="Go-FFmpeg交互"><a href="#Go-FFmpeg交互" class="headerlink" title="Go + FFmpeg交互"></a>Go + FFmpeg交互</h1><p>另附我的掘金主页：<a href="https://juejin.cn/user/1297878069809725">Conqueror712 的个人主页 - 动态 - 掘金 (juejin.cn)</a></p><p><strong>主要思路：</strong></p><blockquote><p>使用 Golang 和 FFmpeg 交互可以分为以下几个步骤：</p><ol><li>安装 FFmpeg: 首先需要安装 FFmpeg，可以在终端中输入命令来安装。</li><li>创建一个Golang项目，并在其中创建一个接收上传视频文件的接口。</li><li>在接口中接收上传的文件，并使用Golang中的 exec 包来执行 FFmpeg 命令来转码视频。</li><li>转码后的文件可以保存在本地或上传到云存储服务器。</li><li>将视频信息存储到 MySQL 数据库中。</li><li>在Golang中使用GORM或其他ORM库来连接数据库并存储数据。</li><li>在代码中使用 exec.Command 函数来执行 FFmpeg 命令。该函数需要 ffmpeg 的完整路径和命令行参数，并返回一个 *exec.Cmd 类型的对象。</li><li>通过使用 .StdoutPipe() 和 .Start() 方法来执行 FFmpeg 命令并获取命令输出。</li><li>使用 io.Copy() 函数将转码后的视频文件写入本地文件或上传到云存储服务器。</li><li>使用GORM将上传视频文件的信息存储到数据库中。</li></ol></blockquote><hr><h2 id="一、本地IO"><a href="#一、本地IO" class="headerlink" title="一、本地IO"></a>一、本地IO</h2><p>以下是一个代码示例，实现<strong>从本地来，到本地去</strong>的功能，<strong>记得改路径和名称！</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os/exec&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 设置视频源文件路径</span></span><br><span class="line">inputFile := <span class="string">&quot;input.mp4&quot;</span></span><br><span class="line"><span class="comment">// 设置转码后文件路径</span></span><br><span class="line">outputFile := <span class="string">&quot;output.mp4&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 ffmpeg 命令行参数</span></span><br><span class="line">args := []<span class="type">string</span>&#123;<span class="string">&quot;-i&quot;</span>, inputFile, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;copy&quot;</span>, outputFile&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 *exec.Cmd</span></span><br><span class="line">cmd := exec.Command(<span class="string">&quot;ffmpeg&quot;</span>, args...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行 ffmpeg 命令</span></span><br><span class="line"><span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;转码成功&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你没有报错的话，可以看到，有输出文件，但是这一来一回有什么用呢？</p><p>事实上目的就是让这个转码后的视频文件是<strong>可以在线播放</strong>的。</p><hr><h2 id="二、保存到数据库"><a href="#二、保存到数据库" class="headerlink" title="二、保存到数据库"></a>二、保存到数据库</h2><p>光从本地来到本地去总是不长久的，我们要打开<strong>数据库</strong>的大门；</p><p>首先需要准备好数据库和表，这里我们同样使用Navicat来操作，具体操作步骤如下，不需要的可以跳过：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">新建连接 -&gt; MySQL -&gt; 连接名随便 -&gt; 密码随便(强烈建议与数据库密码相同否则可能会产生一些错误) -&gt; 双击左侧打开 -&gt; 右键information_schema -&gt; 新建数据库 -&gt; 名称随便 -&gt; 字符集utf8mb4</span><br></pre></td></tr></table></figure><p>然后执行如下代码即可，<strong>注意修改你的路径、名称、数据库名称等信息</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os/exec&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/jinzhu/gorm&quot;</span></span><br><span class="line">_ <span class="string">&quot;github.com/jinzhu/gorm/dialects/mysql&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 Video struct，用来存储视频信息</span></span><br><span class="line"><span class="keyword">type</span> Video <span class="keyword">struct</span> &#123;</span><br><span class="line">gorm.Model</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Path <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 连接数据库</span></span><br><span class="line">db, err := gorm.Open(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;root:password@/database?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;failed to connect to the database&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> db.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建表</span></span><br><span class="line">db.AutoMigrate(&amp;Video&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// FFmpeg命令转换视频</span></span><br><span class="line">cmd := exec.Command(<span class="string">&quot;ffmpeg&quot;</span>, <span class="string">&quot;-i&quot;</span>, <span class="string">&quot;input.mp4&quot;</span>, <span class="string">&quot;-vcodec&quot;</span>, <span class="string">&quot;libx264&quot;</span>, <span class="string">&quot;-acodec&quot;</span>, <span class="string">&quot;aac&quot;</span>, <span class="string">&quot;-strict&quot;</span>, <span class="string">&quot;-2&quot;</span>, <span class="string">&quot;output.mp4&quot;</span>)</span><br><span class="line"></span><br><span class="line">err = cmd.Run()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在数据库里存储视频信息</span></span><br><span class="line">video := Video&#123;Name: <span class="string">&quot;output&quot;</span>, Path: <span class="string">&quot;output.mp4&quot;</span>&#125;</span><br><span class="line">db.Create(&amp;video)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Navicat中效果如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f44cba7872e418cb1d796817ce39873~tplv-k3u1fbpfcp-zoom-1.image" alt="avatar"></p><p>几点说明：</p><ul><li>这个 ffmpeg 示例中的命令是将视频 “input.mp4” 转换为新的视频文件 “output.mp4”。</li><li>在这个命令中，我们使用了 “-i” 参数来指定输入文件，”-vcodec” 和 “-acodec” 参数来指定视频和音频编码，”-strict” 和 “-2” 参数来指定编码标准。</li><li>其中 “-vcodec” 指定了视频编码为 libx264，”-acodec” 指定音频编码为 aac ，这两个编码是在线播放视频常用的编码方式，所以这个转码后的视频文件是可以在线播放的。</li><li>如果你想要转换成其它格式，可以查询ffmpeg的文档和参数来实现。</li></ul><hr><h2 id="三、前端实现与用户交互"><a href="#三、前端实现与用户交互" class="headerlink" title="三、前端实现与用户交互"></a>三、前端实现与用户交互</h2><h3 id="思路一：Nginx"><a href="#思路一：Nginx" class="headerlink" title="思路一：Nginx"></a>思路一：Nginx</h3><p>Nginx 的作用是作为一个<strong>反向代理服务器</strong>，用于将用户的请求转发到后端服务器进行处理。</p><p>反向代理服务器可以帮助实现<strong>负载均衡、安全性、缓存</strong>等功能。</p><p>如果想使用 Nginx 作为 Web 服务器来处理用户的请求并将其转发到后端服务器，可以这样做：</p><ol><li>首先，需要在自己的服务器上安装 Nginx。</li><li>然后，需要编写 Nginx 的配置文件来处理用户的请求。举个例子，如果想将所有的 &#x2F;upload 请求转发到后端服务器的 &#x2F;upload 接口，可以在 Nginx 的配置文件中添加如下代码：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /upload &#123;</span><br><span class="line">    proxy_pass http://backend_server:8000/upload;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在后端服务器上实现对 &#x2F;upload 接口的处理，如接收视频文件并进行转码。可以使用 Gin 或其他框架来实现这个功能，并将转码后的文件存储到数据库中。</li><li>完成以上步骤后，当用户在前端网页上上传视频文件时，这个文件会被发送到 Nginx，然后 Nginx 会将请求转发到后端服务器进行处理。后端服务器接收到请求后会调用 ffmpeg 将视频转码并存储在数据库中。</li></ol><p>如果是在web端指定本地要作为输入的视频路径，这部分需要在前端进行实现，可以在前端页面上使用 HTML input 标签来实现文件选择功能，并在选择文件后使用 JavaScript 来获取文件路径并发送到后端服务器。</p><p>例如，在 HTML 中使用 input 标签来实现文件选择功能：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;input-file&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 JavaScript 代码来获取文件路径并发送到后端服务器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;input-file&quot;</span>);</span><br><span class="line">    input.<span class="title function_">addEventListener</span>(<span class="string">&quot;change&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> file = input.<span class="property">files</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">var</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">        formData.<span class="title function_">append</span>(<span class="string">&quot;file&quot;</span>, file);</span><br><span class="line">        <span class="comment">// send the formData to backend server</span></span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="思路二：GoFTP"><a href="#思路二：GoFTP" class="headerlink" title="思路二：GoFTP"></a>思路二：GoFTP</h3><p>使用 GoFTP 来上传和下载视频，可以在 Go 中使用第三方库：<a href="https://github.com/jlaffaye/ftp">https://github.com/jlaffaye/ftp</a> ；</p><p>使用这个库可以在 Go 中实现 FTP 协议的上传和下载功能，并可以轻松地将视频文件上传到服务器并在服务器上进行转码。如此，可以将文件<strong>上传和转码</strong>的功能放在<strong>同一个服务器</strong>上，而不需要使用反向代理服务器来转发请求。</p><p>使用 GoFTP 来上传和下载视频文件的话不需要使用 HTML 和 JavaScript 。可以使用 Go 程序来直接与 FTP 服务器进行交互。可以使用 GoFTP 库，在 Go 中编写程序来连接到 FTP 服务器实现：连接到FTP服务器，登录，上传文件，下载文件等操作。</p><p>当然，如果需要在web上获取用户选择的视频文件路径，可以使用HTML和JavaScript来实现这部分功能，但是FTP上传和下载操作可以直接在Go程序中实现。</p><p>以下是一个<strong>示例代码</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/jlaffaye/ftp&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 连接到 FTP 服务器</span></span><br><span class="line">conn, err := ftp.Connect(<span class="string">&quot;ftp.example.com:21&quot;</span>)</span><br><span class="line"><span class="comment">// ftp.example.com:21是一个模拟的FTP服务器地址，实际使用中需要替换成真正的FTP服务器的地址。</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Error connecting to FTP server:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Quit()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登录到 FTP 服务器</span></span><br><span class="line"><span class="comment">// 需要提前设置好username and password</span></span><br><span class="line"><span class="keyword">if</span> err := conn.Login(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;password&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Error logging in to FTP server:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开本地文件</span></span><br><span class="line">file, err := os.Open(<span class="string">&quot;example.txt&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Error opening local file:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上传文件到 FTP 服务器</span></span><br><span class="line"><span class="keyword">if</span> err := conn.Stor(<span class="string">&quot;example.txt&quot;</span>, file); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Error uploading file:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;File uploaded successfully!!!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个新的问题出现了，如何搭建一个<strong>本地测试用的服务器</strong>呢？好问题，如下：</p><p>在本地搭建一个测试用的FTP服务器可以使用一些常用的FTP服务器软件来实现，如FileZilla Server， ProFTPD等。</p><ul><li>对于windows系统，可以使用FileZilla Server,下载地址:<a href="https://filezilla-project.org/download.php?type=server">https://filezilla-project.org/download.php?type=server</a> 下载完成后安装，配置好FTP用户名和密码，设置好访问权限，就可以在本地测试使用了。</li><li>对于Linux系统，可以使用ProFTPD, 安装方法可以使用apt-get，yum等安装工具,配置好FTP用户名和密码，设置好访问权限，就可以在本地测试使用了。</li></ul><p><strong>三个注意</strong>：</p><ul><li>首席需要注意的是，在安装和配置FTP服务器的过程中，需要遵循安全原则，如设置强密码，限制访问权限等，以防止未经授权的访问。</li><li>其次还需要注意的是，在使用FTP服务器时需要注意防火墙设置，确保FTP服务器能够正常访问。</li><li>最后需要注意的是，如果您使用的是公网IP地址，需要注意安全性，因为您的FTP服务器可能会被恶意攻击。</li></ul><hr><h3 id="两种方法的对比："><a href="#两种方法的对比：" class="headerlink" title="两种方法的对比："></a>两种方法的对比：</h3><p>使用 Nginx 作为反向代理服务器和使用 GoFTP 上传和下载视频文件，两种方法有一些不同的优缺点。</p><p>使用 Nginx 作为反向代理服务器的优点：</p><ul><li>可以提高系统的安全性，因为 Nginx 可以对用户的请求进行验证和过滤。</li><li>可以实现负载均衡，可以提高系统的可用性和稳定性。</li><li>可以实现缓存功能，可以提高系统的性能。</li></ul><p>使用 Nginx 作为反向代理服务器的缺点：</p><ul><li>可能会增加系统的复杂度。</li><li>可能会增加系统的运维成本。</li></ul><p>使用 GoFTP 上传和下载视频文件的优点：</p><ul><li>不需要使用额外的服务器或框架，可以简化系统的架构。</li><li>可以直接在 Go 程序中实现文件上传和下载功能。</li></ul><p>使用 GoFTP 上传和下载视频文件的缺点：</p><ul><li>可能没有Nginx那么高的安全性，负载均衡和缓存功能。</li><li>可能需要自己手动实现文件上传和下载的功能，运维成本可能更高。</li></ul><p>总结来说，对于需要高安全性，高并发，高可用性的系统，使用 Nginx 作为反向代理服务器可能会更好。但是如果你的系统不需要如此高级的功能，并且希望简化系统架构，减少运维成本，使用 GoFTP 来上传和下载视频文件可能是一个更好的选择。</p><hr><h3 id="两种方法的结合："><a href="#两种方法的结合：" class="headerlink" title="两种方法的结合："></a>两种方法的结合：</h3><p>当然，这两种方法是可以结合起来使用的。</p><ul><li><p>使用 Nginx 作为反向代理服务器，来过滤和验证用户的请求，并将请求转发到 Go 程序中进行处理。</p></li><li><p>在 Go 程序中可以使用 GoFTP 上传和下载视频文件，并在文件上传完成后使用 ffmpeg 进行转码，将转码后的文件保存到数据库。</p></li></ul><p>这样做的好处是，Nginx 可以提供高安全性、高并发、高可用性等功能，而 GoFTP 可以提供简化系统架构、减少运维成本等功能，坏处很显然，就是实现麻烦。</p><hr><h2 id="四、FileZillaServer-X-Plore"><a href="#四、FileZillaServer-X-Plore" class="headerlink" title="四、FileZillaServer + X-Plore"></a>四、FileZillaServer + X-Plore</h2><p>这里介绍一种基于上文<strong>思路二</strong>，使用FileZillaServer + X-Plore实现的<strong>局域网下不同设备之间的文件互传</strong>方法；</p><h3 id="FileZillaServer"><a href="#FileZillaServer" class="headerlink" title="FileZillaServer"></a>FileZillaServer</h3><p><strong>是什么</strong>？</p><p>是能在本地搭建一个测试用的FTP服务器的软件。</p><p><strong>怎么下载怎么用</strong>？</p><p>下载地址：<a href="https://www.filezilla.cn/">FileZilla中文网 - 免费开源的FTP解决方案</a></p><p>前面的安装以及初始化步骤可以参考：</p><p><a href="https://zhuanlan.zhihu.com/p/428058878">FileZilla搭建FTP服务器图解教程 - 知乎 (zhihu.com)</a></p><p>记得第一个要设置为根目录；</p><p>完成设置之后在<strong>本地的资源管理器</strong>中（以前是可以用浏览器的）输入<code>ftp://127.0.0.1</code>进入即可。</p><p>然后就可以看到该用户可以看到的文件列表了。</p><p>这个时候可以为该用户添加<strong>新的可见的非根目录的文件夹</strong>，并且需要人为地指定它在服务器端的路径，例如<code>/myAdditional</code>，随后确定后刷新页面，就可以发现多了一个文件夹，这样就可以做到本地的文件结构和服务器端的不一样。</p><p>有趣的是，这一操作可以让我们<strong>重新组织</strong>本地文件系统下的各个路径。</p><p>还有我们可以使用一个比较方便的可视化的客户端来操作：FileZilla-Client；</p><p>由于操作比较简单这里就不给出介绍了，下载地址同上。</p><hr><h3 id="Android访问FTP服务器"><a href="#Android访问FTP服务器" class="headerlink" title="Android访问FTP服务器"></a>Android访问FTP服务器</h3><p>可供使用的APP有：</p><ul><li>AndFTP</li><li>蚂蚁科技</li><li>Turbo FTP 客户端</li><li>ES 文件资源管理器</li><li>简易 FTP 客户端</li><li>管理员之手应用程序</li><li>Termius - SSH &#x2F; SFTP</li><li>FTP 服务器</li><li>X-Plore</li></ul><p>笔者的选择是X-Plore，非常好用；</p><p>下载之后点击FTP，然后输入刚才在PC端设置的IP（就是cmd中ipconfig的ipv4那个）以及账户+密码，就可以连接到FTP服务器了。</p><p>这个时候我们再运行<strong>思路二中的示例代码</strong>，记得写好要传输的文件，运行即可实现文件互传，非常方便。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言：&lt;/strong&gt;&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;个人博客：&lt;a href=&quot;https://conqueror712.g</summary>
      
    
    
    
    <category term="Devlopment-Tech" scheme="https://conqueror712.github.io/categories/Devlopment-Tech/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux + Shell + Server丨学习记录</title>
    <link href="https://conqueror712.github.io/post/Linux.html"/>
    <id>https://conqueror712.github.io/post/Linux.html</id>
    <published>2022-07-18T05:44:32.000Z</published>
    <updated>2023-03-23T01:29:29.580Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>个人博客：<a href="https://conqueror712.github.io/">https://conqueror712.github.io/</a></p><p>知乎：<a href="https://www.zhihu.com/people/soeur712/posts">https://www.zhihu.com/people/soeur712/posts</a></p><p>Bilibili：<a href="https://space.bilibili.com/57089326">https://space.bilibili.com/57089326</a></p><p>掘金：<a href="https://juejin.cn/user/1297878069809725/posts">https://juejin.cn/user/1297878069809725/posts</a></p></blockquote><h1 id="Linux："><a href="#Linux：" class="headerlink" title="Linux："></a><strong>Linux：</strong></h1><p>目前主流的Linux环境搭建，除了暴力方法（使用钞能力购买一台Linux系统的PC），我们大致有<strong>5种</strong>方案：</p><table><thead><tr><th align="center">方案</th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">单主机安装双系统</td><td align="center">真实的操作系统</td><td align="center">切换麻烦需重启</td></tr><tr><td align="center">双主机安装双系统</td><td align="center">物理隔离</td><td align="center">钞能力</td></tr><tr><td align="center">远程服务器</td><td align="center">真实的操作系统</td><td align="center">性能 带宽 流量 权限有局限</td></tr><tr><td align="center">虚拟机</td><td align="center">完整的使用体验</td><td align="center">资源消耗大 启动缓慢 卡顿 运行效率低</td></tr><tr><td align="center">WSL</td><td align="center">资源消耗小 + 启动迅速 + 无缝切换</td><td align="center">使用体验不完整 部分软件不支持</td></tr><tr><td align="center">Docker</td><td align="center">就是好</td><td align="center">就是好</td></tr></tbody></table><p>下面就我自身而言，说一说我试过的方案。</p><hr><h2 id="更新日志："><a href="#更新日志：" class="headerlink" title="更新日志："></a><strong>更新日志：</strong></h2><p>2022.07.18 创建了该文档，写了一些基本的内容。</p><p>2022.07.19 更新了WSL的安装部分和Docker的安装部分。</p><p>2022.07.20 更新了Linux文件基本属性部分。</p><p>2022.07.22 更新了Linux剩余部分，包括文件内容查看、用户和用户组管理、磁盘管理、vi&#x2F;vim、yum以及apt命令。</p><p>2022.07.23 更新了Shell的简介、变量部分。</p><p>2023.03.18 合并了云服务器学习记录于本文。</p><hr><h3 id="安装部分："><a href="#安装部分：" class="headerlink" title="安装部分："></a><strong>安装部分：</strong></h3><h4 id="单主机安装双系统："><a href="#单主机安装双系统：" class="headerlink" title="单主机安装双系统："></a>单主机安装双系统：</h4><p>本人参考了这位大佬的教程，简单易懂，小狗狗看了都说学会了。</p><p><a href="https://www.bilibili.com/video/BV1554y1n7zv?p=1&totalPage=16">Windows 和 Ubuntu 双系统从安装到卸载_哔哩哔哩_bilibili</a></p><p>系统的安装文件在这里：</p><p><a href="https://cn.ubuntu.com/">企业开源和Linux | Ubuntu</a></p><hr><h3 id="WSL："><a href="#WSL：" class="headerlink" title="WSL："></a>WSL：</h3><p>本人使用的是WSL 2，具体的安装过程有两种办法：</p><p>​直接在Windows控制台中输入<code>wsl --install -d &lt;你想安装的发行版本&gt;</code>，例如<code>ubuntu</code>；</p><p>紧接着等待安装后输入用户名和密码然后重启即可，注意，用户名首字母不能大写；</p><p>重启之后，我们在开始菜单里输入Ubuntu就可以看到已经安装好了，进入即可。</p><p>我们可以看到的是，在打开的Ubuntu命令行中输入python3会直接进入预装的Python中，我这里的版本是3.8。</p><p>我们也可以键入<code>sudo apt-get update</code>来更新一些东西。</p><hr><h3 id="Docker："><a href="#Docker：" class="headerlink" title="Docker："></a>Docker：</h3><p>傻瓜式安装好Docker之后，如果弹出类似于WSL 2 installation is incomplete之类的东西，然后让你restart的话，那么可以在控制面板中找到Windows功能，勾选上适用于<strong>Linux的Windows子系统</strong>之后再下载一个更新包，更新之后restart即可。</p><p>更新包地址：<a href="https://link.zhihu.com/?target=https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi">https://link.zhihu.com/?target=https%3A//wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi</a></p><hr><h2 id="1-Linux文件基本属性"><a href="#1-Linux文件基本属性" class="headerlink" title="1 .Linux文件基本属性"></a><strong>1 .Linux文件基本属性</strong></h2><ul><li>chown (change owner) ： 修改所属用户与组。</li><li>chmod (change mode) ： 修改用户的权限。</li></ul><h3 id="查看文件属性："><a href="#查看文件属性：" class="headerlink" title="查看文件属性："></a>查看文件属性：</h3><p>查看文件的属性以及文件所属的用户和组（Linux系统是一种典型的多用户系统，不同的用户拥有不同的权限）：</p><p><img src="https://s2.loli.net/2022/07/20/KdjuM2pOF6VeGYA.png" alt="avatar"></p><p>对于第0个字符：</p><ul><li>当为 <strong>d</strong> 则是目录</li><li>当为 <strong>-</strong> 则是文件；</li><li>若是 <strong>l</strong> 则表示为链接文档(link file)；</li><li>若是 <strong>b</strong> 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；</li><li>若是 <strong>c</strong> 则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。</li></ul><h3 id="更改文件属性："><a href="#更改文件属性：" class="headerlink" title="更改文件属性："></a>更改文件属性：</h3><h4 id="数字更改法："><a href="#数字更改法：" class="headerlink" title="数字更改法："></a>数字更改法：</h4><ul><li><p>chgrp：更改文件属组：</p><p>  <code>chgrp [-R] 属组名 文件名</code>（-R是递归更改文件的属组，该目录下的所有文件的属组都会更改）</p></li><li><p>chown：更改文件属主（也可以同时更改文件属组）：</p><p>  <code>chown [-R] 属主名 文件名</code></p><p>  <code>chown [-R] 属主名: 属组名 文件名</code></p></li><li><p>chmod：更改文件9个属性  ：</p><table><thead><tr><th align="center"></th><th align="center">owner(user)</th><th align="center">group</th><th align="center">others</th></tr></thead><tbody><tr><td align="center"><strong>read</strong></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>write</strong></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>execute</strong></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p>  我们用数字来代表各个权限：r &#x3D; 4w &#x3D; 2x &#x3D; 1</p><p>  例如，当权限为<code>-rwxrwx---</code>时，分数规则就是：</p><p>  owner &#x3D; 4 + 2 + 1 &#x3D; 7</p><p>  group &#x3D; 4 + 2 + 1 &#x3D; 7</p><p>  others &#x3D; 0 + 0 + 0 &#x3D; 0</p><p>  故该文件的权限数字就是<code>770</code> &#x3D;&#x3D; <code>xyz</code></p><p>  变更权限的命令：<code>chmod [-R] xyz 文件或目录</code></p></li></ul><p>更改完成后不妨再用<code>ls -l</code>再查看一遍文件属性，以确保更改生效。</p><h4 id="符号更改法："><a href="#符号更改法：" class="headerlink" title="符号更改法："></a>符号更改法：</h4><p>我们可以使用 <strong>u, g, o</strong> 来代表三种身份的权限，<strong>a</strong>代表all，也就是对于所有的身份。</p><p>**+**代表加入**-**代表除去**&#x3D;**代表设定<code>chmod u=rwx,g=rx,o=r 文件名</code></p><p>​<em>PS: 部分参考自runoob</em></p><hr><h2 id="2-Linux文件与目录管理："><a href="#2-Linux文件与目录管理：" class="headerlink" title="2. Linux文件与目录管理："></a><strong>2. Linux文件与目录管理：</strong></h2><ul><li>绝对路径：从根目录<code>/</code>写起；</li><li>相对路径：例如由 <code>/usr/share/doc</code> 要到 <code>/usr/share/man</code> 底下时，可以写成： <code>cd ../man</code> ；</li></ul><h3 id="处理目录的常用命令："><a href="#处理目录的常用命令：" class="headerlink" title="处理目录的常用命令："></a>处理目录的常用命令：</h3><ul><li>ls（list files）: 列出目录及文件名</li><li>cd（change directory）：切换目录</li><li>pwd（print work directory）：显示目前的目录</li><li>mkdir（make directory）：创建一个新的目录</li><li>rmdir（remove directory）：删除一个空的目录</li><li>cp（copy file）: 复制文件或目录</li><li>rm（remove）: 删除文件或目录</li><li>mv（move file）: 移动文件与目录，或修改文件与目录的名称</li></ul><p>当你忘记某个命令应该如何使用的时候，你可以使用man [命令]来查看使用文档，例如man ls；(manner)</p><p>由于我比较懒，我就不列出每个命令的用法了，我也是在使用的时候再查找参考文档的（逃）。</p><h3 id="Linux文件内容查看："><a href="#Linux文件内容查看：" class="headerlink" title="Linux文件内容查看："></a>Linux文件内容查看：</h3><ul><li>cat 由第一行开始显示文件内容</li><li>tac 从最后一行开始显示（tac 是 cat 的倒过来）</li><li>nl  显示的时候，顺道输出行号</li><li>more 一页一页的显示文件内容</li><li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页</li><li>head 只看头几行</li><li>tail 只看尾巴几行</li></ul><p>同样地，当你忘记某个命令应该如何使用的时候，你可以使用man [命令]来查看使用文档，例如man cat；(manner)</p><hr><h2 id="3-Linux用户和用户组管理："><a href="#3-Linux用户和用户组管理：" class="headerlink" title="3. Linux用户和用户组管理："></a><strong>3. Linux用户和用户组管理：</strong></h2><h3 id="Linux系统用户账号的管理："><a href="#Linux系统用户账号的管理：" class="headerlink" title="Linux系统用户账号的管理："></a>Linux系统用户账号的管理：</h3><ol><li>添加新的用户账号命令：<code>useradd 选项 用户名</code></li></ol><ul><li><p>选项:</p><ul><li><p>-c comment 指定一段注释性描述</p></li><li><p>-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录</p></li><li><p>-g 用户组 指定用户所属的用户组</p></li><li><p>-G 用户组，用户组 指定用户所属的附加组</p></li><li><p>-s Shell文件 指定用户的登录Shell</p></li><li><p>-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号</p></li></ul></li></ul><ol start="2"><li>删除账号命令：<code>userdel 选项 用户名</code></li></ol><p>​常用的选项是<code>-r</code>，作用是把用户的主目录一起删除；</p><ol start="3"><li><p>修改账号命令：<code>usermod 选项 用户名</code></p><p> 常用的选项与<code>useradd</code>一致，不同的是，有些系统可以使用选项<code>-l 新用户名</code></p><p> （虽然不太清楚这个的区别在哪里但是还是记录上为好）</p></li><li><p>用户口令的管理命令：<code>passwd 选项 用户名</code></p><p> 用户账号刚创建时没有口令，被系统锁定无法使用，必须为其指定了口令之后才可以使用，即使是空的口令。</p><p> 可使用的选项：</p><ul><li>-l 锁定口令，即禁用账号</li><li>-u 口令解锁。</li><li>-d 使账号无口令。</li><li>-f 强迫用户下次登录时修改口令</li></ul><p> 特别地，如果是默认用户名，则修改当前用户的口令。</p></li></ol><h3 id="Linux系统用户组的管理："><a href="#Linux系统用户组的管理：" class="headerlink" title="Linux系统用户组的管理："></a>Linux系统用户组的管理：</h3><ol><li><p>增加一个新的用户组命令：<code>groupadd 选项 用户组</code></p><p> 可用选项：</p><ul><li>-g GID 指定新用户组的组标识号（GID）。</li><li>-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。</li></ul><p> 如果不写GID，则默认是在当前已有的最大组标识号的基础上+1；</p><p> <code>groupadd group1</code></p><p> <code>groupadd -g 114514 group2</code></p></li><li><p>删除一个已有的用户组命令：<code>groupdel 用户组</code></p></li><li><p>修改用户组的属性指令：<code>groupmod 选项 用户组</code></p><p> 可用选项：</p><ul><li>-g GID 为用户组指定新的组标识号。</li><li>-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。</li><li>-n新用户组 将用户组的名字改为新名字</li></ul><p> 例如：</p><p> <code># groupmod –g 10000 -n group3 group2</code></p><p> 此命令将组group2的标识号改为10000，组名修改为group3。</p></li><li><p>如果一个用户同时属于多个用户组，那么用户可以在用户组之间且耳环，以便具有其他用户组的权限。</p><p> 命令：<code>$ newgrp root</code></p></li></ol><h3 id="与用户账号有关的系统文件："><a href="#与用户账号有关的系统文件：" class="headerlink" title="与用户账号有关的系统文件："></a>与用户账号有关的系统文件：</h3><p>与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括&#x2F;etc&#x2F;passwd, &#x2F;etc&#x2F;shadow, &#x2F;etc&#x2F;group等。</p><ol><li><p>&#x2F;etc&#x2F;passwd文件是用户管理工作涉及的最重要的一个文件，每个用户都在该文件中有一个对应的记录行，记录了该用户的一些基本属性，并且该文件对于所有用户都是可读的，每行的格式如下：</p><p> <code>用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell</code></p><p> 例如：<code>adm:x:4:4:System accounting:/usr/adm:</code> （冒号为分隔符，在名称的命名中不能随便使用）</p><p> 其中有一些含义与注意事项，这里直接引用runoob上的内容：</p><blockquote><p><strong>1）”用户名”是代表用户账号的字符串。</strong></p><p>通常长度不超过8个字符，并且由大小写字母和&#x2F;或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。</p><p>为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。</p><p><strong>2）“口令”一些系统中，存放着加密后的用户口令字。</strong></p><p>虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于&#x2F;etc&#x2F;passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到&#x2F;etc&#x2F;shadow文件中，而在&#x2F;etc&#x2F;passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。</p><p><strong>3）“用户标识号”是一个整数，系统内部用它来标识用户。</strong></p><p>一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。</p><p>通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。</p><p><strong>4）“组标识号”字段记录的是用户所属的用户组。</strong></p><p>它对应着&#x2F;etc&#x2F;group文件中的一条记录。</p><p><strong>5)“注释性描述”字段记录着用户的一些个人情况。</strong></p><p>例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用做finger命令的输出。</p><p><strong>6)“主目录”，也就是用户的起始工作目录。</strong></p><p>它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。</p><p><strong>7)用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。</strong></p><p>Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX&#x2F;TOPS-20 type C Shell), bash(Bourne Again Shell)等。</p><p>系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为&#x2F;bin&#x2F;sh。</p><p>用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。</p><p>利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。</p><p><strong>8)系统中有一类用户称为伪用户（pseudo users）。</strong></p><p>这些用户在&#x2F;etc&#x2F;passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。</p><p>常见的伪用户如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">伪 用 户 含 义 </span><br><span class="line">bin 拥有可执行的用户命令文件 </span><br><span class="line">sys 拥有系统文件 </span><br><span class="line">adm 拥有帐户文件 </span><br><span class="line">uucp UUCP使用 </span><br><span class="line">lp lp或lpd子系统使用 </span><br><span class="line">nobody NFS使用</span><br></pre></td></tr></table></figure></blockquote></li><li><p>拥有账户文件</p><p> &#x2F;etc&#x2F;shadow文件只有超级用户才拥有这个文件的读权限，可以保证用户密码的安全性；</p><p> 并且其中的记录行与&#x2F;etc&#x2F;passwd中一一对应，由pwconv自动产生：</p><p> <code>登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</code></p><blockquote><ol><li>“登录名”是与&#x2F;etc&#x2F;passwd文件中的登录名相一致的用户账号</li><li>“口令”字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { .&#x2F;0-9A-Za-z }中的字符，则对应的用户不能登录。</li><li>“最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。</li><li>“最小时间间隔”指的是两次修改口令之间所需的最小天数。</li><li>“最大时间间隔”指的是口令保持有效的最大天数。</li><li>“警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。</li><li>“不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。</li><li>“失效时间”字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。</li></ol></blockquote></li><li><p>用户组的所有信息都存放在&#x2F;etc&#x2F;group文件中</p><p> <code>组名:口令:组标识号:组内用户列表</code></p><blockquote><ol><li>“组名”是用户组的名称，由字母或数字构成。与&#x2F;etc&#x2F;passwd中的登录名一样，组名不应重复。</li><li>“口令”字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。</li><li>“组标识号”与用户标识号类似，也是一个整数，被系统内部用来标识组。</li><li>“组内用户列表”是属于这个组的所有用户的列表，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。</li></ol></blockquote></li><li><p>批量添加用户</p><p> 步骤如下：</p><p> （1）先编辑一个文本用户文件。</p><p> （2）以root身份执行命令 <code>/usr/sbin/newusers</code>，从刚创建的用户文件<code>user.txt</code>中导入数据，创建用户：</p><p> （3）执行命令&#x2F;usr&#x2F;sbin&#x2F;pwunconv。</p><p> （4）编辑每个用户的密码对照文件。</p><p> （5）以 root 身份执行命令 <code>/usr/sbin/chpasswd</code>。</p><p> （6）确定密码经编码写入&#x2F;etc&#x2F;passwd的密码栏后。</p></li></ol><hr><h2 id="4-Linux磁盘管理："><a href="#4-Linux磁盘管理：" class="headerlink" title="4. Linux磁盘管理："></a><strong>4. Linux磁盘管理：</strong></h2><p>磁盘管理与系统性能有着直接关系；</p><h3 id="磁盘管理常用命令："><a href="#磁盘管理常用命令：" class="headerlink" title="磁盘管理常用命令："></a>磁盘管理常用命令：</h3><p>Linux 磁盘管理常用三个命令为 <strong>df</strong>、<strong>du</strong> 和 <strong>fdisk</strong>。</p><ul><li><strong>df</strong>（英文全称：disk free）：列出文件系统的整体磁盘使用量</li><li><strong>du</strong>（英文全称：disk used）：检查磁盘空间使用量</li><li><strong>fdisk</strong>：用于磁盘分区</li></ul><h4 id="df"><a href="#df" class="headerlink" title="df"></a>df</h4><p>df命令参数功能：检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。</p><p>语法：<code>df [-ahikHTm] [目录或文件名]</code></p><p>选项与参数：</p><ul><li>-a ：列出所有的文件系统，包括系统特有的 &#x2F;proc 等文件系统；</li><li>-k ：以 KBytes 的容量显示各文件系统；</li><li>-m ：以 MBytes 的容量显示各文件系统；</li><li>-h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；</li><li>-H ：以 M&#x3D;1000K 取代 M&#x3D;1024K 的进位方式；</li><li>-T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；</li><li>-i ：不用硬盘容量，而以 inode 的数量来显示</li></ul><h4 id="du"><a href="#du" class="headerlink" title="du"></a>du</h4><p>Linux du 命令也是查看使用空间的，但是与 df 命令不同的是 Linux du 命令是对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的，这里介绍 Linux du 命令。</p><p>语法：<code>du [-ahskm] 文件或目录名称</code></p><p>选项与参数：</p><ul><li>-a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。</li><li>-h ：以人们较易读的容量格式 (G&#x2F;M) 显示；</li><li>-s ：列出总量而已，而不列出每个各别的目录占用容量；</li><li>-S ：不包括子目录下的总计，与 -s 有点差别。</li><li>-k ：以 KBytes 列出容量显示；</li><li>-m ：以 MBytes 列出容量显示；</li></ul><h4 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h4><p>fdisk 是 Linux 的磁盘分区表操作工具。</p><p>语法：<code>fdisk [-l] 装置名称</code></p><p>选项与参数：</p><p>​-l ：输出后面接的装置所有的分区内容。若仅有 fdisk -l 时， 则系统将会把整个系统内能够搜寻到的装置的分区均列出来。</p><h3 id="磁盘格式化："><a href="#磁盘格式化：" class="headerlink" title="磁盘格式化："></a>磁盘格式化：</h3><p>磁盘分割完毕后自然就是要进行文件系统的格式化，格式化的命令非常的简单，使用 <code>mkfs</code>（make filesystem） 命令。</p><p>语法：<code>mkfs [-t 文件系统格式] 装置文件名</code></p><p>选项与参数：</p><p>​-t ：可以接文件系统格式，例如 ext3, ext2, vfat 等(系统有支持才会生效)</p><h3 id="磁盘检验："><a href="#磁盘检验：" class="headerlink" title="磁盘检验："></a>磁盘检验：</h3><p>fsck（file system check）用来检查和维护不一致的文件系统。</p><p>若系统掉电或磁盘发生问题，可利用fsck命令对文件系统进行检查。</p><p>语法：<code>fsck [-t 文件系统] [-ACay] 装置名称</code></p><p>选项与参数：</p><ul><li>-t : 给定档案系统的型式，若在 &#x2F;etc&#x2F;fstab 中已有定义或 kernel 本身已支援的则不需加上此参数</li><li>-s : 依序一个一个地执行 fsck 的指令来检查</li><li>-A : 对&#x2F;etc&#x2F;fstab 中所有列出来的 分区（partition）做检查</li><li>-C : 显示完整的检查进度</li><li>-d : 打印出 e2fsck 的 debug 结果</li><li>-p : 同时有 -A 条件时，同时有多个 fsck 的检查一起执行</li><li>-R : 同时有 -A 条件时，省略 &#x2F; 不检查</li><li>-V : 详细显示模式</li><li>-a : 如果检查有错则自动修复</li><li>-r : 如果检查有错则由使用者回答是否修复</li><li>-y : 选项指定检测每个文件是自动输入yes，在不确定那些是不正常的时候，可以执行 # fsck -y 全部检查修复。</li></ul><h3 id="磁盘挂载与卸除："><a href="#磁盘挂载与卸除：" class="headerlink" title="磁盘挂载与卸除："></a>磁盘挂载与卸除：</h3><p>Linux 的磁盘挂载使用 <code>mount</code> 命令，卸载使用 <code>umount</code> 命令。</p><p>语法：<code>xxxxxxxxxx mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n]  装置文件名  挂载点</code></p><hr><h2 id="5-Linux-vi-x2F-vim："><a href="#5-Linux-vi-x2F-vim：" class="headerlink" title="5. Linux vi &#x2F; vim："></a><strong>5. Linux vi &#x2F; vim：</strong></h2><p><img src="https://s2.loli.net/2022/07/22/n3jbDOhtvfrgSeT.gif" alt="avatar"></p><p>（此部分因为本人还没有熟悉Vim的操作，故暂以一图略之）</p><hr><h2 id="6-Linux-yum命令："><a href="#6-Linux-yum命令：" class="headerlink" title="6. Linux yum命令："></a><strong>6. Linux yum命令：</strong></h2><p>Yellow dog Updater, Modified 是一个在 Fedora 和 RedHat 以及 SUSE 中的 Shell 前端软件包管理器。</p><p>基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。</p><h3 id="yum-语法："><a href="#yum-语法：" class="headerlink" title="yum 语法："></a>yum 语法：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum [options] [command] [package ...]</span><br></pre></td></tr></table></figure><ul><li><strong>options：</strong>可选，选项包括-h（帮助），-y（当安装过程提示选择全部为 “yes”），-q（不显示安装的过程）等等。</li><li><strong>command：</strong>要进行的操作。</li><li><strong>package：</strong>安装的包名。</li></ul><h3 id="yum常用命令"><a href="#yum常用命令" class="headerlink" title="yum常用命令"></a>yum常用命令</h3><ul><li>列出所有可更新的软件清单命令：<strong>yum check-update</strong></li><li>更新所有软件命令：<strong>yum update</strong></li><li>仅安装指定的软件命令：<strong>yum install <package_name></strong></li><li>仅更新指定的软件命令：<strong>yum update <package_name></strong></li><li>列出所有可安裝的软件清单命令：<strong>yum list</strong></li><li>删除软件包命令：<strong>yum remove <package_name></strong></li><li>查找软件包命令：<strong>yum search <keyword></strong></li><li>清除缓存命令:<ul><li><strong>yum clean packages</strong>: 清除缓存目录下的软件包</li><li><strong>yum clean headers</strong>: 清除缓存目录下的 headers</li><li><strong>yum clean oldheaders</strong>: 清除缓存目录下旧的 headers</li><li><strong>yum clean, yum clean all (&#x3D; yum clean packages; yum clean oldheaders)</strong> :清除缓存目录下的软件包及旧的 headers</li></ul></li></ul><h3 id="国内-yum-源"><a href="#国内-yum-源" class="headerlink" title="国内 yum 源"></a>国内 yum 源</h3><p>网易（163）yum源是国内最好的yum源之一 ，无论是速度还是软件版本，都非常的不错。</p><p>将yum源设置为163 yum，可以提升软件包安装和更新的速度，同时避免一些常见软件版本无法找到。</p><h4 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h4><p>首先备份&#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br></pre></td></tr></table></figure><p>下载对应版本 repo 文件, 放入 &#x2F;etc&#x2F;yum.repos.d&#x2F; (操作前请做好相应备份)</p><ul><li><a href="http://mirrors.163.com/.help/CentOS5-Base-163.repo">CentOS5</a> ：<a href="http://mirrors.163.com/.help/CentOS5-Base-163.repo">http://mirrors.163.com/.help/CentOS5-Base-163.repo</a></li><li><a href="http://mirrors.163.com/.help/CentOS6-Base-163.repo">CentOS6</a> ：<a href="http://mirrors.163.com/.help/CentOS6-Base-163.repo">http://mirrors.163.com/.help/CentOS6-Base-163.repo</a></li><li><a href="http://mirrors.163.com/.help/CentOS7-Base-163.repo">CentOS7</a> ：<a href="http://mirrors.163.com/.help/CentOS7-Base-163.repo">http://mirrors.163.com/.help/CentOS7-Base-163.repo</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http://mirrors.163.com/.help/CentOS6-Base-163.repo</span><br><span class="line">mv CentOS6-Base-163.repo CentOS-Base.repo</span><br></pre></td></tr></table></figure><p>运行以下命令生成缓存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br></pre></td></tr></table></figure><hr><h2 id="7-Linux-apt命令："><a href="#7-Linux-apt命令：" class="headerlink" title="7. Linux apt命令："></a><strong>7. Linux apt命令：</strong></h2><p>Advanced Packaging Tool  是一个在 Debian 和 Ubuntu 中的 Shell 前端软件包管理器。</p><p>apt 命令提供了查找、安装、升级、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p><p>apt 命令执行需要超级管理员权限(root)。</p><h3 id="apt-语法"><a href="#apt-语法" class="headerlink" title="apt 语法"></a>apt 语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt [options] [command] [package ...]</span><br></pre></td></tr></table></figure><ul><li><strong>options：</strong>可选，选项包括 -h（帮助），-y（当安装过程提示选择全部为”yes”），-q（不显示安装的过程）等等。</li><li><strong>command：</strong>要进行的操作。</li><li><strong>package</strong>：安装的包名。</li></ul><h3 id="apt-常用命令"><a href="#apt-常用命令" class="headerlink" title="apt 常用命令"></a>apt 常用命令</h3><ul><li><p>列出所有可更新的软件清单命令：<strong>sudo apt update</strong></p></li><li><p>升级软件包：<strong>sudo apt upgrade</strong></p><p>  列出可更新的软件包及版本信息：<strong>apt list –upgradeable</strong></p><p>  升级软件包，升级前先删除需要更新软件包：<strong>sudo apt full-upgrade</strong></p></li><li><p>安装指定的软件命令：<strong>sudo apt install <package_name></strong></p><p>  安装多个软件包：<strong>sudo apt install <package_1> <package_2> <package_3></strong></p></li><li><p>更新指定的软件命令：<strong>sudo apt update <package_name></strong></p></li><li><p>显示软件包具体信息,例如：版本号，安装大小，依赖关系等等：<strong>sudo apt show <package_name></strong></p></li><li><p>删除软件包命令：<strong>sudo apt remove <package_name></strong></p></li><li><p>清理不再使用的依赖和库文件: <strong>sudo apt autoremove</strong></p></li><li><p>移除软件包及配置文件: <strong>sudo apt purge <package_name></strong></p></li><li><p>查找软件包命令： <strong>sudo apt search <keyword></strong></p></li><li><p>列出所有已安装的包：<strong>apt list –installed</strong></p></li><li><p>列出所有已安装的包的版本信息：<strong>apt list –all-versions</strong></p></li></ul><hr><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="Shell："><a href="#Shell：" class="headerlink" title="Shell："></a><strong>Shell：</strong></h1><p>Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。</p><p>Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。</p><p>Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。</p><h2 id="Shell脚本："><a href="#Shell脚本：" class="headerlink" title="Shell脚本："></a>Shell脚本：</h2><p>Shell Script与Shell概念不同，但是业界一般直接用Shell来代指Shell脚本。</p><h2 id="Shell环境："><a href="#Shell环境：" class="headerlink" title="Shell环境："></a>Shell环境：</h2><p>Linux常见的Shell种类众多：</p><ul><li>Bourne Shell（&#x2F;usr&#x2F;bin&#x2F;sh或&#x2F;bin&#x2F;sh）</li><li><strong>Bourne Again Shell（&#x2F;bin&#x2F;bash）</strong></li><li>C Shell（&#x2F;usr&#x2F;bin&#x2F;csh）</li><li>K Shell（&#x2F;usr&#x2F;bin&#x2F;ksh）</li><li>Shell for Root（&#x2F;sbin&#x2F;sh）</li></ul><p>我本人学习的是<strong>Bash</strong>，这也是许多Linux系统的默认Shell</p><p><code>#!</code>是告诉系统 其后路径所指定的程序即是解释此脚本文件的Shell程序（说人话就是这个脚本需要什么解释器来执行）。</p><p>这里给出<em>runoob</em>的一个在线编辑器：<a href="https://www.runoob.com/try/showbash.php?filename=helloworld"><strong>Shell 在线工具</strong></a></p><p>Shell脚本的扩展名为.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &quot;Hello World!&quot;</span><br></pre></td></tr></table></figure><p>运行Shell脚本的两种方法：</p><ol><li>作为可执行程序cd到对应的.sh目录下之后</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ./test.sh#使脚本具有执行权限，参考之前的Linux命令部分</span><br><span class="line">./test.sh#执行脚本</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果写成test.sh 则Linux会去PATH寻找有没有这个路径 所以会出现找不到的情况</span></span><br></pre></td></tr></table></figure><pre><code>2. 作为解释器参数 就是直接运行解释器 参数直接写Shell脚本的文件名（个人感觉比较方便）</code></pre><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh test.sh#这里就不用写成./的形式了</span><br></pre></td></tr></table></figure><hr><h2 id="Shell变量："><a href="#Shell变量：" class="headerlink" title="Shell变量："></a><strong>Shell变量：</strong></h2><p>定义变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">YourName = &quot;LiHua&quot;#没有$</span><br></pre></td></tr></table></figure><p>注意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：</p><ul><li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li><li>中间不能有空格，可以使用下划线_。</li><li>不能使用标点符号。</li><li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li></ul><p>使用变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo $YourName#需要加$</span><br><span class="line">echo $&#123;YourName&#125;#大括号是可选的 目的是为了帮助解释器识别变量的边界</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">变量也可以被重定义 会覆盖掉</span></span><br></pre></td></tr></table></figure><p>只读变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">LiHua_Math_Score = &quot;59&quot;</span><br><span class="line">readonly LiHua_Math_Score</span><br></pre></td></tr></table></figure><p>删除变量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LiHua_Math_Score = &quot;59&quot;</span><br><span class="line">unset Lihua_Math_Score</span><br><span class="line">echo $Lihua_Math_Score#实际上并没有任何东西被输出</span><br></pre></td></tr></table></figure><p>变量类型：</p><ul><li><strong>局部变量</strong> 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。</li><li><strong>环境变量</strong> 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</li><li><strong>shell变量</strong> shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</li></ul><h2 id="Shell字符串："><a href="#Shell字符串：" class="headerlink" title="Shell字符串："></a>Shell字符串：</h2><p>Shell的字符串可以用单引号 双引号 甚至无引号不过功能不太一样；</p><p>单引号字符串的限制：</p><ul><li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；</li><li>单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</li></ul><p>双引号的优点：</p><ul><li>双引号里可以有变量</li><li>双引号里可以出现转义字符</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">获取字符串长度</span></span><br><span class="line">str=&quot;BoyNextDoor&quot;</span><br><span class="line">echo $&#123;#str&#125;#输出11</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">提取子字符串</span></span><br><span class="line">str=&quot;BoyNextDoor&quot;</span><br><span class="line">echo $&#123;str:1:4&#125;#输出oyNe</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查找子字符串</span></span><br><span class="line">str=&quot;BoyNextDoor&quot;</span><br><span class="line">echo `expr index &quot;$str&quot; ND`#输出4（这里是1_base）</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">特别地，最后一个参数若输入多个字符，则哪个字符先出现就先计算哪个</span></span><br></pre></td></tr></table></figure><h2 id="Shell数组："><a href="#Shell数组：" class="headerlink" title="Shell数组："></a>Shell数组：</h2><p>bash不支持多维数组 并且不限制数组的大小 0_base</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">定义数组</span></span><br><span class="line">Student_Score=(99 66 67 85)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">单独定义或修改</span></span><br><span class="line">Student_Score[0]=59#可以不使用连续的下标 并且下标的范围没有限制</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">读取数组</span></span><br><span class="line">tmp_value=$&#123;Student_Score[2]&#125;</span><br><span class="line">echo $&#123;array_name[@]&#125;# @符号可以获取数组中的所有元素</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">获取数组长度（与字符串相同）</span></span><br><span class="line">length=$&#123;#Student_Score[@]&#125;# 取得数组元素的个数</span><br><span class="line">length=$&#123;#Student_Score[*]&#125;# 或者</span><br><span class="line">lengthn=$&#123;#Student_Score[n]&#125;# 取得数组单个元素的长度</span><br></pre></td></tr></table></figure><h2 id="Shell注释："><a href="#Shell注释：" class="headerlink" title="Shell注释："></a>Shell注释：</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--------------------------------------------</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这是一个注释</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">author：Conqueror712</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">site：...</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">--------------------------------------------</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">也可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">多行注释</span></span><br><span class="line">:&lt;&lt;EOF</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这其中 EOF也可以用别的符号替换 例如 ?</span></span><br></pre></td></tr></table></figure><hr><h1 id="Cloud-Server："><a href="#Cloud-Server：" class="headerlink" title="Cloud - Server："></a>Cloud - Server：</h1><h2 id="前言部分："><a href="#前言部分：" class="headerlink" title="前言部分："></a>前言部分：</h2><h3 id="需要知道的："><a href="#需要知道的：" class="headerlink" title="需要知道的："></a>需要知道的：</h3><ul><li>知道服务器的IP地址（最好是静态IP地址，不会变）</li><li>账号密码的创建，如果是root用户就直接adduser xxx，创建完在&#x2F;home&#x2F;下查看</li></ul><h3 id="使用SSH终端连接服务器："><a href="#使用SSH终端连接服务器：" class="headerlink" title="使用SSH终端连接服务器："></a>使用SSH终端连接服务器：</h3><ul><li>对于Windows，可以用Xmanager，也可以用Termius（界面不错）</li></ul><h3 id="创建自己的虚拟环境："><a href="#创建自己的虚拟环境：" class="headerlink" title="创建自己的虚拟环境："></a>创建自己的虚拟环境：</h3><ul><li>Anaconda &amp; pip</li></ul><h3 id="文件上传下载："><a href="#文件上传下载：" class="headerlink" title="文件上传下载："></a>文件上传下载：</h3><ul><li>可以用xftp或FileZilla</li></ul><h3 id="在服务器上部署代码："><a href="#在服务器上部署代码：" class="headerlink" title="在服务器上部署代码："></a>在服务器上部署代码：</h3><ul><li>可以本地写好后传上去（Pycharm远程调试）</li><li>也可以直接在服务器上写（Vim）</li><li>还可以使用Windows自带的远程桌面，但是需要在服务器端装上Xrdp</li></ul><h3 id="服务器间传输文件scp："><a href="#服务器间传输文件scp：" class="headerlink" title="服务器间传输文件scp："></a>服务器间传输文件scp：</h3><p>​<code>scp -r &lt;filename&gt; user@&lt;target_ip&gt;:Desktop/&lt;filename1&gt;/...</code></p><h3 id="在外地如何连接："><a href="#在外地如何连接：" class="headerlink" title="在外地如何连接："></a>在外地如何连接：</h3><ul><li>例如之前是用的校园网内网，那非校园网环境，没有vpn的情况下就没办法直接访问内网，那么就需要建立用户与内网之间的联系</li><li>或者直接使用远程桌面的软件，ToDesk，TeamViewer，向日葵等等。</li></ul><hr><h2 id="深度学习环境搭建流程："><a href="#深度学习环境搭建流程：" class="headerlink" title="深度学习环境搭建流程："></a>深度学习环境搭建流程：</h2><ol><li>操作系统</li><li>显卡驱动<code>https://www.nvidia.cn/Download/index.aspx?lang=cn</code></li><li>Cuda<code>https://developer.nvidia.com/cuda-toolkit-archive</code></li><li>Cudnn<code>https://developer.nvidia.com/rdp/cudnn-archive</code></li><li>Pytorch &#x2F; Tensorflow<code>https://pytorch.org/get-started/previous-versions/</code></li></ol><h3 id="显卡驱动安装流程："><a href="#显卡驱动安装流程：" class="headerlink" title="显卡驱动安装流程："></a>显卡驱动安装流程：</h3><p>显卡驱动安装完之后应该是一个.run文件，之后应进行如下操作：</p><ol><li>关闭图形界面（否则跑不起来）<code>sudo service lightdm stop</code></li><li>让.run文件可执行<code>sudo chmod a+x NVIDIA-Linux-x86_64-375.39.rum</code>（具体文件名称需要看自己下载的是什么版本）</li><li><code>sudo sh NVIDIA-Linux-x86_64-375.39.run -no-x-check -no-nouveau-check -no-opengl-files</code>（运行.run文件，并不需要对x文件进行检查）</li><li>查看是否安装成功<code>nvidia-smi</code></li></ol><h3 id="CUDA安装流程："><a href="#CUDA安装流程：" class="headerlink" title="CUDA安装流程："></a>CUDA安装流程：</h3><p>对于版本：若有特定需求则按特定需求，否则尽量选择较高版本（但最好不要最新）的整数版本</p><p>下载可以直接<code>wget &lt;网址&gt;</code></p><p>下载下来之后也是一个.run文件，直接<code>sudo sh &lt;文件名&gt;</code>就可以进行安装了</p><p>在安装过程中，当询问是否安装显卡驱动时，选择No即可（因为之前已经安装过了）</p><p>安装成功之后使用<code>nvcc -V</code>进行安装检查</p><p>如果检查报错，则需要配置环境变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cd /home/zhangsan/</span><br><span class="line"></span><br><span class="line">vim .bashrc</span><br><span class="line"></span><br><span class="line">export PATH=/usr/local/cuda-xxx/bin:$PATH</span><br><span class="line"></span><br><span class="line">export LD_LIBRARY_PATH=/usr/local/cuda-xxx/lib64</span><br><span class="line"></span><br><span class="line">source .bashrc</span><br></pre></td></tr></table></figure><h3 id="CUDNN安装流程："><a href="#CUDNN安装流程：" class="headerlink" title="CUDNN安装流程："></a>CUDNN安装流程：</h3><p>进入网址，选择对应自己CUDA版本的CUDNN，再选择Library for Linux(x86_64)</p><p>解压之后是一个cuda文件夹</p><p><code>sudo cp cuda/include/cudnn.h /usr/local/cuda/include/</code></p><p><code>sudo cp cuda/lib64/libcudnn* /usr/local/cuda/lib64/</code></p><h3 id="Pytorch的安装流程："><a href="#Pytorch的安装流程：" class="headerlink" title="Pytorch的安装流程："></a>Pytorch的安装流程：</h3><ol><li>需要有Python</li><li>安装anacocnda（也需要设置环境变量）</li><li>注意安装前需要先创建并激活conda环境</li></ol><hr><h2 id="AutoDL使用笔记："><a href="#AutoDL使用笔记：" class="headerlink" title="AutoDL使用笔记："></a>AutoDL使用笔记：</h2><p>autodl-tmp是数据库</p><p>tf-logs是默认使用tensorflow的tensorboard的使用文件夹</p><p><code>df -h</code>查看文件和目录占用容量信息</p><p><code>nvidia-smi</code>查看GPU监控信息</p><hr><p>未完待续…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;个人博客：&lt;a href=&quot;https://conqueror712.github.io/&quot;&gt;https://conqueror712.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;知乎：&lt;a href=&quot;https://www.zhihu.com/</summary>
      
    
    
    
    <category term="Devlopment-Tech" scheme="https://conqueror712.github.io/categories/Devlopment-Tech/"/>
    
    
  </entry>
  
</feed>
